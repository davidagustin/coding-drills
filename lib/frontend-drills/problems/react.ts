import type { FrontendDrillProblem } from '../types';

export const reactProblems: FrontendDrillProblem[] = [
  {
    id: 'fe-react-usestate-basic',
    framework: 'react',
    category: 'State & Lifecycle',
    difficulty: 'easy',
    title: 'useState Basic Usage',
    text: 'Call useState with initial value 42 and return just the state value (first element of the array).',
    setup: 'A mock useState function that returns [initialValue, setterFn].',
    setupCode: `const useState = (initial) => [initial, (v) => v];`,
    expected: 42,
    sample: 'useState(42)[0]',
    hints: ['useState returns an array', 'The state value is the first element'],
    tags: ['hooks', 'useState', 'basics'],
  },
  {
    id: 'fe-react-usestate-updater',
    framework: 'react',
    category: 'State & Lifecycle',
    difficulty: 'easy',
    title: 'useState Functional Update',
    text: 'Given a mock setState function, call it with a functional updater that increments the previous value by 5. Return the result when prevState is 10.',
    setup: 'A mock setState that executes the updater function with prevState=10.',
    setupCode: `const setState = (updater) => typeof updater === 'function' ? updater(10) : updater;`,
    expected: 15,
    sample: 'setState((prev) => prev + 5)',
    hints: ['Functional updater receives previous state as argument', 'Return prev + 5'],
    tags: ['hooks', 'useState', 'functional-update'],
  },
  {
    id: 'fe-react-useeffect-deps',
    framework: 'react',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'useEffect Dependency Array',
    text: 'Call useEffect with an effect function that returns the string "cleanup" and a dependency array containing [a, b]. Return the result object.',
    setup: 'A mock useEffect that returns an object with effect and deps.',
    setupCode: `const useEffect = (effect, deps) => ({ effect: effect(), deps });
const a = 1, b = 2;`,
    expected: { effect: 'cleanup', deps: [1, 2] },
    sample: 'useEffect(() => "cleanup", [a, b])',
    hints: [
      'useEffect takes a function and dependency array',
      'Return value from the effect function',
    ],
    tags: ['hooks', 'useEffect', 'cleanup', 'dependencies'],
  },
  {
    id: 'fe-react-useref-init',
    framework: 'react',
    category: 'State & Lifecycle',
    difficulty: 'easy',
    title: 'useRef Initial Value',
    text: 'Call useRef with initial value "hello" and return the entire ref object.',
    setup: 'A mock useRef that returns an object with a current property.',
    setupCode: `const useRef = (initial) => ({ current: initial });`,
    expected: { current: 'hello' },
    sample: 'useRef("hello")',
    hints: [
      'useRef returns an object with a current property',
      'Pass "hello" as the initial value',
    ],
    tags: ['hooks', 'useRef', 'refs'],
  },
  {
    id: 'fe-react-usememo-compute',
    framework: 'react',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'useMemo Computation',
    text: 'Call useMemo with a function that computes the sum of array [1, 2, 3, 4, 5] and a dependency array containing the array. Return the memoized value.',
    setup: 'A mock useMemo that executes the computation function.',
    setupCode: `const useMemo = (fn, deps) => fn();
const arr = [1, 2, 3, 4, 5];`,
    expected: 15,
    sample: 'useMemo(() => arr.reduce((a, b) => a + b, 0), [arr])',
    hints: ['useMemo runs the computation function', 'Use reduce to sum the array', 'Sum is 15'],
    tags: ['hooks', 'useMemo', 'memoization', 'performance'],
  },
  {
    id: 'fe-react-usecallback-fn',
    framework: 'react',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'useCallback Function Reference',
    text: 'Call useCallback with a function that multiplies its argument by multiplier (which is 3) and dependency array [multiplier]. Then call the returned function with 7.',
    setup: 'A mock useCallback that returns the callback function.',
    setupCode: `const useCallback = (fn, deps) => fn;
const multiplier = 3;`,
    expected: 21,
    sample: 'useCallback((x) => x * multiplier, [multiplier])(7)',
    hints: [
      'useCallback returns the function itself',
      'Call the returned function with 7',
      '7 * 3 = 21',
    ],
    tags: ['hooks', 'useCallback', 'memoization', 'performance'],
  },
  {
    id: 'fe-react-conditional-render',
    framework: 'react',
    category: 'Rendering',
    difficulty: 'easy',
    title: 'Conditional Rendering Logic',
    text: 'Return "Loading..." if isLoading is true, otherwise return "Content: " + data.',
    setup: 'Variables isLoading and data are defined.',
    setupCode: `const isLoading = false;
const data = "Hello World";`,
    expected: 'Content: Hello World',
    sample: 'isLoading ? "Loading..." : "Content: " + data',
    hints: ['Use ternary operator', 'isLoading is false so return the else branch'],
    tags: ['rendering', 'conditional', 'ternary'],
  },
  {
    id: 'fe-react-list-keys',
    framework: 'react',
    category: 'Rendering',
    difficulty: 'medium',
    title: 'List Rendering with Keys',
    text: 'Map over items array to create an array of objects with shape { key: id, value: name }.',
    setup: 'An items array with id and name properties.',
    setupCode: `const items = [
  { id: 1, name: 'Apple' },
  { id: 2, name: 'Banana' },
  { id: 3, name: 'Cherry' }
];`,
    expected: [
      { key: 1, value: 'Apple' },
      { key: 2, value: 'Banana' },
      { key: 3, value: 'Cherry' },
    ],
    sample: 'items.map(item => ({ key: item.id, value: item.name }))',
    hints: ['Use map to transform the array', 'Create objects with key and value properties'],
    tags: ['rendering', 'lists', 'keys', 'map'],
  },
  {
    id: 'fe-react-async-state',
    framework: 'react',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Async Data State Pattern',
    text: 'Create an object representing async data state with properties: loading (true), data (null), error (null).',
    setup: 'No setup needed.',
    setupCode: ``,
    expected: { loading: true, data: null, error: null },
    sample: '({ loading: true, data: null, error: null })',
    hints: [
      'Create an object with three properties',
      'Initial state: loading is true, data and error are null',
    ],
    tags: ['data-fetching', 'async', 'state-pattern'],
  },
  {
    id: 'fe-react-form-controlled',
    framework: 'react',
    category: 'Forms & Validation',
    difficulty: 'easy',
    title: 'Controlled Input Pattern',
    text: 'Create an object representing controlled input props with value set to inputValue and onChange set to handleChange.',
    setup: 'Variables inputValue and handleChange are defined.',
    setupCode: `const inputValue = "test@example.com";
const handleChange = "function";`,
    expected: { value: 'test@example.com', onChange: 'function' },
    sample: '({ value: inputValue, onChange: handleChange })',
    hints: [
      'Create object with value and onChange properties',
      'value should be inputValue',
      'onChange should be handleChange function',
    ],
    tags: ['forms', 'controlled-component', 'input'],
    validPatterns: [/value:\s*inputValue/, /onChange:\s*handleChange/],
  },
  {
    id: 'fe-react-event-handler',
    framework: 'react',
    category: 'DOM & Events',
    difficulty: 'easy',
    title: 'Event Handler Binding',
    text: 'Call the mock event handler with an event object { target: { value: "hello" } } and return event.target.value.',
    setup: 'A mock handleInput function.',
    setupCode: `const handleInput = (event) => event.target.value;`,
    expected: 'hello',
    sample: 'handleInput({ target: { value: "hello" } })',
    hints: ['Call handleInput with the event object', 'Access event.target.value'],
    tags: ['events', 'event-handler', 'synthetic-events'],
  },
  {
    id: 'fe-react-custom-hook',
    framework: 'react',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Custom Hook Pattern',
    text: 'Call the custom hook useToggle with initial value false and return the resulting state object.',
    setup: 'A mock useToggle hook that returns [value, toggle function].',
    setupCode: `const useToggle = (initial) => [initial, "function"];`,
    expected: [false, 'function'],
    sample: 'useToggle(false)',
    hints: [
      'Custom hooks return values like built-in hooks',
      'useToggle returns [boolean, function]',
    ],
    tags: ['hooks', 'custom-hooks', 'patterns'],
    validPatterns: [/useToggle\(false\)/],
  },
  {
    id: 'fe-react-props-destructure',
    framework: 'react',
    category: 'Common Patterns',
    difficulty: 'easy',
    title: 'Props Destructuring',
    text: 'Destructure name and age from the props object and return them as a string: "name is age years old".',
    setup: 'A props object with name and age.',
    setupCode: `const props = { name: 'Alice', age: 30 };`,
    expected: 'Alice is 30 years old',
    // biome-ignore lint/suspicious/noTemplateCurlyInString: sample holds user solution code containing template literals
    sample: '(() => { const { name, age } = props; return `${name} is ${age} years old`; })()',
    hints: ['Use destructuring assignment', 'Combine with template literal'],
    tags: ['props', 'destructuring', 'patterns'],
  },
  {
    id: 'fe-react-effect-cleanup',
    framework: 'react',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'useEffect Cleanup Function',
    text: 'Create an effect function that sets up a timer ID of 123 and returns a cleanup function that returns the string "cleared: 123".',
    setup: 'Mock useEffect available.',
    setupCode: `const useEffect = (effect, deps) => effect;`,
    expected: 'cleared: 123',
    sample: 'useEffect(() => { const id = 123; return () => "cleared: " + id; }, [])()()',
    hints: [
      'Effect returns cleanup function',
      'Cleanup function should return "cleared: 123"',
      'Call the returned cleanup to get the result',
    ],
    tags: ['hooks', 'useEffect', 'cleanup', 'lifecycle'],
  },

  // ─── DOM & Events (17 problems) ────────────────────────────────

  {
    id: 'fe-react-event-bubbling',
    framework: 'react',
    category: 'DOM & Events',
    difficulty: 'easy',
    title: 'Event Bubbling Order',
    text: 'Given a mock event system that tracks handler calls, trigger a click on the child element and return the order of handlers called (child first, then parent).',
    setup: 'A mock event system that records bubbling order.',
    setupCode: `const log = [];\nconst parentHandler = () => log.push("parent");\nconst childHandler = () => log.push("child");\nconst simulateClick = () => { childHandler(); parentHandler(); return log; };`,
    expected: ['child', 'parent'],
    sample: 'simulateClick()',
    hints: ['Events bubble from child to parent', 'Child handler fires first'],
    tags: ['events', 'bubbling', 'propagation'],
  },
  {
    id: 'fe-react-stop-propagation',
    framework: 'react',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'Stop Propagation',
    text: 'Simulate a click where the child calls stopPropagation. Return the log of handlers that fired.',
    setup: 'A mock event system with stopPropagation support.',
    setupCode: `const log = [];\nconst simulateWithStop = () => {\n  let stopped = false;\n  const event = { stopPropagation: () => { stopped = true; } };\n  log.push("child");\n  event.stopPropagation();\n  if (!stopped) log.push("parent");\n  return log;\n};`,
    expected: ['child'],
    sample: 'simulateWithStop()',
    hints: ['stopPropagation prevents parent handlers', 'Only child should appear in log'],
    tags: ['events', 'stopPropagation', 'bubbling'],
  },
  {
    id: 'fe-react-prevent-default',
    framework: 'react',
    category: 'DOM & Events',
    difficulty: 'easy',
    title: 'Prevent Default Behavior',
    text: 'Create a form submit handler that calls preventDefault and returns "prevented".',
    setup: 'A mock event object with preventDefault.',
    setupCode: `const mockEvent = { preventDefault: () => {}, type: "submit" };\nconst handleSubmit = (e) => { e.preventDefault(); return "prevented"; };`,
    expected: 'prevented',
    sample: 'handleSubmit(mockEvent)',
    hints: ['Call e.preventDefault() to stop default behavior'],
    tags: ['events', 'preventDefault', 'forms'],
  },
  {
    id: 'fe-react-synthetic-event',
    framework: 'react',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'Synthetic Event Properties',
    text: 'Extract the target value, event type, and whether it bubbles from a synthetic event object. Return them as an object.',
    setup: 'A mock synthetic event.',
    setupCode: `const syntheticEvent = {\n  target: { value: "hello" },\n  type: "change",\n  bubbles: true,\n  nativeEvent: {},\n  preventDefault: () => {},\n  stopPropagation: () => {}\n};\nconst extractInfo = (e) => ({ value: e.target.value, type: e.type, bubbles: e.bubbles });`,
    expected: { value: 'hello', type: 'change', bubbles: true },
    sample: 'extractInfo(syntheticEvent)',
    hints: ['Access target.value, type, and bubbles properties'],
    tags: ['events', 'synthetic-event', 'properties'],
  },
  {
    id: 'fe-react-event-delegation',
    framework: 'react',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'Event Delegation Pattern',
    text: 'Using a single click handler on a parent list, determine which item was clicked by checking the dataset id. Return the clicked item id.',
    setup: 'A mock delegated event handler.',
    setupCode: `const handleListClick = (e) => {\n  const id = e.target.dataset.id;\n  return id ? "item-" + id : "none";\n};\nconst mockEvent = { target: { dataset: { id: "3" } } };`,
    expected: 'item-3',
    sample: 'handleListClick(mockEvent)',
    hints: ['Check e.target.dataset.id', 'Event delegation uses a single parent handler'],
    tags: ['events', 'delegation', 'performance'],
  },
  {
    id: 'fe-react-keyboard-event',
    framework: 'react',
    category: 'DOM & Events',
    difficulty: 'easy',
    title: 'Keyboard Event Handler',
    text: 'Create a keydown handler that returns "submitted" when Enter is pressed and "ignored" otherwise. Test with key "Enter".',
    setup: 'A mock keyboard event handler.',
    setupCode: `const handleKeyDown = (e) => e.key === "Enter" ? "submitted" : "ignored";\nconst enterEvent = { key: "Enter" };`,
    expected: 'submitted',
    sample: 'handleKeyDown(enterEvent)',
    hints: ['Check e.key for the pressed key', 'Enter key has value "Enter"'],
    tags: ['events', 'keyboard', 'onKeyDown'],
  },
  {
    id: 'fe-react-event-currenttarget',
    framework: 'react',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'Event target vs currentTarget',
    text: 'Return an object with target and currentTarget ids from the event, demonstrating the difference.',
    setup: 'A mock event where target and currentTarget differ.',
    setupCode: `const event = {\n  target: { id: "inner-span" },\n  currentTarget: { id: "outer-div" }\n};\nconst getTargets = (e) => ({ target: e.target.id, currentTarget: e.currentTarget.id });`,
    expected: { target: 'inner-span', currentTarget: 'outer-div' },
    sample: 'getTargets(event)',
    hints: [
      'target is the element that triggered the event',
      'currentTarget is the element the handler is attached to',
    ],
    tags: ['events', 'target', 'currentTarget'],
  },
  {
    id: 'fe-react-focus-blur',
    framework: 'react',
    category: 'DOM & Events',
    difficulty: 'easy',
    title: 'Focus and Blur Events',
    text: 'Track focus and blur events. After focusing then blurring, return the event log.',
    setup: 'A mock focus/blur tracker.',
    setupCode: `const log = [];\nconst onFocus = () => log.push("focused");\nconst onBlur = () => log.push("blurred");\nconst simulate = () => { onFocus(); onBlur(); return log; };`,
    expected: ['focused', 'blurred'],
    sample: 'simulate()',
    hints: ['Focus fires when element gains focus', 'Blur fires when element loses focus'],
    tags: ['events', 'focus', 'blur'],
  },
  {
    id: 'fe-react-mouse-position',
    framework: 'react',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'Mouse Event Coordinates',
    text: 'Extract clientX and clientY from a mouse event and return them as an object { x, y }.',
    setup: 'A mock mouse event with coordinates.',
    setupCode: `const mouseEvent = { clientX: 150, clientY: 200, type: "mousemove" };\nconst getPosition = (e) => ({ x: e.clientX, y: e.clientY });`,
    expected: { x: 150, y: 200 },
    sample: 'getPosition(mouseEvent)',
    hints: ['clientX and clientY give mouse position', 'Map them to x and y'],
    tags: ['events', 'mouse', 'coordinates'],
  },
  {
    id: 'fe-react-event-pooling',
    framework: 'react',
    category: 'DOM & Events',
    difficulty: 'hard',
    title: 'Event Pooling and Persist',
    text: 'Simulate React event pooling: after the handler returns, the event is nullified unless persist() is called. Call persist and return the value.',
    setup: 'A mock event with pooling behavior.',
    setupCode: `const createPooledEvent = (val) => {\n  let persisted = false;\n  let value = val;\n  return {\n    target: { value },\n    persist: () => { persisted = true; },\n    _access: () => persisted ? value : null\n  };\n};\nconst evt = createPooledEvent("saved");\nevt.persist();`,
    expected: 'saved',
    sample: 'evt._access()',
    hints: ['Event pooling recycles event objects', 'Call persist() to retain the event'],
    tags: ['events', 'pooling', 'persist'],
  },
  {
    id: 'fe-react-touch-events',
    framework: 'react',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'Touch Event Handler',
    text: 'Extract the first touch point coordinates from a touch event and return { x, y }.',
    setup: 'A mock touch event with touches array.',
    setupCode: `const touchEvent = { touches: [{ clientX: 100, clientY: 250 }] };\nconst getTouch = (e) => ({ x: e.touches[0].clientX, y: e.touches[0].clientY });`,
    expected: { x: 100, y: 250 },
    sample: 'getTouch(touchEvent)',
    hints: ['Access touches[0] for the first touch point', 'Extract clientX and clientY'],
    tags: ['events', 'touch', 'mobile'],
  },
  {
    id: 'fe-react-event-handler-args',
    framework: 'react',
    category: 'DOM & Events',
    difficulty: 'easy',
    title: 'Passing Arguments to Event Handlers',
    text: 'Create a handler factory that takes an id and returns a handler that returns "clicked-" + id. Call it with id 5.',
    setup: 'A handler factory function.',
    setupCode: `const createHandler = (id) => () => "clicked-" + id;`,
    expected: 'clicked-5',
    sample: 'createHandler(5)()',
    hints: ['Use a closure to capture the id', 'Return a function that uses the captured id'],
    tags: ['events', 'closures', 'handler-factory'],
  },
  {
    id: 'fe-react-debounce-handler',
    framework: 'react',
    category: 'DOM & Events',
    difficulty: 'hard',
    title: 'Debounced Event Handler',
    text: 'Implement a simple debounce that returns the last value passed after multiple rapid calls. Simulate 3 calls and return the final captured value.',
    setup: 'A mock debounce implementation.',
    setupCode: `const debounce = (fn) => {\n  let lastArgs;\n  const debounced = (...args) => { lastArgs = args; };\n  debounced.flush = () => fn(...lastArgs);\n  return debounced;\n};\nconst handler = debounce((val) => val);\nhandler("first");\nhandler("second");\nhandler("third");`,
    expected: 'third',
    sample: 'handler.flush()',
    hints: ['Debounce captures the latest call', 'flush() executes with the last arguments'],
    tags: ['events', 'debounce', 'performance'],
  },
  {
    id: 'fe-react-throttle-handler',
    framework: 'react',
    category: 'DOM & Events',
    difficulty: 'hard',
    title: 'Throttled Event Handler',
    text: 'Implement a throttle that captures only the first call in a series. Simulate 3 calls and return the captured value.',
    setup: 'A mock throttle implementation.',
    setupCode: `const throttle = (fn) => {\n  let called = false;\n  let result;\n  return (...args) => {\n    if (!called) {\n      called = true;\n      result = fn(...args);\n    }\n    return result;\n  };\n};\nconst handler = throttle((val) => val);`,
    expected: 'first',
    sample: '(handler("first"), handler("second"), handler("third"))',
    hints: ['Throttle only executes the first call', 'Subsequent calls return the first result'],
    tags: ['events', 'throttle', 'performance'],
  },
  {
    id: 'fe-react-event-composition',
    framework: 'react',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'Composing Event Handlers',
    text: 'Compose two event handlers into one that runs both. Return the combined log.',
    setup: 'Two handlers and a compose function.',
    setupCode: `const log = [];\nconst handler1 = () => log.push("validated");\nconst handler2 = () => log.push("submitted");\nconst compose = (...fns) => () => { fns.forEach(fn => fn()); return log; };`,
    expected: ['validated', 'submitted'],
    sample: 'compose(handler1, handler2)()',
    hints: ['Run each handler in order', 'Collect results in the log array'],
    tags: ['events', 'composition', 'patterns'],
  },
  {
    id: 'fe-react-drag-events',
    framework: 'react',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'Drag Event Data Transfer',
    text: 'Set data on a mock dataTransfer during dragstart and retrieve it during drop. Return the transferred data.',
    setup: 'A mock drag and drop system.',
    setupCode: `const dataStore = {};\nconst dataTransfer = {\n  setData: (type, val) => { dataStore[type] = val; },\n  getData: (type) => dataStore[type]\n};\ndataTransfer.setData("text/plain", "dragged-item-42");`,
    expected: 'dragged-item-42',
    sample: 'dataTransfer.getData("text/plain")',
    hints: ['setData stores data by type', 'getData retrieves by the same type key'],
    tags: ['events', 'drag-drop', 'dataTransfer'],
  },
  {
    id: 'fe-react-event-capture-phase',
    framework: 'react',
    category: 'DOM & Events',
    difficulty: 'easy',
    title: 'Capture Phase vs Bubble Phase',
    text: 'Simulate event flow with capture and bubble phases. Return the order of handler execution.',
    setup: 'A mock event flow simulation.',
    setupCode: `const log = [];\nconst captureHandler = () => log.push("capture");\nconst bubbleHandler = () => log.push("bubble");\nconst simulateFlow = () => { captureHandler(); bubbleHandler(); return log; };`,
    expected: ['capture', 'bubble'],
    sample: 'simulateFlow()',
    hints: [
      'Capture phase runs before bubble phase',
      'In React, use onClickCapture for capture phase',
    ],
    tags: ['events', 'capture', 'phases'],
  },

  // ─── State & Lifecycle (17 problems) ───────────────────────────

  {
    id: 'fe-react-usecontext-basic',
    framework: 'react',
    category: 'State & Lifecycle',
    difficulty: 'easy',
    title: 'useContext Basic Usage',
    text: 'Call useContext with a context object that has a value of "dark" and return the theme.',
    setup: 'A mock useContext that returns the context value.',
    setupCode: `const useContext = (ctx) => ctx._currentValue;\nconst ThemeContext = { _currentValue: "dark" };`,
    expected: 'dark',
    sample: 'useContext(ThemeContext)',
    hints: ['useContext returns the current context value'],
    tags: ['hooks', 'useContext', 'context'],
  },
  {
    id: 'fe-react-reducer-dispatch',
    framework: 'react',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'useReducer Dispatch Action',
    text: 'Given a counter reducer and dispatch function, dispatch an INCREMENT action and return the new state.',
    setup: 'A mock useReducer with a counter reducer.',
    setupCode: `const counterReducer = (state, action) => {\n  switch(action.type) {\n    case 'INCREMENT': return { count: state.count + 1 };\n    case 'DECREMENT': return { count: state.count - 1 };\n    default: return state;\n  }\n};\nconst useReducer = (reducer, init) => {\n  let state = init;\n  const dispatch = (action) => { state = reducer(state, action); };\n  dispatch({ type: 'INCREMENT' });\n  return [state, dispatch];\n};`,
    expected: { count: 1 },
    sample: 'useReducer(counterReducer, { count: 0 })[0]',
    hints: ['useReducer returns [state, dispatch]', 'Dispatch INCREMENT to increment count'],
    tags: ['hooks', 'useReducer', 'dispatch', 'actions'],
  },
  {
    id: 'fe-react-usestate-object',
    framework: 'react',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'useState with Object Spread',
    text: 'Merge a partial update into an existing state object using the spread operator. Return the merged state.',
    setup: 'A mock setState that merges using spread.',
    setupCode: `const prevState = { name: "Alice", age: 30, city: "NYC" };\nconst updateState = (prev, partial) => ({ ...prev, ...partial });`,
    expected: { name: 'Alice', age: 31, city: 'NYC' },
    sample: 'updateState(prevState, { age: 31 })',
    hints: ['Spread previous state first', 'Then spread the partial update to override'],
    tags: ['hooks', 'useState', 'object-state', 'spread'],
  },
  {
    id: 'fe-react-usestate-array',
    framework: 'react',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'useState Array Immutable Update',
    text: 'Add a new item to a state array immutably. Return the new array.',
    setup: 'An initial array and an add function.',
    setupCode: `const items = ["apple", "banana"];\nconst addItem = (arr, item) => [...arr, item];`,
    expected: ['apple', 'banana', 'cherry'],
    sample: 'addItem(items, "cherry")',
    hints: ['Use spread to create a new array', 'Append the new item at the end'],
    tags: ['hooks', 'useState', 'immutable', 'arrays'],
  },
  {
    id: 'fe-react-usestate-lazy-init',
    framework: 'react',
    category: 'State & Lifecycle',
    difficulty: 'easy',
    title: 'useState Lazy Initialization',
    text: 'Call useState with a lazy initializer function that computes an expensive initial value. Return the state value.',
    setup: 'A mock useState that accepts a function initializer.',
    setupCode: `const useState = (init) => {\n  const val = typeof init === 'function' ? init() : init;\n  return [val, () => {}];\n};`,
    expected: 100,
    sample: 'useState(() => 50 * 2)[0]',
    hints: [
      'Pass a function to useState for lazy init',
      'The function runs once to compute initial value',
    ],
    tags: ['hooks', 'useState', 'lazy-init', 'performance'],
  },
  {
    id: 'fe-react-multiple-effects',
    framework: 'react',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'Multiple useEffect Calls',
    text: 'Simulate multiple useEffect hooks running in order. Return the log of effects.',
    setup: 'A mock system that tracks multiple effects.',
    setupCode: `const log = [];\nconst useEffect = (fn) => { log.push(fn()); };\nconst runEffects = () => {\n  useEffect(() => "effect-1");\n  useEffect(() => "effect-2");\n  useEffect(() => "effect-3");\n  return log;\n};`,
    expected: ['effect-1', 'effect-2', 'effect-3'],
    sample: 'runEffects()',
    hints: ['Multiple useEffect hooks run in order', 'Each effect runs after render'],
    tags: ['hooks', 'useEffect', 'multiple', 'lifecycle'],
  },
  {
    id: 'fe-react-uselayouteffect',
    framework: 'react',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'useLayoutEffect vs useEffect Order',
    text: 'Simulate the execution order of useLayoutEffect and useEffect. Return the log.',
    setup: 'Mock hooks that track execution order.',
    setupCode: `const log = [];\nconst useLayoutEffect = (fn) => { log.push("layout:" + fn()); };\nconst useEffect = (fn) => { log.push("effect:" + fn()); };\nconst runHooks = () => {\n  useLayoutEffect(() => "measure");\n  useEffect(() => "fetch");\n  return log;\n};`,
    expected: ['layout:measure', 'effect:fetch'],
    sample: 'runHooks()',
    hints: ['useLayoutEffect fires before useEffect', 'Layout effects are synchronous'],
    tags: ['hooks', 'useLayoutEffect', 'lifecycle', 'order'],
  },
  {
    id: 'fe-react-context-provider-value',
    framework: 'react',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'Context Provider Value',
    text: 'Create a context with a default value, override it with a provider value, and read from the consumer. Return the consumed value.',
    setup: 'A mock context system with provider.',
    setupCode: `const createContext = (defaultVal) => {\n  let current = defaultVal;\n  return {\n    _currentValue: current,\n    Provider: (val) => { current = val; },\n    read: () => current\n  };\n};\nconst ThemeCtx = createContext("light");\nThemeCtx.Provider("dark");`,
    expected: 'dark',
    sample: 'ThemeCtx.read()',
    hints: ['Provider overrides the default value', 'Consumer reads the current value'],
    tags: ['context', 'provider', 'consumer'],
  },
  {
    id: 'fe-react-reducer-multiple-actions',
    framework: 'react',
    category: 'State & Lifecycle',
    difficulty: 'hard',
    title: 'useReducer Multiple Actions',
    text: 'Apply a sequence of actions to a reducer: ADD_TODO, TOGGLE_TODO, ADD_TODO. Return the final state.',
    setup: 'A todo reducer with multiple action support.',
    setupCode: `const todoReducer = (state, action) => {\n  switch(action.type) {\n    case 'ADD_TODO': return { ...state, todos: [...state.todos, { id: action.id, text: action.text, done: false }] };\n    case 'TOGGLE_TODO': return { ...state, todos: state.todos.map(t => t.id === action.id ? { ...t, done: !t.done } : t) };\n    default: return state;\n  }\n};\nconst actions = [\n  { type: 'ADD_TODO', id: 1, text: 'Learn React' },\n  { type: 'TOGGLE_TODO', id: 1 },\n  { type: 'ADD_TODO', id: 2, text: 'Build app' }\n];\nconst finalState = actions.reduce(todoReducer, { todos: [] });`,
    expected: {
      todos: [
        { id: 1, text: 'Learn React', done: true },
        { id: 2, text: 'Build app', done: false },
      ],
    },
    sample: 'finalState',
    hints: ['Apply actions sequentially with reduce', 'ADD_TODO appends, TOGGLE_TODO flips done'],
    tags: ['hooks', 'useReducer', 'complex-state', 'actions'],
  },
  {
    id: 'fe-react-useref-mutable',
    framework: 'react',
    category: 'State & Lifecycle',
    difficulty: 'easy',
    title: 'useRef Mutable Value',
    text: 'Use a ref to track how many times a component rendered. After 3 renders, return the count.',
    setup: 'A mock useRef tracking render count.',
    setupCode: `const useRef = (initial) => ({ current: initial });\nconst renderCount = useRef(0);\nrenderCount.current++;\nrenderCount.current++;\nrenderCount.current++;`,
    expected: 3,
    sample: 'renderCount.current',
    hints: ['useRef.current is mutable', 'Increment on each render'],
    tags: ['hooks', 'useRef', 'mutable', 'render-count'],
  },
  {
    id: 'fe-react-use-imperative-handle',
    framework: 'react',
    category: 'State & Lifecycle',
    difficulty: 'hard',
    title: 'useImperativeHandle Pattern',
    text: 'Mock useImperativeHandle to expose a custom focus and scrollTo API via ref. Return the exposed methods object.',
    setup: 'A mock useImperativeHandle.',
    setupCode: `const useImperativeHandle = (ref, createHandle) => {\n  ref.current = createHandle();\n};\nconst ref = { current: null };\nuseImperativeHandle(ref, () => ({\n  focus: () => "focused",\n  scrollTo: (pos) => "scrolled-to-" + pos\n}));`,
    expected: { focus: 'focused', scrollTo: 'scrolled-to-top' },
    sample: '({ focus: ref.current.focus(), scrollTo: ref.current.scrollTo("top") })',
    hints: ['useImperativeHandle customizes the ref value', 'Return an object with custom methods'],
    tags: ['hooks', 'useImperativeHandle', 'forwardRef'],
  },
  {
    id: 'fe-react-state-batching',
    framework: 'react',
    category: 'State & Lifecycle',
    difficulty: 'hard',
    title: 'State Update Batching',
    text: 'Simulate React batching: multiple setState calls in one handler produce only one render. Return the render count and final state.',
    setup: 'A mock batching system.',
    setupCode: `let renderCount = 0;\nlet state = { a: 0, b: 0 };\nconst batch = (fn) => {\n  const updates = [];\n  const setState = (partial) => updates.push(partial);\n  fn(setState);\n  updates.forEach(u => { state = { ...state, ...u }; });\n  renderCount++;\n  return { renderCount, state };\n};`,
    expected: { renderCount: 1, state: { a: 1, b: 2 } },
    sample: 'batch((setState) => { setState({ a: 1 }); setState({ b: 2 }); })',
    hints: [
      'Batching merges multiple setState calls into one render',
      'Only one render count increment',
    ],
    tags: ['state', 'batching', 'performance', 'rendering'],
  },
  {
    id: 'fe-react-usestate-toggle',
    framework: 'react',
    category: 'State & Lifecycle',
    difficulty: 'easy',
    title: 'useState Toggle Boolean',
    text: 'Toggle a boolean state value using the functional updater form. Start with true, toggle once, return the result.',
    setup: 'A mock useState with toggle.',
    setupCode: `const useState = (init) => {\n  let val = init;\n  const setState = (updater) => { val = typeof updater === 'function' ? updater(val) : updater; };\n  setState(prev => !prev);\n  return [val, setState];\n};`,
    expected: false,
    sample: 'useState(true)[0]',
    hints: ['Use functional updater: prev => !prev', 'true toggled becomes false'],
    tags: ['hooks', 'useState', 'toggle', 'boolean'],
  },
  {
    id: 'fe-react-effect-deps-compare',
    framework: 'react',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'Effect Dependency Comparison',
    text: 'Implement a shallow comparison for effect dependencies. Return whether the effect should re-run given old and new deps.',
    setup: 'A mock dependency comparison function.',
    setupCode: `const depsChanged = (oldDeps, newDeps) => {\n  if (!oldDeps) return true;\n  return oldDeps.some((dep, i) => !Object.is(dep, newDeps[i]));\n};\nconst oldDeps = [1, "hello", true];\nconst newDeps = [1, "hello", false];`,
    expected: true,
    sample: 'depsChanged(oldDeps, newDeps)',
    hints: ['Compare each dependency with Object.is', 'If any differ, the effect should re-run'],
    tags: ['hooks', 'useEffect', 'dependencies', 'shallow-compare'],
  },
  {
    id: 'fe-react-usesyncexternalstore',
    framework: 'react',
    category: 'State & Lifecycle',
    difficulty: 'hard',
    title: 'useSyncExternalStore Pattern',
    text: 'Mock useSyncExternalStore to subscribe to an external store and return its current snapshot.',
    setup: 'A mock external store and useSyncExternalStore.',
    setupCode: `const store = {\n  _value: 42,\n  getSnapshot: function() { return this._value; },\n  subscribe: function(cb) { return () => {}; }\n};\nconst useSyncExternalStore = (subscribe, getSnapshot) => getSnapshot();`,
    expected: 42,
    sample: 'useSyncExternalStore(store.subscribe, () => store.getSnapshot())',
    hints: [
      'useSyncExternalStore takes subscribe and getSnapshot',
      'getSnapshot returns the current value',
    ],
    tags: ['hooks', 'useSyncExternalStore', 'external-store'],
  },
  {
    id: 'fe-react-usestate-counter-multiple',
    framework: 'react',
    category: 'State & Lifecycle',
    difficulty: 'easy',
    title: 'Multiple useState Hooks',
    text: 'Use separate useState calls for name and age. Return them as an object.',
    setup: 'Mock useState returns different values for each call.',
    setupCode: `let callIndex = 0;\nconst states = [["Alice", () => {}], [25, () => {}]];\nconst useState = (init) => states[callIndex++] || [init, () => {}];\nconst name = useState("")[0];\nconst age = useState(0)[0];`,
    expected: { name: 'Alice', age: 25 },
    sample: '({ name, age })',
    hints: ['Each useState call is independent', 'React tracks hook calls by order'],
    tags: ['hooks', 'useState', 'multiple-state'],
  },
  {
    id: 'fe-react-reducer-init-function',
    framework: 'react',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'useReducer with Init Function',
    text: 'Use useReducer with a third init argument function that transforms the initial arg. Return the initial state.',
    setup: 'A mock useReducer with lazy init.',
    setupCode: `const useReducer = (reducer, initArg, init) => {\n  const initialState = init ? init(initArg) : initArg;\n  return [initialState, () => {}];\n};\nconst init = (count) => ({ count, history: [count] });\nconst reducer = (s, a) => s;`,
    expected: { count: 10, history: [10] },
    sample: 'useReducer(reducer, 10, init)[0]',
    hints: ['The third argument transforms the initial arg', 'init(10) produces the initial state'],
    tags: ['hooks', 'useReducer', 'lazy-init'],
  },

  // ─── Common Patterns (17 problems) ─────────────────────────────

  {
    id: 'fe-react-hoc-pattern',
    framework: 'react',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Higher-Order Component Pattern',
    text: 'Create an HOC that wraps a component and injects an "isAdmin" prop. Return the enhanced props.',
    setup: 'A mock HOC system.',
    setupCode: `const withAdmin = (Component) => (props) => Component({ ...props, isAdmin: true });\nconst MyComponent = (props) => props;\nconst Enhanced = withAdmin(MyComponent);`,
    expected: { name: 'Alice', isAdmin: true },
    sample: 'Enhanced({ name: "Alice" })',
    hints: ['HOC takes a component and returns a new one', 'Spread existing props and add isAdmin'],
    tags: ['patterns', 'hoc', 'higher-order-component'],
  },
  {
    id: 'fe-react-render-props',
    framework: 'react',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Render Props Pattern',
    text: 'Use the render prop pattern to pass mouse coordinates to a render function. Return the rendered output.',
    setup: 'A mock component using render props.',
    setupCode: `const MouseTracker = (props) => {\n  const mouse = { x: 100, y: 200 };\n  return props.render(mouse);\n};`,
    expected: 'Mouse at 100, 200',
    sample: 'MouseTracker({ render: (mouse) => "Mouse at " + mouse.x + ", " + mouse.y })',
    hints: [
      'Render props pass data to a render function',
      'The render function receives mouse coordinates',
    ],
    tags: ['patterns', 'render-props'],
  },
  {
    id: 'fe-react-compound-component',
    framework: 'react',
    category: 'Common Patterns',
    difficulty: 'hard',
    title: 'Compound Component Pattern',
    text: 'Implement a compound component where parent shares state with children. Return the combined output.',
    setup: 'A mock compound component system.',
    setupCode: `const Tabs = (props) => {\n  const activeTab = props.defaultTab;\n  return props.children.map(child => child({ activeTab }));\n};\nconst Tab = (label) => ({ activeTab }) => activeTab === label ? label + ":active" : label + ":inactive";`,
    expected: ['home:active', 'profile:inactive', 'settings:inactive'],
    sample:
      'Tabs({ defaultTab: "home", children: [Tab("home"), Tab("profile"), Tab("settings")] })',
    hints: ['Parent passes shared state to children', 'Each child receives activeTab prop'],
    tags: ['patterns', 'compound-components', 'composition'],
  },
  {
    id: 'fe-react-custom-hook-useprevious',
    framework: 'react',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Custom Hook: usePrevious',
    text: 'Implement usePrevious that tracks the previous value. After updating from 5 to 10, return the previous value.',
    setup: 'A mock usePrevious hook.',
    setupCode: `const usePrevious = (value) => {\n  const ref = { current: undefined };\n  const prev = ref.current;\n  ref.current = value;\n  return prev;\n};\nconst ref = { current: 5 };\nref.current = 10;\nconst previous = 5;`,
    expected: 5,
    sample: 'previous',
    hints: [
      'usePrevious stores the last value in a ref',
      'It returns the value from the previous render',
    ],
    tags: ['hooks', 'custom-hooks', 'usePrevious'],
  },
  {
    id: 'fe-react-portal-logic',
    framework: 'react',
    category: 'Common Patterns',
    difficulty: 'easy',
    title: 'Portal Rendering Logic',
    text: 'Mock createPortal to render content in a different container. Return the portal descriptor.',
    setup: 'A mock createPortal function.',
    setupCode: `const createPortal = (children, container) => ({ type: "portal", children, container });`,
    expected: { type: 'portal', children: 'Modal Content', container: 'modal-root' },
    sample: 'createPortal("Modal Content", "modal-root")',
    hints: ['createPortal takes children and a container', 'Returns a portal descriptor object'],
    tags: ['patterns', 'portal', 'createPortal'],
  },
  {
    id: 'fe-react-error-boundary-logic',
    framework: 'react',
    category: 'Common Patterns',
    difficulty: 'hard',
    title: 'Error Boundary Pattern',
    text: 'Simulate an error boundary that catches errors from child rendering. Return the error boundary state after an error.',
    setup: 'A mock error boundary.',
    setupCode: `const ErrorBoundary = () => {\n  let state = { hasError: false, error: null };\n  const getDerivedStateFromError = (error) => ({ hasError: true, error: error.message });\n  try {\n    throw new Error("Component crashed");\n  } catch (e) {\n    state = getDerivedStateFromError(e);\n  }\n  return state;\n};`,
    expected: { hasError: true, error: 'Component crashed' },
    sample: 'ErrorBoundary()',
    hints: [
      'Error boundaries catch rendering errors',
      'getDerivedStateFromError updates state on error',
    ],
    tags: ['patterns', 'error-boundary', 'error-handling'],
  },
  {
    id: 'fe-react-context-selector',
    framework: 'react',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Context Selector Pattern',
    text: 'Use a selector to read only a specific part of a context value. Return the selected value.',
    setup: 'A mock context with selector support.',
    setupCode: `const context = { user: { name: "Alice", age: 30 }, theme: "dark", lang: "en" };\nconst useContextSelector = (ctx, selector) => selector(ctx);`,
    expected: 'Alice',
    sample: 'useContextSelector(context, (ctx) => ctx.user.name)',
    hints: ['Selector function extracts a specific value', 'Prevents unnecessary re-renders'],
    tags: ['context', 'selector', 'performance'],
  },
  {
    id: 'fe-react-controlled-uncontrolled',
    framework: 'react',
    category: 'Common Patterns',
    difficulty: 'easy',
    title: 'Controlled vs Uncontrolled Check',
    text: 'Determine if a component is controlled or uncontrolled based on its props. Return "controlled" or "uncontrolled".',
    setup: 'A function that checks for controlled props.',
    setupCode: `const isControlled = (props) => props.value !== undefined ? "controlled" : "uncontrolled";\nconst controlledProps = { value: "test", onChange: () => {} };\nconst uncontrolledProps = { defaultValue: "test" };`,
    expected: 'controlled',
    sample: 'isControlled(controlledProps)',
    hints: ['Controlled components have value prop', 'Uncontrolled use defaultValue'],
    tags: ['patterns', 'controlled', 'uncontrolled'],
  },
  {
    id: 'fe-react-provider-composition',
    framework: 'react',
    category: 'Common Patterns',
    difficulty: 'hard',
    title: 'Provider Composition (Provider Hell Fix)',
    text: 'Compose multiple providers into a single wrapper. Return the deeply nested value after all providers.',
    setup: 'A mock compose providers function.',
    setupCode: `const composeProviders = (providers) => {\n  return providers.reduce((acc, [Provider, value]) => {\n    return { ...acc, ...value };\n  }, {});\n};\nconst providers = [\n  ["ThemeProvider", { theme: "dark" }],\n  ["AuthProvider", { user: "Alice" }],\n  ["LangProvider", { lang: "en" }]\n];`,
    expected: { theme: 'dark', user: 'Alice', lang: 'en' },
    sample: 'composeProviders(providers)',
    hints: ['Compose reduces provider hell', 'Merge all provider values into one object'],
    tags: ['patterns', 'providers', 'composition'],
  },
  {
    id: 'fe-react-custom-hook-uselocalstorage',
    framework: 'react',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Custom Hook: useLocalStorage',
    text: 'Mock a useLocalStorage hook that reads from a mock storage. Return the stored value.',
    setup: 'A mock localStorage and useLocalStorage hook.',
    setupCode: `const mockStorage = { theme: "dark", lang: "en" };\nconst useLocalStorage = (key, defaultVal) => {\n  const stored = mockStorage[key];\n  return [stored !== undefined ? stored : defaultVal, (v) => { mockStorage[key] = v; }];\n};`,
    expected: 'dark',
    sample: 'useLocalStorage("theme", "light")[0]',
    hints: ['Read from storage first', 'Fall back to default value'],
    tags: ['hooks', 'custom-hooks', 'localStorage'],
  },
  {
    id: 'fe-react-lazy-component',
    framework: 'react',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'React.lazy Pattern',
    text: 'Mock React.lazy to create a lazily loaded component descriptor. Return the lazy component type.',
    setup: 'A mock React.lazy implementation.',
    setupCode: `const lazy = (importFn) => {\n  return { $$typeof: "lazy", _init: importFn, _status: "pending" };\n};\nconst LazyComponent = lazy(() => ({ default: "MyComponent" }));`,
    expected: { $$typeof: 'lazy', _status: 'pending' },
    sample: '({ $$typeof: LazyComponent.$$typeof, _status: LazyComponent._status })',
    hints: ['React.lazy wraps a dynamic import', 'Returns a special lazy type'],
    tags: ['patterns', 'lazy', 'code-splitting'],
  },
  {
    id: 'fe-react-custom-hook-usewindowsize',
    framework: 'react',
    category: 'Common Patterns',
    difficulty: 'easy',
    title: 'Custom Hook: useWindowSize',
    text: 'Mock a useWindowSize hook that returns the current window dimensions. Return the size object.',
    setup: 'A mock useWindowSize hook.',
    setupCode: `const useWindowSize = () => ({ width: 1024, height: 768 });`,
    expected: { width: 1024, height: 768 },
    sample: 'useWindowSize()',
    hints: ['Returns current window dimensions', 'Object with width and height'],
    tags: ['hooks', 'custom-hooks', 'useWindowSize'],
  },
  {
    id: 'fe-react-custom-hook-usedebounce',
    framework: 'react',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Custom Hook: useDebounce',
    text: 'Mock a useDebounce hook that returns the debounced value. After the delay, return the latest value.',
    setup: 'A mock useDebounce that immediately resolves.',
    setupCode: `const useDebounce = (value, delay) => {\n  return value;\n};\nconst searchTerm = "react hooks";`,
    expected: 'react hooks',
    sample: 'useDebounce(searchTerm, 500)',
    hints: ['useDebounce delays updating the value', 'Returns the debounced value after delay'],
    tags: ['hooks', 'custom-hooks', 'useDebounce', 'debounce'],
  },
  {
    id: 'fe-react-slot-pattern',
    framework: 'react',
    category: 'Common Patterns',
    difficulty: 'easy',
    title: 'Slot Pattern (Named Children)',
    text: 'Implement a layout component that accepts header, body, and footer slots. Return the assembled layout.',
    setup: 'A mock layout component with slots.',
    setupCode: `const Layout = (slots) => ({\n  header: slots.header,\n  body: slots.body,\n  footer: slots.footer\n});`,
    expected: { header: 'My App', body: 'Content here', footer: '2024' },
    sample: 'Layout({ header: "My App", body: "Content here", footer: "2024" })',
    hints: ['Slots are named children passed as props', 'Destructure to place them in the layout'],
    tags: ['patterns', 'slots', 'composition', 'layout'],
  },
  {
    id: 'fe-react-observer-pattern',
    framework: 'react',
    category: 'Common Patterns',
    difficulty: 'hard',
    title: 'Observer Pattern for State',
    text: 'Implement a simple observable store. Subscribe two listeners, emit a value, and return what both received.',
    setup: 'A mock observable store.',
    setupCode: `const createStore = (initial) => {\n  let value = initial;\n  const listeners = [];\n  return {\n    subscribe: (fn) => { listeners.push(fn); },\n    emit: (val) => { value = val; listeners.forEach(fn => fn(val)); },\n    getValue: () => value\n  };\n};\nconst store = createStore(0);\nconst results = [];\nstore.subscribe(v => results.push("A:" + v));\nstore.subscribe(v => results.push("B:" + v));\nstore.emit(42);`,
    expected: ['A:42', 'B:42'],
    sample: 'results',
    hints: ['Observers subscribe to state changes', 'All listeners are notified on emit'],
    tags: ['patterns', 'observer', 'pub-sub', 'store'],
  },
  {
    id: 'fe-react-children-map',
    framework: 'react',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'React.Children.map Pattern',
    text: 'Use a mock Children.map to transform each child by adding an index property. Return the transformed children.',
    setup: 'A mock React.Children.map.',
    setupCode: `const Children = {\n  map: (children, fn) => children.map((child, index) => fn(child, index))\n};\nconst kids = ["Alice", "Bob", "Charlie"];`,
    expected: [
      { child: 'Alice', index: 0 },
      { child: 'Bob', index: 1 },
      { child: 'Charlie', index: 2 },
    ],
    sample: 'Children.map(kids, (child, index) => ({ child, index }))',
    hints: ['Children.map iterates over React children', 'Transform each child with the callback'],
    tags: ['patterns', 'children', 'React.Children'],
  },
  {
    id: 'fe-react-custom-hook-usefetch',
    framework: 'react',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Custom Hook: useFetch',
    text: 'Mock a useFetch hook that returns loading, data, and error states. Return the state for a successful fetch.',
    setup: 'A mock useFetch that simulates success.',
    setupCode: `const useFetch = (url) => {\n  if (url === "/api/users") {\n    return { loading: false, data: [{ id: 1, name: "Alice" }], error: null };\n  }\n  return { loading: true, data: null, error: null };\n};`,
    expected: { loading: false, data: [{ id: 1, name: 'Alice' }], error: null },
    sample: 'useFetch("/api/users")',
    hints: [
      'useFetch returns loading, data, error triple',
      'Match the URL to return the right state',
    ],
    tags: ['hooks', 'custom-hooks', 'useFetch', 'data-fetching'],
  },

  // ─── Rendering (17 problems) ───────────────────────────────────

  {
    id: 'fe-react-fragment-usage',
    framework: 'react',
    category: 'Rendering',
    difficulty: 'easy',
    title: 'Fragment Grouping',
    text: 'Use a mock Fragment to group multiple elements without adding extra DOM nodes. Return the fragment descriptor.',
    setup: 'A mock React.Fragment.',
    setupCode: `const Fragment = (...children) => ({ type: "fragment", children });`,
    expected: { type: 'fragment', children: ['Hello', ' ', 'World'] },
    sample: 'Fragment("Hello", " ", "World")',
    hints: ['Fragments group children without extra DOM nodes', 'Short syntax is <></>'],
    tags: ['rendering', 'fragment', 'jsx'],
  },
  {
    id: 'fe-react-memo-shallow',
    framework: 'react',
    category: 'Rendering',
    difficulty: 'medium',
    title: 'React.memo Shallow Comparison',
    text: 'Determine if a memoized component should re-render by comparing previous and next props. Return true if props changed.',
    setup: 'A mock props comparison function.',
    setupCode: `const shallowEqual = (prev, next) => {\n  const prevKeys = Object.keys(prev);\n  const nextKeys = Object.keys(next);\n  if (prevKeys.length !== nextKeys.length) return false;\n  return prevKeys.every(key => Object.is(prev[key], next[key]));\n};\nconst prevProps = { name: "Alice", count: 5 };\nconst nextProps = { name: "Alice", count: 6 };`,
    expected: false,
    sample: 'shallowEqual(prevProps, nextProps)',
    hints: ['Shallow comparison checks each prop with Object.is', 'count changed from 5 to 6'],
    tags: ['rendering', 'memo', 'shallow-compare', 'performance'],
  },
  {
    id: 'fe-react-key-reorder',
    framework: 'react',
    category: 'Rendering',
    difficulty: 'medium',
    title: 'Key-Based Reconciliation',
    text: 'Given an old list and a new reordered list, determine which items need to be moved based on keys. Return the moved item keys.',
    setup: 'A mock reconciliation diff.',
    setupCode: `const findMoved = (oldList, newList) => {\n  const oldOrder = oldList.map(i => i.key);\n  const newOrder = newList.map(i => i.key);\n  return newOrder.filter((key, i) => oldOrder[i] !== key);\n};\nconst oldList = [{ key: "a" }, { key: "b" }, { key: "c" }];\nconst newList = [{ key: "c" }, { key: "a" }, { key: "b" }];`,
    expected: ['c', 'a', 'b'],
    sample: 'findMoved(oldList, newList)',
    hints: ['Compare positions by index', 'Items that changed position need to move'],
    tags: ['rendering', 'reconciliation', 'keys', 'virtual-dom'],
  },
  {
    id: 'fe-react-conditional-null',
    framework: 'react',
    category: 'Rendering',
    difficulty: 'easy',
    title: 'Conditional Render with null',
    text: 'Return null when shouldHide is true, otherwise return the content string. React ignores null in rendering.',
    setup: 'A conditional render function.',
    setupCode: `const shouldHide = true;\nconst content = "Visible Content";\nconst render = (hide, content) => hide ? null : content;`,
    expected: null,
    sample: 'render(shouldHide, content)',
    hints: ['Return null to render nothing', 'React skips null values in output'],
    tags: ['rendering', 'conditional', 'null'],
  },
  {
    id: 'fe-react-short-circuit',
    framework: 'react',
    category: 'Rendering',
    difficulty: 'easy',
    title: 'Short-Circuit Rendering',
    text: 'Use the && operator for conditional rendering. Return the result of (hasItems && count).',
    setup: 'Variables for short-circuit rendering.',
    setupCode: `const items = [1, 2, 3];\nconst hasItems = items.length > 0;\nconst count = items.length;`,
    expected: 3,
    sample: 'hasItems && count',
    hints: ['&& returns the right side if left is truthy', 'items.length is 3 which is truthy'],
    tags: ['rendering', 'conditional', 'short-circuit'],
  },
  {
    id: 'fe-react-render-switch',
    framework: 'react',
    category: 'Rendering',
    difficulty: 'medium',
    title: 'Switch-Case Rendering',
    text: 'Implement a render function that returns different content based on a status value using a lookup map.',
    setup: 'A status-based renderer.',
    setupCode: `const renderByStatus = (status) => {\n  const views = {\n    loading: "Loading spinner",\n    error: "Error message",\n    success: "Data content",\n    empty: "No data"\n  };\n  return views[status] || "Unknown";\n};`,
    expected: 'Error message',
    sample: 'renderByStatus("error")',
    hints: ['Use an object lookup instead of switch-case', 'Map status to content'],
    tags: ['rendering', 'conditional', 'switch', 'patterns'],
  },
  {
    id: 'fe-react-list-filter-render',
    framework: 'react',
    category: 'Rendering',
    difficulty: 'medium',
    title: 'Filtered List Rendering',
    text: 'Filter and map a list of users to render only active users. Return the names of active users.',
    setup: 'A list of users with active status.',
    setupCode: `const users = [\n  { id: 1, name: "Alice", active: true },\n  { id: 2, name: "Bob", active: false },\n  { id: 3, name: "Charlie", active: true },\n  { id: 4, name: "Diana", active: false }\n];`,
    expected: ['Alice', 'Charlie'],
    sample: 'users.filter(u => u.active).map(u => u.name)',
    hints: ['Filter first, then map', 'Only active users should be included'],
    tags: ['rendering', 'lists', 'filter', 'map'],
  },
  {
    id: 'fe-react-nested-list',
    framework: 'react',
    category: 'Rendering',
    difficulty: 'medium',
    title: 'Nested List Rendering',
    text: 'Render a nested data structure (categories with items). Return a flat array of "category: item" strings.',
    setup: 'A nested data structure.',
    setupCode: `const categories = [\n  { name: "Fruits", items: ["Apple", "Banana"] },\n  { name: "Vegs", items: ["Carrot"] }\n];`,
    expected: ['Fruits: Apple', 'Fruits: Banana', 'Vegs: Carrot'],
    sample: 'categories.flatMap(cat => cat.items.map(item => cat.name + ": " + item))',
    hints: ['Use flatMap to flatten nested arrays', 'Combine category name with each item'],
    tags: ['rendering', 'lists', 'nested', 'flatMap'],
  },
  {
    id: 'fe-react-memo-custom-compare',
    framework: 'react',
    category: 'Rendering',
    difficulty: 'hard',
    title: 'React.memo with Custom Comparator',
    text: 'Implement a custom comparator for React.memo that only compares the "id" prop, ignoring other changes. Return whether the component should skip re-render.',
    setup: 'A mock memo with custom comparator.',
    setupCode: `const memo = (component, areEqual) => {\n  return { component, areEqual };\n};\nconst areEqual = (prev, next) => prev.id === next.id;\nconst memoized = memo((props) => props, areEqual);\nconst shouldSkip = memoized.areEqual({ id: 1, name: "Alice" }, { id: 1, name: "Bob" });`,
    expected: true,
    sample: 'shouldSkip',
    hints: ['Custom comparator only checks id', 'Same id means skip re-render (return true)'],
    tags: ['rendering', 'memo', 'performance', 'custom-compare'],
  },
  {
    id: 'fe-react-suspense-fallback',
    framework: 'react',
    category: 'Rendering',
    difficulty: 'medium',
    title: 'Suspense Fallback Logic',
    text: 'Simulate Suspense behavior: if the child throws a promise (is loading), show fallback. Otherwise show content.',
    setup: 'A mock Suspense component.',
    setupCode: `const Suspense = (props) => {\n  try {\n    const result = props.children();\n    return result;\n  } catch (e) {\n    if (e && typeof e.then === 'function') return props.fallback;\n    throw e;\n  }\n};\nconst Loading = "Loading...";\nconst pendingChild = () => { throw { then: () => {} }; };`,
    expected: 'Loading...',
    sample: 'Suspense({ children: pendingChild, fallback: Loading })',
    hints: ['Suspense catches thrown promises', 'Shows fallback while data is loading'],
    tags: ['rendering', 'suspense', 'fallback', 'async'],
  },
  {
    id: 'fe-react-element-type-check',
    framework: 'react',
    category: 'Rendering',
    difficulty: 'easy',
    title: 'React Element Type Check',
    text: 'Check if a value is a valid React element descriptor (has $$typeof symbol). Return true or false.',
    setup: 'Mock React element descriptors.',
    setupCode: `const REACT_ELEMENT_TYPE = "react.element";\nconst isValidElement = (obj) => obj !== null && typeof obj === 'object' && obj.$$typeof === REACT_ELEMENT_TYPE;\nconst element = { $$typeof: "react.element", type: "div", props: {} };\nconst notElement = { type: "div" };`,
    expected: true,
    sample: 'isValidElement(element)',
    hints: ['React elements have $$typeof property', 'Check for the react.element symbol'],
    tags: ['rendering', 'elements', 'validation'],
  },
  {
    id: 'fe-react-vdom-diff',
    framework: 'react',
    category: 'Rendering',
    difficulty: 'hard',
    title: 'Virtual DOM Diff',
    text: 'Compute a simple diff between old and new virtual DOM trees. Return the list of changes.',
    setup: 'A mock VDOM diff algorithm.',
    setupCode: `const diff = (oldNode, newNode) => {\n  const changes = [];\n  if (oldNode.type !== newNode.type) {\n    changes.push({ type: "REPLACE", path: "/" });\n  } else {\n    Object.keys(newNode.props || {}).forEach(key => {\n      if (oldNode.props[key] !== newNode.props[key]) {\n        changes.push({ type: "UPDATE", path: "/" + key, value: newNode.props[key] });\n      }\n    });\n  }\n  return changes;\n};\nconst oldTree = { type: "div", props: { className: "old", id: "main" } };\nconst newTree = { type: "div", props: { className: "new", id: "main" } };`,
    expected: [{ type: 'UPDATE', path: '/className', value: 'new' }],
    sample: 'diff(oldTree, newTree)',
    hints: ['Compare each prop between old and new', 'Only className changed'],
    tags: ['rendering', 'virtual-dom', 'reconciliation', 'diff'],
  },
  {
    id: 'fe-react-render-callback',
    framework: 'react',
    category: 'Rendering',
    difficulty: 'medium',
    title: 'Children as Function (Render Callback)',
    text: 'Implement a DataProvider that passes fetched data to children as a function. Return the rendered output.',
    setup: 'A mock DataProvider using children as function.',
    setupCode: `const DataProvider = (props) => {\n  const data = { users: ["Alice", "Bob"] };\n  return props.children(data);\n};`,
    expected: 'Users: Alice, Bob',
    sample: 'DataProvider({ children: (data) => "Users: " + data.users.join(", ") })',
    hints: ['Children is a function that receives data', 'Invoke children with the fetched data'],
    tags: ['rendering', 'render-callback', 'children-as-function'],
  },
  {
    id: 'fe-react-conditional-classname',
    framework: 'react',
    category: 'Rendering',
    difficulty: 'easy',
    title: 'Dynamic className',
    text: 'Build a className string conditionally based on component state. Return the final className.',
    setup: 'A classname builder function.',
    setupCode: `const cx = (...classes) => classes.filter(Boolean).join(" ");\nconst isActive = true;\nconst isDisabled = false;\nconst isLarge = true;`,
    expected: 'btn active large',
    sample: 'cx("btn", isActive && "active", isDisabled && "disabled", isLarge && "large")',
    hints: ['Filter out falsy values', 'Join remaining classes with spaces'],
    tags: ['rendering', 'className', 'conditional'],
  },
  {
    id: 'fe-react-vdom-create-element',
    framework: 'react',
    category: 'Rendering',
    difficulty: 'medium',
    title: 'createElement Pattern',
    text: 'Mock React.createElement to create a virtual DOM node. Return the element descriptor.',
    setup: 'A mock createElement function.',
    setupCode: `const createElement = (type, props, ...children) => ({\n  $$typeof: "react.element",\n  type,\n  props: { ...props, children: children.length === 1 ? children[0] : children }\n});`,
    expected: { $$typeof: 'react.element', type: 'div', props: { id: 'root', children: 'Hello' } },
    sample: 'createElement("div", { id: "root" }, "Hello")',
    hints: [
      'createElement takes type, props, and children',
      'Single child is unwrapped from array',
    ],
    tags: ['rendering', 'createElement', 'virtual-dom'],
  },
  {
    id: 'fe-react-fiber-priority',
    framework: 'react',
    category: 'Rendering',
    difficulty: 'hard',
    title: 'Fiber Priority Scheduling',
    text: 'Simulate React Fiber priority-based scheduling. Sort tasks by priority and return execution order.',
    setup: 'A mock task scheduler with priorities.',
    setupCode: `const PRIORITIES = { IMMEDIATE: 1, USER_BLOCKING: 2, NORMAL: 3, LOW: 4, IDLE: 5 };\nconst tasks = [\n  { name: "animation", priority: PRIORITIES.USER_BLOCKING },\n  { name: "data-fetch", priority: PRIORITIES.NORMAL },\n  { name: "analytics", priority: PRIORITIES.IDLE },\n  { name: "click-handler", priority: PRIORITIES.IMMEDIATE }\n];\nconst schedule = (tasks) => tasks.sort((a, b) => a.priority - b.priority).map(t => t.name);`,
    expected: ['click-handler', 'animation', 'data-fetch', 'analytics'],
    sample: 'schedule(tasks)',
    hints: ['Lower priority number = higher urgency', 'IMMEDIATE runs first, IDLE runs last'],
    tags: ['rendering', 'fiber', 'scheduling', 'priority'],
  },
  {
    id: 'fe-react-render-nothing',
    framework: 'react',
    category: 'Rendering',
    difficulty: 'hard',
    title: 'Falsy Values in JSX',
    text: 'Determine which falsy values React renders as text. Filter the values that produce visible output.',
    setup: 'A mock renderer that matches React behavior.',
    setupCode: `const willRender = (val) => {\n  if (val === false || val === null || val === undefined || val === true) return false;\n  if (val === 0 || val === "") return true;\n  return !!val;\n};\nconst values = [false, 0, "", null, undefined, true, NaN, "hello"];`,
    expected: [0, '', 'hello'],
    sample: 'values.filter(v => willRender(v))',
    hints: [
      'React renders 0 and empty string as text',
      'false, null, undefined, true render nothing',
      'NaN is falsy and does not render',
    ],
    tags: ['rendering', 'jsx', 'falsy-values'],
  },

  // ─── Data Fetching (17 problems) ───────────────────────────────

  {
    id: 'fe-react-fetch-loading-states',
    framework: 'react',
    category: 'Data Fetching',
    difficulty: 'easy',
    title: 'Loading State Machine',
    text: 'Create a state machine for data fetching with states: idle, loading, success, error. Transition from idle to loading. Return the new state.',
    setup: 'A mock state machine for fetching.',
    setupCode: `const transitions = {\n  idle: { FETCH: "loading" },\n  loading: { SUCCESS: "success", ERROR: "error" },\n  success: { FETCH: "loading" },\n  error: { FETCH: "loading", RESET: "idle" }\n};\nconst transition = (state, event) => transitions[state][event] || state;`,
    expected: 'loading',
    sample: 'transition("idle", "FETCH")',
    hints: ['Follow the state machine transitions', 'idle + FETCH = loading'],
    tags: ['data-fetching', 'state-machine', 'loading'],
  },
  {
    id: 'fe-react-fetch-error-handling',
    framework: 'react',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Fetch Error Handling Pattern',
    text: 'Simulate a failed fetch and extract the error message. Return the error state object.',
    setup: 'A mock fetch that fails.',
    setupCode: `const simulateFetch = (shouldFail) => {\n  if (shouldFail) {\n    return { loading: false, data: null, error: "Network request failed" };\n  }\n  return { loading: false, data: { id: 1 }, error: null };\n};`,
    expected: { loading: false, data: null, error: 'Network request failed' },
    sample: 'simulateFetch(true)',
    hints: ['Check the shouldFail flag', 'Return error state when fetch fails'],
    tags: ['data-fetching', 'error-handling', 'state'],
  },
  {
    id: 'fe-react-fetch-cache',
    framework: 'react',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Simple Request Cache',
    text: 'Implement a simple cache that stores fetch results by URL. Retrieve a cached result. Return the cached data.',
    setup: 'A mock fetch cache.',
    setupCode: `const cache = {};\nconst cachedFetch = (url, data) => {\n  if (cache[url]) return { cached: true, data: cache[url] };\n  cache[url] = data;\n  return { cached: false, data };\n};\ncachedFetch("/api/users", ["Alice", "Bob"]);`,
    expected: { cached: true, data: ['Alice', 'Bob'] },
    sample: 'cachedFetch("/api/users", null)',
    hints: ['Check cache first before fetching', 'Return cached data if available'],
    tags: ['data-fetching', 'cache', 'performance'],
  },
  {
    id: 'fe-react-fetch-abort',
    framework: 'react',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'AbortController Pattern',
    text: 'Simulate aborting a fetch request with AbortController. Return the abort status.',
    setup: 'A mock AbortController.',
    setupCode: `const AbortController = () => {\n  let aborted = false;\n  return {\n    signal: { get aborted() { return aborted; } },\n    abort: () => { aborted = true; }\n  };\n};\nconst controller = AbortController();\ncontroller.abort();`,
    expected: true,
    sample: 'controller.signal.aborted',
    hints: [
      'AbortController.abort() sets signal.aborted to true',
      'Use to cancel fetch in useEffect cleanup',
    ],
    tags: ['data-fetching', 'abort', 'cleanup'],
  },
  {
    id: 'fe-react-fetch-retry',
    framework: 'react',
    category: 'Data Fetching',
    difficulty: 'hard',
    title: 'Fetch with Retry Logic',
    text: 'Implement a fetch with retry that succeeds on the 3rd attempt. Return the result with attempt count.',
    setup: 'A mock fetch that fails twice then succeeds.',
    setupCode: `const fetchWithRetry = (maxRetries) => {\n  let attempt = 0;\n  const tryFetch = () => {\n    attempt++;\n    if (attempt < 3) return { ok: false, attempt };\n    return { ok: true, data: "success", attempt };\n  };\n  let result = tryFetch();\n  while (!result.ok && attempt < maxRetries) {\n    result = tryFetch();\n  }\n  return result;\n};`,
    expected: { ok: true, data: 'success', attempt: 3 },
    sample: 'fetchWithRetry(5)',
    hints: ['Retry until success or max retries', 'Succeeds on attempt 3'],
    tags: ['data-fetching', 'retry', 'resilience'],
  },
  {
    id: 'fe-react-fetch-race-condition',
    framework: 'react',
    category: 'Data Fetching',
    difficulty: 'hard',
    title: 'Race Condition Prevention',
    text: 'Simulate preventing stale data from a race condition by tracking request IDs. Return only the latest result.',
    setup: 'A mock system that prevents race conditions.',
    setupCode: `const createFetchManager = () => {\n  let currentId = 0;\n  return {\n    fetch: (data) => {\n      const id = ++currentId;\n      return { id, data };\n    },\n    isLatest: (id) => id === currentId\n  };\n};\nconst manager = createFetchManager();\nconst result1 = manager.fetch("stale");\nconst result2 = manager.fetch("fresh");`,
    expected: { isStale: true, isFresh: true },
    sample: '({ isStale: !manager.isLatest(result1.id), isFresh: manager.isLatest(result2.id) })',
    hints: ['Track request IDs to detect stale responses', 'Only the latest ID is valid'],
    tags: ['data-fetching', 'race-condition', 'stale-data'],
  },
  {
    id: 'fe-react-fetch-pagination',
    framework: 'react',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Paginated Data Fetching',
    text: 'Implement pagination state management. After fetching page 2, return the combined state.',
    setup: 'A mock pagination system.',
    setupCode: `const createPagination = () => {\n  let state = { items: [], page: 1, hasMore: true };\n  const fetchPage = (page, newItems) => {\n    state = {\n      items: [...state.items, ...newItems],\n      page,\n      hasMore: newItems.length > 0\n    };\n    return state;\n  };\n  fetchPage(1, ["a", "b"]);\n  return { fetchPage, getState: () => state };\n};\nconst pager = createPagination();\npager.fetchPage(2, ["c", "d"]);`,
    expected: { items: ['a', 'b', 'c', 'd'], page: 2, hasMore: true },
    sample: 'pager.getState()',
    hints: ['Accumulate items from all pages', 'Track current page and hasMore flag'],
    tags: ['data-fetching', 'pagination', 'state'],
  },
  {
    id: 'fe-react-fetch-dedupe',
    framework: 'react',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Request Deduplication',
    text: 'Implement request deduplication so the same URL is only fetched once. Return fetch counts per URL.',
    setup: 'A mock deduplication system.',
    setupCode: `const fetchCounts = {};\nconst pending = {};\nconst dedupedFetch = (url) => {\n  if (pending[url]) return pending[url];\n  fetchCounts[url] = (fetchCounts[url] || 0) + 1;\n  pending[url] = { data: url + "-data" };\n  return pending[url];\n};\ndedupedFetch("/api/users");\ndedupedFetch("/api/users");\ndedupedFetch("/api/posts");`,
    expected: { '/api/users': 1, '/api/posts': 1 },
    sample: 'fetchCounts',
    hints: [
      'Deduplication prevents duplicate in-flight requests',
      'Same URL should only count once',
    ],
    tags: ['data-fetching', 'deduplication', 'performance'],
  },
  {
    id: 'fe-react-fetch-optimistic',
    framework: 'react',
    category: 'Data Fetching',
    difficulty: 'hard',
    title: 'Optimistic Update Pattern',
    text: 'Implement optimistic update: update UI immediately, then confirm or rollback. Simulate a successful update and return the final state.',
    setup: 'A mock optimistic update system.',
    setupCode: `const optimisticUpdate = (current, optimistic, serverResult) => {\n  let state = optimistic;\n  if (serverResult.ok) {\n    state = serverResult.data;\n  } else {\n    state = current;\n  }\n  return state;\n};\nconst current = { likes: 10 };\nconst optimistic = { likes: 11 };\nconst serverResult = { ok: true, data: { likes: 11 } };`,
    expected: { likes: 11 },
    sample: 'optimisticUpdate(current, optimistic, serverResult)',
    hints: ['Apply optimistic update immediately', 'Keep if server confirms, rollback if not'],
    tags: ['data-fetching', 'optimistic-update', 'ux'],
  },
  {
    id: 'fe-react-fetch-stale-while-revalidate',
    framework: 'react',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Stale-While-Revalidate',
    text: 'Implement SWR pattern: return cached (stale) data immediately, then update with fresh data. Return the current state.',
    setup: 'A mock SWR system.',
    setupCode: `const swrCache = { "/api/data": { data: "stale-data", timestamp: 1000 } };\nconst swr = (url, freshData) => {\n  const cached = swrCache[url];\n  const state = { data: cached ? cached.data : null, isValidating: true };\n  swrCache[url] = { data: freshData, timestamp: 2000 };\n  state.data = freshData;\n  state.isValidating = false;\n  return state;\n};`,
    expected: { data: 'fresh-data', isValidating: false },
    sample: 'swr("/api/data", "fresh-data")',
    hints: ['SWR shows stale data then updates', 'After revalidation, fresh data replaces stale'],
    tags: ['data-fetching', 'swr', 'caching', 'stale'],
  },
  {
    id: 'fe-react-fetch-transform',
    framework: 'react',
    category: 'Data Fetching',
    difficulty: 'easy',
    title: 'Transform API Response',
    text: 'Transform an API response to extract and reshape data. Return the transformed result.',
    setup: 'A raw API response and a transform function.',
    setupCode: `const apiResponse = {\n  status: 200,\n  data: {\n    results: [\n      { id: 1, first_name: "Alice", last_name: "Smith" },\n      { id: 2, first_name: "Bob", last_name: "Jones" }\n    ]\n  }\n};\nconst transform = (res) => res.data.results.map(u => ({ id: u.id, name: u.first_name + " " + u.last_name }));`,
    expected: [
      { id: 1, name: 'Alice Smith' },
      { id: 2, name: 'Bob Jones' },
    ],
    sample: 'transform(apiResponse)',
    hints: ['Navigate to data.results', 'Combine first_name and last_name'],
    tags: ['data-fetching', 'transform', 'api'],
  },
  {
    id: 'fe-react-fetch-polling',
    framework: 'react',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Polling Data Pattern',
    text: 'Simulate 3 polling iterations that each update a counter. Return the final state after all polls.',
    setup: 'A mock polling system.',
    setupCode: `const poll = (times) => {\n  let state = { count: 0, polls: 0 };\n  for (let i = 0; i < times; i++) {\n    state.count += 10;\n    state.polls++;\n  }\n  return state;\n};`,
    expected: { count: 30, polls: 3 },
    sample: 'poll(3)',
    hints: ['Each poll adds 10 to count', '3 polls = count of 30'],
    tags: ['data-fetching', 'polling', 'interval'],
  },
  {
    id: 'fe-react-fetch-infinite-scroll',
    framework: 'react',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Infinite Scroll Data',
    text: 'Accumulate data from multiple page fetches for infinite scroll. After 3 pages, return the combined data and next cursor.',
    setup: 'A mock infinite scroll data accumulator.',
    setupCode: `const pages = [\n  { data: [1, 2], cursor: "c1" },\n  { data: [3, 4], cursor: "c2" },\n  { data: [5, 6], cursor: null }\n];\nconst accumulate = (pages) => ({\n  items: pages.flatMap(p => p.data),\n  nextCursor: pages[pages.length - 1].cursor,\n  hasMore: pages[pages.length - 1].cursor !== null\n});`,
    expected: { items: [1, 2, 3, 4, 5, 6], nextCursor: null, hasMore: false },
    sample: 'accumulate(pages)',
    hints: ['flatMap combines all page data', 'Last page cursor determines hasMore'],
    tags: ['data-fetching', 'infinite-scroll', 'pagination'],
  },
  {
    id: 'fe-react-fetch-normalize',
    framework: 'react',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Normalize API Data',
    text: 'Normalize an array of entities into a lookup object by id. Return the normalized structure.',
    setup: 'An entity array and normalizer.',
    setupCode: `const entities = [\n  { id: "u1", name: "Alice" },\n  { id: "u2", name: "Bob" },\n  { id: "u3", name: "Charlie" }\n];\nconst normalize = (items) => {\n  const byId = {};\n  const allIds = [];\n  items.forEach(item => {\n    byId[item.id] = item;\n    allIds.push(item.id);\n  });\n  return { byId, allIds };\n};`,
    expected: {
      byId: {
        u1: { id: 'u1', name: 'Alice' },
        u2: { id: 'u2', name: 'Bob' },
        u3: { id: 'u3', name: 'Charlie' },
      },
      allIds: ['u1', 'u2', 'u3'],
    },
    sample: 'normalize(entities)',
    hints: ['Create a byId lookup and allIds array', 'Common pattern for Redux/state management'],
    tags: ['data-fetching', 'normalize', 'state-management'],
  },
  {
    id: 'fe-react-fetch-parallel',
    framework: 'react',
    category: 'Data Fetching',
    difficulty: 'easy',
    title: 'Parallel Data Fetching',
    text: 'Simulate fetching two endpoints in parallel and combining results. Return the combined data.',
    setup: 'Mock parallel fetch results.',
    setupCode: `const fetchUser = () => ({ name: "Alice" });\nconst fetchPosts = () => ([{ title: "Hello" }]);\nconst fetchAll = () => {\n  const user = fetchUser();\n  const posts = fetchPosts();\n  return { user, posts };\n};`,
    expected: { user: { name: 'Alice' }, posts: [{ title: 'Hello' }] },
    sample: 'fetchAll()',
    hints: ['Fetch both endpoints simultaneously', 'Combine results into one object'],
    tags: ['data-fetching', 'parallel', 'Promise.all'],
  },
  {
    id: 'fe-react-fetch-dependent',
    framework: 'react',
    category: 'Data Fetching',
    difficulty: 'easy',
    title: 'Dependent Data Fetching',
    text: 'Fetch user first, then use their ID to fetch posts. Return the combined result.',
    setup: 'Mock dependent fetch functions.',
    setupCode: `const fetchUser = () => ({ id: 42, name: "Alice" });\nconst fetchUserPosts = (userId) => [{ userId, title: "Post by " + userId }];\nconst fetchSequential = () => {\n  const user = fetchUser();\n  const posts = fetchUserPosts(user.id);\n  return { user, posts };\n};`,
    expected: { user: { id: 42, name: 'Alice' }, posts: [{ userId: 42, title: 'Post by 42' }] },
    sample: 'fetchSequential()',
    hints: ['Second fetch depends on first result', 'Use user.id to fetch posts'],
    tags: ['data-fetching', 'dependent', 'waterfall'],
  },
  {
    id: 'fe-react-fetch-error-recovery',
    framework: 'react',
    category: 'Data Fetching',
    difficulty: 'easy',
    title: 'Error Recovery State',
    text: 'After a fetch error, transition to a recovery state with a retry count. Return the state.',
    setup: 'A mock error recovery system.',
    setupCode: `const errorRecovery = (error, retryCount) => ({\n  status: "error",\n  message: error,\n  retryCount,\n  canRetry: retryCount < 3\n});`,
    expected: { status: 'error', message: 'Timeout', retryCount: 1, canRetry: true },
    sample: 'errorRecovery("Timeout", 1)',
    hints: ['Track error message and retry count', 'canRetry is true if under max retries'],
    tags: ['data-fetching', 'error', 'recovery', 'retry'],
  },

  // ─── Forms & Validation (17 problems) ──────────────────────────

  {
    id: 'fe-react-form-multifield',
    framework: 'react',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'Multi-Field Form State',
    text: 'Manage a form with multiple fields using a single state object. Update the email field and return the new state.',
    setup: 'A mock form state manager.',
    setupCode: `const formState = { name: "Alice", email: "", age: 25 };\nconst updateField = (state, field, value) => ({ ...state, [field]: value });`,
    expected: { name: 'Alice', email: 'alice@test.com', age: 25 },
    sample: 'updateField(formState, "email", "alice@test.com")',
    hints: ['Use computed property names [field]', 'Spread existing state and override one field'],
    tags: ['forms', 'multi-field', 'state'],
  },
  {
    id: 'fe-react-form-validation-sync',
    framework: 'react',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'Synchronous Validation',
    text: 'Validate a form with rules: name required, email must contain @, age must be > 0. Return the errors object.',
    setup: 'A mock form validator.',
    setupCode: `const validate = (values) => {\n  const errors = {};\n  if (!values.name) errors.name = "Name is required";\n  if (!values.email.includes("@")) errors.email = "Invalid email";\n  if (values.age <= 0) errors.age = "Age must be positive";\n  return errors;\n};`,
    expected: { email: 'Invalid email' },
    sample: 'validate({ name: "Alice", email: "invalid", age: 25 })',
    hints: ['Check each field against its rule', 'Only add errors for failing validations'],
    tags: ['forms', 'validation', 'synchronous'],
  },
  {
    id: 'fe-react-form-touched',
    framework: 'react',
    category: 'Forms & Validation',
    difficulty: 'easy',
    title: 'Field Touched State',
    text: 'Track which form fields have been touched (blurred). After touching name and email, return the touched state.',
    setup: 'A mock touched state tracker.',
    setupCode: `const createTouched = () => {\n  const touched = {};\n  const touch = (field) => { touched[field] = true; };\n  touch("name");\n  touch("email");\n  return touched;\n};`,
    expected: { name: true, email: true },
    sample: 'createTouched()',
    hints: ['Track touched state per field', 'Set to true on blur'],
    tags: ['forms', 'touched', 'field-state'],
  },
  {
    id: 'fe-react-form-dirty-check',
    framework: 'react',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'Form Dirty Check',
    text: 'Compare current form values with initial values to determine if the form is dirty. Return the dirty status.',
    setup: 'Initial and current form values.',
    setupCode: `const initial = { name: "Alice", email: "alice@test.com" };\nconst current = { name: "Alice", email: "alice@new.com" };\nconst isDirty = (init, curr) => Object.keys(init).some(key => init[key] !== curr[key]);`,
    expected: true,
    sample: 'isDirty(initial, current)',
    hints: ['Compare each field value', 'Dirty if any field differs from initial'],
    tags: ['forms', 'dirty', 'comparison'],
  },
  {
    id: 'fe-react-form-submit-handler',
    framework: 'react',
    category: 'Forms & Validation',
    difficulty: 'easy',
    title: 'Form Submit Handler',
    text: 'Create a submit handler that validates before submitting. Return the submission result.',
    setup: 'A mock form submission system.',
    setupCode: `const handleSubmit = (values, validate) => {\n  const errors = validate(values);\n  if (Object.keys(errors).length > 0) return { success: false, errors };\n  return { success: true, data: values };\n};\nconst noErrors = () => ({});`,
    expected: { success: true, data: { name: 'Alice' } },
    sample: 'handleSubmit({ name: "Alice" }, noErrors)',
    hints: ['Validate first, submit if no errors', 'Return success with data on valid submit'],
    tags: ['forms', 'submit', 'validation'],
  },
  {
    id: 'fe-react-form-dynamic-fields',
    framework: 'react',
    category: 'Forms & Validation',
    difficulty: 'hard',
    title: 'Dynamic Form Fields',
    text: 'Manage a form where fields can be added and removed dynamically. Add a field, then remove the first. Return the final fields.',
    setup: 'A mock dynamic fields manager.',
    setupCode: `const createFieldManager = () => {\n  let fields = [{ id: 1, value: "first" }, { id: 2, value: "second" }];\n  return {\n    add: (field) => { fields = [...fields, field]; },\n    remove: (id) => { fields = fields.filter(f => f.id !== id); },\n    getFields: () => fields\n  };\n};\nconst manager = createFieldManager();\nmanager.add({ id: 3, value: "third" });\nmanager.remove(1);`,
    expected: [
      { id: 2, value: 'second' },
      { id: 3, value: 'third' },
    ],
    sample: 'manager.getFields()',
    hints: ['Add appends to array', 'Remove filters by id'],
    tags: ['forms', 'dynamic-fields', 'array-state'],
  },
  {
    id: 'fe-react-form-field-array',
    framework: 'react',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'Field Array Pattern',
    text: 'Manage an array of phone numbers in a form. Append, prepend, and swap. Return the final order.',
    setup: 'A mock field array helper.',
    setupCode: `const fieldArray = (initial) => {\n  let arr = [...initial];\n  return {\n    append: (val) => { arr = [...arr, val]; },\n    prepend: (val) => { arr = [val, ...arr]; },\n    swap: (a, b) => { const temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; },\n    getValues: () => arr\n  };\n};\nconst phones = fieldArray(["111", "222"]);\nphones.append("333");\nphones.prepend("000");\nphones.swap(0, 3);`,
    expected: ['333', '111', '222', '000'],
    sample: 'phones.getValues()',
    hints: ['append adds to end, prepend adds to start', 'swap exchanges two positions'],
    tags: ['forms', 'field-array', 'array-manipulation'],
  },
  {
    id: 'fe-react-form-async-validation',
    framework: 'react',
    category: 'Forms & Validation',
    difficulty: 'hard',
    title: 'Async Field Validation',
    text: 'Simulate async validation that checks if a username is taken. Return the validation result for a taken username.',
    setup: 'A mock async validator.',
    setupCode: `const takenUsernames = ["alice", "bob", "admin"];\nconst validateUsername = (username) => {\n  const isTaken = takenUsernames.includes(username.toLowerCase());\n  return { valid: !isTaken, error: isTaken ? "Username already taken" : null };\n};`,
    expected: { valid: false, error: 'Username already taken' },
    sample: 'validateUsername("alice")',
    hints: ['Check against the taken list', 'Return valid:false with error if taken'],
    tags: ['forms', 'async-validation', 'username'],
  },
  {
    id: 'fe-react-form-nested-object',
    framework: 'react',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'Nested Form Values',
    text: 'Update a deeply nested form value using a path string. Return the updated form state.',
    setup: 'A mock nested value setter.',
    setupCode: `const setNested = (obj, path, value) => {\n  const keys = path.split(".");\n  const result = JSON.parse(JSON.stringify(obj));\n  let current = result;\n  for (let i = 0; i < keys.length - 1; i++) {\n    current = current[keys[i]];\n  }\n  current[keys[keys.length - 1]] = value;\n  return result;\n};\nconst form = { user: { address: { city: "NYC", zip: "10001" } } };`,
    expected: { user: { address: { city: 'LA', zip: '10001' } } },
    sample: 'setNested(form, "user.address.city", "LA")',
    hints: ['Split the path by dots', 'Navigate to the nested location and set the value'],
    tags: ['forms', 'nested', 'deep-update'],
  },
  {
    id: 'fe-react-form-radio-group',
    framework: 'react',
    category: 'Forms & Validation',
    difficulty: 'easy',
    title: 'Radio Group State',
    text: 'Manage a radio group where only one option can be selected. Select "medium" and return the state.',
    setup: 'A mock radio group state.',
    setupCode: `const radioGroup = (options, selected) => ({\n  options,\n  selected,\n  isSelected: (opt) => opt === selected\n});\nconst sizes = radioGroup(["small", "medium", "large"], "medium");`,
    expected: { options: ['small', 'medium', 'large'], selected: 'medium' },
    sample: '({ options: sizes.options, selected: sizes.selected })',
    hints: ['Radio group allows single selection', 'Track the selected value'],
    tags: ['forms', 'radio', 'selection'],
  },
  {
    id: 'fe-react-form-checkbox-group',
    framework: 'react',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'Checkbox Group State',
    text: 'Manage a checkbox group where multiple options can be selected. Toggle "react" and "vue". Return selected items.',
    setup: 'A mock checkbox group.',
    setupCode: `const checkboxGroup = () => {\n  let selected = new Set();\n  const toggle = (item) => {\n    if (selected.has(item)) selected.delete(item);\n    else selected.add(item);\n  };\n  toggle("react");\n  toggle("vue");\n  return Array.from(selected).sort();\n};`,
    expected: ['react', 'vue'],
    sample: 'checkboxGroup()',
    hints: ['Toggle adds if not present, removes if present', 'Use Set for efficient toggling'],
    tags: ['forms', 'checkbox', 'multi-select'],
  },
  {
    id: 'fe-react-form-error-display',
    framework: 'react',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'Error Display Logic',
    text: 'Show errors only for touched fields that have validation errors. Return the visible errors.',
    setup: 'Mock touched state and errors.',
    setupCode: `const errors = { name: "Required", email: "Invalid email", age: null };\nconst touched = { name: true, email: false, age: true };\nconst visibleErrors = (errors, touched) => {\n  const result = {};\n  Object.keys(errors).forEach(key => {\n    if (touched[key] && errors[key]) result[key] = errors[key];\n  });\n  return result;\n};`,
    expected: { name: 'Required' },
    sample: 'visibleErrors(errors, touched)',
    hints: ['Only show errors for touched fields', 'Filter out null errors and untouched fields'],
    tags: ['forms', 'errors', 'touched', 'ux'],
  },
  {
    id: 'fe-react-form-multistep',
    framework: 'react',
    category: 'Forms & Validation',
    difficulty: 'hard',
    title: 'Multi-Step Form Wizard',
    text: 'Manage a multi-step form that collects data across 3 steps. Merge all step data and return the complete form values.',
    setup: 'A mock multi-step form.',
    setupCode: `const createWizard = (steps) => {\n  let currentStep = 0;\n  const data = {};\n  return {\n    next: (stepData) => {\n      Object.assign(data, stepData);\n      currentStep++;\n      return currentStep;\n    },\n    complete: () => ({ step: currentStep, data }),\n    getData: () => data\n  };\n};\nconst wizard = createWizard(3);\nwizard.next({ name: "Alice", email: "alice@test.com" });\nwizard.next({ plan: "pro", billing: "yearly" });\nwizard.next({ agree: true });`,
    expected: {
      name: 'Alice',
      email: 'alice@test.com',
      plan: 'pro',
      billing: 'yearly',
      agree: true,
    },
    sample: 'wizard.getData()',
    hints: [
      'Each step merges new data into the form state',
      'All steps combined give the complete data',
    ],
    tags: ['forms', 'wizard', 'multi-step'],
  },
  {
    id: 'fe-react-form-select-multiple',
    framework: 'react',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'Multi-Select Dropdown',
    text: 'Manage a multi-select dropdown state. Select options and return the selected values.',
    setup: 'A mock multi-select handler.',
    setupCode: `const multiSelect = (options, selectedValues) => {\n  return {\n    options,\n    selected: selectedValues,\n    display: selectedValues.join(", ")\n  };\n};`,
    expected: { options: ['JS', 'TS', 'Python', 'Go'], selected: ['JS', 'TS'], display: 'JS, TS' },
    sample: 'multiSelect(["JS", "TS", "Python", "Go"], ["JS", "TS"])',
    hints: ['Multi-select allows multiple selections', 'Display joins selected values'],
    tags: ['forms', 'select', 'multi-select'],
  },
  {
    id: 'fe-react-form-password-validation',
    framework: 'react',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'Password Strength Validation',
    text: 'Validate password strength based on rules: min 8 chars, has uppercase, has number. Return the validation result.',
    setup: 'A mock password validator.',
    setupCode: `const validatePassword = (password) => {\n  const rules = [\n    { label: "Min 8 characters", pass: password.length >= 8 },\n    { label: "Has uppercase", pass: /[A-Z]/.test(password) },\n    { label: "Has number", pass: /[0-9]/.test(password) }\n  ];\n  const strength = rules.filter(r => r.pass).length;\n  return { rules, strength, valid: strength === rules.length };\n};\nconst result = validatePassword("Hello123");`,
    expected: { strength: 3, valid: true },
    sample: '({ strength: result.strength, valid: result.valid })',
    hints: ['Check each rule independently', 'Strength is the count of passing rules'],
    tags: ['forms', 'password', 'strength', 'validation'],
  },
  {
    id: 'fe-react-form-debounced-validation',
    framework: 'react',
    category: 'Forms & Validation',
    difficulty: 'hard',
    title: 'Debounced Form Validation',
    text: 'Implement debounced validation that only validates after the user stops typing. Simulate rapid input and return the final validation.',
    setup: 'A mock debounced validator.',
    setupCode: `const debouncedValidate = () => {\n  let lastValue = "";\n  const validate = (val) => {\n    lastValue = val;\n    return val.length >= 3 ? { valid: true } : { valid: false, error: "Min 3 chars" };\n  };\n  validate("a");\n  validate("ab");\n  validate("abc");\n  return validate(lastValue);\n};`,
    expected: { valid: true },
    sample: 'debouncedValidate()',
    hints: ['Debounced validation runs on the final value', 'Only the last input matters'],
    tags: ['forms', 'debounce', 'validation'],
  },
  {
    id: 'fe-react-form-reset',
    framework: 'react',
    category: 'Forms & Validation',
    difficulty: 'easy',
    title: 'Form Reset Pattern',
    text: 'Reset a form to its initial values. Return the form state after reset.',
    setup: 'A mock form with reset capability.',
    setupCode: `const createForm = (initialValues) => {\n  let values = { ...initialValues };\n  return {\n    update: (field, val) => { values = { ...values, [field]: val }; },\n    reset: () => { values = { ...initialValues }; },\n    getValues: () => values\n  };\n};\nconst form = createForm({ name: "", email: "" });\nform.update("name", "Alice");\nform.update("email", "alice@test.com");\nform.reset();`,
    expected: { name: '', email: '' },
    sample: 'form.getValues()',
    hints: ['Reset restores initial values', 'All fields go back to their defaults'],
    tags: ['forms', 'reset', 'initial-values'],
  },
];
