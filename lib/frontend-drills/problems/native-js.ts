import type { FrontendDrillProblem } from '../types';

/**
 * Native JavaScript drill problems.
 * These problems use plain JS objects to simulate DOM structures
 * since the validator blocks window, document, fetch, and eval.
 */
export const nativeJsProblems: FrontendDrillProblem[] = [
  // DOM & Events
  {
    id: 'fe-js-query-class',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'easy',
    title: 'Query Elements by Class',
    text: 'Filter the elements array to find all elements with the class "active".',
    setup: 'An array of element objects with tagName, id, and classList properties.',
    setupCode: `const elements = [
  { tagName: "div", id: "a", classList: ["active", "card"] },
  { tagName: "span", id: "b", classList: ["hidden"] },
  { tagName: "div", id: "c", classList: ["active"] },
  { tagName: "p", id: "d", classList: [] }
];`,
    expected: [
      { tagName: 'div', id: 'a', classList: ['active', 'card'] },
      { tagName: 'div', id: 'c', classList: ['active'] },
    ],
    sample: 'elements.filter(el => el.classList.includes("active"))',
    hints: ['Use .filter() and .includes() methods', 'Check if classList array includes "active"'],
    tags: ['DOM', 'filter', 'classList', 'querySelector'],
  },

  {
    id: 'fe-js-event-delegation',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'Event Delegation Pattern',
    text: 'Given an array of click events (each with a target.id), filter only those where target.id starts with "btn-".',
    setup: 'An array of event objects with target.id properties.',
    setupCode: `const events = [
  { type: "click", target: { id: "btn-submit" } },
  { type: "click", target: { id: "link-home" } },
  { type: "click", target: { id: "btn-cancel" } },
  { type: "click", target: { id: "div-container" } },
  { type: "click", target: { id: "btn-delete" } }
];`,
    expected: [
      { type: 'click', target: { id: 'btn-submit' } },
      { type: 'click', target: { id: 'btn-cancel' } },
      { type: 'click', target: { id: 'btn-delete' } },
    ],
    sample: 'events.filter(e => e.target.id.startsWith("btn-"))',
    hints: ['Use .filter() with .startsWith()', 'Access target.id from each event object'],
    tags: ['events', 'delegation', 'filter', 'startsWith'],
  },

  // Common Patterns
  {
    id: 'fe-js-debounce-basic',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Debounce Function',
    text: 'Implement a simple debounce function that delays execution until after a specified wait time.',
    setup: 'Return a debounce function that takes (func, wait) and returns a debounced version.',
    setupCode: `let callCount = 0;
const increment = () => { callCount++; };
const debounced = debounce(increment, 100);`,
    expected: 'function',
    sample: `function debounce(func, wait) {
  let timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), wait);
  };
}`,
    hints: [
      'Use setTimeout and clearTimeout',
      'Return a new function that clears previous timeout',
      'Store timeout in closure',
    ],
    tags: ['debounce', 'closure', 'setTimeout', 'performance'],
  },

  {
    id: 'fe-js-throttle-basic',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Throttle Function',
    text: 'Implement a simple throttle function that ensures a function is called at most once per specified interval.',
    setup: 'Return a throttle function that takes (func, limit) and returns a throttled version.',
    setupCode: `let callCount = 0;
const increment = () => { callCount++; };
const throttled = throttle(increment, 100);`,
    expected: 'function',
    sample: `function throttle(func, limit) {
  let inThrottle;
  return function(...args) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}`,
    hints: [
      'Use a flag to track throttle state',
      'Call function immediately if not throttled',
      'Reset flag after timeout',
    ],
    tags: ['throttle', 'closure', 'setTimeout', 'performance'],
  },

  {
    id: 'fe-js-localstorage-mock',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'easy',
    title: 'LocalStorage Mock Operations',
    text: 'Using the provided storage object (a plain object), set "theme" to "dark" and return the value.',
    setup: 'A plain object simulating localStorage with setItem and getItem methods.',
    setupCode: `const storage = {
  data: {},
  setItem(key, value) { this.data[key] = value; },
  getItem(key) { return this.data[key]; }
};`,
    expected: 'dark',
    sample: `storage.setItem("theme", "dark");
const theme = storage.getItem("theme");`,
    hints: ['Call setItem to store the value', 'Call getItem to retrieve it'],
    tags: ['localStorage', 'storage', 'API'],
  },

  // Rendering
  {
    id: 'fe-js-build-html-string',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'easy',
    title: 'Build HTML String from Array',
    text: 'Given an array of items, create an HTML string of <li> elements.',
    setup: 'An array of fruit names.',
    setupCode: `const items = ["Apple", "Banana", "Cherry"];`,
    expected: '<li>Apple</li><li>Banana</li><li>Cherry</li>',
    // biome-ignore lint/suspicious/noTemplateCurlyInString: sample holds user solution code containing template literals
    sample: 'items.map(item => `<li>${item}</li>`).join("")',
    hints: [
      'Use .map() to transform each item',
      'Use template literals',
      'Join the array into a string',
    ],
    tags: ['innerHTML', 'map', 'template literals', 'rendering'],
  },

  {
    id: 'fe-js-create-element-object',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'medium',
    title: 'Create Element Object',
    text: 'Create an object representing a button element with tagName "button", textContent "Click me", and attributes object with class "btn-primary".',
    setup: 'Return an object that simulates a DOM element.',
    setupCode: `// Expected structure:
// { tagName: "button", textContent: "Click me", attributes: { class: "btn-primary" } }`,
    expected: {
      tagName: 'button',
      textContent: 'Click me',
      attributes: { class: 'btn-primary' },
    },
    sample: `const element = {
  tagName: "button",
  textContent: "Click me",
  attributes: { class: "btn-primary" }
};`,
    hints: ['Create a plain object with tagName, textContent, and attributes properties'],
    tags: ['createElement', 'DOM', 'object'],
  },

  // Data Fetching
  {
    id: 'fe-js-mock-fetch-promise',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Mock Fetch with Promise',
    text: 'Create a mockFetch function that returns a Promise resolving to { data: [1, 2, 3] } after 0ms.',
    setup: 'Return a function that returns a Promise.',
    setupCode: `// mockFetch should resolve to { data: [1, 2, 3] }`,
    expected: 'function',
    sample: `function mockFetch() {
  return Promise.resolve({ data: [1, 2, 3] });
}`,
    hints: [
      'Use Promise.resolve() to create a resolved promise',
      'Return an object with data property',
    ],
    tags: ['fetch', 'Promise', 'async', 'API'],
  },

  {
    id: 'fe-js-async-await-pattern',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Async/Await Data Extraction',
    text: 'Create an async function that calls mockFetch() and returns the data property from the result.',
    setup: 'A mockFetch function that returns Promise.resolve({ data: [1, 2, 3] }).',
    setupCode: `const mockFetch = () => Promise.resolve({ data: [1, 2, 3] });`,
    expected: 'function',
    sample: `async function getData() {
  const result = await mockFetch();
  return result.data;
}`,
    hints: [
      'Use async function keyword',
      'Use await to wait for the promise',
      'Return the data property',
    ],
    tags: ['async', 'await', 'Promise', 'data'],
  },

  // Forms & Validation
  {
    id: 'fe-js-email-validation',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'easy',
    title: 'Email Validation Function',
    text: 'Create a function isValidEmail(email) that returns true if the email contains "@" and ".", false otherwise.',
    setup: 'Return a validation function.',
    setupCode: `const testEmail = "user@example.com";`,
    expected: 'function',
    sample: `function isValidEmail(email) {
  return email.includes("@") && email.includes(".");
}`,
    hints: ['Use .includes() to check for both "@" and "."', 'Return a boolean'],
    tags: ['validation', 'forms', 'email', 'regex'],
  },

  {
    id: 'fe-js-form-data-extract',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'Extract Form Data from Array',
    text: 'Given an array of input objects with name and value properties, create an object mapping names to values.',
    setup: 'An array of form input objects.',
    setupCode: `const inputs = [
  { name: "username", value: "john" },
  { name: "email", value: "john@example.com" },
  { name: "age", value: "30" }
];`,
    expected: {
      username: 'john',
      email: 'john@example.com',
      age: '30',
    },
    sample: `inputs.reduce((acc, input) => {
  acc[input.name] = input.value;
  return acc;
}, {})`,
    hints: [
      'Use .reduce() to build an object',
      'Set acc[input.name] = input.value',
      'Start with empty object {}',
    ],
    tags: ['forms', 'reduce', 'object', 'FormData'],
  },

  {
    id: 'fe-js-password-strength',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'Password Strength Validator',
    text: 'Create a function checkPasswordStrength(password) that returns "weak" if length < 8, "medium" if length < 12, else "strong".',
    setup: 'Return a validation function.',
    setupCode: `const testPassword = "MyP@ssw0rd";`,
    expected: 'function',
    sample: `function checkPasswordStrength(password) {
  if (password.length < 8) return "weak";
  if (password.length < 12) return "medium";
  return "strong";
}`,
    hints: [
      'Check password.length',
      'Use if/else or ternary operators',
      'Return one of three strings',
    ],
    tags: ['validation', 'forms', 'password', 'security'],
  },

  // ─── NEW DOM & Events (17) ───────────────────────────────────

  {
    id: 'fe-js-classlist-toggle',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'easy',
    title: 'Toggle Class on Element',
    text: 'Given an element object with a classList array, implement a toggleClass function that adds the class if not present or removes it if present. Return the updated classList.',
    setup: 'An element object with classList array.',
    setupCode: `const el = { classList: ["active", "card"] };\nfunction toggleClass(element, cls) {\n  const idx = element.classList.indexOf(cls);\n  if (idx >= 0) element.classList.splice(idx, 1);\n  else element.classList.push(cls);\n  return element.classList;\n}`,
    expected: ['card'],
    sample: 'toggleClass(el, "active")',
    hints: ['Check if class exists with indexOf', 'Remove with splice, add with push'],
    tags: ['DOM', 'classList', 'toggle'],
  },

  {
    id: 'fe-js-add-class',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'easy',
    title: 'Add Class to Element',
    text: 'Given an element object with a classList array, add the class "highlight" only if it is not already present. Return the classList.',
    setup: 'An element object with classList array.',
    setupCode: `const el = { classList: ["card"] };\nfunction addClass(element, cls) {\n  if (!element.classList.includes(cls)) element.classList.push(cls);\n  return element.classList;\n}`,
    expected: ['card', 'highlight'],
    sample: 'addClass(el, "highlight")',
    hints: ['Check with includes before pushing'],
    tags: ['DOM', 'classList', 'add'],
  },

  {
    id: 'fe-js-remove-class',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'easy',
    title: 'Remove Class from Element',
    text: 'Given an element object with a classList array, remove the class "hidden" and return the updated classList.',
    setup: 'An element object with classList array.',
    setupCode: `const el = { classList: ["card", "hidden", "active"] };\nfunction removeClass(element, cls) {\n  const idx = element.classList.indexOf(cls);\n  if (idx >= 0) element.classList.splice(idx, 1);\n  return element.classList;\n}`,
    expected: ['card', 'active'],
    sample: 'removeClass(el, "hidden")',
    hints: ['Find the index with indexOf', 'Remove with splice'],
    tags: ['DOM', 'classList', 'remove'],
  },

  {
    id: 'fe-js-event-object-create',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'easy',
    title: 'Create Event Object',
    text: 'Create a keyboard event object with type "keydown", key "Enter", and keyCode 13.',
    setup: 'Return a plain event object.',
    setupCode: `// Build the event object`,
    expected: { type: 'keydown', key: 'Enter', keyCode: 13 },
    sample: `const event = { type: "keydown", key: "Enter", keyCode: 13 };`,
    hints: ['Create a plain object with type, key, and keyCode'],
    tags: ['DOM', 'events', 'keyboard'],
  },

  {
    id: 'fe-js-closest-ancestor',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'Find Closest Ancestor',
    text: 'Given a node with parent references, implement a closest function that walks up the tree and returns the first ancestor whose tagName matches the given tag (case-insensitive), or null.',
    setup: 'A chain of node objects linked by parent property.',
    setupCode: `const grandparent = { tagName: "DIV", parent: null };\nconst par = { tagName: "UL", parent: grandparent };\nconst child = { tagName: "LI", parent: par };\nfunction closest(node, tag) {\n  let cur = node.parent;\n  while (cur) {\n    if (cur.tagName.toLowerCase() === tag.toLowerCase()) return cur;\n    cur = cur.parent;\n  }\n  return null;\n}`,
    expected: { tagName: 'UL', parent: { tagName: 'DIV', parent: null } },
    sample: 'closest(child, "ul")',
    hints: ['Walk up using parent references', 'Compare tagName case-insensitively'],
    tags: ['DOM', 'traversal', 'closest'],
  },

  {
    id: 'fe-js-event-listener-map',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'Event Listener Map',
    text: 'Implement an event listener registry: addEventListener adds a callback for an event type, and emit calls all listeners for that type with the given data. Return the collected results.',
    setup: 'An event registry object.',
    setupCode: `const registry = { listeners: {} };\nfunction addEventListener(reg, type, cb) {\n  if (!reg.listeners[type]) reg.listeners[type] = [];\n  reg.listeners[type].push(cb);\n}\nfunction emit(reg, type, data) {\n  return (reg.listeners[type] || []).map(cb => cb(data));\n}\naddEventListener(registry, "click", d => d.x + 1);\naddEventListener(registry, "click", d => d.x * 2);`,
    expected: [11, 20],
    sample: 'emit(registry, "click", { x: 10 })',
    hints: [
      'Store listeners in an object keyed by event type',
      'Map over listeners to collect results',
    ],
    tags: ['DOM', 'events', 'listeners', 'registry'],
  },

  {
    id: 'fe-js-stop-propagation',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'Simulate Event Propagation',
    text: 'Given an array of handler objects (each with a handler function and a stopPropagation flag), simulate event bubbling. Execute handlers in order, but stop if any handler sets stopPropagation to true. Return the array of results from executed handlers.',
    setup: 'An array of handler descriptors.',
    setupCode: `const handlers = [\n  { handler: () => "child", stop: false },\n  { handler: () => "parent", stop: true },\n  { handler: () => "grandparent", stop: false }\n];\nfunction propagate(handlers) {\n  const results = [];\n  for (const h of handlers) {\n    results.push(h.handler());\n    if (h.stop) break;\n  }\n  return results;\n}`,
    expected: ['child', 'parent'],
    sample: 'propagate(handlers)',
    hints: ['Loop through handlers and collect results', 'Break when stop is true'],
    tags: ['DOM', 'events', 'propagation', 'bubbling'],
  },

  {
    id: 'fe-js-delegate-match',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'Delegation Selector Match',
    text: 'Implement a delegateMatch function that checks if a target element matches a simple selector. Support "#id" for id matching and ".class" for classList matching. Return true or false.',
    setup: 'A target element object and selector strings.',
    setupCode: `const target = { id: "btn-1", classList: ["primary", "large"] };\nfunction delegateMatch(el, selector) {\n  if (selector.startsWith("#")) return el.id === selector.slice(1);\n  if (selector.startsWith(".")) return el.classList.includes(selector.slice(1));\n  return false;\n}`,
    expected: true,
    sample: 'delegateMatch(target, ".primary")',
    hints: ['Check first character for # or .', 'Slice off the prefix and compare'],
    tags: ['DOM', 'events', 'delegation', 'selector'],
  },

  {
    id: 'fe-js-pointer-event',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'easy',
    title: 'Pointer Event Position',
    text: 'Given a pointer event object with clientX, clientY, and a container offset, calculate the position relative to the container. Return { x, y }.',
    setup: 'A pointer event and container offset.',
    setupCode: `const event = { clientX: 150, clientY: 200 };\nconst offset = { left: 50, top: 30 };\nfunction relativePos(evt, off) {\n  return { x: evt.clientX - off.left, y: evt.clientY - off.top };\n}`,
    expected: { x: 100, y: 170 },
    sample: 'relativePos(event, offset)',
    hints: ['Subtract container offset from client coordinates'],
    tags: ['DOM', 'events', 'pointer', 'position'],
  },

  {
    id: 'fe-js-focus-trap',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'Focus Trap Cycle',
    text: 'Given an array of focusable element ids and a current focus index, implement focusNext and focusPrev that cycle through the elements. Return the id at the new index.',
    setup: 'An array of focusable ids and current index.',
    setupCode: `const focusable = ["input-name", "input-email", "btn-submit"];\nfunction focusNext(items, currentIdx) {\n  return items[(currentIdx + 1) % items.length];\n}\nfunction focusPrev(items, currentIdx) {\n  return items[(currentIdx - 1 + items.length) % items.length];\n}`,
    expected: 'input-name',
    sample: 'focusNext(focusable, 2)',
    hints: ['Use modulo to wrap around', 'For prev, add length before modulo to avoid negatives'],
    tags: ['DOM', 'focus', 'accessibility', 'trap'],
  },

  {
    id: 'fe-js-scroll-position',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'Scroll Progress Percentage',
    text: 'Given scrollTop, scrollHeight, and clientHeight, calculate the scroll progress as a percentage (0-100), rounded to the nearest integer.',
    setup: 'Scroll dimension values.',
    setupCode: `const scrollTop = 250;\nconst scrollHeight = 1000;\nconst clientHeight = 500;\nfunction scrollProgress(top, total, visible) {\n  return Math.round((top / (total - visible)) * 100);\n}`,
    expected: 50,
    sample: 'scrollProgress(scrollTop, scrollHeight, clientHeight)',
    hints: [
      'Max scroll is scrollHeight - clientHeight',
      'Divide scrollTop by max scroll and multiply by 100',
    ],
    tags: ['DOM', 'scroll', 'position', 'percentage'],
  },

  {
    id: 'fe-js-mutation-observer-sim',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'hard',
    title: 'MutationObserver Simulation',
    text: 'Implement a simple mutation observer that watches an object for property changes. The observe function should use a Proxy to intercept set operations and collect mutations. Return the mutations array after making changes.',
    setup: 'A target object and observer setup.',
    setupCode: `function createObserver() {\n  const mutations = [];\n  function observe(target) {\n    return new Proxy(target, {\n      set(obj, prop, value) {\n        mutations.push({ type: "attribute", property: prop, oldValue: obj[prop], newValue: value });\n        obj[prop] = value;\n        return true;\n      }\n    });\n  }\n  return { observe, mutations };\n}\nconst obs = createObserver();\nconst watched = obs.observe({ name: "Alice", age: 30 });\nwatched.name = "Bob";\nwatched.age = 31;`,
    expected: [
      { type: 'attribute', property: 'name', oldValue: 'Alice', newValue: 'Bob' },
      { type: 'attribute', property: 'age', oldValue: 30, newValue: 31 },
    ],
    sample: 'obs.mutations',
    hints: ['Use Proxy with a set trap', 'Record old and new values in the mutations array'],
    tags: ['DOM', 'MutationObserver', 'Proxy', 'reactive'],
  },

  {
    id: 'fe-js-intersection-observer-sim',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'hard',
    title: 'IntersectionObserver Simulation',
    text: 'Given an array of elements with their top positions and a viewport range (viewTop, viewBottom), determine which elements are "intersecting" (their top is within the viewport). Return an array of entry objects with { id, isIntersecting }.',
    setup: 'Elements with positions and a viewport.',
    setupCode: `const elements = [\n  { id: "a", top: 50 },\n  { id: "b", top: 300 },\n  { id: "c", top: 600 },\n  { id: "d", top: 900 }\n];\nconst viewTop = 100;\nconst viewBottom = 700;\nfunction checkIntersections(els, vTop, vBottom) {\n  return els.map(el => ({\n    id: el.id,\n    isIntersecting: el.top >= vTop && el.top <= vBottom\n  }));\n}`,
    expected: [
      { id: 'a', isIntersecting: false },
      { id: 'b', isIntersecting: true },
      { id: 'c', isIntersecting: true },
      { id: 'd', isIntersecting: false },
    ],
    sample: 'checkIntersections(elements, viewTop, viewBottom)',
    hints: ['Check if element top is within viewport range', 'Map to entry objects'],
    tags: ['DOM', 'IntersectionObserver', 'viewport', 'visibility'],
  },

  {
    id: 'fe-js-resize-observer-sim',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'ResizeObserver Simulation',
    text: 'Given an element object with width and height, and a resize function that updates dimensions, collect resize entries. Return the entries after two resizes.',
    setup: 'Element object and resize tracking.',
    setupCode: `const entries = [];\nconst el = { width: 100, height: 50 };\nfunction resize(element, w, h) {\n  const old = { width: element.width, height: element.height };\n  element.width = w;\n  element.height = h;\n  entries.push({ target: element.width + "x" + element.height, previousSize: old.width + "x" + old.height });\n}\nresize(el, 200, 100);\nresize(el, 300, 150);`,
    expected: [
      { target: '200x100', previousSize: '100x50' },
      { target: '300x150', previousSize: '200x100' },
    ],
    sample: 'entries',
    hints: ['Record old dimensions before updating', 'Push entry after each resize'],
    tags: ['DOM', 'ResizeObserver', 'dimensions'],
  },

  {
    id: 'fe-js-custom-dispatch',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'Custom Event Dispatch',
    text: 'Implement a dispatchEvent system where elements can have listeners and dispatching an event calls all matching listeners. Return collected results.',
    setup: 'Element with listener map.',
    setupCode: `const el = { listeners: {} };\nfunction on(element, type, cb) {\n  if (!element.listeners[type]) element.listeners[type] = [];\n  element.listeners[type].push(cb);\n}\nfunction dispatch(element, type, detail) {\n  return (element.listeners[type] || []).map(cb => cb({ type, detail }));\n}\non(el, "custom", e => e.detail.value * 2);\non(el, "custom", e => e.detail.value + 10);`,
    expected: [20, 20],
    sample: 'dispatch(el, "custom", { value: 10 })',
    hints: [
      'Store listeners by event type',
      'Pass event object with type and detail to each listener',
    ],
    tags: ['DOM', 'events', 'custom', 'dispatch'],
  },

  {
    id: 'fe-js-dom-traverse-depth',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'hard',
    title: 'Depth-First DOM Traversal',
    text: 'Given a tree of node objects (each with tag and children array), implement a depth-first traversal that returns all tag names in order.',
    setup: 'A tree of node objects.',
    setupCode: `const tree = {\n  tag: "div",\n  children: [\n    { tag: "h1", children: [] },\n    { tag: "ul", children: [\n      { tag: "li", children: [] },\n      { tag: "li", children: [{ tag: "a", children: [] }] }\n    ]}\n  ]\n};\nfunction dfs(node) {\n  const result = [node.tag];\n  for (const child of node.children) {\n    result.push(...dfs(child));\n  }\n  return result;\n}`,
    expected: ['div', 'h1', 'ul', 'li', 'li', 'a'],
    sample: 'dfs(tree)',
    hints: [
      'Start with current node tag',
      'Recursively process children',
      'Spread child results into the array',
    ],
    tags: ['DOM', 'traversal', 'DFS', 'tree'],
  },

  {
    id: 'fe-js-attr-dataset',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'easy',
    title: 'Dataset Attribute Access',
    text: 'Given an element with a dataset object, extract data-user-id and data-role into a plain object { userId, role }.',
    setup: 'An element with dataset properties.',
    setupCode: `const el = { dataset: { userId: "42", role: "admin" } };\nfunction extractData(element) {\n  return { userId: element.dataset.userId, role: element.dataset.role };\n}`,
    expected: { userId: '42', role: 'admin' },
    sample: 'extractData(el)',
    hints: ['Access dataset properties directly', 'data-user-id becomes dataset.userId'],
    tags: ['DOM', 'dataset', 'attributes'],
  },

  // ─── NEW State & Lifecycle (17) ──────────────────────────────

  {
    id: 'fe-js-simple-store',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'easy',
    title: 'Simple State Store',
    text: 'Create a store with getState and setState methods. setState merges new values into the existing state. Return the state after two updates.',
    setup: 'A store factory function.',
    setupCode: `function createStore(initial) {\n  let state = { ...initial };\n  return {\n    getState() { return state; },\n    setState(update) { state = { ...state, ...update }; }\n  };\n}\nconst store = createStore({ count: 0, name: "test" });\nstore.setState({ count: 5 });\nstore.setState({ name: "updated" });`,
    expected: { count: 5, name: 'updated' },
    sample: 'store.getState()',
    hints: ['Use object spread to merge state', 'Return current state from getState'],
    tags: ['state', 'store', 'closure'],
  },

  {
    id: 'fe-js-pub-sub',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'Pub/Sub System',
    text: 'Implement a publish/subscribe system with subscribe, unsubscribe, and publish methods. subscribe returns an unsubscribe function. Return collected messages after publishing.',
    setup: 'A pub/sub factory.',
    setupCode: `function createPubSub() {\n  const subs = {};\n  return {\n    subscribe(topic, cb) {\n      if (!subs[topic]) subs[topic] = [];\n      subs[topic].push(cb);\n      return () => { subs[topic] = subs[topic].filter(fn => fn !== cb); };\n    },\n    publish(topic, data) {\n      return (subs[topic] || []).map(cb => cb(data));\n    }\n  };\n}\nconst ps = createPubSub();\nconst results = [];\nps.subscribe("msg", d => results.push("A:" + d));\nconst unsub = ps.subscribe("msg", d => results.push("B:" + d));\nps.publish("msg", "hello");\nunsub();\nps.publish("msg", "world");`,
    expected: ['A:hello', 'B:hello', 'A:world'],
    sample: 'results',
    hints: ['Store subscribers by topic', 'Return an unsubscribe function from subscribe'],
    tags: ['state', 'pubsub', 'pattern'],
  },

  {
    id: 'fe-js-observable-state',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'Observable State',
    text: 'Create an observable value that notifies subscribers when changed. Implement get, set, and subscribe methods. Return the log of notifications.',
    setup: 'An observable factory.',
    setupCode: `function observable(initial) {\n  let value = initial;\n  const listeners = [];\n  return {\n    get() { return value; },\n    set(v) { value = v; listeners.forEach(fn => fn(v)); },\n    subscribe(fn) { listeners.push(fn); }\n  };\n}\nconst obs = observable(0);\nconst log = [];\nobs.subscribe(v => log.push(v));\nobs.set(1);\nobs.set(2);\nobs.set(3);`,
    expected: [1, 2, 3],
    sample: 'log',
    hints: ['Store listeners in array', 'Call all listeners on set'],
    tags: ['state', 'observable', 'reactive'],
  },

  {
    id: 'fe-js-state-machine-traffic',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'Traffic Light State Machine',
    text: 'Implement a traffic light state machine with states green, yellow, red. Define transitions: green->yellow, yellow->red, red->green. Return the state after 4 transitions.',
    setup: 'A state machine definition.',
    setupCode: `function createMachine(initial, transitions) {\n  let state = initial;\n  return {\n    getState() { return state; },\n    transition() {\n      state = transitions[state] || state;\n      return state;\n    }\n  };\n}\nconst light = createMachine("green", { green: "yellow", yellow: "red", red: "green" });\nlight.transition();\nlight.transition();\nlight.transition();\nlight.transition();`,
    expected: 'yellow',
    sample: 'light.getState()',
    hints: ['Map each state to its next state', 'Look up current state in transitions object'],
    tags: ['state', 'state-machine', 'transitions'],
  },

  {
    id: 'fe-js-proxy-reactive',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'hard',
    title: 'Proxy-Based Reactivity',
    text: 'Use a Proxy to create a reactive object that logs all property reads and writes. Return the log after some operations.',
    setup: 'A reactive proxy factory.',
    setupCode: `function reactive(target) {\n  const log = [];\n  const proxy = new Proxy(target, {\n    get(obj, prop) {\n      log.push({ op: "get", prop, value: obj[prop] });\n      return obj[prop];\n    },\n    set(obj, prop, value) {\n      log.push({ op: "set", prop, value });\n      obj[prop] = value;\n      return true;\n    }\n  });\n  return { proxy, log };\n}\nconst { proxy, log } = reactive({ x: 1 });\nconst val = proxy.x;\nproxy.x = 10;\nconst val2 = proxy.x;`,
    expected: [
      { op: 'get', prop: 'x', value: 1 },
      { op: 'set', prop: 'x', value: 10 },
      { op: 'get', prop: 'x', value: 10 },
    ],
    sample: 'log',
    hints: ['Proxy get trap logs reads', 'Proxy set trap logs writes'],
    tags: ['state', 'Proxy', 'reactive', 'logging'],
  },

  {
    id: 'fe-js-lifecycle-hooks',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'Component Lifecycle Hooks',
    text: 'Simulate a component lifecycle with onMount, onUpdate, and onDestroy hooks. Run the lifecycle sequence and return the log of hook calls.',
    setup: 'A lifecycle simulator.',
    setupCode: `function createComponent() {\n  const log = [];\n  return {\n    log,\n    onMount() { log.push("mounted"); },\n    onUpdate(data) { log.push("updated:" + data); },\n    onDestroy() { log.push("destroyed"); },\n    run() {\n      this.onMount();\n      this.onUpdate("A");\n      this.onUpdate("B");\n      this.onDestroy();\n    }\n  };\n}\nconst comp = createComponent();\ncomp.run();`,
    expected: ['mounted', 'updated:A', 'updated:B', 'destroyed'],
    sample: 'comp.log',
    hints: ['Each hook pushes to the log', 'Run calls hooks in lifecycle order'],
    tags: ['state', 'lifecycle', 'hooks', 'component'],
  },

  {
    id: 'fe-js-cleanup-pattern',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'easy',
    title: 'Cleanup Function Pattern',
    text: 'Implement a setup function that returns a cleanup function. The setup adds an item to a resources array; cleanup removes it. Return resources after setup and cleanup.',
    setup: 'A resources array and setup/cleanup pattern.',
    setupCode: `const resources = [];\nfunction setup(name) {\n  resources.push(name);\n  return () => {\n    const idx = resources.indexOf(name);\n    if (idx >= 0) resources.splice(idx, 1);\n  };\n}\nconst cleanupA = setup("timer");\nsetup("listener");\ncleanupA();`,
    expected: ['listener'],
    sample: 'resources',
    hints: [
      'Setup pushes to array and returns a removal function',
      'Cleanup finds and splices the item',
    ],
    tags: ['state', 'cleanup', 'closure'],
  },

  {
    id: 'fe-js-error-boundary',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'Error Boundary Pattern',
    text: 'Implement an error boundary that catches errors from child functions and records them. Return the results and errors arrays.',
    setup: 'An error boundary wrapper.',
    setupCode: `function errorBoundary() {\n  const results = [];\n  const errors = [];\n  return {\n    results,\n    errors,\n    run(fn) {\n      try {\n        results.push(fn());\n      } catch (e) {\n        errors.push(e.message || String(e));\n      }\n    }\n  };\n}\nconst eb = errorBoundary();\neb.run(() => 42);\neb.run(() => { throw new Error("fail"); });\neb.run(() => 99);`,
    expected: { results: [42, 99], errors: ['fail'] },
    sample: '({ results: eb.results, errors: eb.errors })',
    hints: ['Wrap fn() in try/catch', 'Push results or errors accordingly'],
    tags: ['state', 'error-boundary', 'try-catch'],
  },

  {
    id: 'fe-js-reducer-pattern',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'Reducer Pattern',
    text: 'Implement a Redux-like reducer that handles ADD and REMOVE actions on a list. Dispatch several actions and return the final state.',
    setup: 'A reducer function and dispatch mechanism.',
    setupCode: `function reducer(state, action) {\n  switch (action.type) {\n    case "ADD": return [...state, action.payload];\n    case "REMOVE": return state.filter(x => x !== action.payload);\n    default: return state;\n  }\n}\nlet state = ["apple"];\nstate = reducer(state, { type: "ADD", payload: "banana" });\nstate = reducer(state, { type: "ADD", payload: "cherry" });\nstate = reducer(state, { type: "REMOVE", payload: "apple" });`,
    expected: ['banana', 'cherry'],
    sample: 'state',
    hints: ['Use switch on action.type', 'Return new arrays, do not mutate'],
    tags: ['state', 'reducer', 'redux', 'immutable'],
  },

  {
    id: 'fe-js-computed-state',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'Computed/Derived State',
    text: 'Given a state object with firstName and lastName, create a computed function that derives fullName. Return the computed result.',
    setup: 'A state object and computed derivation.',
    setupCode: `const state = { firstName: "John", lastName: "Doe" };\nfunction computed(stateFn) {\n  return { get value() { return stateFn(); } };\n}\nconst fullName = computed(() => state.firstName + " " + state.lastName);`,
    expected: 'John Doe',
    sample: 'fullName.value',
    hints: ['Use a getter to derive the value lazily', 'Concatenate firstName and lastName'],
    tags: ['state', 'computed', 'derived', 'getter'],
  },

  {
    id: 'fe-js-undo-redo',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'hard',
    title: 'Undo/Redo State History',
    text: 'Implement an undo/redo system that tracks state history. Push states, undo to go back, redo to go forward. Return the current state after several operations.',
    setup: 'An undo/redo manager.',
    setupCode: `function createHistory(initial) {\n  const past = [];\n  const future = [];\n  let current = initial;\n  return {\n    getCurrent() { return current; },\n    push(val) { past.push(current); current = val; future.length = 0; },\n    undo() { if (past.length) { future.push(current); current = past.pop(); } },\n    redo() { if (future.length) { past.push(current); current = future.pop(); } }\n  };\n}\nconst h = createHistory("A");\nh.push("B");\nh.push("C");\nh.push("D");\nh.undo();\nh.undo();\nh.redo();`,
    expected: 'C',
    sample: 'h.getCurrent()',
    hints: [
      'Maintain past and future stacks',
      'Undo pops from past, pushes to future',
      'Redo does the reverse',
    ],
    tags: ['state', 'undo', 'redo', 'history'],
  },

  {
    id: 'fe-js-middleware-chain',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'hard',
    title: 'Middleware Chain for State',
    text: 'Implement a middleware system where each middleware can transform an action before it reaches the reducer. Apply two middlewares (logger and doubler) and return the final state and log.',
    setup: 'A middleware-enhanced store.',
    setupCode: `function createStoreWithMiddleware(reducer, initial, middlewares) {\n  let state = initial;\n  const log = [];\n  function dispatch(action) {\n    let act = action;\n    for (const mw of middlewares) {\n      act = mw(act, log);\n    }\n    state = reducer(state, act);\n  }\n  return { getState: () => state, dispatch, log };\n}\nconst logger = (action, log) => { log.push(action.type); return action; };\nconst doubler = (action, log) => {\n  if (action.type === "ADD") return { ...action, payload: action.payload * 2 };\n  return action;\n};\nconst store = createStoreWithMiddleware(\n  (state, action) => action.type === "ADD" ? state + action.payload : state,\n  0,\n  [logger, doubler]\n);\nstore.dispatch({ type: "ADD", payload: 5 });\nstore.dispatch({ type: "ADD", payload: 3 });`,
    expected: { state: 16, log: ['ADD', 'ADD'] },
    sample: '({ state: store.getState(), log: store.log })',
    hints: [
      'Chain middlewares by passing action through each',
      'Each middleware returns potentially modified action',
    ],
    tags: ['state', 'middleware', 'redux', 'chain'],
  },

  {
    id: 'fe-js-effect-scheduler',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'easy',
    title: 'Effect Scheduler',
    text: 'Implement a simple effect scheduler that collects effect functions and runs them all in order. Return the log after flushing.',
    setup: 'An effect scheduler.',
    setupCode: `function createScheduler() {\n  const queue = [];\n  const log = [];\n  return {\n    schedule(fn) { queue.push(fn); },\n    flush() { while (queue.length) { const fn = queue.shift(); log.push(fn()); } },\n    log\n  };\n}\nconst sched = createScheduler();\nsched.schedule(() => "effect1");\nsched.schedule(() => "effect2");\nsched.schedule(() => "effect3");\nsched.flush();`,
    expected: ['effect1', 'effect2', 'effect3'],
    sample: 'sched.log',
    hints: ['Queue effects in an array', 'Flush processes them in FIFO order'],
    tags: ['state', 'effects', 'scheduler', 'queue'],
  },

  {
    id: 'fe-js-selector-pattern',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'easy',
    title: 'State Selector Pattern',
    text: 'Given a nested state object, create selector functions that extract specific slices. Return the selected values.',
    setup: 'A nested state and selector functions.',
    setupCode: `const state = {\n  user: { name: "Alice", age: 30 },\n  settings: { theme: "dark", lang: "en" }\n};\nconst selectUserName = s => s.user.name;\nconst selectTheme = s => s.settings.theme;`,
    expected: { name: 'Alice', theme: 'dark' },
    sample: '({ name: selectUserName(state), theme: selectTheme(state) })',
    hints: [
      'Selectors are functions that extract state slices',
      'Access nested properties with dot notation',
    ],
    tags: ['state', 'selector', 'pattern'],
  },

  {
    id: 'fe-js-batch-updates',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'Batch State Updates',
    text: 'Implement a store that batches multiple setState calls and only notifies subscribers once after the batch completes. Return the notification count.',
    setup: 'A batching store.',
    setupCode: `function createBatchStore(initial) {\n  let state = { ...initial };\n  let notifyCount = 0;\n  let batching = false;\n  let pending = false;\n  return {\n    getState() { return state; },\n    getNotifyCount() { return notifyCount; },\n    setState(update) {\n      state = { ...state, ...update };\n      if (batching) { pending = true; }\n      else { notifyCount++; }\n    },\n    batch(fn) {\n      batching = true;\n      pending = false;\n      fn();\n      batching = false;\n      if (pending) notifyCount++;\n    }\n  };\n}\nconst s = createBatchStore({ a: 1, b: 2 });\ns.setState({ a: 10 });\ns.batch(() => {\n  s.setState({ a: 20 });\n  s.setState({ b: 30 });\n  s.setState({ a: 40 });\n});`,
    expected: 2,
    sample: 's.getNotifyCount()',
    hints: ['Track a batching flag', 'Only increment notify count once per batch'],
    tags: ['state', 'batch', 'performance'],
  },

  {
    id: 'fe-js-context-provider',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'Context Provider Pattern',
    text: 'Implement a simple context system with createContext (returns { provide, consume }). Provide sets a value, consume retrieves it. Nested provides override outer ones. Return consumed values.',
    setup: 'A context provider system.',
    setupCode: `function createContext(defaultValue) {\n  const stack = [defaultValue];\n  return {\n    provide(value, fn) {\n      stack.push(value);\n      const result = fn();\n      stack.pop();\n      return result;\n    },\n    consume() { return stack[stack.length - 1]; }\n  };\n}\nconst ctx = createContext("default");\nconst r1 = ctx.consume();\nconst r2 = ctx.provide("outer", () => {\n  const inner = ctx.provide("inner", () => ctx.consume());\n  return [ctx.consume(), inner];\n});`,
    expected: { r1: 'default', r2: ['outer', 'inner'] },
    sample: '({ r1, r2 })',
    hints: ['Use a stack for nested values', 'Push on provide, pop after callback'],
    tags: ['state', 'context', 'provider', 'pattern'],
  },

  {
    id: 'fe-js-signal-basic',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'easy',
    title: 'Basic Signal Pattern',
    text: 'Create a signal (reactive primitive) with get and set methods. Subscribers are called on set. Return the final value.',
    setup: 'A signal factory.',
    setupCode: `function createSignal(initial) {\n  let value = initial;\n  return {\n    get() { return value; },\n    set(v) { value = v; }\n  };\n}\nconst [count] = [createSignal(0)];\ncount.set(1);\ncount.set(2);\ncount.set(5);`,
    expected: 5,
    sample: 'count.get()',
    hints: ['Store value in closure', 'set updates the value, get returns it'],
    tags: ['state', 'signal', 'reactive'],
  },

  // ─── NEW Common Patterns (17) ────────────────────────────────

  {
    id: 'fe-js-memoize-basic',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Memoization',
    text: 'Implement a memoize function that caches results based on the first argument. Return the result and call count.',
    setup: 'A memoize wrapper.',
    setupCode: `let callCount = 0;\nfunction memoize(fn) {\n  const cache = new Map();\n  return function(arg) {\n    if (cache.has(arg)) return cache.get(arg);\n    const result = fn(arg);\n    cache.set(arg, result);\n    return result;\n  };\n}\nconst expensive = memoize(n => { callCount++; return n * n; });\nexpensive(4);\nexpensive(4);\nexpensive(5);\nexpensive(4);`,
    expected: { result: 25, calls: 2 },
    sample: '({ result: expensive(5), calls: callCount })',
    hints: ['Use a Map to cache results', 'Check cache before calling the function'],
    tags: ['memoization', 'cache', 'performance'],
  },

  {
    id: 'fe-js-curry',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Currying',
    text: 'Implement a curry function that transforms a function taking 3 arguments into a chain of single-argument functions. Return the result.',
    setup: 'A curry utility.',
    setupCode: `function curry(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return fn(a, b, c);\n      };\n    };\n  };\n}\nconst add3 = curry((a, b, c) => a + b + c);`,
    expected: 15,
    sample: 'add3(3)(5)(7)',
    hints: [
      'Return nested functions, each taking one argument',
      'Call original function when all arguments collected',
    ],
    tags: ['curry', 'functional', 'closures'],
  },

  {
    id: 'fe-js-partial-application',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'easy',
    title: 'Partial Application',
    text: 'Implement a partial function that pre-fills some arguments. Return the result of calling the partially applied function.',
    setup: 'A partial application utility.',
    setupCode: `function partial(fn, ...preArgs) {\n  return function(...laterArgs) {\n    return fn(...preArgs, ...laterArgs);\n  };\n}\nconst multiply = (a, b, c) => a * b * c;\nconst double = partial(multiply, 2);`,
    expected: 30,
    sample: 'double(3, 5)',
    hints: [
      'Spread pre-filled args before later args',
      'Return a new function that combines both arg sets',
    ],
    tags: ['partial', 'functional', 'closures'],
  },

  {
    id: 'fe-js-pipe',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'easy',
    title: 'Pipe Function',
    text: 'Implement a pipe function that composes functions left to right. Pass a value through the pipeline and return the result.',
    setup: 'A pipe utility.',
    setupCode: `function pipe(...fns) {\n  return (x) => fns.reduce((acc, fn) => fn(acc), x);\n}\nconst transform = pipe(\n  x => x + 1,\n  x => x * 2,\n  x => x - 3\n);`,
    expected: 7,
    sample: 'transform(4)',
    hints: ['Use reduce to chain function calls', 'Start with x, pass result to next function'],
    tags: ['pipe', 'compose', 'functional'],
  },

  {
    id: 'fe-js-compose',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'easy',
    title: 'Compose Function',
    text: 'Implement a compose function that composes functions right to left (opposite of pipe). Return the result.',
    setup: 'A compose utility.',
    setupCode: `function compose(...fns) {\n  return (x) => fns.reduceRight((acc, fn) => fn(acc), x);\n}\nconst transform = compose(\n  x => x - 3,\n  x => x * 2,\n  x => x + 1\n);`,
    expected: 7,
    sample: 'transform(4)',
    hints: ['Use reduceRight to chain from right to left', 'Same as pipe but reversed order'],
    tags: ['compose', 'functional'],
  },

  {
    id: 'fe-js-mediator',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Mediator Pattern',
    text: 'Implement a mediator that coordinates communication between components. Components register with the mediator and send messages through it. Return the message log.',
    setup: 'A mediator with registered components.',
    setupCode: `function createMediator() {\n  const components = {};\n  const log = [];\n  return {\n    register(name, handler) { components[name] = handler; },\n    send(from, to, data) {\n      log.push({ from, to, data });\n      if (components[to]) components[to](data, from);\n    },\n    log\n  };\n}\nconst med = createMediator();\nmed.register("chatA", (data, from) => {});\nmed.register("chatB", (data, from) => {});\nmed.send("chatA", "chatB", "hello");\nmed.send("chatB", "chatA", "hi back");`,
    expected: [
      { from: 'chatA', to: 'chatB', data: 'hello' },
      { from: 'chatB', to: 'chatA', data: 'hi back' },
    ],
    sample: 'med.log',
    hints: ['Store components by name', 'Log every message sent through the mediator'],
    tags: ['mediator', 'pattern', 'communication'],
  },

  {
    id: 'fe-js-command-pattern',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Command Pattern',
    text: 'Implement a command pattern with execute and undo. Each command modifies a value. Execute commands, then undo the last one. Return the final value.',
    setup: 'A command executor.',
    setupCode: `function createCommandExecutor(initial) {\n  let value = initial;\n  const history = [];\n  return {\n    execute(cmd) {\n      history.push({ undo: () => { value = cmd.undo(value); } });\n      value = cmd.execute(value);\n    },\n    undo() {\n      const last = history.pop();\n      if (last) last.undo();\n    },\n    getValue() { return value; }\n  };\n}\nconst exec = createCommandExecutor(10);\nexec.execute({ execute: v => v + 5, undo: v => v - 5 });\nexec.execute({ execute: v => v * 2, undo: v => v / 2 });\nexec.undo();`,
    expected: 15,
    sample: 'exec.getValue()',
    hints: ['Each command has execute and undo functions', 'Track executed commands for undo'],
    tags: ['command', 'pattern', 'undo'],
  },

  {
    id: 'fe-js-iterator-range',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Custom Iterator: Range',
    text: 'Implement a range iterator that yields numbers from start to end (exclusive). Use Symbol.iterator protocol. Spread it into an array.',
    setup: 'A range iterable object.',
    setupCode: `function range(start, end) {\n  return {\n    [Symbol.iterator]() {\n      let current = start;\n      return {\n        next() {\n          if (current < end) return { value: current++, done: false };\n          return { done: true };\n        }\n      };\n    }\n  };\n}`,
    expected: [2, 3, 4, 5, 6],
    sample: '[...range(2, 7)]',
    hints: ['Implement Symbol.iterator method', 'Return object with next() method'],
    tags: ['iterator', 'Symbol.iterator', 'protocol'],
  },

  {
    id: 'fe-js-generator-fibonacci',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Generator: Fibonacci',
    text: 'Implement a Fibonacci generator and collect the first 8 numbers.',
    setup: 'A Fibonacci generator function.',
    setupCode: `function* fibonacci() {\n  let a = 0, b = 1;\n  while (true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}\nconst fib = fibonacci();\nconst result = [];\nfor (let i = 0; i < 8; i++) result.push(fib.next().value);`,
    expected: [0, 1, 1, 2, 3, 5, 8, 13],
    sample: 'result',
    hints: ['Use yield to produce values', 'Destructure to swap a and b'],
    tags: ['generator', 'fibonacci', 'yield'],
  },

  {
    id: 'fe-js-singleton',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'easy',
    title: 'Singleton Pattern',
    text: 'Implement a singleton factory that always returns the same instance. Verify two calls return the same object.',
    setup: 'A singleton factory.',
    setupCode: `const createSingleton = (() => {\n  let instance = null;\n  return () => {\n    if (!instance) instance = { id: Math.random(), created: true };\n    return instance;\n  };\n})();\nconst a = createSingleton();\nconst b = createSingleton();`,
    expected: true,
    sample: 'a === b',
    hints: ['Cache the instance in a closure', 'Return cached instance on subsequent calls'],
    tags: ['singleton', 'pattern', 'closure'],
  },

  {
    id: 'fe-js-factory-pattern',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'easy',
    title: 'Factory Pattern',
    text: 'Implement a createShape factory that returns objects with type and area based on the shape type. Return results for circle and rectangle.',
    setup: 'A shape factory.',
    setupCode: `function createShape(type, params) {\n  if (type === "circle") return { type, area: Math.round(Math.PI * params.r * params.r) };\n  if (type === "rectangle") return { type, area: params.w * params.h };\n  return { type: "unknown", area: 0 };\n}\nconst c = createShape("circle", { r: 5 });\nconst r = createShape("rectangle", { w: 4, h: 6 });`,
    expected: [
      { type: 'circle', area: 79 },
      { type: 'rectangle', area: 24 },
    ],
    sample: '[c, r]',
    hints: ['Switch on type to create different objects', 'Each shape calculates area differently'],
    tags: ['factory', 'pattern', 'objects'],
  },

  {
    id: 'fe-js-strategy-pattern',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Strategy Pattern',
    text: 'Implement a sorter that accepts different comparison strategies. Sort an array with ascending and descending strategies. Return both results.',
    setup: 'A strategy-based sorter.',
    setupCode: `const strategies = {\n  ascending: (a, b) => a - b,\n  descending: (a, b) => b - a\n};\nfunction sortWith(arr, strategyName) {\n  return [...arr].sort(strategies[strategyName]);\n}\nconst data = [3, 1, 4, 1, 5, 9];`,
    expected: { asc: [1, 1, 3, 4, 5, 9], desc: [9, 5, 4, 3, 1, 1] },
    sample: '({ asc: sortWith(data, "ascending"), desc: sortWith(data, "descending") })',
    hints: ['Store strategy functions in an object', 'Look up strategy by name and pass to sort'],
    tags: ['strategy', 'pattern', 'sort'],
  },

  {
    id: 'fe-js-decorator-pattern',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Decorator Pattern',
    text: 'Implement decorators that wrap a base function to add logging and timing metadata. Chain two decorators and return the enriched result.',
    setup: 'A decorator chain.',
    setupCode: `function withLogging(fn) {\n  return function(...args) {\n    const result = fn(...args);\n    return { ...result, logged: true };\n  };\n}\nfunction withTimestamp(fn) {\n  return function(...args) {\n    const result = fn(...args);\n    return { ...result, timestamp: 12345 };\n  };\n}\nconst base = (x) => ({ value: x * 2 });\nconst decorated = withTimestamp(withLogging(base));`,
    expected: { value: 10, logged: true, timestamp: 12345 },
    sample: 'decorated(5)',
    hints: [
      'Each decorator wraps the function and enriches the result',
      'Chain decorators by passing one into another',
    ],
    tags: ['decorator', 'pattern', 'wrapper'],
  },

  {
    id: 'fe-js-immutable-update',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'easy',
    title: 'Immutable Object Update',
    text: 'Update a nested object immutably: change user.address.city to "Seattle" without mutating the original. Return both the original city and the new city.',
    setup: 'A nested object to update immutably.',
    setupCode: `const original = { user: { name: "Alice", address: { city: "Portland", state: "OR" } } };\nconst updated = {\n  ...original,\n  user: {\n    ...original.user,\n    address: { ...original.user.address, city: "Seattle" }\n  }\n};`,
    expected: { originalCity: 'Portland', newCity: 'Seattle' },
    sample: '({ originalCity: original.user.address.city, newCity: updated.user.address.city })',
    hints: ['Spread at each level of nesting', 'Only override the property you want to change'],
    tags: ['immutable', 'spread', 'update'],
  },

  {
    id: 'fe-js-deep-clone',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'hard',
    title: 'Deep Clone',
    text: 'Implement a deepClone function that handles objects, arrays, and primitives. Clone a nested structure and verify independence.',
    setup: 'A deep clone utility.',
    setupCode: `function deepClone(obj) {\n  if (obj === null || typeof obj !== "object") return obj;\n  if (Array.isArray(obj)) return obj.map(item => deepClone(item));\n  const cloned = {};\n  for (const key of Object.keys(obj)) cloned[key] = deepClone(obj[key]);\n  return cloned;\n}\nconst src = { a: 1, b: [2, 3], c: { d: 4 } };\nconst copy = deepClone(src);\ncopy.b.push(99);\ncopy.c.d = 999;`,
    expected: { srcB: [2, 3], copyB: [2, 3, 99], srcD: 4, copyD: 999 },
    sample: '({ srcB: src.b, copyB: copy.b, srcD: src.c.d, copyD: copy.c.d })',
    hints: [
      'Handle primitives, arrays, and objects separately',
      'Recursively clone nested structures',
    ],
    tags: ['deepClone', 'recursive', 'immutable'],
  },

  {
    id: 'fe-js-event-emitter-once',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'hard',
    title: 'Event Emitter with Once',
    text: 'Implement an event emitter with on, once, and emit methods. once listeners auto-remove after first call. Return the log after multiple emits.',
    setup: 'An event emitter with once support.',
    setupCode: `function createEmitter() {\n  const events = {};\n  return {\n    on(evt, fn) {\n      if (!events[evt]) events[evt] = [];\n      events[evt].push({ fn, once: false });\n    },\n    once(evt, fn) {\n      if (!events[evt]) events[evt] = [];\n      events[evt].push({ fn, once: true });\n    },\n    emit(evt, data) {\n      if (!events[evt]) return [];\n      const results = events[evt].map(h => h.fn(data));\n      events[evt] = events[evt].filter(h => !h.once);\n      return results;\n    }\n  };\n}\nconst em = createEmitter();\nconst log = [];\nem.on("data", v => { log.push("on:" + v); });\nem.once("data", v => { log.push("once:" + v); });\nem.emit("data", "A");\nem.emit("data", "B");`,
    expected: ['on:A', 'once:A', 'on:B'],
    sample: 'log',
    hints: [
      'Mark once listeners and filter them after emit',
      'on listeners persist, once listeners are removed',
    ],
    tags: ['emitter', 'once', 'pattern', 'events'],
  },

  {
    id: 'fe-js-lazy-eval',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'hard',
    title: 'Lazy Evaluation',
    text: 'Implement a lazy function that defers computation until .value is accessed. The computation should run only once. Return the value and call count.',
    setup: 'A lazy evaluation wrapper.',
    setupCode: `let computeCount = 0;\nfunction lazy(fn) {\n  let computed = false;\n  let result;\n  return {\n    get value() {\n      if (!computed) {\n        result = fn();\n        computed = true;\n      }\n      return result;\n    }\n  };\n}\nconst val = lazy(() => { computeCount++; return 42; });\nconst a = val.value;\nconst b = val.value;\nconst c = val.value;`,
    expected: { value: 42, count: 1 },
    sample: '({ value: val.value, count: computeCount })',
    hints: ['Use a getter with a computed flag', 'Cache the result after first computation'],
    tags: ['lazy', 'evaluation', 'getter', 'cache'],
  },

  // ─── NEW Rendering (17) ──────────────────────────────────────

  {
    id: 'fe-js-virtual-dom-diff',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'hard',
    title: 'Virtual DOM Diff',
    text: 'Compare oldTree and newTree objects and return an array of patch operations describing the differences.',
    setup: 'Two virtual DOM tree objects.',
    setupCode: `const oldTree = { tag: "div", props: { id: "root" }, children: [{ tag: "p", props: {}, children: ["Hello"] }] };\nconst newTree = { tag: "div", props: { id: "root" }, children: [{ tag: "p", props: {}, children: ["World"] }] };`,
    expected: [{ type: 'TEXT', path: [0, 0], oldVal: 'Hello', newVal: 'World' }],
    sample: `function diff(old, newN, path = []) {\n  if (typeof old === 'string' && typeof newN === 'string' && old !== newN) return [{ type: 'TEXT', path, oldVal: old, newVal: newN }];\n  if (!old || !newN) return [];\n  const patches = [];\n  const maxLen = Math.max((old.children||[]).length, (newN.children||[]).length);\n  for (let i = 0; i < maxLen; i++) patches.push(...diff((old.children||[])[i], (newN.children||[])[i], [...path, i]));\n  return patches;\n}\ndiff(oldTree, newTree)`,
    hints: ['Recursively compare children', 'Track path for patch location'],
    tags: ['virtual-DOM', 'diff', 'reconciliation'],
  },

  {
    id: 'fe-js-render-table',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'easy',
    title: 'Render HTML Table',
    text: 'Given headers and rows arrays, build an HTML table string.',
    setup: 'Headers and rows data.',
    setupCode: `const headers = ["Name", "Age"];\nconst rows = [["Alice", "30"], ["Bob", "25"]];`,
    expected:
      '<table><tr><th>Name</th><th>Age</th></tr><tr><td>Alice</td><td>30</td></tr><tr><td>Bob</td><td>25</td></tr></table>',
    // biome-ignore lint/suspicious/noTemplateCurlyInString: sample holds user solution code containing template literals
    sample:
      '`<table><tr>${headers.map(h => `<th>${h}</th>`).join("")}</tr>${rows.map(r => `<tr>${r.map(c => `<td>${c}</td>`).join("")}</tr>`).join("")}</table>`',
    hints: [
      'Map headers to th elements',
      'Map rows to tr with td elements',
      'Join everything together',
    ],
    tags: ['rendering', 'table', 'template-literals'],
  },

  {
    id: 'fe-js-conditional-render',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'easy',
    title: 'Conditional Rendering',
    text: 'Given a user object that may or may not have a name, render a greeting or a login prompt. Return the HTML string.',
    setup: 'User objects for conditional rendering.',
    setupCode: `function renderGreeting(user) {\n  if (user && user.name) return \`<h1>Hello, \${user.name}!</h1>\`;\n  return "<h1>Please log in</h1>";\n}\nconst loggedIn = renderGreeting({ name: "Alice" });\nconst loggedOut = renderGreeting(null);`,
    expected: { loggedIn: '<h1>Hello, Alice!</h1>', loggedOut: '<h1>Please log in</h1>' },
    sample: '({ loggedIn, loggedOut })',
    hints: ['Check if user and user.name exist', 'Return different HTML based on condition'],
    tags: ['rendering', 'conditional', 'template-literals'],
  },

  {
    id: 'fe-js-list-reconcile',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'hard',
    title: 'List Reconciliation',
    text: 'Given an old list and new list of items (with id and text), compute add, remove, and update operations needed to transform old into new.',
    setup: 'Old and new item lists.',
    setupCode: `const oldList = [{ id: 1, text: "A" }, { id: 2, text: "B" }, { id: 3, text: "C" }];\nconst newList = [{ id: 2, text: "B2" }, { id: 3, text: "C" }, { id: 4, text: "D" }];\nfunction reconcile(oldL, newL) {\n  const ops = [];\n  const oldMap = new Map(oldL.map(i => [i.id, i]));\n  const newMap = new Map(newL.map(i => [i.id, i]));\n  for (const [id] of oldMap) {\n    if (!newMap.has(id)) ops.push({ op: "remove", id });\n  }\n  for (const [id, item] of newMap) {\n    if (!oldMap.has(id)) ops.push({ op: "add", id, text: item.text });\n    else if (oldMap.get(id).text !== item.text) ops.push({ op: "update", id, text: item.text });\n  }\n  return ops;\n}`,
    expected: [
      { op: 'remove', id: 1 },
      { op: 'update', id: 2, text: 'B2' },
      { op: 'add', id: 4, text: 'D' },
    ],
    sample: 'reconcile(oldList, newList)',
    hints: [
      'Create maps for fast lookups by id',
      'Compare old and new to find adds, removes, updates',
    ],
    tags: ['rendering', 'reconciliation', 'list', 'diff'],
  },

  {
    id: 'fe-js-fragment-build',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'easy',
    title: 'Build Fragment Object',
    text: 'Create a fragment (array of virtual nodes) from a list of tag names. Return the fragment array.',
    setup: 'A list of tag names.',
    setupCode: `function createFragment(tags) {\n  return tags.map(tag => ({ tag, props: {}, children: [] }));\n}\nconst tags = ["p", "span", "div"];`,
    expected: [
      { tag: 'p', props: {}, children: [] },
      { tag: 'span', props: {}, children: [] },
      { tag: 'div', props: {}, children: [] },
    ],
    sample: 'createFragment(tags)',
    hints: ['Map each tag to a virtual node object'],
    tags: ['rendering', 'fragment', 'virtual-DOM'],
  },

  {
    id: 'fe-js-template-engine',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'medium',
    title: 'Simple Template Engine',
    text: 'Implement a template function that replaces {{key}} placeholders with values from a data object. Return the rendered string.',
    setup: 'A template string and data.',
    setupCode: `function template(str, data) {\n  return str.replace(/\\{\\{(\\w+)\\}\\}/g, (match, key) => {\n    return data[key] !== undefined ? data[key] : match;\n  });\n}`,
    expected: 'Hello Alice, you are 30 years old!',
    sample: 'template("Hello {{name}}, you are {{age}} years old!", { name: "Alice", age: 30 })',
    hints: ['Use regex to match {{key}} patterns', 'Replace with data[key] if it exists'],
    tags: ['rendering', 'template', 'regex', 'interpolation'],
  },

  {
    id: 'fe-js-render-nested-list',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'medium',
    title: 'Render Nested List',
    text: 'Given a nested data structure (items with optional children), render a nested HTML list string (<ul>/<li>).',
    setup: 'A nested list data structure.',
    setupCode: `const items = [\n  { text: "A", children: [{ text: "A1" }, { text: "A2" }] },\n  { text: "B" }\n];\nfunction renderList(items) {\n  return "<ul>" + items.map(item => {\n    let html = "<li>" + item.text;\n    if (item.children) html += renderList(item.children);\n    html += "</li>";\n    return html;\n  }).join("") + "</ul>";\n}`,
    expected: '<ul><li>A<ul><li>A1</li><li>A2</li></ul></li><li>B</li></ul>',
    sample: 'renderList(items)',
    hints: ['Recursively render children', 'Wrap each level in <ul> tags'],
    tags: ['rendering', 'nested', 'recursive', 'list'],
  },

  {
    id: 'fe-js-lazy-render',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'medium',
    title: 'Lazy Render Queue',
    text: 'Implement a render queue that collects render tasks and processes them in batches of a given size. Return the rendered batch results.',
    setup: 'A lazy render queue.',
    setupCode: `function createRenderQueue(batchSize) {\n  const queue = [];\n  return {\n    add(renderFn) { queue.push(renderFn); },\n    flush() {\n      const batch = queue.splice(0, batchSize);\n      return batch.map(fn => fn());\n    }\n  };\n}\nconst rq = createRenderQueue(2);\nrq.add(() => "<div>1</div>");\nrq.add(() => "<div>2</div>");\nrq.add(() => "<div>3</div>");\nconst batch1 = rq.flush();\nconst batch2 = rq.flush();`,
    expected: { batch1: ['<div>1</div>', '<div>2</div>'], batch2: ['<div>3</div>'] },
    sample: '({ batch1, batch2 })',
    hints: ['Use splice to take a batch from the queue', 'Map batch items to get render results'],
    tags: ['rendering', 'lazy', 'queue', 'batch'],
  },

  {
    id: 'fe-js-escape-html',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'easy',
    title: 'Escape HTML Entities',
    text: 'Implement a function that escapes &, <, >, and " characters to their HTML entity equivalents.',
    setup: 'An HTML escaping function.',
    setupCode: `function escapeHtml(str) {\n  const map = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;" };\n  return str.replace(/[&<>"]/g, ch => map[ch]);\n}`,
    expected: '&lt;p class=&quot;test&quot;&gt;A &amp; B&lt;/p&gt;',
    sample: 'escapeHtml(\'<p class="test">A & B</p>\')',
    hints: ['Map special characters to HTML entities', 'Use replace with regex'],
    tags: ['rendering', 'escape', 'XSS', 'security'],
  },

  {
    id: 'fe-js-vnode-create',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'easy',
    title: 'Create Virtual Node',
    text: 'Implement a createElement function (like React.createElement) that returns a virtual node object with tag, props, and children.',
    setup: 'A virtual node factory.',
    setupCode: `function createElement(tag, props, ...children) {\n  return { tag, props: props || {}, children: children.flat() };\n}`,
    expected: {
      tag: 'div',
      props: { id: 'app' },
      children: [
        { tag: 'h1', props: {}, children: ['Hello'] },
        { tag: 'p', props: { class: 'text' }, children: ['World'] },
      ],
    },
    sample:
      'createElement("div", { id: "app" }, createElement("h1", null, "Hello"), createElement("p", { class: "text" }, "World"))',
    hints: [
      'Use rest params for children',
      'Flatten children array',
      'Default props to empty object',
    ],
    tags: ['rendering', 'virtual-DOM', 'createElement'],
  },

  {
    id: 'fe-js-render-attrs',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'medium',
    title: 'Render Attributes String',
    text: 'Given an attributes object, render it as an HTML attribute string. Skip falsy values. Return the string.',
    setup: 'An attributes object.',
    setupCode: `function renderAttrs(attrs) {\n  return Object.entries(attrs)\n    .filter(([, v]) => v != null && v !== false)\n    .map(([k, v]) => v === true ? k : \`\${k}="\${v}"\`)\n    .join(" ");\n}`,
    expected: 'class="btn" id="main" disabled',
    sample: 'renderAttrs({ class: "btn", id: "main", hidden: false, disabled: true, title: null })',
    hints: ['Filter out null, undefined, false', 'Boolean true renders just the attribute name'],
    tags: ['rendering', 'attributes', 'HTML'],
  },

  {
    id: 'fe-js-vdom-to-html',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'hard',
    title: 'Virtual DOM to HTML String',
    text: 'Convert a virtual DOM tree (object with tag, props, children) to an HTML string. Handle text nodes (strings) and nested elements.',
    setup: 'A virtual DOM tree.',
    setupCode: `function toHtml(node) {\n  if (typeof node === "string") return node;\n  const attrs = Object.entries(node.props || {})\n    .map(([k, v]) => \` \${k}="\${v}"\`).join("");\n  const children = (node.children || []).map(c => toHtml(c)).join("");\n  return \`<\${node.tag}\${attrs}>\${children}</\${node.tag}>\`;\n}\nconst tree = { tag: "div", props: { id: "app" }, children: [\n  { tag: "h1", props: {}, children: ["Title"] },\n  { tag: "p", props: { class: "body" }, children: ["Content"] }\n]};`,
    expected: '<div id="app"><h1>Title</h1><p class="body">Content</p></div>',
    sample: 'toHtml(tree)',
    hints: [
      'Handle string nodes as base case',
      'Recursively render children',
      'Build attribute string from props',
    ],
    tags: ['rendering', 'virtual-DOM', 'HTML', 'recursive'],
  },

  {
    id: 'fe-js-render-switch',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'medium',
    title: 'Render with Switch Component',
    text: 'Implement a renderByStatus function that returns different HTML based on status: "loading", "error", or "success". Return all three results.',
    setup: 'A status-based renderer.',
    setupCode: `function renderByStatus(status, data) {\n  switch (status) {\n    case "loading": return "<div class=\\"spinner\\">Loading...</div>";\n    case "error": return \`<div class="error">\${data}</div>\`;\n    case "success": return \`<div class="content">\${data}</div>\`;\n    default: return "";\n  }\n}`,
    expected: {
      loading: '<div class="spinner">Loading...</div>',
      error: '<div class="error">Network fail</div>',
      success: '<div class="content">Hello</div>',
    },
    sample:
      '({ loading: renderByStatus("loading"), error: renderByStatus("error", "Network fail"), success: renderByStatus("success", "Hello") })',
    hints: ['Use switch statement on status', 'Return appropriate HTML for each case'],
    tags: ['rendering', 'conditional', 'switch', 'status'],
  },

  {
    id: 'fe-js-class-string-builder',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'medium',
    title: 'Class String Builder',
    text: 'Implement a classNames function that accepts an object of class-boolean pairs and returns a space-separated class string with only the truthy classes.',
    setup: 'A classNames utility.',
    setupCode: `function classNames(obj) {\n  return Object.entries(obj)\n    .filter(([, v]) => v)\n    .map(([k]) => k)\n    .join(" ");\n}`,
    expected: 'btn btn-primary active',
    sample:
      'classNames({ btn: true, "btn-primary": true, disabled: false, active: true, hidden: 0 })',
    hints: ['Filter entries where value is truthy', 'Map to keys and join with space'],
    tags: ['rendering', 'className', 'utility'],
  },

  {
    id: 'fe-js-render-map-filter',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'easy',
    title: 'Filtered List Rendering',
    text: 'Given an array of user objects, render only active users as <li> elements. Return the HTML string.',
    setup: 'An array of user objects.',
    setupCode: `const users = [\n  { name: "Alice", active: true },\n  { name: "Bob", active: false },\n  { name: "Charlie", active: true }\n];`,
    expected: '<li>Alice</li><li>Charlie</li>',
    // biome-ignore lint/suspicious/noTemplateCurlyInString: sample holds user solution code containing template literals
    sample: 'users.filter(u => u.active).map(u => `<li>${u.name}</li>`).join("")',
    hints: ['Filter for active users first', 'Map to li elements', 'Join into string'],
    tags: ['rendering', 'filter', 'map', 'list'],
  },

  {
    id: 'fe-js-style-object',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'medium',
    title: 'Style Object to CSS String',
    text: 'Convert a JavaScript style object (camelCase) to a CSS string (kebab-case). Return the CSS string.',
    setup: 'A style object.',
    setupCode: `function styleToCSS(styles) {\n  return Object.entries(styles)\n    .map(([k, v]) => {\n      const prop = k.replace(/[A-Z]/g, m => "-" + m.toLowerCase());\n      return \`\${prop}: \${v}\`;\n    })\n    .join("; ");\n}`,
    expected: 'background-color: red; font-size: 16px; margin-top: 10px',
    sample: 'styleToCSS({ backgroundColor: "red", fontSize: "16px", marginTop: "10px" })',
    hints: ['Convert camelCase to kebab-case with regex', 'Join with semicolons'],
    tags: ['rendering', 'style', 'CSS', 'camelCase'],
  },

  {
    id: 'fe-js-dom-tree-obj',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'hard',
    title: 'Build DOM Tree from Config',
    text: 'Given a nested configuration object, build a DOM tree as nested objects. Each config has tag, optional text, optional attrs, and optional children array. Return the tree.',
    setup: 'A config-to-tree builder.',
    setupCode: `function buildTree(config) {\n  const node = { tag: config.tag, attrs: config.attrs || {}, children: [] };\n  if (config.text) node.children.push(config.text);\n  if (config.children) {\n    for (const child of config.children) {\n      node.children.push(buildTree(child));\n    }\n  }\n  return node;\n}\nconst config = {\n  tag: "div",\n  attrs: { id: "root" },\n  children: [\n    { tag: "h1", text: "Title" },\n    { tag: "ul", children: [\n      { tag: "li", text: "Item 1" },\n      { tag: "li", text: "Item 2" }\n    ]}\n  ]\n};`,
    expected: {
      tag: 'div',
      attrs: { id: 'root' },
      children: [
        { tag: 'h1', attrs: {}, children: ['Title'] },
        {
          tag: 'ul',
          attrs: {},
          children: [
            { tag: 'li', attrs: {}, children: ['Item 1'] },
            { tag: 'li', attrs: {}, children: ['Item 2'] },
          ],
        },
      ],
    },
    sample: 'buildTree(config)',
    hints: ['Recursively build children', 'Handle text as a string child'],
    tags: ['rendering', 'tree', 'recursive', 'config'],
  },

  // ─── NEW Data Fetching (17) ──────────────────────────────────

  {
    id: 'fe-js-promise-all-sim',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'easy',
    title: 'Promise.all Simulation',
    text: 'Given an array of values, create an array of resolved promises and use Promise.all to collect them. Return the resolved array.',
    setup: 'Values to wrap in promises.',
    setupCode: `const values = [1, 2, 3];\nconst promises = values.map(v => Promise.resolve(v * 10));`,
    expected: [10, 20, 30],
    sample: 'await Promise.all(promises)',
    hints: ['Promise.resolve wraps a value in a resolved promise', 'Promise.all waits for all'],
    tags: ['Promise', 'Promise.all', 'async'],
  },

  {
    id: 'fe-js-promise-race-sim',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'easy',
    title: 'Promise.race Simulation',
    text: 'Given two promises that resolve to different values, the first one resolves immediately and the second after a delay. Use Promise.race to get the fastest result.',
    setup: 'Two promises with different resolve times.',
    setupCode: `const fast = Promise.resolve("fast");\nconst slow = new Promise(r => setTimeout(() => r("slow"), 1000));`,
    expected: 'fast',
    sample: 'await Promise.race([fast, slow])',
    hints: ['Promise.race returns the first settled promise', 'The already-resolved promise wins'],
    tags: ['Promise', 'race', 'async'],
  },

  {
    id: 'fe-js-retry-logic',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Retry Logic',
    text: 'Implement a retry function that calls an async function up to maxRetries times. Track attempt count. Return the result and attempt count.',
    setup: 'A flaky function and retry wrapper.',
    setupCode: `let attempts = 0;\nconst flakyFn = () => {\n  attempts++;\n  if (attempts < 3) throw new Error("fail");\n  return "success";\n};\nfunction retry(fn, maxRetries) {\n  for (let i = 0; i <= maxRetries; i++) {\n    try {\n      return fn();\n    } catch (e) {\n      if (i === maxRetries) throw e;\n    }\n  }\n}`,
    expected: { result: 'success', attempts: 3 },
    sample: '({ result: retry(flakyFn, 5), attempts })',
    hints: ['Loop up to maxRetries', 'Catch errors and retry', 'Re-throw on last attempt'],
    tags: ['retry', 'error-handling', 'resilience'],
  },

  {
    id: 'fe-js-exponential-backoff',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Exponential Backoff Delays',
    text: 'Calculate exponential backoff delay times for retries 0 through 4, with a base delay of 100ms and max of 2000ms. Return the delay array.',
    setup: 'A backoff calculator.',
    setupCode: `function backoffDelays(base, maxDelay, retries) {\n  const delays = [];\n  for (let i = 0; i < retries; i++) {\n    delays.push(Math.min(base * Math.pow(2, i), maxDelay));\n  }\n  return delays;\n}`,
    expected: [100, 200, 400, 800, 1600],
    sample: 'backoffDelays(100, 2000, 5)',
    hints: ['Multiply base by 2^attempt', 'Cap with Math.min and maxDelay'],
    tags: ['backoff', 'exponential', 'retry'],
  },

  {
    id: 'fe-js-request-queue',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Request Queue',
    text: 'Implement a request queue that processes async functions sequentially. Each function returns a value. Return the results in order.',
    setup: 'A sequential request queue.',
    setupCode: `function createQueue() {\n  const results = [];\n  const queue = [];\n  let processing = false;\n  async function process() {\n    if (processing) return;\n    processing = true;\n    while (queue.length) {\n      const fn = queue.shift();\n      results.push(await fn());\n    }\n    processing = false;\n  }\n  return {\n    add(fn) { queue.push(fn); return process(); },\n    getResults() { return results; }\n  };\n}\nconst q = createQueue();\nawait q.add(() => Promise.resolve("A"));\nawait q.add(() => Promise.resolve("B"));\nawait q.add(() => Promise.resolve("C"));`,
    expected: ['A', 'B', 'C'],
    sample: 'q.getResults()',
    hints: [
      'Process queue items one at a time with await',
      'Track processing state to prevent concurrent runs',
    ],
    tags: ['queue', 'async', 'sequential'],
  },

  {
    id: 'fe-js-cache-first',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Cache-First Strategy',
    text: 'Implement a cache-first data fetcher. If data is in cache, return it immediately. Otherwise, call the fetcher, cache the result, and return it. Track fetch calls.',
    setup: 'A cache-first wrapper.',
    setupCode: `let fetchCalls = 0;\nfunction createCachedFetcher(fetcher) {\n  const cache = new Map();\n  return {\n    async get(key) {\n      if (cache.has(key)) return cache.get(key);\n      fetchCalls++;\n      const data = await fetcher(key);\n      cache.set(key, data);\n      return data;\n    }\n  };\n}\nconst cf = createCachedFetcher(key => Promise.resolve("data-" + key));\nconst r1 = await cf.get("a");\nconst r2 = await cf.get("a");\nconst r3 = await cf.get("b");`,
    expected: { r1: 'data-a', r2: 'data-a', r3: 'data-b', calls: 2 },
    sample: '({ r1, r2, r3, calls: fetchCalls })',
    hints: ['Check cache with Map.has', 'Only call fetcher on cache miss'],
    tags: ['cache', 'fetch', 'strategy'],
  },

  {
    id: 'fe-js-optimistic-update',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Optimistic Update',
    text: 'Implement an optimistic update pattern: update state immediately, then confirm or rollback based on the async result. Return the state log.',
    setup: 'An optimistic update manager.',
    setupCode: `function createOptimistic(initial) {\n  let state = initial;\n  const log = [];\n  return {\n    async update(optimisticValue, asyncFn) {\n      const prev = state;\n      state = optimisticValue;\n      log.push({ state, phase: "optimistic" });\n      try {\n        const result = await asyncFn();\n        state = result;\n        log.push({ state, phase: "confirmed" });\n      } catch (e) {\n        state = prev;\n        log.push({ state, phase: "rollback" });\n      }\n    },\n    getLog() { return log; }\n  };\n}\nconst opt = createOptimistic("old");\nawait opt.update("new", () => Promise.resolve("new-confirmed"));`,
    expected: [
      { state: 'new', phase: 'optimistic' },
      { state: 'new-confirmed', phase: 'confirmed' },
    ],
    sample: 'opt.getLog()',
    hints: ['Save previous state for rollback', 'Update optimistically, then confirm or revert'],
    tags: ['optimistic', 'update', 'async', 'state'],
  },

  {
    id: 'fe-js-pagination',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'easy',
    title: 'Pagination Logic',
    text: 'Given a total of 47 items and a page size of 10, calculate total pages and get the items for page 3 (0-indexed). Return page info.',
    setup: 'Pagination calculation.',
    setupCode: `const allItems = Array.from({ length: 47 }, (_, i) => i + 1);\nfunction paginate(items, page, pageSize) {\n  const totalPages = Math.ceil(items.length / pageSize);\n  const start = page * pageSize;\n  const pageItems = items.slice(start, start + pageSize);\n  return { totalPages, page, pageItems };\n}`,
    expected: { totalPages: 5, page: 3, pageItems: [31, 32, 33, 34, 35, 36, 37, 38, 39, 40] },
    sample: 'paginate(allItems, 3, 10)',
    hints: ['Total pages = ceil(total / pageSize)', 'Slice items from page*pageSize'],
    tags: ['pagination', 'slice', 'math'],
  },

  {
    id: 'fe-js-cursor-pagination',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Cursor-Based Pagination',
    text: 'Implement cursor-based pagination. Given sorted items with ids, fetch items after a given cursor. Return items and nextCursor.',
    setup: 'Cursor-based pagination logic.',
    setupCode: `const items = [\n  { id: "a1", name: "A" }, { id: "b2", name: "B" },\n  { id: "c3", name: "C" }, { id: "d4", name: "D" },\n  { id: "e5", name: "E" }\n];\nfunction fetchAfterCursor(items, cursor, limit) {\n  let startIdx = 0;\n  if (cursor) {\n    const cursorIdx = items.findIndex(i => i.id === cursor);\n    startIdx = cursorIdx >= 0 ? cursorIdx + 1 : 0;\n  }\n  const page = items.slice(startIdx, startIdx + limit);\n  const nextCursor = page.length === limit ? page[page.length - 1].id : null;\n  return { data: page, nextCursor };\n}`,
    expected: {
      data: [
        { id: 'c3', name: 'C' },
        { id: 'd4', name: 'D' },
      ],
      nextCursor: 'd4',
    },
    sample: 'fetchAfterCursor(items, "b2", 2)',
    hints: ['Find cursor position, start after it', 'nextCursor is last item id if page is full'],
    tags: ['pagination', 'cursor', 'fetch'],
  },

  {
    id: 'fe-js-error-handling-fetch',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'easy',
    title: 'Fetch Error Handling',
    text: 'Wrap an async operation in try/catch and return a result object with { data, error }. Return results for both success and failure cases.',
    setup: 'A safe fetch wrapper.',
    setupCode: `async function safeFetch(fn) {\n  try {\n    const data = await fn();\n    return { data, error: null };\n  } catch (e) {\n    return { data: null, error: e.message };\n  }\n}\nconst ok = await safeFetch(() => Promise.resolve("hello"));\nconst fail = await safeFetch(() => Promise.reject(new Error("oops")));`,
    expected: { ok: { data: 'hello', error: null }, fail: { data: null, error: 'oops' } },
    sample: '({ ok, fail })',
    hints: ['Wrap in try/catch', 'Return standardized { data, error } object'],
    tags: ['error-handling', 'async', 'fetch'],
  },

  {
    id: 'fe-js-abort-controller-sim',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'AbortController Simulation',
    text: 'Simulate an AbortController with abort() method and signal object. A cancellable operation checks signal.aborted. Return whether the operation was aborted.',
    setup: 'An AbortController-like object.',
    setupCode: `function createAbortController() {\n  const signal = { aborted: false };\n  return {\n    signal,\n    abort() { signal.aborted = true; }\n  };\n}\nfunction cancellableOp(signal) {\n  if (signal.aborted) return { status: "aborted" };\n  return { status: "completed", data: 42 };\n}\nconst ac = createAbortController();\nconst r1 = cancellableOp(ac.signal);\nac.abort();\nconst r2 = cancellableOp(ac.signal);`,
    expected: { r1: { status: 'completed', data: 42 }, r2: { status: 'aborted' } },
    sample: '({ r1, r2 })',
    hints: ['Signal is an object with aborted boolean', 'Check signal.aborted before proceeding'],
    tags: ['AbortController', 'cancel', 'signal'],
  },

  {
    id: 'fe-js-race-condition',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'hard',
    title: 'Race Condition Prevention',
    text: 'Implement a "latest only" pattern that ignores stale responses. Only the result from the most recent call is kept. Return the final result.',
    setup: 'A latest-only fetch wrapper.',
    setupCode: `function createLatestOnly() {\n  let currentId = 0;\n  return {\n    async fetch(asyncFn) {\n      const id = ++currentId;\n      const result = await asyncFn();\n      if (id === currentId) return { stale: false, data: result };\n      return { stale: true, data: result };\n    }\n  };\n}\nconst lo = createLatestOnly();\nconst p1 = lo.fetch(() => Promise.resolve("first"));\nconst p2 = lo.fetch(() => Promise.resolve("second"));\nconst r1 = await p1;\nconst r2 = await p2;`,
    expected: { r1: { stale: true, data: 'first' }, r2: { stale: false, data: 'second' } },
    sample: '({ r1, r2 })',
    hints: ['Increment a request ID for each call', 'Compare ID after await to detect staleness'],
    tags: ['race-condition', 'async', 'stale'],
  },

  {
    id: 'fe-js-polling',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Polling Until Condition',
    text: 'Implement a poll function that calls an async function repeatedly until a condition is met. Track the number of polls. Return the final result and poll count.',
    setup: 'A polling mechanism.',
    setupCode: `let pollCount = 0;\nlet serverValue = 0;\nasync function poll(fn, condition, maxPolls) {\n  for (let i = 0; i < maxPolls; i++) {\n    pollCount++;\n    const result = await fn();\n    if (condition(result)) return result;\n  }\n  return null;\n}\nserverValue = 0;\nconst result = await poll(\n  () => { serverValue++; return Promise.resolve(serverValue); },\n  v => v >= 3,\n  10\n);`,
    expected: { result: 3, polls: 3 },
    sample: '({ result, polls: pollCount })',
    hints: ['Loop and await each poll', 'Check condition after each result'],
    tags: ['polling', 'async', 'condition'],
  },

  {
    id: 'fe-js-parallel-fetch',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'easy',
    title: 'Parallel Data Fetching',
    text: 'Fetch user and posts data in parallel using Promise.all. Combine into a single result object.',
    setup: 'Two async data sources.',
    setupCode: `const getUser = () => Promise.resolve({ id: 1, name: "Alice" });\nconst getPosts = () => Promise.resolve([{ title: "Post 1" }, { title: "Post 2" }]);\nasync function fetchAll() {\n  const [user, posts] = await Promise.all([getUser(), getPosts()]);\n  return { user, posts };\n}`,
    expected: { user: { id: 1, name: 'Alice' }, posts: [{ title: 'Post 1' }, { title: 'Post 2' }] },
    sample: 'await fetchAll()',
    hints: ['Use Promise.all with array of promises', 'Destructure the results'],
    tags: ['Promise.all', 'parallel', 'async'],
  },

  {
    id: 'fe-js-response-transform',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Response Transformer Pipeline',
    text: 'Implement a response transformer pipeline that applies a series of transform functions to API response data. Return the transformed result.',
    setup: 'A transformer pipeline.',
    setupCode: `function createTransformer(...transforms) {\n  return function(data) {\n    return transforms.reduce((result, fn) => fn(result), data);\n  };\n}\nconst transform = createTransformer(\n  data => data.items,\n  items => items.filter(i => i.active),\n  items => items.map(i => i.name)\n);\nconst apiResponse = { items: [\n  { name: "Alice", active: true },\n  { name: "Bob", active: false },\n  { name: "Charlie", active: true }\n]};`,
    expected: ['Alice', 'Charlie'],
    sample: 'transform(apiResponse)',
    hints: ['Use reduce to chain transforms', 'Each transform receives previous result'],
    tags: ['transform', 'pipeline', 'fetch'],
  },

  {
    id: 'fe-js-promise-allsettled',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'hard',
    title: 'Promise.allSettled Simulation',
    text: 'Implement a custom allSettled that returns status objects for all promises regardless of rejection. Return the results.',
    setup: 'A custom allSettled implementation.',
    setupCode: `function allSettled(promises) {\n  return Promise.all(\n    promises.map(p =>\n      Promise.resolve(p)\n        .then(value => ({ status: "fulfilled", value }))\n        .catch(reason => ({ status: "rejected", reason: reason.message || String(reason) }))\n    )\n  );\n}\nconst results = await allSettled([\n  Promise.resolve(1),\n  Promise.reject(new Error("fail")),\n  Promise.resolve(3)\n]);`,
    expected: [
      { status: 'fulfilled', value: 1 },
      { status: 'rejected', reason: 'fail' },
      { status: 'fulfilled', value: 3 },
    ],
    sample: 'results',
    hints: [
      'Wrap each promise to catch rejections',
      'Return status objects for both fulfilled and rejected',
    ],
    tags: ['Promise', 'allSettled', 'error-handling'],
  },

  {
    id: 'fe-js-deduplicate-requests',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'hard',
    title: 'Deduplicate Concurrent Requests',
    text: 'Implement a request deduplicator that returns the same promise for identical concurrent requests. Track fetch count.',
    setup: 'A deduplication wrapper.',
    setupCode: `let dedupFetchCount = 0;\nfunction createDeduplicator(fetcher) {\n  const pending = new Map();\n  return {\n    async get(key) {\n      if (pending.has(key)) return pending.get(key);\n      dedupFetchCount++;\n      const promise = fetcher(key).then(result => {\n        pending.delete(key);\n        return result;\n      });\n      pending.set(key, promise);\n      return promise;\n    }\n  };\n}\nconst dd = createDeduplicator(k => Promise.resolve("val-" + k));\nconst [a, b, c] = await Promise.all([dd.get("x"), dd.get("x"), dd.get("y")]);`,
    expected: { a: 'val-x', b: 'val-x', c: 'val-y', fetchCount: 2 },
    sample: '({ a, b, c, fetchCount: dedupFetchCount })',
    hints: ['Store pending promises in a Map', 'Return existing promise for duplicate keys'],
    tags: ['dedup', 'fetch', 'concurrent', 'Map'],
  },

  // ─── NEW Forms & Validation (17) ─────────────────────────────

  {
    id: 'fe-js-required-fields',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'easy',
    title: 'Required Fields Validation',
    text: 'Given a form data object and an array of required field names, return an array of missing field names (empty or undefined).',
    setup: 'Form data and required fields list.',
    setupCode: `const formData = { name: "Alice", email: "", age: "30", phone: "" };\nconst required = ["name", "email", "phone", "address"];\nfunction getMissing(data, requiredFields) {\n  return requiredFields.filter(f => !data[f]);\n}`,
    expected: ['email', 'phone', 'address'],
    sample: 'getMissing(formData, required)',
    hints: ['Filter required fields where value is falsy', 'Empty string is falsy'],
    tags: ['forms', 'validation', 'required'],
  },

  {
    id: 'fe-js-phone-format',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'easy',
    title: 'Phone Number Format',
    text: 'Given a 10-digit string, format it as (XXX) XXX-XXXX. Return the formatted string.',
    setup: 'A phone number formatter.',
    setupCode: `function formatPhone(digits) {\n  return \`(\${digits.slice(0,3)}) \${digits.slice(3,6)}-\${digits.slice(6)}\`;\n}`,
    expected: '(555) 123-4567',
    sample: 'formatPhone("5551234567")',
    hints: ['Use slice to extract parts', 'Format with template literal'],
    tags: ['forms', 'format', 'phone'],
  },

  {
    id: 'fe-js-input-mask',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'Input Masking',
    text: 'Implement a credit card input mask that adds a space every 4 digits. Strip non-digits first, then format. Return the masked value.',
    setup: 'A credit card mask function.',
    setupCode: `function maskCard(input) {\n  const digits = input.replace(/\\D/g, "").slice(0, 16);\n  return digits.replace(/(\\d{4})(?=\\d)/g, "$1 ");\n}`,
    expected: '1234 5678 9012 3456',
    sample: 'maskCard("1234-5678-9012-3456")',
    hints: ['Strip non-digits first', 'Insert space every 4 digits with regex'],
    tags: ['forms', 'mask', 'credit-card'],
  },

  {
    id: 'fe-js-form-serialize',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'easy',
    title: 'Form Serialization to URL Params',
    text: 'Serialize a form data object to a URL query string. Return the encoded string.',
    setup: 'A form data object.',
    setupCode: `function serializeForm(data) {\n  return Object.entries(data)\n    .map(([k, v]) => encodeURIComponent(k) + "=" + encodeURIComponent(v))\n    .join("&");\n}`,
    expected: 'name=Alice%20Smith&age=30&city=New%20York',
    sample: 'serializeForm({ name: "Alice Smith", age: "30", city: "New York" })',
    hints: ['Use encodeURIComponent for both keys and values', 'Join with &'],
    tags: ['forms', 'serialize', 'URL', 'params'],
  },

  {
    id: 'fe-js-dynamic-validation',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'Dynamic Validation Rules',
    text: 'Implement a validator that accepts dynamic rules (each rule is a function returning an error string or null). Validate a value and return all errors.',
    setup: 'A dynamic validation engine.',
    setupCode: `function validate(value, rules) {\n  return rules\n    .map(rule => rule(value))\n    .filter(error => error !== null);\n}\nconst rules = [\n  v => v.length < 3 ? "Too short" : null,\n  v => v.length > 10 ? "Too long" : null,\n  v => !/[A-Z]/.test(v) ? "Needs uppercase" : null,\n  v => !/\\d/.test(v) ? "Needs digit" : null\n];`,
    expected: ['Needs uppercase', 'Needs digit'],
    sample: 'validate("hello", rules)',
    hints: ['Map rules to error messages', 'Filter out null values'],
    tags: ['forms', 'validation', 'dynamic', 'rules'],
  },

  {
    id: 'fe-js-multi-step-form',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'Multi-Step Form State',
    text: 'Implement a multi-step form manager that tracks current step, form data per step, and allows navigation. Return the combined data after filling all steps.',
    setup: 'A multi-step form state manager.',
    setupCode: `function createMultiStepForm(steps) {\n  let current = 0;\n  const data = {};\n  return {\n    getCurrentStep() { return steps[current]; },\n    setData(stepData) { data[steps[current]] = stepData; },\n    next() { if (current < steps.length - 1) current++; },\n    prev() { if (current > 0) current--; },\n    getData() { return data; }\n  };\n}\nconst form = createMultiStepForm(["personal", "address", "payment"]);\nform.setData({ name: "Alice" });\nform.next();\nform.setData({ city: "Portland" });\nform.next();\nform.setData({ card: "1234" });`,
    expected: {
      personal: { name: 'Alice' },
      address: { city: 'Portland' },
      payment: { card: '1234' },
    },
    sample: 'form.getData()',
    hints: ['Track current step index', 'Store data keyed by step name'],
    tags: ['forms', 'multi-step', 'wizard', 'state'],
  },

  {
    id: 'fe-js-file-data-validate',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'File Upload Validation',
    text: 'Validate file objects against constraints (maxSize in bytes, allowedTypes). Return validation results for each file.',
    setup: 'File objects and validation constraints.',
    setupCode: `function validateFiles(files, constraints) {\n  return files.map(f => {\n    const errors = [];\n    if (f.size > constraints.maxSize) errors.push("too-large");\n    if (!constraints.allowedTypes.includes(f.type)) errors.push("invalid-type");\n    return { name: f.name, valid: errors.length === 0, errors };\n  });\n}\nconst files = [\n  { name: "photo.jpg", size: 500000, type: "image/jpeg" },\n  { name: "doc.pdf", size: 2000000, type: "application/pdf" },\n  { name: "huge.png", size: 6000000, type: "image/png" }\n];\nconst constraints = { maxSize: 5000000, allowedTypes: ["image/jpeg", "image/png"] };`,
    expected: [
      { name: 'photo.jpg', valid: true, errors: [] },
      { name: 'doc.pdf', valid: false, errors: ['invalid-type'] },
      { name: 'huge.png', valid: false, errors: ['too-large'] },
    ],
    sample: 'validateFiles(files, constraints)',
    hints: ['Check size and type against constraints', 'Collect errors per file'],
    tags: ['forms', 'file', 'validation', 'upload'],
  },

  {
    id: 'fe-js-formdata-like',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'FormData-Like Operations',
    text: 'Implement a FormData-like class with append, get, getAll, and entries methods. append allows multiple values for the same key. Return results of operations.',
    setup: 'A FormData mock.',
    setupCode: `function createFormData() {\n  const data = new Map();\n  return {\n    append(key, value) {\n      if (!data.has(key)) data.set(key, []);\n      data.get(key).push(value);\n    },\n    get(key) {\n      const vals = data.get(key);\n      return vals ? vals[0] : null;\n    },\n    getAll(key) {\n      return data.get(key) || [];\n    },\n    entries() {\n      const result = [];\n      for (const [k, vals] of data) {\n        for (const v of vals) result.push([k, v]);\n      }\n      return result;\n    }\n  };\n}\nconst fd = createFormData();\nfd.append("name", "Alice");\nfd.append("hobby", "reading");\nfd.append("hobby", "coding");`,
    expected: {
      name: 'Alice',
      hobbies: ['reading', 'coding'],
      entries: [
        ['name', 'Alice'],
        ['hobby', 'reading'],
        ['hobby', 'coding'],
      ],
    },
    sample: '({ name: fd.get("name"), hobbies: fd.getAll("hobby"), entries: fd.entries() })',
    hints: ['Store values as arrays in a Map', 'append pushes to array, get returns first'],
    tags: ['forms', 'FormData', 'Map'],
  },

  {
    id: 'fe-js-constraint-validation',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'Constraint Validation API Mock',
    text: 'Implement a mock validity object that checks constraints (required, minLength, maxLength, pattern). Return the validity state for a given value.',
    setup: 'A constraint validator.',
    setupCode: `function checkValidity(value, constraints) {\n  const validity = {\n    valid: true,\n    valueMissing: false,\n    tooShort: false,\n    tooLong: false,\n    patternMismatch: false\n  };\n  if (constraints.required && !value) { validity.valueMissing = true; validity.valid = false; }\n  if (constraints.minLength && value.length < constraints.minLength) { validity.tooShort = true; validity.valid = false; }\n  if (constraints.maxLength && value.length > constraints.maxLength) { validity.tooLong = true; validity.valid = false; }\n  if (constraints.pattern && !new RegExp(constraints.pattern).test(value)) { validity.patternMismatch = true; validity.valid = false; }\n  return validity;\n}`,
    expected: {
      valid: false,
      valueMissing: false,
      tooShort: true,
      tooLong: false,
      patternMismatch: false,
    },
    sample:
      'checkValidity("ab", { required: true, minLength: 3, maxLength: 10, pattern: "^[a-z]+$" })',
    hints: ['Check each constraint independently', 'Set valid to false if any constraint fails'],
    tags: ['forms', 'constraint', 'validation', 'API'],
  },

  {
    id: 'fe-js-dirty-tracking',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'easy',
    title: 'Form Dirty Tracking',
    text: 'Track which fields have been modified from their initial values. Return an object with isDirty boolean and changedFields array.',
    setup: 'Initial and current form values.',
    setupCode: `function trackDirty(initial, current) {\n  const changedFields = Object.keys(current).filter(k => current[k] !== initial[k]);\n  return { isDirty: changedFields.length > 0, changedFields };\n}\nconst initial = { name: "Alice", email: "a@b.com", age: "30" };\nconst current = { name: "Alice", email: "alice@new.com", age: "31" };`,
    expected: { isDirty: true, changedFields: ['email', 'age'] },
    sample: 'trackDirty(initial, current)',
    hints: ['Compare each field between initial and current', 'Filter for fields that differ'],
    tags: ['forms', 'dirty', 'tracking', 'state'],
  },

  {
    id: 'fe-js-debounced-validation',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'Debounced Validation Results',
    text: 'Implement a validator that collects multiple synchronous validation calls and only returns the result of the last one. Simulate debounced validation. Return the final result.',
    setup: 'A synchronous debounced validator.',
    setupCode: `function createDebouncedValidator(validateFn) {\n  let lastInput = null;\n  return {\n    validate(input) { lastInput = input; },\n    getResult() { return lastInput !== null ? validateFn(lastInput) : null; }\n  };\n}\nconst dv = createDebouncedValidator(v => v.length >= 3 ? "valid" : "too short");\ndv.validate("a");\ndv.validate("ab");\ndv.validate("abc");\ndv.validate("abcd");`,
    expected: 'valid',
    sample: 'dv.getResult()',
    hints: ['Store only the last input', 'Validate the last input when result is requested'],
    tags: ['forms', 'validation', 'debounce'],
  },

  {
    id: 'fe-js-field-dependencies',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'hard',
    title: 'Field Dependency Validation',
    text: 'Implement validation where some fields depend on others (e.g., confirmPassword must match password, endDate must be after startDate). Return all errors.',
    setup: 'Form with dependent field validation.',
    setupCode: `function validateWithDeps(data, rules) {\n  const errors = {};\n  for (const [field, ruleFn] of Object.entries(rules)) {\n    const error = ruleFn(data[field], data);\n    if (error) errors[field] = error;\n  }\n  return errors;\n}\nconst formData = {\n  password: "abc123",\n  confirmPassword: "abc124",\n  startDate: "2024-03-01",\n  endDate: "2024-02-01"\n};\nconst rules = {\n  confirmPassword: (val, all) => val !== all.password ? "Passwords must match" : null,\n  endDate: (val, all) => val <= all.startDate ? "End must be after start" : null\n};`,
    expected: { confirmPassword: 'Passwords must match', endDate: 'End must be after start' },
    sample: 'validateWithDeps(formData, rules)',
    hints: ['Pass full form data to each rule function', 'Rules can compare against other fields'],
    tags: ['forms', 'validation', 'dependencies', 'cross-field'],
  },

  {
    id: 'fe-js-touched-fields',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'easy',
    title: 'Touched Fields Tracker',
    text: 'Track which form fields have been "touched" (focused then blurred). Return the touched state object.',
    setup: 'A touched fields tracker.',
    setupCode: `function createTouchedTracker(fields) {\n  const touched = {};\n  fields.forEach(f => touched[f] = false);\n  return {\n    touch(field) { touched[field] = true; },\n    getTouched() { return { ...touched }; }\n  };\n}\nconst tracker = createTouchedTracker(["name", "email", "age"]);\ntracker.touch("name");\ntracker.touch("email");`,
    expected: { name: true, email: true, age: false },
    sample: 'tracker.getTouched()',
    hints: ['Initialize all fields as false', 'Set to true when touched'],
    tags: ['forms', 'touched', 'tracking'],
  },

  {
    id: 'fe-js-form-reset',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'easy',
    title: 'Form Reset to Defaults',
    text: 'Implement a form manager with update and reset methods. Reset restores initial values. Return state after update then reset.',
    setup: 'A form state with reset capability.',
    setupCode: `function createForm(defaults) {\n  let current = { ...defaults };\n  return {\n    update(field, value) { current[field] = value; },\n    reset() { current = { ...defaults }; },\n    getValues() { return { ...current }; }\n  };\n}\nconst form = createForm({ name: "", email: "", age: "" });\nform.update("name", "Alice");\nform.update("email", "alice@test.com");\nconst beforeReset = form.getValues();\nform.reset();\nconst afterReset = form.getValues();`,
    expected: {
      before: { name: 'Alice', email: 'alice@test.com', age: '' },
      after: { name: '', email: '', age: '' },
    },
    sample: '({ before: beforeReset, after: afterReset })',
    hints: ['Copy defaults on creation', 'Reset by re-copying defaults'],
    tags: ['forms', 'reset', 'state'],
  },

  {
    id: 'fe-js-async-validation',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'hard',
    title: 'Async Field Validation',
    text: 'Implement async validators that check values against a mock server lookup. Run validators in parallel and collect results.',
    setup: 'Async validators with mock server.',
    setupCode: `const takenUsernames = ["admin", "root", "test"];\nasync function checkUsername(name) {\n  return takenUsernames.includes(name) ? "Username taken" : null;\n}\nasync function checkEmail(email) {\n  return email.endsWith("@spam.com") ? "Blocked domain" : null;\n}\nasync function asyncValidate(data, validators) {\n  const entries = Object.entries(validators);\n  const results = await Promise.all(\n    entries.map(async ([field, fn]) => [field, await fn(data[field])])\n  );\n  const errors = {};\n  for (const [field, error] of results) {\n    if (error) errors[field] = error;\n  }\n  return errors;\n}\nconst result = await asyncValidate(\n  { username: "admin", email: "user@good.com" },\n  { username: checkUsername, email: checkEmail }\n);`,
    expected: { username: 'Username taken' },
    sample: 'result',
    hints: ['Run validators in parallel with Promise.all', 'Filter out null results'],
    tags: ['forms', 'validation', 'async', 'server'],
  },

  {
    id: 'fe-js-schema-validation',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'hard',
    title: 'Schema-Based Validation',
    text: 'Implement a schema validator that validates an object against a schema definition with type checking and required fields. Return validation result.',
    setup: 'A schema validation engine.',
    setupCode: `function validateSchema(data, schema) {\n  const errors = [];\n  for (const [field, rules] of Object.entries(schema)) {\n    const value = data[field];\n    if (rules.required && (value === undefined || value === null || value === "")) {\n      errors.push({ field, error: "required" });\n      continue;\n    }\n    if (value !== undefined && value !== null && rules.type) {\n      if (rules.type === "number" && typeof value !== "number") errors.push({ field, error: "invalid-type" });\n      if (rules.type === "string" && typeof value !== "string") errors.push({ field, error: "invalid-type" });\n    }\n    if (rules.min !== undefined && typeof value === "number" && value < rules.min) {\n      errors.push({ field, error: "below-min" });\n    }\n  }\n  return { valid: errors.length === 0, errors };\n}\nconst schema = {\n  name: { type: "string", required: true },\n  age: { type: "number", required: true, min: 0 },\n  email: { type: "string", required: false }\n};`,
    expected: {
      valid: false,
      errors: [{ field: 'age', error: 'invalid-type' }],
    },
    sample: 'validateSchema({ name: "Alice", age: "thirty" }, schema)',
    hints: ['Check required first, then type, then constraints', 'Collect all errors'],
    tags: ['forms', 'schema', 'validation', 'types'],
  },

  {
    id: 'fe-js-form-array-fields',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'Dynamic Array Fields',
    text: 'Implement a form field manager for dynamic arrays (like adding/removing tags). Support add, remove, and getAll operations. Return the final list.',
    setup: 'A dynamic array field manager.',
    setupCode: `function createArrayField(initial) {\n  const items = [...initial];\n  return {\n    add(item) { items.push(item); },\n    remove(index) { items.splice(index, 1); },\n    getAll() { return [...items]; }\n  };\n}\nconst tags = createArrayField(["js", "react"]);\ntags.add("vue");\ntags.add("angular");\ntags.remove(1);\ntags.add("svelte");`,
    expected: ['js', 'vue', 'angular', 'svelte'],
    sample: 'tags.getAll()',
    hints: ['Use push to add, splice to remove', 'Return a copy from getAll'],
    tags: ['forms', 'dynamic', 'array', 'fields'],
  },
];
