import type { FrontendDrillProblem } from '../types';

/**
 * Native JavaScript drill problems.
 * These problems use plain JS objects to simulate DOM structures
 * since the validator blocks window, document, fetch, and eval.
 */
export const nativeJsProblems: FrontendDrillProblem[] = [
  // DOM & Events
  {
    id: 'fe-js-query-class',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'easy',
    title: 'Query Elements by Class',
    text: 'Filter the elements array to find all elements with the class "active".',
    setup: 'An array of element objects with tagName, id, and classList properties.',
    setupCode: `const elements = [
  { tagName: "div", id: "a", classList: ["active", "card"] },
  { tagName: "span", id: "b", classList: ["hidden"] },
  { tagName: "div", id: "c", classList: ["active"] },
  { tagName: "p", id: "d", classList: [] }
];`,
    expected: [
      { tagName: 'div', id: 'a', classList: ['active', 'card'] },
      { tagName: 'div', id: 'c', classList: ['active'] },
    ],
    sample: 'elements.filter(el => el.classList.includes("active"))',
    hints: ['Use .filter() and .includes() methods', 'Check if classList array includes "active"'],
    tags: ['DOM', 'filter', 'classList', 'querySelector'],
  },

  {
    id: 'fe-js-event-delegation',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'Event Delegation Pattern',
    text: 'Given an array of click events (each with a target.id), filter only those where target.id starts with "btn-".',
    setup: 'An array of event objects with target.id properties.',
    setupCode: `const events = [
  { type: "click", target: { id: "btn-submit" } },
  { type: "click", target: { id: "link-home" } },
  { type: "click", target: { id: "btn-cancel" } },
  { type: "click", target: { id: "div-container" } },
  { type: "click", target: { id: "btn-delete" } }
];`,
    expected: [
      { type: 'click', target: { id: 'btn-submit' } },
      { type: 'click', target: { id: 'btn-cancel' } },
      { type: 'click', target: { id: 'btn-delete' } },
    ],
    sample: 'events.filter(e => e.target.id.startsWith("btn-"))',
    hints: ['Use .filter() with .startsWith()', 'Access target.id from each event object'],
    tags: ['events', 'delegation', 'filter', 'startsWith'],
  },

  // Common Patterns
  {
    id: 'fe-js-debounce-basic',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Debounce Function',
    text: 'Implement a simple debounce function that delays execution until after a specified wait time.',
    setup: 'Return a debounce function that takes (func, wait) and returns a debounced version.',
    setupCode: `let callCount = 0;
const increment = () => { callCount++; };`,
    expected: 'function',
    sample: `function debounce(func, wait) {
  let timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), wait);
  };
}
typeof debounce(increment, 100)`,
    hints: [
      'Use setTimeout and clearTimeout',
      'Return a new function that clears previous timeout',
      'Store timeout in closure',
    ],
    tags: ['debounce', 'closure', 'setTimeout', 'performance'],
  },

  {
    id: 'fe-js-throttle-basic',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Throttle Function',
    text: 'Implement a simple throttle function that ensures a function is called at most once per specified interval.',
    setup: 'Return a throttle function that takes (func, limit) and returns a throttled version.',
    setupCode: `let callCount = 0;
const increment = () => { callCount++; };`,
    expected: 'function',
    sample: `function throttle(func, limit) {
  let inThrottle;
  return function(...args) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}
typeof throttle(increment, 100)`,
    hints: [
      'Use a flag to track throttle state',
      'Call function immediately if not throttled',
      'Reset flag after timeout',
    ],
    tags: ['throttle', 'closure', 'setTimeout', 'performance'],
  },

  {
    id: 'fe-js-localstorage-mock',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'easy',
    title: 'LocalStorage Mock Operations',
    text: 'Build a storage object that mimics localStorage with a data object, setItem(key, value), and getItem(key) methods. Then set "theme" to "dark" and retrieve it.',
    setup: 'No setup needed - build the storage mock yourself.',
    setupCode: `// Implement a localStorage-like storage object with setItem and getItem`,
    expected: 'dark',
    sample: `const storage = {\n  data: {},\n  setItem(key, value) { this.data[key] = value; },\n  getItem(key) { return this.data[key]; }\n};\nstorage.setItem("theme", "dark");\nconst theme = storage.getItem("theme");`,
    hints: [
      'Use a plain object (data) as the backing store',
      'setItem writes to this.data[key]',
      'getItem reads from this.data[key]',
    ],
    tags: ['localStorage', 'storage', 'API'],
  },

  // Rendering
  {
    id: 'fe-js-build-html-string',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'easy',
    title: 'Build HTML String from Array',
    text: 'Given an array of items, create an HTML string of <li> elements.',
    setup: 'An array of fruit names.',
    setupCode: `const items = ["Apple", "Banana", "Cherry"];`,
    expected: '<li>Apple</li><li>Banana</li><li>Cherry</li>',
    // biome-ignore lint/suspicious/noTemplateCurlyInString: sample holds user solution code containing template literals
    sample: 'items.map(item => `<li>${item}</li>`).join("")',
    hints: [
      'Use .map() to transform each item',
      'Use template literals',
      'Join the array into a string',
    ],
    tags: ['innerHTML', 'map', 'template literals', 'rendering'],
  },

  {
    id: 'fe-js-create-element-object',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'medium',
    title: 'Create Element Object',
    text: 'Write a createElement(tag, text, attrs) function that returns a virtual DOM element object with tagName, textContent, and attributes properties. Then call it to create a button with text "Click me" and class "btn-primary".',
    setup: 'No setup needed.',
    setupCode: `// Implement createElement(tag, text, attrs) and call it`,
    expected: {
      tagName: 'button',
      textContent: 'Click me',
      attributes: { class: 'btn-primary' },
    },
    sample: `function createElement(tag, text, attrs) {\n  return { tagName: tag, textContent: text, attributes: attrs };\n}\ncreateElement("button", "Click me", { class: "btn-primary" })`,
    hints: [
      'The function returns an object with tagName, textContent, attributes',
      'Map the parameters to the object properties',
      'Call with "button", "Click me", and an attributes object',
    ],
    tags: ['createElement', 'DOM', 'object'],
  },

  // Data Fetching
  {
    id: 'fe-js-mock-fetch-promise',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Mock Fetch with Promise',
    text: 'Create a mockFetch function that returns a Promise resolving to { data: [1, 2, 3] } after 0ms.',
    setup: 'Return a function that returns a Promise.',
    setupCode: `// mockFetch should resolve to { data: [1, 2, 3] }`,
    expected: 'function',
    sample: `function mockFetch() {
  return Promise.resolve({ data: [1, 2, 3] });
}
typeof mockFetch`,
    hints: [
      'Use Promise.resolve() to create a resolved promise',
      'Return an object with data property',
    ],
    tags: ['fetch', 'Promise', 'async', 'API'],
  },

  {
    id: 'fe-js-async-await-pattern',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Async/Await Data Extraction',
    text: 'Create a function that calls mockFetch() and returns the data property from the result.',
    setup: 'A mockFetch function that returns { data: [1, 2, 3] } synchronously.',
    setupCode: `const mockFetch = () => ({ data: [1, 2, 3] });`,
    expected: 'function',
    sample: `function getData() {
  const result = mockFetch();
  return result.data;
}
typeof getData`,
    hints: [
      'Use async function keyword',
      'Use await to wait for the promise',
      'Return the data property',
    ],
    tags: ['async', 'await', 'Promise', 'data'],
  },

  // Forms & Validation
  {
    id: 'fe-js-email-validation',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'easy',
    title: 'Email Validation Function',
    text: 'Create a function isValidEmail(email) that returns true if the email contains "@" and ".", false otherwise. Test it with the provided email.',
    setup: 'A test email string.',
    setupCode: `const testEmail = "user@example.com";`,
    expected: true,
    sample: `function isValidEmail(email) {
  return email.includes("@") && email.includes(".");
}
isValidEmail(testEmail)`,
    hints: ['Use .includes() to check for both "@" and "."', 'Return a boolean'],
    tags: ['validation', 'forms', 'email', 'regex'],
  },

  {
    id: 'fe-js-form-data-extract',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'Extract Form Data from Array',
    text: 'Given an array of input objects with name and value properties, create an object mapping names to values.',
    setup: 'An array of form input objects.',
    setupCode: `const inputs = [
  { name: "username", value: "john" },
  { name: "email", value: "john@example.com" },
  { name: "age", value: "30" }
];`,
    expected: {
      username: 'john',
      email: 'john@example.com',
      age: '30',
    },
    sample: `inputs.reduce((acc, input) => {
  acc[input.name] = input.value;
  return acc;
}, {})`,
    hints: [
      'Use .reduce() to build an object',
      'Set acc[input.name] = input.value',
      'Start with empty object {}',
    ],
    tags: ['forms', 'reduce', 'object', 'FormData'],
  },

  {
    id: 'fe-js-password-strength',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'Password Strength Validator',
    text: 'Create a function checkPasswordStrength(password) that returns "weak" if length < 8, "medium" if length < 12, else "strong". Test it with the provided password.',
    setup: 'A test password string.',
    setupCode: `const testPassword = "MyP@ssw0rd";`,
    expected: 'medium',
    sample: `function checkPasswordStrength(password) {
  if (password.length < 8) return "weak";
  if (password.length < 12) return "medium";
  return "strong";
}
checkPasswordStrength(testPassword)`,
    hints: [
      'Check password.length',
      'Use if/else or ternary operators',
      'Return one of three strings',
    ],
    tags: ['validation', 'forms', 'password', 'security'],
  },

  // ─── NEW DOM & Events (17) ───────────────────────────────────

  {
    id: 'fe-js-classlist-toggle',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'easy',
    title: 'Toggle Class on Element',
    text: 'Write a toggleClass(element, cls) function that removes the class from the classList array if present, or adds it if absent. Then call it to toggle "active" off the element and return the updated classList.',
    setup: 'An element object with classList array.',
    setupCode: `// Element with classList array\nconst el = { classList: ["active", "card"] };`,
    expected: ['card'],
    sample: `function toggleClass(element, cls) {\n  const idx = element.classList.indexOf(cls);\n  if (idx >= 0) element.classList.splice(idx, 1);\n  else element.classList.push(cls);\n  return element.classList;\n}\ntoggleClass(el, "active")`,
    hints: [
      'Check if the class exists with indexOf or includes',
      'Use splice to remove, push to add',
      'Return the updated classList array',
    ],
    tags: ['DOM', 'classList', 'toggle'],
  },

  {
    id: 'fe-js-add-class',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'easy',
    title: 'Add Class to Element',
    text: 'Write an addClass(element, cls) function that adds a class to the classList array only if not already present. Call it to add "highlight" to the element and return the classList.',
    setup: 'An element object with classList array.',
    setupCode: `// Element with classList array\nconst el = { classList: ["card"] };`,
    expected: ['card', 'highlight'],
    sample: `function addClass(element, cls) {\n  if (!element.classList.includes(cls)) element.classList.push(cls);\n  return element.classList;\n}\naddClass(el, "highlight")`,
    hints: [
      'Check if the class already exists with includes',
      'Only push if not present',
      'Return the classList array',
    ],
    tags: ['DOM', 'classList', 'add'],
  },

  {
    id: 'fe-js-remove-class',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'easy',
    title: 'Remove Class from Element',
    text: 'Write a removeClass(element, cls) function that removes a class from the classList array if present. Call it to remove "hidden" from the element and return the updated classList.',
    setup: 'An element object with classList array.',
    setupCode: `// Element with classList array\nconst el = { classList: ["card", "hidden", "active"] };`,
    expected: ['card', 'active'],
    sample: `function removeClass(element, cls) {\n  const idx = element.classList.indexOf(cls);\n  if (idx >= 0) element.classList.splice(idx, 1);\n  return element.classList;\n}\nremoveClass(el, "hidden")`,
    hints: [
      'Find the index of the class with indexOf',
      'Use splice to remove it',
      'Return the updated classList',
    ],
    tags: ['DOM', 'classList', 'remove'],
  },

  {
    id: 'fe-js-event-object-create',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'easy',
    title: 'Create Event Object',
    text: 'Write a createKeyEvent(type, key, keyCode) function that returns a plain event object with those three properties. Then call it to create a "keydown" event for the Enter key (keyCode 13).',
    setup: 'No setup needed.',
    setupCode: `// Implement createKeyEvent and call it`,
    expected: { type: 'keydown', key: 'Enter', keyCode: 13 },
    sample: `function createKeyEvent(type, key, keyCode) {\n  return { type, key, keyCode };\n}\nconst event = createKeyEvent("keydown", "Enter", 13);`,
    hints: [
      'The function takes three arguments and returns an object',
      'Use shorthand property names when key matches variable name',
      'Call it with "keydown", "Enter", 13',
    ],
    tags: ['DOM', 'events', 'keyboard'],
  },

  {
    id: 'fe-js-closest-ancestor',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'Find Closest Ancestor',
    text: 'Write a closest(node, tag) function that walks up the parent chain and returns the first ancestor whose tagName matches the given tag (case-insensitive), or null if none found. Call it to find the "ul" ancestor of child.',
    setup: 'A chain of node objects linked by parent property.',
    setupCode: `// Node chain: child -> par -> grandparent\nconst grandparent = { tagName: "DIV", parent: null };\nconst par = { tagName: "UL", parent: grandparent };\nconst child = { tagName: "LI", parent: par };`,
    expected: { tagName: 'UL', parent: { tagName: 'DIV', parent: null } },
    sample: `function closest(node, tag) {\n  let cur = node.parent;\n  while (cur) {\n    if (cur.tagName.toLowerCase() === tag.toLowerCase()) return cur;\n    cur = cur.parent;\n  }\n  return null;\n}\nclosest(child, "ul")`,
    hints: [
      'Start from node.parent and walk upward',
      'Compare tagName using toLowerCase()',
      'Return null if no match found',
    ],
    tags: ['DOM', 'traversal', 'closest'],
  },

  {
    id: 'fe-js-event-listener-map',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'Event Listener Map',
    text: 'Build an event listener registry with addEventListener(reg, type, cb) and emit(reg, type, data). addEventListener stores callbacks by event type. emit calls all listeners for that type and returns an array of their results. Register two "click" listeners (one adds 1 to data.x, one doubles data.x), then emit with {x:10}.',
    setup: 'An empty registry object.',
    setupCode: `// Registry with a listeners object to store callbacks by type\nconst registry = { listeners: {} };`,
    expected: [11, 20],
    sample: `function addEventListener(reg, type, cb) {\n  if (!reg.listeners[type]) reg.listeners[type] = [];\n  reg.listeners[type].push(cb);\n}\nfunction emit(reg, type, data) {\n  return (reg.listeners[type] || []).map(cb => cb(data));\n}\naddEventListener(registry, "click", d => d.x + 1);\naddEventListener(registry, "click", d => d.x * 2);\nemit(registry, "click", { x: 10 })`,
    hints: [
      'Store listeners in an object keyed by event type',
      'addEventListener pushes callbacks into the array for that type',
      'emit maps over all listeners for the type and returns results',
    ],
    tags: ['DOM', 'events', 'listeners', 'registry'],
  },

  {
    id: 'fe-js-stop-propagation',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'Simulate Event Propagation',
    text: 'Write a propagate(handlers) function that simulates event bubbling. Iterate through the handler objects, calling each handler() and collecting results. If a handler has stop: true, stop after executing it. Return the array of collected results.',
    setup: 'An array of handler descriptor objects with handler function and stop boolean.',
    setupCode: `// Each handler has a handler() function and a stop flag\nconst handlers = [\n  { handler: () => "child", stop: false },\n  { handler: () => "parent", stop: true },\n  { handler: () => "grandparent", stop: false }\n];`,
    expected: ['child', 'parent'],
    sample: `function propagate(handlers) {\n  const results = [];\n  for (const h of handlers) {\n    results.push(h.handler());\n    if (h.stop) break;\n  }\n  return results;\n}\npropagate(handlers)`,
    hints: [
      'Loop through handlers and push each result',
      'Check the stop flag after each handler call',
      'Break out of the loop when stop is true',
    ],
    tags: ['DOM', 'events', 'propagation', 'bubbling'],
  },

  {
    id: 'fe-js-delegate-match',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'Delegation Selector Match',
    text: 'Write a delegateMatch(el, selector) function that checks if an element matches a simple CSS selector. If the selector starts with "#", compare against el.id. If it starts with ".", check if el.classList includes the class. Return true or false. Test it with ".primary".',
    setup: 'A target element object with id and classList.',
    setupCode: `// Element with id and classList\nconst target = { id: "btn-1", classList: ["primary", "large"] };`,
    expected: true,
    sample: `function delegateMatch(el, selector) {\n  if (selector.startsWith("#")) return el.id === selector.slice(1);\n  if (selector.startsWith(".")) return el.classList.includes(selector.slice(1));\n  return false;\n}\ndelegateMatch(target, ".primary")`,
    hints: [
      'Check the first character of the selector to determine type',
      'Use slice(1) to get the name without the prefix',
      'For class selectors, check if classList includes the name',
    ],
    tags: ['DOM', 'events', 'delegation', 'selector'],
  },

  {
    id: 'fe-js-pointer-event',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'easy',
    title: 'Pointer Event Position',
    text: 'Write a relativePos(evt, off) function that calculates a pointer position relative to a container. Subtract the container offset (left, top) from the event coordinates (clientX, clientY) and return {x, y}.',
    setup: 'A pointer event object and container offset object.',
    setupCode: `// Pointer event with client coordinates\nconst event = { clientX: 150, clientY: 200 };\n// Container offset from viewport\nconst offset = { left: 50, top: 30 };`,
    expected: { x: 100, y: 170 },
    sample: `function relativePos(evt, off) {\n  return { x: evt.clientX - off.left, y: evt.clientY - off.top };\n}\nrelativePos(event, offset)`,
    hints: ['x = clientX - left', 'y = clientY - top', 'Return an object with x and y properties'],
    tags: ['DOM', 'events', 'pointer', 'position'],
  },

  {
    id: 'fe-js-focus-trap',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'Focus Trap Cycle',
    text: 'Write a focusNext(items, currentIdx) function that returns the next item in a circular list (wrapping from end to start). Call it with index 2 (the last element) so it wraps to index 0.',
    setup: 'An array of focusable element ids.',
    setupCode: `// Focusable element ids in tab order\nconst focusable = ["input-name", "input-email", "btn-submit"];`,
    expected: 'input-name',
    sample: `function focusNext(items, currentIdx) {\n  return items[(currentIdx + 1) % items.length];\n}\nfocusNext(focusable, 2)`,
    hints: [
      'Use modulo (%) to wrap around the array length',
      'Index 2 + 1 = 3, and 3 % 3 = 0',
      'The modulo operator handles the circular wrap',
    ],
    tags: ['DOM', 'focus', 'accessibility', 'trap'],
  },

  {
    id: 'fe-js-scroll-position',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'Scroll Progress Percentage',
    text: 'Write a scrollProgress(top, total, visible) function that calculates scroll progress as a percentage (0-100), rounded to the nearest integer. The maximum scrollable distance is total - visible.',
    setup: 'Scroll dimension values.',
    setupCode: `// scrollTop = how far scrolled, scrollHeight = total content, clientHeight = visible area\nconst scrollTop = 250;\nconst scrollHeight = 1000;\nconst clientHeight = 500;`,
    expected: 50,
    sample: `function scrollProgress(top, total, visible) {\n  return Math.round((top / (total - visible)) * 100);\n}\nscrollProgress(scrollTop, scrollHeight, clientHeight)`,
    hints: [
      'Maximum scroll distance is scrollHeight - clientHeight',
      'Progress = scrollTop / maxScroll * 100',
      'Use Math.round to get an integer',
    ],
    tags: ['DOM', 'scroll', 'position', 'percentage'],
  },

  {
    id: 'fe-js-mutation-observer-sim',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'hard',
    title: 'MutationObserver Simulation',
    text: 'Implement a createObserver() function that returns {observe, mutations}. observe(target) should return a Proxy that intercepts property sets, recording {type:"attribute", property, oldValue, newValue} into the mutations array. Then observe an object, make two property changes, and return the mutations.',
    setup: 'No setup needed - implement everything.',
    setupCode: `// Implement createObserver using Proxy to track property changes`,
    expected: [
      { type: 'attribute', property: 'name', oldValue: 'Alice', newValue: 'Bob' },
      { type: 'attribute', property: 'age', oldValue: 30, newValue: 31 },
    ],
    sample: `function createObserver() {\n  const mutations = [];\n  function observe(target) {\n    return new Proxy(target, {\n      set(obj, prop, value) {\n        mutations.push({ type: "attribute", property: prop, oldValue: obj[prop], newValue: value });\n        obj[prop] = value;\n        return true;\n      }\n    });\n  }\n  return { observe, mutations };\n}\nconst obs = createObserver();\nconst watched = obs.observe({ name: "Alice", age: 30 });\nwatched.name = "Bob";\nwatched.age = 31;\nobs.mutations`,
    hints: [
      'Use Proxy with a set trap to intercept assignments',
      'Record obj[prop] as oldValue before updating',
      'Store mutations in an array shared via closure',
    ],
    tags: ['DOM', 'MutationObserver', 'Proxy', 'reactive'],
  },

  {
    id: 'fe-js-intersection-observer-sim',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'hard',
    title: 'IntersectionObserver Simulation',
    text: 'Write a checkIntersections(els, vTop, vBottom) function that determines which elements are visible. For each element, check if its top position falls within the viewport range [vTop, vBottom]. Return an array of {id, isIntersecting} objects.',
    setup: 'Elements with top positions and viewport bounds.',
    setupCode: `// Elements with their top positions\nconst elements = [\n  { id: "a", top: 50 },\n  { id: "b", top: 300 },\n  { id: "c", top: 600 },\n  { id: "d", top: 900 }\n];\n// Viewport range\nconst viewTop = 100;\nconst viewBottom = 700;`,
    expected: [
      { id: 'a', isIntersecting: false },
      { id: 'b', isIntersecting: true },
      { id: 'c', isIntersecting: true },
      { id: 'd', isIntersecting: false },
    ],
    sample: `function checkIntersections(els, vTop, vBottom) {\n  return els.map(el => ({\n    id: el.id,\n    isIntersecting: el.top >= vTop && el.top <= vBottom\n  }));\n}\ncheckIntersections(elements, viewTop, viewBottom)`,
    hints: [
      'Map each element to an entry object',
      'Check if top >= vTop && top <= vBottom',
      'isIntersecting is a boolean',
    ],
    tags: ['DOM', 'IntersectionObserver', 'viewport', 'visibility'],
  },

  {
    id: 'fe-js-resize-observer-sim',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'ResizeObserver Simulation',
    text: 'Write a resize(element, w, h) function that updates an element\'s width and height, and pushes a resize entry recording the old and new sizes as "WxH" strings. Call it twice and return the entries array.',
    setup: 'An element object with width/height and an entries array to collect results.',
    setupCode: `// Entries array to collect resize records\nconst entries = [];\n// Element with current dimensions\nconst el = { width: 100, height: 50 };`,
    expected: [
      { target: '200x100', previousSize: '100x50' },
      { target: '300x150', previousSize: '200x100' },
    ],
    sample: `function resize(element, w, h) {\n  const old = { width: element.width, height: element.height };\n  element.width = w;\n  element.height = h;\n  entries.push({ target: element.width + "x" + element.height, previousSize: old.width + "x" + old.height });\n}\nresize(el, 200, 100);\nresize(el, 300, 150);\nentries`,
    hints: [
      'Save old dimensions before overwriting',
      'Format sizes as "WxH" strings',
      'Push an entry with target (new) and previousSize (old)',
    ],
    tags: ['DOM', 'ResizeObserver', 'dimensions'],
  },

  {
    id: 'fe-js-custom-dispatch',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'medium',
    title: 'Custom Event Dispatch',
    text: 'Build a custom event system with on(element, type, cb) and dispatch(element, type, detail). on registers a callback for an event type. dispatch calls all listeners with an event object {type, detail} and returns their results. Register two "custom" listeners, then dispatch with {value:10}.',
    setup: 'An element object with a listeners map.',
    setupCode: `// Element with empty listeners map\nconst el = { listeners: {} };`,
    expected: [20, 20],
    sample: `function on(element, type, cb) {\n  if (!element.listeners[type]) element.listeners[type] = [];\n  element.listeners[type].push(cb);\n}\nfunction dispatch(element, type, detail) {\n  return (element.listeners[type] || []).map(cb => cb({ type, detail }));\n}\non(el, "custom", e => e.detail.value * 2);\non(el, "custom", e => e.detail.value + 10);\ndispatch(el, "custom", { value: 10 })`,
    hints: [
      'Store listeners in arrays keyed by event type',
      'dispatch passes {type, detail} to each callback',
      'Return the array of callback results',
    ],
    tags: ['DOM', 'events', 'custom', 'dispatch'],
  },

  {
    id: 'fe-js-dom-traverse-depth',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'hard',
    title: 'Depth-First DOM Traversal',
    text: 'Write a dfs(node) function that performs a depth-first traversal of a node tree and returns an array of all tag names in visit order. Each node has a tag string and a children array.',
    setup: 'A tree of node objects with tag and children.',
    setupCode: `// Tree: div > [h1, ul > [li, li > [a]]]\nconst tree = {\n  tag: "div",\n  children: [\n    { tag: "h1", children: [] },\n    { tag: "ul", children: [\n      { tag: "li", children: [] },\n      { tag: "li", children: [{ tag: "a", children: [] }] }\n    ]}\n  ]\n};`,
    expected: ['div', 'h1', 'ul', 'li', 'li', 'a'],
    sample: `function dfs(node) {\n  const result = [node.tag];\n  for (const child of node.children) {\n    result.push(...dfs(child));\n  }\n  return result;\n}\ndfs(tree)`,
    hints: [
      'Start with the current node tag in the result',
      'Recursively call dfs on each child',
      'Spread child results into the parent array',
    ],
    tags: ['DOM', 'traversal', 'DFS', 'tree'],
  },

  {
    id: 'fe-js-attr-dataset',
    framework: 'native-js',
    category: 'DOM & Events',
    difficulty: 'easy',
    title: 'Dataset Attribute Access',
    text: "Write an extractData(element) function that reads the userId and role properties from an element's dataset object and returns them as {userId, role}.",
    setup: 'An element with dataset properties.',
    setupCode: `// Element with dataset (simulates data-user-id and data-role attributes)\nconst el = { dataset: { userId: "42", role: "admin" } };`,
    expected: { userId: '42', role: 'admin' },
    sample: `function extractData(element) {\n  return { userId: element.dataset.userId, role: element.dataset.role };\n}\nextractData(el)`,
    hints: [
      'Access element.dataset to get data attributes',
      'data-user-id is camelCased as dataset.userId',
      'Return a plain object with the extracted values',
    ],
    tags: ['DOM', 'dataset', 'attributes'],
  },

  // ─── NEW State & Lifecycle (17) ──────────────────────────────

  {
    id: 'fe-js-simple-store',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'easy',
    title: 'Simple State Store',
    text: 'Write a createStore(initial) function that returns an object with getState() and setState(update) methods. setState merges the update into the current state using spread. Create a store, make two updates, and return the final state.',
    setup: 'No setup needed.',
    setupCode: `// Implement createStore with getState and setState`,
    expected: { count: 5, name: 'updated' },
    sample: `function createStore(initial) {\n  let state = { ...initial };\n  return {\n    getState() { return state; },\n    setState(update) { state = { ...state, ...update }; }\n  };\n}\nconst store = createStore({ count: 0, name: "test" });\nstore.setState({ count: 5 });\nstore.setState({ name: "updated" });\nstore.getState()`,
    hints: [
      'Use object spread to merge updates into state',
      'Store state in a closure variable',
      'getState returns the current state object',
    ],
    tags: ['state', 'store', 'closure'],
  },

  {
    id: 'fe-js-pub-sub',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'Pub/Sub System',
    text: 'Write a createPubSub() function returning {subscribe(topic, cb), publish(topic, data)}. subscribe stores callbacks by topic and returns an unsubscribe function. publish calls all callbacks for that topic. Subscribe two listeners to "msg", publish "hello", unsubscribe the second, then publish "world". Return the collected results.',
    setup: 'A results array to collect messages.',
    setupCode: `// Collect published messages here\nconst results = [];`,
    expected: ['A:hello', 'B:hello', 'A:world'],
    sample: `function createPubSub() {\n  const subs = {};\n  return {\n    subscribe(topic, cb) {\n      if (!subs[topic]) subs[topic] = [];\n      subs[topic].push(cb);\n      return () => { subs[topic] = subs[topic].filter(fn => fn !== cb); };\n    },\n    publish(topic, data) {\n      return (subs[topic] || []).map(cb => cb(data));\n    }\n  };\n}\nconst ps = createPubSub();\nps.subscribe("msg", d => results.push("A:" + d));\nconst unsub = ps.subscribe("msg", d => results.push("B:" + d));\nps.publish("msg", "hello");\nunsub();\nps.publish("msg", "world");\nresults`,
    hints: [
      'Store subscribers in an object keyed by topic',
      'subscribe returns a function that filters out the callback',
      'publish maps over all subscribers for the given topic',
    ],
    tags: ['state', 'pubsub', 'pattern'],
  },

  {
    id: 'fe-js-observable-state',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'Observable State',
    text: 'Write an observable(initial) function returning {get(), set(v), subscribe(fn)}. When set is called, update the value and notify all subscribers with the new value. Subscribe a logger, set values 1, 2, 3, and return the log.',
    setup: 'A log array to collect notifications.',
    setupCode: `// Collect subscriber notifications here\nconst log = [];`,
    expected: [1, 2, 3],
    sample: `function observable(initial) {\n  let value = initial;\n  const listeners = [];\n  return {\n    get() { return value; },\n    set(v) { value = v; listeners.forEach(fn => fn(v)); },\n    subscribe(fn) { listeners.push(fn); }\n  };\n}\nconst obs = observable(0);\nobs.subscribe(v => log.push(v));\nobs.set(1);\nobs.set(2);\nobs.set(3);\nlog`,
    hints: [
      'Store the value and listeners array in a closure',
      'set updates the value then calls each listener',
      'subscribe adds a function to the listeners array',
    ],
    tags: ['state', 'observable', 'reactive'],
  },

  {
    id: 'fe-js-state-machine-traffic',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'Traffic Light State Machine',
    text: 'Write a createMachine(initial, transitions) function returning {getState(), transition()}. The transitions object maps each state to its next state. transition() updates the current state. Create a traffic light (green->yellow->red->green), run 4 transitions, and return the final state.',
    setup: 'No setup needed.',
    setupCode: `// Implement createMachine and use it for a traffic light`,
    expected: 'yellow',
    sample: `function createMachine(initial, transitions) {\n  let state = initial;\n  return {\n    getState() { return state; },\n    transition() {\n      state = transitions[state] || state;\n      return state;\n    }\n  };\n}\nconst light = createMachine("green", { green: "yellow", yellow: "red", red: "green" });\nlight.transition();\nlight.transition();\nlight.transition();\nlight.transition();\nlight.getState()`,
    hints: [
      'transitions is a lookup object: transitions[currentState] gives the next state',
      'Store the current state in a closure variable',
      'After 4 transitions from green: yellow, red, green, yellow',
    ],
    tags: ['state', 'state-machine', 'transitions'],
  },

  {
    id: 'fe-js-proxy-reactive',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'hard',
    title: 'Proxy-Based Reactivity',
    text: 'Write a reactive(target) function that returns {proxy, log}. The proxy uses get/set traps to log all property reads as {op:"get", prop, value} and writes as {op:"set", prop, value}. Create a reactive object, read x, set x to 10, read x again, and return the log.',
    setup: 'No setup needed.',
    setupCode: `// Implement reactive() using Proxy with get and set traps`,
    expected: [
      { op: 'get', prop: 'x', value: 1 },
      { op: 'set', prop: 'x', value: 10 },
      { op: 'get', prop: 'x', value: 10 },
    ],
    sample: `function reactive(target) {\n  const log = [];\n  const proxy = new Proxy(target, {\n    get(obj, prop) {\n      log.push({ op: "get", prop, value: obj[prop] });\n      return obj[prop];\n    },\n    set(obj, prop, value) {\n      log.push({ op: "set", prop, value });\n      obj[prop] = value;\n      return true;\n    }\n  });\n  return { proxy, log };\n}\nconst { proxy, log } = reactive({ x: 1 });\nconst val = proxy.x;\nproxy.x = 10;\nconst val2 = proxy.x;\nlog`,
    hints: [
      'Proxy get trap: log the read, then return the value',
      'Proxy set trap: log the write, update the property, return true',
      'The log captures operations in order',
    ],
    tags: ['state', 'Proxy', 'reactive', 'logging'],
  },

  {
    id: 'fe-js-lifecycle-hooks',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'Component Lifecycle Hooks',
    text: 'Write a createComponent() function that returns {log, onMount(), onUpdate(data), onDestroy(), run()}. Each hook pushes to the log array ("mounted", "updated:"+data, "destroyed"). run() calls onMount, onUpdate("A"), onUpdate("B"), onDestroy in order. Create and run the component, then return the log.',
    setup: 'No setup needed.',
    setupCode: `// Implement createComponent with lifecycle hooks`,
    expected: ['mounted', 'updated:A', 'updated:B', 'destroyed'],
    sample: `function createComponent() {\n  const log = [];\n  return {\n    log,\n    onMount() { log.push("mounted"); },\n    onUpdate(data) { log.push("updated:" + data); },\n    onDestroy() { log.push("destroyed"); },\n    run() {\n      this.onMount();\n      this.onUpdate("A");\n      this.onUpdate("B");\n      this.onDestroy();\n    }\n  };\n}\nconst comp = createComponent();\ncomp.run();\ncomp.log`,
    hints: [
      'Each hook method pushes a descriptive string to the log',
      'run() calls hooks in lifecycle order: mount, updates, destroy',
      'Use this.onMount() etc. inside run to call the methods',
    ],
    tags: ['state', 'lifecycle', 'hooks', 'component'],
  },

  {
    id: 'fe-js-cleanup-pattern',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'easy',
    title: 'Cleanup Function Pattern',
    text: 'Write a setup(name) function that pushes the name onto the resources array and returns a cleanup function that removes it. Call setup for "timer" and "listener", then run the cleanup for "timer". Return resources.',
    setup: 'A shared resources array.',
    setupCode: `// Shared resources array\nconst resources = [];`,
    expected: ['listener'],
    sample: `function setup(name) {\n  resources.push(name);\n  return () => {\n    const idx = resources.indexOf(name);\n    if (idx >= 0) resources.splice(idx, 1);\n  };\n}\nconst cleanupA = setup("timer");\nsetup("listener");\ncleanupA();\nresources`,
    hints: [
      'setup pushes the name and returns a removal function',
      'The cleanup function uses indexOf + splice to remove',
      'The closure captures the name so cleanup knows what to remove',
    ],
    tags: ['state', 'cleanup', 'closure'],
  },

  {
    id: 'fe-js-error-boundary',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'Error Boundary Pattern',
    text: 'Write an errorBoundary() function returning {results, errors, run(fn)}. run() calls fn() inside try/catch: push return values to results, error messages to errors. Run three functions (one throws), then return {results, errors}.',
    setup: 'No setup needed.',
    setupCode: `// Implement errorBoundary with try/catch isolation`,
    expected: { results: [42, 99], errors: ['fail'] },
    sample: `function errorBoundary() {\n  const results = [];\n  const errors = [];\n  return {\n    results,\n    errors,\n    run(fn) {\n      try {\n        results.push(fn());\n      } catch (e) {\n        errors.push(e.message || String(e));\n      }\n    }\n  };\n}\nconst eb = errorBoundary();\neb.run(() => 42);\neb.run(() => { throw new Error("fail"); });\neb.run(() => 99);\n({ results: eb.results, errors: eb.errors })`,
    hints: [
      'Wrap fn() in try/catch inside run()',
      'On success push to results, on error push e.message to errors',
      'Each run is independent - errors in one do not affect others',
    ],
    tags: ['state', 'error-boundary', 'try-catch'],
  },

  {
    id: 'fe-js-reducer-pattern',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'Reducer Pattern',
    text: 'Write a reducer(state, action) function that handles ADD (appends payload to array) and REMOVE (filters out payload) actions, returning a new array each time. Start with ["apple"], dispatch ADD "banana", ADD "cherry", REMOVE "apple", and return the final state.',
    setup: 'No setup needed.',
    setupCode: `// Implement the reducer and dispatch actions`,
    expected: ['banana', 'cherry'],
    sample: `function reducer(state, action) {\n  switch (action.type) {\n    case "ADD": return [...state, action.payload];\n    case "REMOVE": return state.filter(x => x !== action.payload);\n    default: return state;\n  }\n}\nlet state = ["apple"];\nstate = reducer(state, { type: "ADD", payload: "banana" });\nstate = reducer(state, { type: "ADD", payload: "cherry" });\nstate = reducer(state, { type: "REMOVE", payload: "apple" });\nstate`,
    hints: [
      'Use switch on action.type for different cases',
      'ADD: spread existing state and append payload',
      'REMOVE: filter out items matching payload (never mutate)',
    ],
    tags: ['state', 'reducer', 'redux', 'immutable'],
  },

  {
    id: 'fe-js-computed-state',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'Computed/Derived State',
    text: 'Write a computed(stateFn) function that returns an object with a value getter that lazily calls stateFn() each time. Use it to derive fullName from a state object. Return fullName.value.',
    setup: 'A state object with firstName and lastName.',
    setupCode: `// State to derive from\nconst state = { firstName: "John", lastName: "Doe" };`,
    expected: 'John Doe',
    sample: `function computed(stateFn) {\n  return { get value() { return stateFn(); } };\n}\nconst fullName = computed(() => state.firstName + " " + state.lastName);\nfullName.value`,
    hints: [
      'Use a getter (get value()) to compute on access',
      'The stateFn captures state via closure',
      'Concatenate firstName and lastName with a space',
    ],
    tags: ['state', 'computed', 'derived', 'getter'],
  },

  {
    id: 'fe-js-undo-redo',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'hard',
    title: 'Undo/Redo State History',
    text: 'Write a createHistory(initial) function returning {getCurrent(), push(val), undo(), redo()}. Maintain past and future stacks. push clears future. undo moves current to future and pops past. redo reverses. Push A->B->C->D, undo twice, redo once. Return current state.',
    setup: 'No setup needed.',
    setupCode: `// Implement undo/redo history manager`,
    expected: 'C',
    sample: `function createHistory(initial) {\n  const past = [];\n  const future = [];\n  let current = initial;\n  return {\n    getCurrent() { return current; },\n    push(val) { past.push(current); current = val; future.length = 0; },\n    undo() { if (past.length) { future.push(current); current = past.pop(); } },\n    redo() { if (future.length) { past.push(current); current = future.pop(); } }\n  };\n}\nconst h = createHistory("A");\nh.push("B");\nh.push("C");\nh.push("D");\nh.undo();\nh.undo();\nh.redo();\nh.getCurrent()`,
    hints: [
      'Use two arrays: past and future as stacks',
      'undo: push current to future, pop past to current',
      'redo: push current to past, pop future to current',
    ],
    tags: ['state', 'undo', 'redo', 'history'],
  },

  {
    id: 'fe-js-middleware-chain',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'hard',
    title: 'Middleware Chain for State',
    text: 'Write a createStoreWithMiddleware(reducer, initial, middlewares) function. dispatch() passes the action through each middleware (which can transform it) before applying the reducer. Create a store with a logger middleware (logs action.type) and a doubler middleware (doubles ADD payload). Dispatch two ADD actions and return {state, log}.',
    setup: 'No setup needed.',
    setupCode: `// Implement middleware-enhanced store, logger, and doubler middlewares`,
    expected: { state: 16, log: ['ADD', 'ADD'] },
    sample: `function createStoreWithMiddleware(reducer, initial, middlewares) {\n  let state = initial;\n  const log = [];\n  function dispatch(action) {\n    let act = action;\n    for (const mw of middlewares) {\n      act = mw(act, log);\n    }\n    state = reducer(state, act);\n  }\n  return { getState: () => state, dispatch, log };\n}\nconst logger = (action, log) => { log.push(action.type); return action; };\nconst doubler = (action, log) => {\n  if (action.type === "ADD") return { ...action, payload: action.payload * 2 };\n  return action;\n};\nconst store = createStoreWithMiddleware(\n  (state, action) => action.type === "ADD" ? state + action.payload : state,\n  0,\n  [logger, doubler]\n);\nstore.dispatch({ type: "ADD", payload: 5 });\nstore.dispatch({ type: "ADD", payload: 3 });\n({ state: store.getState(), log: store.log })`,
    hints: [
      'Each middleware is a function (action, log) => transformedAction',
      'Loop through middlewares, passing the action through each in sequence',
      'The final transformed action goes to the reducer',
    ],
    tags: ['state', 'middleware', 'redux', 'chain'],
  },

  {
    id: 'fe-js-effect-scheduler',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'easy',
    title: 'Effect Scheduler',
    text: 'Write a createScheduler() function returning {schedule(fn), flush(), log}. schedule queues a function. flush runs all queued functions in FIFO order, pushing each return value to the log. Schedule three effects and flush them. Return the log.',
    setup: 'No setup needed.',
    setupCode: `// Implement the effect scheduler`,
    expected: ['effect1', 'effect2', 'effect3'],
    sample: `function createScheduler() {\n  const queue = [];\n  const log = [];\n  return {\n    schedule(fn) { queue.push(fn); },\n    flush() { while (queue.length) { const fn = queue.shift(); log.push(fn()); } },\n    log\n  };\n}\nconst sched = createScheduler();\nsched.schedule(() => "effect1");\nsched.schedule(() => "effect2");\nsched.schedule(() => "effect3");\nsched.flush();\nsched.log`,
    hints: [
      'schedule pushes functions into a queue array',
      'flush shifts from the queue and calls each function',
      'Push each function return value into the log',
    ],
    tags: ['state', 'effects', 'scheduler', 'queue'],
  },

  {
    id: 'fe-js-selector-pattern',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'easy',
    title: 'State Selector Pattern',
    text: 'Given a nested state object, create selector functions that extract specific slices. Return the selected values.',
    setup: 'A nested state and selector functions.',
    setupCode: `const state = {\n  user: { name: "Alice", age: 30 },\n  settings: { theme: "dark", lang: "en" }\n};\nconst selectUserName = s => s.user.name;\nconst selectTheme = s => s.settings.theme;`,
    expected: { name: 'Alice', theme: 'dark' },
    sample: '({ name: selectUserName(state), theme: selectTheme(state) })',
    hints: [
      'Selectors are functions that extract state slices',
      'Access nested properties with dot notation',
    ],
    tags: ['state', 'selector', 'pattern'],
  },

  {
    id: 'fe-js-batch-updates',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'Batch State Updates',
    text: 'Write a createBatchStore(initial) with getState(), setState(update), batch(fn), and getNotifyCount(). Outside a batch, each setState increments the notify count. Inside a batch, only one notification fires after the batch completes. Make one standalone setState, then batch three setStates. Return the notify count.',
    setup: 'No setup needed.',
    setupCode: `// Implement a batching store that coalesces notifications`,
    expected: 2,
    sample: `function createBatchStore(initial) {\n  let state = { ...initial };\n  let notifyCount = 0;\n  let batching = false;\n  let pending = false;\n  return {\n    getState() { return state; },\n    getNotifyCount() { return notifyCount; },\n    setState(update) {\n      state = { ...state, ...update };\n      if (batching) { pending = true; }\n      else { notifyCount++; }\n    },\n    batch(fn) {\n      batching = true;\n      pending = false;\n      fn();\n      batching = false;\n      if (pending) notifyCount++;\n    }\n  };\n}\nconst s = createBatchStore({ a: 1, b: 2 });\ns.setState({ a: 10 });\ns.batch(() => {\n  s.setState({ a: 20 });\n  s.setState({ b: 30 });\n  s.setState({ a: 40 });\n});\ns.getNotifyCount()`,
    hints: [
      'Use a batching flag to suppress individual notifications',
      'Track whether any setState was called during the batch with a pending flag',
      'After the batch callback, fire one notification if pending is true',
    ],
    tags: ['state', 'batch', 'performance'],
  },

  {
    id: 'fe-js-context-provider',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'medium',
    title: 'Context Provider Pattern',
    text: 'Write a createContext(defaultValue) function returning {provide(value, fn), consume()}. provide pushes a value onto a stack, runs fn, then pops. consume returns the top of the stack. Test with nested provides and return the consumed values.',
    setup: 'No setup needed.',
    setupCode: `// Implement a stack-based context provider`,
    expected: { r1: 'default', r2: ['outer', 'inner'] },
    sample: `function createContext(defaultValue) {\n  const stack = [defaultValue];\n  return {\n    provide(value, fn) {\n      stack.push(value);\n      const result = fn();\n      stack.pop();\n      return result;\n    },\n    consume() { return stack[stack.length - 1]; }\n  };\n}\nconst ctx = createContext("default");\nconst r1 = ctx.consume();\nconst r2 = ctx.provide("outer", () => {\n  const inner = ctx.provide("inner", () => ctx.consume());\n  return [ctx.consume(), inner];\n});\n({ r1, r2 })`,
    hints: [
      'Use an array as a stack, initialized with defaultValue',
      'provide pushes, runs callback, then pops',
      'consume reads the top of the stack (last element)',
    ],
    tags: ['state', 'context', 'provider', 'pattern'],
  },

  {
    id: 'fe-js-signal-basic',
    framework: 'native-js',
    category: 'State & Lifecycle',
    difficulty: 'easy',
    title: 'Basic Signal Pattern',
    text: 'Write a createSignal(initial) function that returns an object with get() and set(v) methods using a closure. Create a signal starting at 0, set it to 1, 2, then 5, and return the final value via get().',
    setup: 'No setup needed.',
    setupCode: `// Implement createSignal with get/set closure`,
    expected: 5,
    sample: `function createSignal(initial) {\n  let value = initial;\n  return {\n    get() { return value; },\n    set(v) { value = v; }\n  };\n}\nconst count = createSignal(0);\ncount.set(1);\ncount.set(2);\ncount.set(5);\ncount.get()`,
    hints: [
      'Store the value in a closure variable',
      'get() returns the current value',
      'set(v) updates the closure variable',
    ],
    tags: ['state', 'signal', 'reactive'],
  },

  // ─── NEW Common Patterns (17) ────────────────────────────────

  {
    id: 'fe-js-memoize-basic',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Memoization',
    text: 'Write a memoize(fn) function that returns a new function caching results by the first argument using a Map. Create a memoized square function that increments callCount. Call it with 4, 4, 5, 4 (cache hits skip the real function). Return {result: memoized(5), calls: callCount}.',
    setup: 'A call counter.',
    setupCode: `// Tracks how many times the real function runs\nlet callCount = 0;`,
    expected: { result: 25, calls: 2 },
    sample: `function memoize(fn) {\n  const cache = new Map();\n  return function(arg) {\n    if (cache.has(arg)) return cache.get(arg);\n    const result = fn(arg);\n    cache.set(arg, result);\n    return result;\n  };\n}\nconst expensive = memoize(n => { callCount++; return n * n; });\nexpensive(4);\nexpensive(4);\nexpensive(5);\nexpensive(4);\n({ result: expensive(5), calls: callCount })`,
    hints: [
      'Use a Map to store argument->result pairs',
      'Check cache.has(arg) before calling fn',
      'Only two unique arguments (4 and 5) means only 2 real calls',
    ],
    tags: ['memoization', 'cache', 'performance'],
  },

  {
    id: 'fe-js-curry',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Currying',
    text: 'Implement a curry function that transforms a function taking 3 arguments into a chain of single-argument functions. Return the result.',
    setup: 'A curry utility.',
    setupCode: `function curry(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return fn(a, b, c);\n      };\n    };\n  };\n}\nconst add3 = curry((a, b, c) => a + b + c);`,
    expected: 15,
    sample: 'add3(3)(5)(7)',
    hints: [
      'Return nested functions, each taking one argument',
      'Call original function when all arguments collected',
    ],
    tags: ['curry', 'functional', 'closures'],
  },

  {
    id: 'fe-js-partial-application',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'easy',
    title: 'Partial Application',
    text: 'Implement a partial function that pre-fills some arguments. Return the result of calling the partially applied function.',
    setup: 'A partial application utility.',
    setupCode: `function partial(fn, ...preArgs) {\n  return function(...laterArgs) {\n    return fn(...preArgs, ...laterArgs);\n  };\n}\nconst multiply = (a, b, c) => a * b * c;\nconst double = partial(multiply, 2);`,
    expected: 30,
    sample: 'double(3, 5)',
    hints: [
      'Spread pre-filled args before later args',
      'Return a new function that combines both arg sets',
    ],
    tags: ['partial', 'functional', 'closures'],
  },

  {
    id: 'fe-js-pipe',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'easy',
    title: 'Pipe Function',
    text: 'Implement a pipe function that composes functions left to right. Pass a value through the pipeline and return the result.',
    setup: 'A pipe utility.',
    setupCode: `function pipe(...fns) {\n  return (x) => fns.reduce((acc, fn) => fn(acc), x);\n}\nconst transform = pipe(\n  x => x + 1,\n  x => x * 2,\n  x => x - 3\n);`,
    expected: 7,
    sample: 'transform(4)',
    hints: ['Use reduce to chain function calls', 'Start with x, pass result to next function'],
    tags: ['pipe', 'compose', 'functional'],
  },

  {
    id: 'fe-js-compose',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'easy',
    title: 'Compose Function',
    text: 'Implement a compose function that composes functions right to left (opposite of pipe). Return the result.',
    setup: 'A compose utility.',
    setupCode: `function compose(...fns) {\n  return (x) => fns.reduceRight((acc, fn) => fn(acc), x);\n}\nconst transform = compose(\n  x => x - 3,\n  x => x * 2,\n  x => x + 1\n);`,
    expected: 7,
    sample: 'transform(4)',
    hints: ['Use reduceRight to chain from right to left', 'Same as pipe but reversed order'],
    tags: ['compose', 'functional'],
  },

  {
    id: 'fe-js-mediator',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Mediator Pattern',
    text: 'Write a createMediator() function returning {register(name, handler), send(from, to, data), log}. register stores a handler by name. send logs {from, to, data} and calls the target handler. Register two components, send two messages, and return the log.',
    setup: 'No setup needed.',
    setupCode: `// Implement the mediator pattern`,
    expected: [
      { from: 'chatA', to: 'chatB', data: 'hello' },
      { from: 'chatB', to: 'chatA', data: 'hi back' },
    ],
    sample: `function createMediator() {\n  const components = {};\n  const log = [];\n  return {\n    register(name, handler) { components[name] = handler; },\n    send(from, to, data) {\n      log.push({ from, to, data });\n      if (components[to]) components[to](data, from);\n    },\n    log\n  };\n}\nconst med = createMediator();\nmed.register("chatA", (data, from) => {});\nmed.register("chatB", (data, from) => {});\nmed.send("chatA", "chatB", "hello");\nmed.send("chatB", "chatA", "hi back");\nmed.log`,
    hints: [
      'Store component handlers in an object keyed by name',
      'send logs the message then calls the target handler if registered',
      'The log captures all messages passing through the mediator',
    ],
    tags: ['mediator', 'pattern', 'communication'],
  },

  {
    id: 'fe-js-command-pattern',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Command Pattern',
    text: 'Write a createCommandExecutor(initial) returning {execute(cmd), undo(), getValue()}. Commands have execute(v) and undo(v) functions. execute runs the command and saves undo info. undo reverses the last command. Start at 10, execute +5 then *2, undo the last, and return the value.',
    setup: 'No setup needed.',
    setupCode: `// Implement the command executor pattern`,
    expected: 15,
    sample: `function createCommandExecutor(initial) {\n  let value = initial;\n  const history = [];\n  return {\n    execute(cmd) {\n      history.push({ undo: () => { value = cmd.undo(value); } });\n      value = cmd.execute(value);\n    },\n    undo() {\n      const last = history.pop();\n      if (last) last.undo();\n    },\n    getValue() { return value; }\n  };\n}\nconst exec = createCommandExecutor(10);\nexec.execute({ execute: v => v + 5, undo: v => v - 5 });\nexec.execute({ execute: v => v * 2, undo: v => v / 2 });\nexec.undo();\nexec.getValue()`,
    hints: [
      'Push undo closures onto a history stack before executing',
      'Each command object has execute(v) => newV and undo(v) => oldV',
      'undo pops from history and calls the saved undo function',
    ],
    tags: ['command', 'pattern', 'undo'],
  },

  {
    id: 'fe-js-iterator-range',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Custom Iterator: Range',
    text: 'Implement a range iterator that yields numbers from start to end (exclusive). Use Symbol.iterator protocol. Spread it into an array.',
    setup: 'A range iterable object.',
    setupCode: `function range(start, end) {\n  return {\n    [Symbol.iterator]() {\n      let current = start;\n      return {\n        next() {\n          if (current < end) return { value: current++, done: false };\n          return { done: true };\n        }\n      };\n    }\n  };\n}`,
    expected: [2, 3, 4, 5, 6],
    sample: '[...range(2, 7)]',
    hints: ['Implement Symbol.iterator method', 'Return object with next() method'],
    tags: ['iterator', 'Symbol.iterator', 'protocol'],
  },

  {
    id: 'fe-js-generator-fibonacci',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Generator: Fibonacci',
    text: 'Write a fibonacci() generator function that yields the Fibonacci sequence (0, 1, 1, 2, 3, 5, ...) infinitely. Then collect the first 8 values into an array and return it.',
    setup: 'No setup needed.',
    setupCode: `// Implement fibonacci generator and collect first 8 values`,
    expected: [0, 1, 1, 2, 3, 5, 8, 13],
    sample: `function* fibonacci() {\n  let a = 0, b = 1;\n  while (true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}\nconst fib = fibonacci();\nconst result = [];\nfor (let i = 0; i < 8; i++) result.push(fib.next().value);\nresult`,
    hints: [
      'Use function* and yield to produce values lazily',
      'Track two variables a and b, yield a, then advance both',
      'Use destructuring [a, b] = [b, a + b] to swap',
    ],
    tags: ['generator', 'fibonacci', 'yield'],
  },

  {
    id: 'fe-js-singleton',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'easy',
    title: 'Singleton Pattern',
    text: 'Write a self-invoking function that returns a factory. The factory creates an object on first call and caches it, returning the same instance on every subsequent call. Call it twice and verify both references are identical (===).',
    setup: 'No setup needed.',
    setupCode: `// Implement a singleton factory using closure`,
    expected: true,
    sample: `const createSingleton = (() => {\n  let instance = null;\n  return () => {\n    if (!instance) instance = { id: 1, created: true };\n    return instance;\n  };\n})();\nconst a = createSingleton();\nconst b = createSingleton();\na === b`,
    hints: [
      'Use an IIFE to create a private closure',
      'Store instance in a variable captured by closure',
      'On first call create the object, on subsequent calls return the cached one',
    ],
    tags: ['singleton', 'pattern', 'closure'],
  },

  {
    id: 'fe-js-factory-pattern',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'easy',
    title: 'Factory Pattern',
    text: 'Write a createShape(type, params) factory function. For "circle", return {type, area} using Math.round(PI * r^2). For "rectangle", return {type, area: w * h}. Create a circle (r=5) and rectangle (w=4, h=6) and return them as an array.',
    setup: 'No setup needed.',
    setupCode: `// Implement createShape factory function`,
    expected: [
      { type: 'circle', area: 79 },
      { type: 'rectangle', area: 24 },
    ],
    sample: `function createShape(type, params) {\n  if (type === "circle") return { type, area: Math.round(Math.PI * params.r * params.r) };\n  if (type === "rectangle") return { type, area: params.w * params.h };\n  return { type: "unknown", area: 0 };\n}\nconst c = createShape("circle", { r: 5 });\nconst r = createShape("rectangle", { w: 4, h: 6 });\n[c, r]`,
    hints: [
      'Branch on the type string to decide which formula to use',
      'Circle area: Math.round(Math.PI * r * r)',
      'Rectangle area: w * h',
    ],
    tags: ['factory', 'pattern', 'objects'],
  },

  {
    id: 'fe-js-strategy-pattern',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Strategy Pattern',
    text: 'Implement a sorter that accepts different comparison strategies. Sort an array with ascending and descending strategies. Return both results.',
    setup: 'A strategy-based sorter.',
    setupCode: `const strategies = {\n  ascending: (a, b) => a - b,\n  descending: (a, b) => b - a\n};\nfunction sortWith(arr, strategyName) {\n  return [...arr].sort(strategies[strategyName]);\n}\nconst data = [3, 1, 4, 1, 5, 9];`,
    expected: { asc: [1, 1, 3, 4, 5, 9], desc: [9, 5, 4, 3, 1, 1] },
    sample: '({ asc: sortWith(data, "ascending"), desc: sortWith(data, "descending") })',
    hints: ['Store strategy functions in an object', 'Look up strategy by name and pass to sort'],
    tags: ['strategy', 'pattern', 'sort'],
  },

  {
    id: 'fe-js-decorator-pattern',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'medium',
    title: 'Decorator Pattern',
    text: 'Implement decorators that wrap a base function to add logging and timing metadata. Chain two decorators and return the enriched result.',
    setup: 'A decorator chain.',
    setupCode: `function withLogging(fn) {\n  return function(...args) {\n    const result = fn(...args);\n    return { ...result, logged: true };\n  };\n}\nfunction withTimestamp(fn) {\n  return function(...args) {\n    const result = fn(...args);\n    return { ...result, timestamp: 12345 };\n  };\n}\nconst base = (x) => ({ value: x * 2 });\nconst decorated = withTimestamp(withLogging(base));`,
    expected: { value: 10, logged: true, timestamp: 12345 },
    sample: 'decorated(5)',
    hints: [
      'Each decorator wraps the function and enriches the result',
      'Chain decorators by passing one into another',
    ],
    tags: ['decorator', 'pattern', 'wrapper'],
  },

  {
    id: 'fe-js-immutable-update',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'easy',
    title: 'Immutable Object Update',
    text: 'Update a nested object immutably: change user.address.city to "Seattle" without mutating the original. Return both the original city and the new city.',
    setup: 'A nested object to update immutably.',
    setupCode: `const original = { user: { name: "Alice", address: { city: "Portland", state: "OR" } } };\nconst updated = {\n  ...original,\n  user: {\n    ...original.user,\n    address: { ...original.user.address, city: "Seattle" }\n  }\n};`,
    expected: { originalCity: 'Portland', newCity: 'Seattle' },
    sample: '({ originalCity: original.user.address.city, newCity: updated.user.address.city })',
    hints: ['Spread at each level of nesting', 'Only override the property you want to change'],
    tags: ['immutable', 'spread', 'update'],
  },

  {
    id: 'fe-js-deep-clone',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'hard',
    title: 'Deep Clone',
    text: 'Implement a deepClone function that handles objects, arrays, and primitives. Clone a nested structure and verify independence.',
    setup: 'A deep clone utility.',
    setupCode: `function deepClone(obj) {\n  if (obj === null || typeof obj !== "object") return obj;\n  if (Array.isArray(obj)) return obj.map(item => deepClone(item));\n  const cloned = {};\n  for (const key of Object.keys(obj)) cloned[key] = deepClone(obj[key]);\n  return cloned;\n}\nconst src = { a: 1, b: [2, 3], c: { d: 4 } };\nconst copy = deepClone(src);\ncopy.b.push(99);\ncopy.c.d = 999;`,
    expected: { srcB: [2, 3], copyB: [2, 3, 99], srcD: 4, copyD: 999 },
    sample: '({ srcB: src.b, copyB: copy.b, srcD: src.c.d, copyD: copy.c.d })',
    hints: [
      'Handle primitives, arrays, and objects separately',
      'Recursively clone nested structures',
    ],
    tags: ['deepClone', 'recursive', 'immutable'],
  },

  {
    id: 'fe-js-event-emitter-once',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'hard',
    title: 'Event Emitter with Once',
    text: 'Write a createEmitter() returning {on(evt, fn), once(evt, fn), emit(evt, data)}. on adds a persistent listener. once adds a listener that auto-removes after one call. emit calls all listeners and removes once listeners. Add an on and a once listener for "data", emit "A" then "B", and return the log.',
    setup: 'A log array to collect results.',
    setupCode: `// Collect emitter output here\nconst log = [];`,
    expected: ['on:A', 'once:A', 'on:B'],
    sample: `function createEmitter() {\n  const events = {};\n  return {\n    on(evt, fn) {\n      if (!events[evt]) events[evt] = [];\n      events[evt].push({ fn, once: false });\n    },\n    once(evt, fn) {\n      if (!events[evt]) events[evt] = [];\n      events[evt].push({ fn, once: true });\n    },\n    emit(evt, data) {\n      if (!events[evt]) return [];\n      const results = events[evt].map(h => h.fn(data));\n      events[evt] = events[evt].filter(h => !h.once);\n      return results;\n    }\n  };\n}\nconst em = createEmitter();\nem.on("data", v => { log.push("on:" + v); });\nem.once("data", v => { log.push("once:" + v); });\nem.emit("data", "A");\nem.emit("data", "B");\nlog`,
    hints: [
      'Store listeners as {fn, once} objects in arrays by event name',
      'After calling all listeners during emit, filter out once:true entries',
      'on listeners stay, once listeners are removed after first emit',
    ],
    tags: ['emitter', 'once', 'pattern', 'events'],
  },

  {
    id: 'fe-js-lazy-eval',
    framework: 'native-js',
    category: 'Common Patterns',
    difficulty: 'hard',
    title: 'Lazy Evaluation',
    text: 'Write a lazy(fn) function that returns an object with a value getter. The getter calls fn() only on first access, caches the result, and returns the cached value on subsequent accesses. Access .value three times and return {value, count} to prove fn ran only once.',
    setup: 'A compute counter.',
    setupCode: `// Tracks how many times the computation runs\nlet computeCount = 0;`,
    expected: { value: 42, count: 1 },
    sample: `function lazy(fn) {\n  let computed = false;\n  let result;\n  return {\n    get value() {\n      if (!computed) {\n        result = fn();\n        computed = true;\n      }\n      return result;\n    }\n  };\n}\nconst val = lazy(() => { computeCount++; return 42; });\nconst a = val.value;\nconst b = val.value;\nconst c = val.value;\n({ value: val.value, count: computeCount })`,
    hints: [
      'Use a getter (get value()) for lazy access',
      'Track a "computed" flag and a "result" variable',
      'Only call fn() if not yet computed, then cache the result',
    ],
    tags: ['lazy', 'evaluation', 'getter', 'cache'],
  },

  // ─── NEW Rendering (17) ──────────────────────────────────────

  {
    id: 'fe-js-virtual-dom-diff',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'hard',
    title: 'Virtual DOM Diff',
    text: 'Compare oldTree and newTree objects and return an array of patch operations describing the differences.',
    setup: 'Two virtual DOM tree objects.',
    setupCode: `const oldTree = { tag: "div", props: { id: "root" }, children: [{ tag: "p", props: {}, children: ["Hello"] }] };\nconst newTree = { tag: "div", props: { id: "root" }, children: [{ tag: "p", props: {}, children: ["World"] }] };`,
    expected: [{ type: 'TEXT', path: [0, 0], oldVal: 'Hello', newVal: 'World' }],
    sample: `function diff(old, newN, path = []) {\n  if (typeof old === 'string' && typeof newN === 'string' && old !== newN) return [{ type: 'TEXT', path, oldVal: old, newVal: newN }];\n  if (!old || !newN) return [];\n  const patches = [];\n  const maxLen = Math.max((old.children||[]).length, (newN.children||[]).length);\n  for (let i = 0; i < maxLen; i++) patches.push(...diff((old.children||[])[i], (newN.children||[])[i], [...path, i]));\n  return patches;\n}\ndiff(oldTree, newTree)`,
    hints: ['Recursively compare children', 'Track path for patch location'],
    tags: ['virtual-DOM', 'diff', 'reconciliation'],
  },

  {
    id: 'fe-js-render-table',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'easy',
    title: 'Render HTML Table',
    text: 'Given headers and rows arrays, build an HTML table string.',
    setup: 'Headers and rows data.',
    setupCode: `const headers = ["Name", "Age"];\nconst rows = [["Alice", "30"], ["Bob", "25"]];`,
    expected:
      '<table><tr><th>Name</th><th>Age</th></tr><tr><td>Alice</td><td>30</td></tr><tr><td>Bob</td><td>25</td></tr></table>',
    // biome-ignore lint/suspicious/noTemplateCurlyInString: sample holds user solution code containing template literals
    sample:
      '`<table><tr>${headers.map(h => `<th>${h}</th>`).join("")}</tr>${rows.map(r => `<tr>${r.map(c => `<td>${c}</td>`).join("")}</tr>`).join("")}</table>`',
    hints: [
      'Map headers to th elements',
      'Map rows to tr with td elements',
      'Join everything together',
    ],
    tags: ['rendering', 'table', 'template-literals'],
  },

  {
    id: 'fe-js-conditional-render',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'easy',
    title: 'Conditional Rendering',
    text: 'Given a user object that may or may not have a name, render a greeting or a login prompt. Return the HTML string.',
    setup: 'User objects for conditional rendering.',
    setupCode: `function renderGreeting(user) {\n  if (user && user.name) return \`<h1>Hello, \${user.name}!</h1>\`;\n  return "<h1>Please log in</h1>";\n}\nconst loggedIn = renderGreeting({ name: "Alice" });\nconst loggedOut = renderGreeting(null);`,
    expected: { loggedIn: '<h1>Hello, Alice!</h1>', loggedOut: '<h1>Please log in</h1>' },
    sample: '({ loggedIn, loggedOut })',
    hints: ['Check if user and user.name exist', 'Return different HTML based on condition'],
    tags: ['rendering', 'conditional', 'template-literals'],
  },

  {
    id: 'fe-js-list-reconcile',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'hard',
    title: 'List Reconciliation',
    text: 'Write a reconcile(oldL, newL) function that computes the operations to transform one list into another. Each item has {id, text}. Return an array of operations: {op:"remove", id} for deleted items, {op:"update", id, text} for changed text, {op:"add", id, text} for new items.',
    setup: 'Old and new item lists.',
    setupCode: `// Old and new lists to reconcile\nconst oldList = [{ id: 1, text: "A" }, { id: 2, text: "B" }, { id: 3, text: "C" }];\nconst newList = [{ id: 2, text: "B2" }, { id: 3, text: "C" }, { id: 4, text: "D" }];`,
    expected: [
      { op: 'remove', id: 1 },
      { op: 'update', id: 2, text: 'B2' },
      { op: 'add', id: 4, text: 'D' },
    ],
    sample: `function reconcile(oldL, newL) {\n  const ops = [];\n  const oldMap = new Map(oldL.map(i => [i.id, i]));\n  const newMap = new Map(newL.map(i => [i.id, i]));\n  for (const [id] of oldMap) {\n    if (!newMap.has(id)) ops.push({ op: "remove", id });\n  }\n  for (const [id, item] of newMap) {\n    if (!oldMap.has(id)) ops.push({ op: "add", id, text: item.text });\n    else if (oldMap.get(id).text !== item.text) ops.push({ op: "update", id, text: item.text });\n  }\n  return ops;\n}\nreconcile(oldList, newList)`,
    hints: [
      'Create Maps from both lists for O(1) lookups by id',
      'Items in old but not new are removes; items in new but not old are adds',
      'Items in both with different text are updates',
    ],
    tags: ['rendering', 'reconciliation', 'list', 'diff'],
  },

  {
    id: 'fe-js-fragment-build',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'easy',
    title: 'Build Fragment Object',
    text: 'Write a createFragment(tags) function that maps an array of tag name strings into an array of virtual node objects, each with {tag, props: {}, children: []}.',
    setup: 'An array of tag names.',
    setupCode: `// Tag names to convert into virtual nodes\nconst tags = ["p", "span", "div"];`,
    expected: [
      { tag: 'p', props: {}, children: [] },
      { tag: 'span', props: {}, children: [] },
      { tag: 'div', props: {}, children: [] },
    ],
    sample: `function createFragment(tags) {\n  return tags.map(tag => ({ tag, props: {}, children: [] }));\n}\ncreateFragment(tags)`,
    hints: [
      'Use .map() to transform each tag string',
      'Each node needs tag, props (empty object), and children (empty array)',
      'Return the mapped array',
    ],
    tags: ['rendering', 'fragment', 'virtual-DOM'],
  },

  {
    id: 'fe-js-template-engine',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'medium',
    title: 'Simple Template Engine',
    text: 'Write a template(str, data) function that replaces all {{key}} placeholders in the string with corresponding values from the data object. If a key is not in data, leave the placeholder unchanged. Test it with a greeting template.',
    setup: 'No setup needed.',
    setupCode: `// Implement a template engine with {{key}} interpolation`,
    expected: 'Hello Alice, you are 30 years old!',
    sample: `function template(str, data) {\n  return str.replace(/\\{\\{(\\w+)\\}\\}/g, (match, key) => {\n    return data[key] !== undefined ? data[key] : match;\n  });\n}\ntemplate("Hello {{name}}, you are {{age}} years old!", { name: "Alice", age: 30 })`,
    hints: [
      'Use str.replace with a regex to find {{word}} patterns',
      'The regex capture group gives you the key name',
      'Look up data[key] and return it, or return the original match',
    ],
    tags: ['rendering', 'template', 'regex', 'interpolation'],
  },

  {
    id: 'fe-js-render-nested-list',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'medium',
    title: 'Render Nested List',
    text: 'Write a renderList(items) function that recursively renders a nested data structure into HTML. Each item has a text property and optional children array. Wrap each level in <ul>, each item in <li>, and recurse into children.',
    setup: 'A nested list data structure.',
    setupCode: `// Nested items: A has children A1 and A2, B has no children\nconst items = [\n  { text: "A", children: [{ text: "A1" }, { text: "A2" }] },\n  { text: "B" }\n];`,
    expected: '<ul><li>A<ul><li>A1</li><li>A2</li></ul></li><li>B</li></ul>',
    sample: `function renderList(items) {\n  return "<ul>" + items.map(item => {\n    let html = "<li>" + item.text;\n    if (item.children) html += renderList(item.children);\n    html += "</li>";\n    return html;\n  }).join("") + "</ul>";\n}\nrenderList(items)`,
    hints: [
      'Wrap the whole level in <ul>...</ul>',
      'Each item becomes <li>text</li>',
      'If item.children exists, recursively call renderList inside the <li>',
    ],
    tags: ['rendering', 'nested', 'recursive', 'list'],
  },

  {
    id: 'fe-js-lazy-render',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'medium',
    title: 'Lazy Render Queue',
    text: 'Implement a render queue that collects render tasks and processes them in batches of a given size. Return the rendered batch results.',
    setup: 'A lazy render queue.',
    setupCode: `function createRenderQueue(batchSize) {\n  const queue = [];\n  return {\n    add(renderFn) { queue.push(renderFn); },\n    flush() {\n      const batch = queue.splice(0, batchSize);\n      return batch.map(fn => fn());\n    }\n  };\n}\nconst rq = createRenderQueue(2);\nrq.add(() => "<div>1</div>");\nrq.add(() => "<div>2</div>");\nrq.add(() => "<div>3</div>");\nconst batch1 = rq.flush();\nconst batch2 = rq.flush();`,
    expected: { batch1: ['<div>1</div>', '<div>2</div>'], batch2: ['<div>3</div>'] },
    sample: '({ batch1, batch2 })',
    hints: ['Use splice to take a batch from the queue', 'Map batch items to get render results'],
    tags: ['rendering', 'lazy', 'queue', 'batch'],
  },

  {
    id: 'fe-js-escape-html',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'easy',
    title: 'Escape HTML Entities',
    text: 'Write an escapeHtml(str) function that replaces &, <, >, and " with their HTML entity equivalents (&amp; &lt; &gt; &quot;). Test it with an HTML string containing all four characters.',
    setup: 'No setup needed.',
    setupCode: `// Implement HTML entity escaping`,
    expected: '&lt;p class=&quot;test&quot;&gt;A &amp; B&lt;/p&gt;',
    sample: `function escapeHtml(str) {\n  const map = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;" };\n  return str.replace(/[&<>"]/g, ch => map[ch]);\n}\nescapeHtml('<p class="test">A & B</p>')`,
    hints: [
      'Create a lookup object mapping each character to its entity',
      'Use str.replace with a regex character class [&<>"]',
      'The replacement function looks up each match in the map',
    ],
    tags: ['rendering', 'escape', 'XSS', 'security'],
  },

  {
    id: 'fe-js-vnode-create',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'easy',
    title: 'Create Virtual Node',
    text: 'Write a createElement(tag, props, ...children) function that returns a virtual node {tag, props, children}. Default null props to {}. Flatten children. Build a nested vDOM tree with a div containing an h1 and a p.',
    setup: 'No setup needed.',
    setupCode: `// Implement createElement similar to React.createElement`,
    expected: {
      tag: 'div',
      props: { id: 'app' },
      children: [
        { tag: 'h1', props: {}, children: ['Hello'] },
        { tag: 'p', props: { class: 'text' }, children: ['World'] },
      ],
    },
    sample: `function createElement(tag, props, ...children) {\n  return { tag, props: props || {}, children: children.flat() };\n}\ncreateElement("div", { id: "app" }, createElement("h1", null, "Hello"), createElement("p", { class: "text" }, "World"))`,
    hints: [
      'Use rest params (...children) to collect all children arguments',
      'Use children.flat() in case of nested arrays',
      'Default props to {} when null is passed',
    ],
    tags: ['rendering', 'virtual-DOM', 'createElement'],
  },

  {
    id: 'fe-js-render-attrs',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'medium',
    title: 'Render Attributes String',
    text: 'Write a renderAttrs(attrs) function that converts an attributes object to an HTML attribute string. Skip null, undefined, and false values. For true values, render just the attribute name (e.g., "disabled"). For strings, render key="value".',
    setup: 'No setup needed.',
    setupCode: `// Implement HTML attribute rendering`,
    expected: 'class="btn" id="main" disabled',
    sample: `function renderAttrs(attrs) {\n  return Object.entries(attrs)\n    .filter(([, v]) => v != null && v !== false)\n    .map(([k, v]) => v === true ? k : \`\${k}="\${v}"\`)\n    .join(" ");\n}\nrenderAttrs({ class: "btn", id: "main", hidden: false, disabled: true, title: null })`,
    hints: [
      'Filter out entries where value is null, undefined, or false',
      'If value is true, output just the key name',
      'Otherwise output key="value" format, joined by spaces',
    ],
    tags: ['rendering', 'attributes', 'HTML'],
  },

  {
    id: 'fe-js-vdom-to-html',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'hard',
    title: 'Virtual DOM to HTML String',
    text: 'Write a toHtml(node) function that recursively converts a virtual DOM tree into an HTML string. String nodes return as-is. Element nodes have tag, props, children. Build the opening tag with attributes from props, recursively render children, and close the tag.',
    setup: 'A virtual DOM tree to render.',
    setupCode: `// Virtual DOM tree: div#app > [h1("Title"), p.body("Content")]\nconst tree = { tag: "div", props: { id: "app" }, children: [\n  { tag: "h1", props: {}, children: ["Title"] },\n  { tag: "p", props: { class: "body" }, children: ["Content"] }\n]};`,
    expected: '<div id="app"><h1>Title</h1><p class="body">Content</p></div>',
    sample: `function toHtml(node) {\n  if (typeof node === "string") return node;\n  const attrs = Object.entries(node.props || {})\n    .map(([k, v]) => \` \${k}="\${v}"\`).join("");\n  const children = (node.children || []).map(c => toHtml(c)).join("");\n  return \`<\${node.tag}\${attrs}>\${children}</\${node.tag}>\`;\n}\ntoHtml(tree)`,
    hints: [
      'Base case: if node is a string, return it directly',
      'Build attributes: map props entries to key="value" strings',
      'Recursively render children and join them',
    ],
    tags: ['rendering', 'virtual-DOM', 'HTML', 'recursive'],
  },

  {
    id: 'fe-js-render-switch',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'medium',
    title: 'Render with Switch Component',
    text: 'Write a renderByStatus(status, data) function that uses a switch statement to return different HTML: "loading" returns a spinner div, "error" returns an error div with data, "success" returns a content div with data. Return all three results.',
    setup: 'No setup needed.',
    setupCode: `// Implement status-based conditional rendering`,
    expected: {
      loading: '<div class="spinner">Loading...</div>',
      error: '<div class="error">Network fail</div>',
      success: '<div class="content">Hello</div>',
    },
    sample: `function renderByStatus(status, data) {\n  switch (status) {\n    case "loading": return "<div class=\\"spinner\\">Loading...</div>";\n    case "error": return \`<div class="error">\${data}</div>\`;\n    case "success": return \`<div class="content">\${data}</div>\`;\n    default: return "";\n  }\n}\n({ loading: renderByStatus("loading"), error: renderByStatus("error", "Network fail"), success: renderByStatus("success", "Hello") })`,
    hints: [
      'Use switch(status) with cases for each state',
      'loading does not use data, error and success interpolate it',
      'Return empty string for unknown statuses',
    ],
    tags: ['rendering', 'conditional', 'switch', 'status'],
  },

  {
    id: 'fe-js-class-string-builder',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'medium',
    title: 'Class String Builder',
    text: 'Write a classNames(obj) function that takes an object where keys are class names and values are booleans. Return a space-separated string of only the class names with truthy values.',
    setup: 'No setup needed.',
    setupCode: `// Implement classNames utility (like the classnames npm package)`,
    expected: 'btn btn-primary active',
    sample: `function classNames(obj) {\n  return Object.entries(obj)\n    .filter(([, v]) => v)\n    .map(([k]) => k)\n    .join(" ");\n}\nclassNames({ btn: true, "btn-primary": true, disabled: false, active: true, hidden: 0 })`,
    hints: [
      'Use Object.entries to get [key, value] pairs',
      'Filter for truthy values only',
      'Map to just the keys and join with spaces',
    ],
    tags: ['rendering', 'className', 'utility'],
  },

  {
    id: 'fe-js-render-map-filter',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'easy',
    title: 'Filtered List Rendering',
    text: 'Given an array of user objects, render only active users as <li> elements. Return the HTML string.',
    setup: 'An array of user objects.',
    setupCode: `const users = [\n  { name: "Alice", active: true },\n  { name: "Bob", active: false },\n  { name: "Charlie", active: true }\n];`,
    expected: '<li>Alice</li><li>Charlie</li>',
    // biome-ignore lint/suspicious/noTemplateCurlyInString: sample holds user solution code containing template literals
    sample: 'users.filter(u => u.active).map(u => `<li>${u.name}</li>`).join("")',
    hints: ['Filter for active users first', 'Map to li elements', 'Join into string'],
    tags: ['rendering', 'filter', 'map', 'list'],
  },

  {
    id: 'fe-js-style-object',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'medium',
    title: 'Style Object to CSS String',
    text: 'Write a styleToCSS(styles) function that converts a JavaScript style object (camelCase properties) to a CSS string (kebab-case properties). Join property declarations with "; ".',
    setup: 'No setup needed.',
    setupCode: `// Implement camelCase to kebab-case CSS conversion`,
    expected: 'background-color: red; font-size: 16px; margin-top: 10px',
    sample: `function styleToCSS(styles) {\n  return Object.entries(styles)\n    .map(([k, v]) => {\n      const prop = k.replace(/[A-Z]/g, m => "-" + m.toLowerCase());\n      return \`\${prop}: \${v}\`;\n    })\n    .join("; ");\n}\nstyleToCSS({ backgroundColor: "red", fontSize: "16px", marginTop: "10px" })`,
    hints: [
      'Use regex /[A-Z]/g to find uppercase letters',
      'Replace each with "-" + lowercase version',
      'Format as "prop: value" and join with "; "',
    ],
    tags: ['rendering', 'style', 'CSS', 'camelCase'],
  },

  {
    id: 'fe-js-dom-tree-obj',
    framework: 'native-js',
    category: 'Rendering',
    difficulty: 'hard',
    title: 'Build DOM Tree from Config',
    text: 'Write a buildTree(config) function that recursively converts a config object into a DOM tree. Each config has tag, optional attrs, optional text (string child), and optional children (array). Output nodes have {tag, attrs, children}. Default attrs to {}.',
    setup: 'A nested configuration object.',
    setupCode: `// Config tree to convert\nconst config = {\n  tag: "div",\n  attrs: { id: "root" },\n  children: [\n    { tag: "h1", text: "Title" },\n    { tag: "ul", children: [\n      { tag: "li", text: "Item 1" },\n      { tag: "li", text: "Item 2" }\n    ]}\n  ]\n};`,
    expected: {
      tag: 'div',
      attrs: { id: 'root' },
      children: [
        { tag: 'h1', attrs: {}, children: ['Title'] },
        {
          tag: 'ul',
          attrs: {},
          children: [
            { tag: 'li', attrs: {}, children: ['Item 1'] },
            { tag: 'li', attrs: {}, children: ['Item 2'] },
          ],
        },
      ],
    },
    sample: `function buildTree(config) {\n  const node = { tag: config.tag, attrs: config.attrs || {}, children: [] };\n  if (config.text) node.children.push(config.text);\n  if (config.children) {\n    for (const child of config.children) {\n      node.children.push(buildTree(child));\n    }\n  }\n  return node;\n}\nbuildTree(config)`,
    hints: [
      'Create a node with tag, attrs (default {}), and empty children array',
      'If config.text exists, push it as a string child',
      'If config.children exists, recursively buildTree each child',
    ],
    tags: ['rendering', 'tree', 'recursive', 'config'],
  },

  // ─── NEW Data Fetching (17) ──────────────────────────────────

  {
    id: 'fe-js-promise-all-sim',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'easy',
    title: 'Promise.all Simulation',
    text: 'Implement a synchronous version of Promise.all: given an array of values, apply a transform to each and collect the results into a single array.',
    setup: 'Values to transform and collect.',
    setupCode: `const values = [1, 2, 3];\nfunction collectAll(items, fn) {\n  return items.map(fn);\n}`,
    expected: [10, 20, 30],
    sample: 'collectAll(values, v => v * 10)',
    hints: ['Map over items to apply the transform', 'Return the resulting array'],
    tags: ['Promise', 'Promise.all', 'map'],
  },

  {
    id: 'fe-js-promise-race-sim',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'easy',
    title: 'Promise.race Simulation',
    text: 'Write a race(items) function that takes an array of {value, priority} objects and returns the value with the lowest priority number (the fastest competitor). Use reduce to find it.',
    setup: 'Competitors with priorities.',
    setupCode: `// Each competitor has a value and priority (lower = faster)\nconst competitors = [\n  { value: "slow", priority: 1000 },\n  { value: "fast", priority: 1 },\n  { value: "medium", priority: 500 }\n];`,
    expected: 'fast',
    sample: `function race(items) {\n  return items.reduce((best, item) => item.priority < best.priority ? item : best).value;\n}\nrace(competitors)`,
    hints: [
      'Use reduce to find the item with the minimum priority',
      'Compare item.priority < best.priority',
      'Return the .value of the winner',
    ],
    tags: ['Promise', 'race', 'reduce'],
  },

  {
    id: 'fe-js-retry-logic',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Retry Logic',
    text: 'Write a retry(fn, maxRetries) function that calls fn up to maxRetries+1 times total. If fn throws, catch the error and try again. If all retries fail, re-throw. Test with a function that fails twice then succeeds. Return {result, attempts}.',
    setup: 'A flaky function that fails the first 2 calls.',
    setupCode: `// Tracks total call count; fails until 3rd attempt\nlet attempts = 0;\nconst flakyFn = () => {\n  attempts++;\n  if (attempts < 3) throw new Error("fail");\n  return "success";\n};`,
    expected: { result: 'success', attempts: 3 },
    sample: `function retry(fn, maxRetries) {\n  for (let i = 0; i <= maxRetries; i++) {\n    try {\n      return fn();\n    } catch (e) {\n      if (i === maxRetries) throw e;\n    }\n  }\n}\n({ result: retry(flakyFn, 5), attempts })`,
    hints: [
      'Loop from 0 to maxRetries inclusive',
      'Wrap fn() in try/catch inside the loop',
      'On the last iteration, re-throw instead of continuing',
    ],
    tags: ['retry', 'error-handling', 'resilience'],
  },

  {
    id: 'fe-js-exponential-backoff',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Exponential Backoff Delays',
    text: 'Write a backoffDelays(base, maxDelay, retries) function that returns an array of exponential backoff delays. Each delay is base * 2^i, capped at maxDelay. Calculate delays for 5 retries with base 100 and max 2000.',
    setup: 'No setup needed.',
    setupCode: `// Implement exponential backoff delay calculation`,
    expected: [100, 200, 400, 800, 1600],
    sample: `function backoffDelays(base, maxDelay, retries) {\n  const delays = [];\n  for (let i = 0; i < retries; i++) {\n    delays.push(Math.min(base * Math.pow(2, i), maxDelay));\n  }\n  return delays;\n}\nbackoffDelays(100, 2000, 5)`,
    hints: [
      'Loop from 0 to retries-1',
      'Each delay = base * 2^i',
      'Use Math.min to cap at maxDelay',
    ],
    tags: ['backoff', 'exponential', 'retry'],
  },

  {
    id: 'fe-js-request-queue',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Request Queue',
    text: 'Write a createQueue() returning {add(fn), process(), getResults()}. add enqueues a function. process runs all queued functions in order, collecting return values. Add three functions, process them, and return the results.',
    setup: 'No setup needed.',
    setupCode: `// Implement a sequential request queue`,
    expected: ['A', 'B', 'C'],
    sample: `function createQueue() {\n  const results = [];\n  const queue = [];\n  return {\n    add(fn) { queue.push(fn); },\n    run() {\n      while (queue.length) {\n        const fn = queue.shift();\n        results.push(fn());\n      }\n    },\n    getResults() { return results; }\n  };\n}\nconst q = createQueue();\nq.add(() => "A");\nq.add(() => "B");\nq.add(() => "C");\nq.run();\nq.getResults()`,
    hints: [
      'Use an array as the queue, push to add, shift to dequeue',
      'process loops while queue has items',
      'Push each function return value into results',
    ],
    tags: ['queue', 'sequential', 'pattern'],
  },

  {
    id: 'fe-js-cache-first',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Cache-First Strategy',
    text: 'Write a createCachedFetcher(fetcher) returning {get(key)}. get checks a Map cache first; on miss, calls fetcher(key), caches the result, and increments fetchCalls. Get "a" twice and "b" once. Return all results and the fetch call count.',
    setup: 'A fetch call counter.',
    setupCode: `// Tracks how many times the real fetcher is called\nlet fetchCalls = 0;`,
    expected: { r1: 'data-a', r2: 'data-a', r3: 'data-b', calls: 2 },
    sample: `function createCachedFetcher(fetcher) {\n  const cache = new Map();\n  return {\n    get(key) {\n      if (cache.has(key)) return cache.get(key);\n      fetchCalls++;\n      const data = fetcher(key);\n      cache.set(key, data);\n      return data;\n    }\n  };\n}\nconst cf = createCachedFetcher(key => "data-" + key);\nconst r1 = cf.get("a");\nconst r2 = cf.get("a");\nconst r3 = cf.get("b");\n({ r1, r2, r3, calls: fetchCalls })`,
    hints: [
      'Use a Map as the cache',
      'Check cache.has(key) before calling the fetcher',
      'On cache miss: call fetcher, store result, increment counter',
    ],
    tags: ['cache', 'fetch', 'strategy'],
  },

  {
    id: 'fe-js-optimistic-update',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Optimistic Update',
    text: 'Write a createOptimistic(initial) returning {update(optimisticValue, fn), getLog()}. update sets state optimistically, logs it as "optimistic", then calls fn(). If fn succeeds, set state to its return value and log "confirmed". If fn throws, rollback to previous state and log "rollback". Return the log.',
    setup: 'No setup needed.',
    setupCode: `// Implement optimistic update with rollback support`,
    expected: [
      { state: 'new', phase: 'optimistic' },
      { state: 'new-confirmed', phase: 'confirmed' },
    ],
    sample: `function createOptimistic(initial) {\n  let state = initial;\n  const log = [];\n  return {\n    update(optimisticValue, fn) {\n      const prev = state;\n      state = optimisticValue;\n      log.push({ state, phase: "optimistic" });\n      try {\n        const result = fn();\n        state = result;\n        log.push({ state, phase: "confirmed" });\n      } catch (e) {\n        state = prev;\n        log.push({ state, phase: "rollback" });\n      }\n    },\n    getLog() { return log; }\n  };\n}\nconst opt = createOptimistic("old");\nopt.update("new", () => "new-confirmed");\nopt.getLog()`,
    hints: [
      'Save previous state before the optimistic update',
      'Wrap fn() in try/catch for confirmation vs rollback',
      'Log each phase with the current state value',
    ],
    tags: ['optimistic', 'update', 'state'],
  },

  {
    id: 'fe-js-pagination',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'easy',
    title: 'Pagination Logic',
    text: 'Write a paginate(items, page, pageSize) function that returns {totalPages, page, pageItems}. totalPages is the ceiling of items.length / pageSize. pageItems is the slice for that page. Paginate 47 items with page size 10 and get page 3 (0-indexed).',
    setup: 'An array of 47 items (1-47).',
    setupCode: `// 47 items numbered 1 to 47\nconst allItems = Array.from({ length: 47 }, (_, i) => i + 1);`,
    expected: { totalPages: 5, page: 3, pageItems: [31, 32, 33, 34, 35, 36, 37, 38, 39, 40] },
    sample: `function paginate(items, page, pageSize) {\n  const totalPages = Math.ceil(items.length / pageSize);\n  const start = page * pageSize;\n  const pageItems = items.slice(start, start + pageSize);\n  return { totalPages, page, pageItems };\n}\npaginate(allItems, 3, 10)`,
    hints: [
      'totalPages = Math.ceil(items.length / pageSize)',
      'start index = page * pageSize',
      'Use slice(start, start + pageSize) for the page items',
    ],
    tags: ['pagination', 'slice', 'math'],
  },

  {
    id: 'fe-js-cursor-pagination',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Cursor-Based Pagination',
    text: 'Write a fetchAfterCursor(items, cursor, limit) function. Find the cursor item, start from the next one, take up to limit items. Return {data, nextCursor}. nextCursor is the last item id if the page is full, null otherwise.',
    setup: 'A sorted list of items with unique ids.',
    setupCode: `// Sorted items with unique ids\nconst items = [\n  { id: "a1", name: "A" }, { id: "b2", name: "B" },\n  { id: "c3", name: "C" }, { id: "d4", name: "D" },\n  { id: "e5", name: "E" }\n];`,
    expected: {
      data: [
        { id: 'c3', name: 'C' },
        { id: 'd4', name: 'D' },
      ],
      nextCursor: 'd4',
    },
    sample: `function fetchAfterCursor(items, cursor, limit) {\n  let startIdx = 0;\n  if (cursor) {\n    const cursorIdx = items.findIndex(i => i.id === cursor);\n    startIdx = cursorIdx >= 0 ? cursorIdx + 1 : 0;\n  }\n  const page = items.slice(startIdx, startIdx + limit);\n  const nextCursor = page.length === limit ? page[page.length - 1].id : null;\n  return { data: page, nextCursor };\n}\nfetchAfterCursor(items, "b2", 2)`,
    hints: [
      'Use findIndex to locate the cursor item',
      'Start from cursorIdx + 1',
      'If page.length equals limit, there may be more items (set nextCursor)',
    ],
    tags: ['pagination', 'cursor', 'fetch'],
  },

  {
    id: 'fe-js-error-handling-fetch',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'easy',
    title: 'Fetch Error Handling',
    text: 'Write a safeFetch(fn) function that calls fn() inside try/catch. On success, return {data: result, error: null}. On error, return {data: null, error: message}. Test with a succeeding and a failing function.',
    setup: 'No setup needed.',
    setupCode: `// Implement safe fetch wrapper with try/catch`,
    expected: { ok: { data: 'hello', error: null }, fail: { data: null, error: 'oops' } },
    sample: `function safeFetch(fn) {\n  try {\n    const data = fn();\n    return { data, error: null };\n  } catch (e) {\n    return { data: null, error: e.message };\n  }\n}\nconst ok = safeFetch(() => "hello");\nconst fail = safeFetch(() => { throw new Error("oops"); });\n({ ok, fail })`,
    hints: [
      'Wrap fn() in try/catch',
      'On success: {data: fn(), error: null}',
      'On catch: {data: null, error: e.message}',
    ],
    tags: ['error-handling', 'try-catch', 'pattern'],
  },

  {
    id: 'fe-js-abort-controller-sim',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'AbortController Simulation',
    text: 'Write createAbortController() returning {signal, abort()}. signal has an aborted boolean. abort() sets it to true. Also write cancellableOp(signal) that returns {status:"aborted"} if signal.aborted, else {status:"completed", data:42}. Run the op before and after calling abort().',
    setup: 'No setup needed.',
    setupCode: `// Implement AbortController simulation and cancellable operation`,
    expected: { r1: { status: 'completed', data: 42 }, r2: { status: 'aborted' } },
    sample: `function createAbortController() {\n  const signal = { aborted: false };\n  return {\n    signal,\n    abort() { signal.aborted = true; }\n  };\n}\nfunction cancellableOp(signal) {\n  if (signal.aborted) return { status: "aborted" };\n  return { status: "completed", data: 42 };\n}\nconst ac = createAbortController();\nconst r1 = cancellableOp(ac.signal);\nac.abort();\nconst r2 = cancellableOp(ac.signal);\n({ r1, r2 })`,
    hints: [
      'signal is a shared object; abort mutates it',
      'cancellableOp checks signal.aborted at the start',
      'Before abort: completed; after abort: aborted',
    ],
    tags: ['AbortController', 'cancel', 'signal'],
  },

  {
    id: 'fe-js-race-condition',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'hard',
    title: 'Race Condition Prevention',
    text: 'Write a createLatestOnly() returning {startRequest(), acceptResult(id, data)}. startRequest increments and returns a request ID. acceptResult only stores data if id matches the current ID (returns {stale:false, data}), otherwise returns {stale:true, data}. Start two requests, then accept results in order (first request arrives late). Return both results.',
    setup: 'No setup needed.',
    setupCode: `// Implement a "latest only" pattern to prevent stale responses`,
    expected: { r1: { stale: true, data: 'first' }, r2: { stale: false, data: 'second' } },
    sample: `function createLatestOnly() {\n  let currentId = 0;\n  let accepted = null;\n  return {\n    startRequest() { return ++currentId; },\n    acceptResult(id, data) {\n      if (id === currentId) { accepted = { stale: false, data }; return accepted; }\n      return { stale: true, data };\n    },\n    getAccepted() { return accepted; }\n  };\n}\nconst lo = createLatestOnly();\nconst id1 = lo.startRequest();\nconst id2 = lo.startRequest();\nconst r1 = lo.acceptResult(id1, "first");\nconst r2 = lo.acceptResult(id2, "second");\n({ r1, r2 })`,
    hints: [
      'Each startRequest increments a counter and returns the new ID',
      'acceptResult compares the given id to currentId',
      'If ids do not match, the response is stale',
    ],
    tags: ['race-condition', 'pattern', 'stale'],
  },

  {
    id: 'fe-js-polling',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Polling Until Condition',
    text: 'Write a poll(fn, condition, maxPolls) function that calls fn repeatedly (up to maxPolls times), incrementing pollCount each time. If condition(result) is true, return the result immediately. If maxPolls is reached, return null. Poll a counter until it reaches 3.',
    setup: 'Poll counter and a simulated server value.',
    setupCode: `// Track poll count and server state\nlet pollCount = 0;\nlet serverValue = 0;`,
    expected: { result: 3, polls: 3 },
    sample: `function poll(fn, condition, maxPolls) {\n  for (let i = 0; i < maxPolls; i++) {\n    pollCount++;\n    const result = fn();\n    if (condition(result)) return result;\n  }\n  return null;\n}\nserverValue = 0;\nconst result = poll(\n  () => { serverValue++; return serverValue; },\n  v => v >= 3,\n  10\n);\n({ result, polls: pollCount })`,
    hints: [
      'Loop up to maxPolls times',
      'Call fn() and check condition(result) each iteration',
      'Return early when condition is satisfied',
    ],
    tags: ['polling', 'loop', 'condition'],
  },

  {
    id: 'fe-js-parallel-fetch',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'easy',
    title: 'Parallel Data Fetching',
    text: 'Write a fetchAll(sources) function that takes an object of named data source functions, calls each one, and returns an object with the same keys mapped to results. Test with getUser and getPosts sources.',
    setup: 'Two data source functions.',
    setupCode: `// Data source functions\nconst getUser = () => ({ id: 1, name: "Alice" });\nconst getPosts = () => [{ title: "Post 1" }, { title: "Post 2" }];`,
    expected: { user: { id: 1, name: 'Alice' }, posts: [{ title: 'Post 1' }, { title: 'Post 2' }] },
    sample: `function fetchAll(sources) {\n  const result = {};\n  for (const [key, fn] of Object.entries(sources)) {\n    result[key] = fn();\n  }\n  return result;\n}\nfetchAll({ user: getUser, posts: getPosts })`,
    hints: [
      'Iterate over Object.entries of the sources',
      'Call each function and store the result by key',
      'Return the combined results object',
    ],
    tags: ['data-fetching', 'combine', 'pattern'],
  },

  {
    id: 'fe-js-response-transform',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'medium',
    title: 'Response Transformer Pipeline',
    text: 'Write a createTransformer(...transforms) function that returns a new function. When called with data, it pipes the data through each transform in sequence using reduce. Create a pipeline that extracts items, filters active ones, and maps to names.',
    setup: 'An API response object.',
    setupCode: `// Simulated API response\nconst apiResponse = { items: [\n  { name: "Alice", active: true },\n  { name: "Bob", active: false },\n  { name: "Charlie", active: true }\n]};`,
    expected: ['Alice', 'Charlie'],
    sample: `function createTransformer(...transforms) {\n  return function(data) {\n    return transforms.reduce((result, fn) => fn(result), data);\n  };\n}\nconst transform = createTransformer(\n  data => data.items,\n  items => items.filter(i => i.active),\n  items => items.map(i => i.name)\n);\ntransform(apiResponse)`,
    hints: [
      'Use rest params to collect transforms',
      'Reduce passes each result to the next function',
      'The first transform receives the raw data',
    ],
    tags: ['transform', 'pipeline', 'fetch'],
  },

  {
    id: 'fe-js-promise-allsettled',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'hard',
    title: 'Promise.allSettled Simulation',
    text: 'Write an allSettled(fns) function that maps over an array of functions. For each, call it in try/catch. Success: {status:"fulfilled", value}. Error: {status:"rejected", reason: message}. Test with three functions (second throws).',
    setup: 'No setup needed.',
    setupCode: `// Implement synchronous allSettled`,
    expected: [
      { status: 'fulfilled', value: 1 },
      { status: 'rejected', reason: 'fail' },
      { status: 'fulfilled', value: 3 },
    ],
    sample: `function allSettled(fns) {\n  return fns.map(fn => {\n    try {\n      const value = fn();\n      return { status: "fulfilled", value };\n    } catch (e) {\n      return { status: "rejected", reason: e.message || String(e) };\n    }\n  });\n}\nconst fns = [() => 1, () => { throw new Error("fail"); }, () => 3];\nallSettled(fns)`,
    hints: [
      'Map over fns and wrap each call in try/catch',
      'On success return {status:"fulfilled", value: result}',
      'On error return {status:"rejected", reason: e.message}',
    ],
    tags: ['allSettled', 'error-handling', 'try-catch'],
  },

  {
    id: 'fe-js-deduplicate-requests',
    framework: 'native-js',
    category: 'Data Fetching',
    difficulty: 'hard',
    title: 'Deduplicate Concurrent Requests',
    text: 'Write a createDeduplicator(fetcher) returning {get(key)}. get checks a Map cache; on miss, calls fetcher(key), caches the result, and increments dedupFetchCount. Get "x" twice and "y" once. Return all values and the fetch count.',
    setup: 'A dedup fetch counter.',
    setupCode: `// Tracks unique fetch calls\nlet dedupFetchCount = 0;`,
    expected: { a: 'val-x', b: 'val-x', c: 'val-y', fetchCount: 2 },
    sample: `function createDeduplicator(fetcher) {\n  const cache = new Map();\n  return {\n    get(key) {\n      if (cache.has(key)) return cache.get(key);\n      dedupFetchCount++;\n      const result = fetcher(key);\n      cache.set(key, result);\n      return result;\n    }\n  };\n}\nconst dd = createDeduplicator(k => "val-" + k);\nconst a = dd.get("x");\nconst b = dd.get("x");\nconst c = dd.get("y");\n({ a, b, c, fetchCount: dedupFetchCount })`,
    hints: [
      'Use a Map for O(1) cache lookups',
      'Only call the fetcher when cache misses',
      'Duplicate keys return the cached value without re-fetching',
    ],
    tags: ['dedup', 'cache', 'Map'],
  },

  // ─── NEW Forms & Validation (17) ─────────────────────────────

  {
    id: 'fe-js-required-fields',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'easy',
    title: 'Required Fields Validation',
    text: 'Write a getMissing(data, requiredFields) function that returns an array of field names that are missing (empty string, undefined, or absent) from the data object.',
    setup: 'Form data and required field names.',
    setupCode: `// Form data (some fields empty or missing)\nconst formData = { name: "Alice", email: "", age: "30", phone: "" };\n// Required field names to check\nconst required = ["name", "email", "phone", "address"];`,
    expected: ['email', 'phone', 'address'],
    sample: `function getMissing(data, requiredFields) {\n  return requiredFields.filter(f => !data[f]);\n}\ngetMissing(formData, required)`,
    hints: [
      'Filter the required fields array',
      'A field is missing if data[field] is falsy',
      'Empty string and undefined are both falsy',
    ],
    tags: ['forms', 'validation', 'required'],
  },

  {
    id: 'fe-js-phone-format',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'easy',
    title: 'Phone Number Format',
    text: 'Write a formatPhone(digits) function that takes a 10-digit string and formats it as (XXX) XXX-XXXX using slice to extract the three parts.',
    setup: 'No setup needed.',
    setupCode: `// Implement phone number formatting`,
    expected: '(555) 123-4567',
    sample: `function formatPhone(digits) {\n  return \`(\${digits.slice(0,3)}) \${digits.slice(3,6)}-\${digits.slice(6)}\`;\n}\nformatPhone("5551234567")`,
    hints: [
      'slice(0,3) for area code',
      'slice(3,6) for prefix, slice(6) for the rest',
      'Use a template literal to assemble the format',
    ],
    tags: ['forms', 'format', 'phone'],
  },

  {
    id: 'fe-js-input-mask',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'Input Masking',
    text: 'Write a maskCard(input) function that strips all non-digit characters, limits to 16 digits, then inserts a space after every 4 digits. Return the masked string.',
    setup: 'No setup needed.',
    setupCode: `// Implement credit card input masking`,
    expected: '1234 5678 9012 3456',
    sample: `function maskCard(input) {\n  const digits = input.replace(/\\D/g, "").slice(0, 16);\n  return digits.replace(/(\\d{4})(?=\\d)/g, "$1 ");\n}\nmaskCard("1234-5678-9012-3456")`,
    hints: [
      'First strip non-digits with replace(/\\D/g, "")',
      'Limit to 16 characters with slice(0, 16)',
      'Use regex with lookahead to insert spaces: /(\\d{4})(?=\\d)/g',
    ],
    tags: ['forms', 'mask', 'credit-card'],
  },

  {
    id: 'fe-js-form-serialize',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'easy',
    title: 'Form Serialization to URL Params',
    text: 'Write a serializeForm(data) function that converts an object into a URL query string. Use encodeURIComponent on both keys and values, and join pairs with "&".',
    setup: 'No setup needed.',
    setupCode: `// Implement URL query string serialization`,
    expected: 'name=Alice%20Smith&age=30&city=New%20York',
    sample: `function serializeForm(data) {\n  return Object.entries(data)\n    .map(([k, v]) => encodeURIComponent(k) + "=" + encodeURIComponent(v))\n    .join("&");\n}\nserializeForm({ name: "Alice Smith", age: "30", city: "New York" })`,
    hints: [
      'Use Object.entries to get key-value pairs',
      'encodeURIComponent handles spaces and special chars',
      'Join each key=value pair with "&"',
    ],
    tags: ['forms', 'serialize', 'URL', 'params'],
  },

  {
    id: 'fe-js-dynamic-validation',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'Dynamic Validation Rules',
    text: 'Write a validate(value, rules) function where each rule is a function that returns an error string or null. Map rules over the value, filter out nulls, and return the array of error messages. Define rules for min length 3, max length 10, requires uppercase, requires digit.',
    setup: 'No setup needed.',
    setupCode: `// Implement dynamic validation with pluggable rules`,
    expected: ['Needs uppercase', 'Needs digit'],
    sample: `function validate(value, rules) {\n  return rules\n    .map(rule => rule(value))\n    .filter(error => error !== null);\n}\nconst rules = [\n  v => v.length < 3 ? "Too short" : null,\n  v => v.length > 10 ? "Too long" : null,\n  v => !/[A-Z]/.test(v) ? "Needs uppercase" : null,\n  v => !/\\d/.test(v) ? "Needs digit" : null\n];\nvalidate("hello", rules)`,
    hints: [
      'Each rule returns an error string or null',
      'Map all rules to get error/null results',
      'Filter out null values to get only the errors',
    ],
    tags: ['forms', 'validation', 'dynamic', 'rules'],
  },

  {
    id: 'fe-js-multi-step-form',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'Multi-Step Form State',
    text: 'Write a createMultiStepForm(steps) returning {getCurrentStep(), setData(data), next(), prev(), getData()}. Track the current step index. setData stores data keyed by step name. Fill in three steps and return the combined data.',
    setup: 'No setup needed.',
    setupCode: `// Implement a multi-step form manager`,
    expected: {
      personal: { name: 'Alice' },
      address: { city: 'Portland' },
      payment: { card: '1234' },
    },
    sample: `function createMultiStepForm(steps) {\n  let current = 0;\n  const data = {};\n  return {\n    getCurrentStep() { return steps[current]; },\n    setData(stepData) { data[steps[current]] = stepData; },\n    next() { if (current < steps.length - 1) current++; },\n    prev() { if (current > 0) current--; },\n    getData() { return data; }\n  };\n}\nconst form = createMultiStepForm(["personal", "address", "payment"]);\nform.setData({ name: "Alice" });\nform.next();\nform.setData({ city: "Portland" });\nform.next();\nform.setData({ card: "1234" });\nform.getData()`,
    hints: [
      'Use an index variable to track the current step',
      'setData stores data under data[steps[current]]',
      'next/prev adjust the index with bounds checking',
    ],
    tags: ['forms', 'multi-step', 'wizard', 'state'],
  },

  {
    id: 'fe-js-file-data-validate',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'File Upload Validation',
    text: 'Write a validateFiles(files, constraints) function. For each file, check size against maxSize and type against allowedTypes. Return an array of {name, valid, errors} where errors contains "too-large" and/or "invalid-type" strings.',
    setup: 'File objects and constraints.',
    setupCode: `// Files to validate\nconst files = [\n  { name: "photo.jpg", size: 500000, type: "image/jpeg" },\n  { name: "doc.pdf", size: 2000000, type: "application/pdf" },\n  { name: "huge.png", size: 6000000, type: "image/png" }\n];\n// Validation constraints\nconst constraints = { maxSize: 5000000, allowedTypes: ["image/jpeg", "image/png"] };`,
    expected: [
      { name: 'photo.jpg', valid: true, errors: [] },
      { name: 'doc.pdf', valid: false, errors: ['invalid-type'] },
      { name: 'huge.png', valid: false, errors: ['too-large'] },
    ],
    sample: `function validateFiles(files, constraints) {\n  return files.map(f => {\n    const errors = [];\n    if (f.size > constraints.maxSize) errors.push("too-large");\n    if (!constraints.allowedTypes.includes(f.type)) errors.push("invalid-type");\n    return { name: f.name, valid: errors.length === 0, errors };\n  });\n}\nvalidateFiles(files, constraints)`,
    hints: [
      'Map each file to a validation result',
      'Check f.size > constraints.maxSize for size errors',
      'Check allowedTypes.includes(f.type) for type errors',
    ],
    tags: ['forms', 'file', 'validation', 'upload'],
  },

  {
    id: 'fe-js-formdata-like',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'FormData-Like Operations',
    text: 'Write a createFormData() returning {append(key, value), get(key), getAll(key), entries()}. Use a Map storing arrays of values per key. append adds to the array. get returns the first value. getAll returns all values. entries returns [key, value] pairs. Append three values and return the results.',
    setup: 'No setup needed.',
    setupCode: `// Implement a FormData-like interface using a Map`,
    expected: {
      name: 'Alice',
      hobbies: ['reading', 'coding'],
      entries: [
        ['name', 'Alice'],
        ['hobby', 'reading'],
        ['hobby', 'coding'],
      ],
    },
    sample: `function createFormData() {\n  const data = new Map();\n  return {\n    append(key, value) {\n      if (!data.has(key)) data.set(key, []);\n      data.get(key).push(value);\n    },\n    get(key) {\n      const vals = data.get(key);\n      return vals ? vals[0] : null;\n    },\n    getAll(key) {\n      return data.get(key) || [];\n    },\n    entries() {\n      const result = [];\n      for (const [k, vals] of data) {\n        for (const v of vals) result.push([k, v]);\n      }\n      return result;\n    }\n  };\n}\nconst fd = createFormData();\nfd.append("name", "Alice");\nfd.append("hobby", "reading");\nfd.append("hobby", "coding");\n({ name: fd.get("name"), hobbies: fd.getAll("hobby"), entries: fd.entries() })`,
    hints: [
      'Store values as arrays in the Map',
      'append creates the array if needed, then pushes',
      'get returns the first element, getAll returns the full array',
    ],
    tags: ['forms', 'FormData', 'Map'],
  },

  {
    id: 'fe-js-constraint-validation',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'Constraint Validation API Mock',
    text: 'Write a checkValidity(value, constraints) function that returns a validity object with {valid, valueMissing, tooShort, tooLong, patternMismatch}. Check constraints.required, minLength, maxLength, and pattern independently. Set valid to false if any check fails.',
    setup: 'No setup needed.',
    setupCode: `// Implement constraint validation mimicking the browser API`,
    expected: {
      valid: false,
      valueMissing: false,
      tooShort: true,
      tooLong: false,
      patternMismatch: false,
    },
    sample: `function checkValidity(value, constraints) {\n  const validity = {\n    valid: true,\n    valueMissing: false,\n    tooShort: false,\n    tooLong: false,\n    patternMismatch: false\n  };\n  if (constraints.required && !value) { validity.valueMissing = true; validity.valid = false; }\n  if (constraints.minLength && value.length < constraints.minLength) { validity.tooShort = true; validity.valid = false; }\n  if (constraints.maxLength && value.length > constraints.maxLength) { validity.tooLong = true; validity.valid = false; }\n  if (constraints.pattern && !new RegExp(constraints.pattern).test(value)) { validity.patternMismatch = true; validity.valid = false; }\n  return validity;\n}\ncheckValidity("ab", { required: true, minLength: 3, maxLength: 10, pattern: "^[a-z]+$" })`,
    hints: [
      'Start with all flags false and valid true',
      'Check each constraint and flip flags as needed',
      'Use new RegExp(pattern).test(value) for pattern matching',
    ],
    tags: ['forms', 'constraint', 'validation', 'API'],
  },

  {
    id: 'fe-js-dirty-tracking',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'easy',
    title: 'Form Dirty Tracking',
    text: 'Write a trackDirty(initial, current) function that compares two objects and returns {isDirty, changedFields}. changedFields is an array of keys where the values differ. isDirty is true if any fields changed.',
    setup: 'Initial and current form values.',
    setupCode: `// Initial and current form state\nconst initial = { name: "Alice", email: "a@b.com", age: "30" };\nconst current = { name: "Alice", email: "alice@new.com", age: "31" };`,
    expected: { isDirty: true, changedFields: ['email', 'age'] },
    sample: `function trackDirty(initial, current) {\n  const changedFields = Object.keys(current).filter(k => current[k] !== initial[k]);\n  return { isDirty: changedFields.length > 0, changedFields };\n}\ntrackDirty(initial, current)`,
    hints: [
      'Use Object.keys to iterate over field names',
      'Filter for keys where current[k] !== initial[k]',
      'isDirty is simply changedFields.length > 0',
    ],
    tags: ['forms', 'dirty', 'tracking', 'state'],
  },

  {
    id: 'fe-js-debounced-validation',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'Debounced Validation Results',
    text: 'Write a createDebouncedValidator(validateFn) returning {validate(input), getResult()}. validate stores the latest input (simulating debounce by discarding earlier calls). getResult runs validateFn on the last input. Call validate four times, then get the result.',
    setup: 'No setup needed.',
    setupCode: `// Implement debounced validation (only validates the last input)`,
    expected: 'valid',
    sample: `function createDebouncedValidator(validateFn) {\n  let lastInput = null;\n  return {\n    validate(input) { lastInput = input; },\n    getResult() { return lastInput !== null ? validateFn(lastInput) : null; }\n  };\n}\nconst dv = createDebouncedValidator(v => v.length >= 3 ? "valid" : "too short");\ndv.validate("a");\ndv.validate("ab");\ndv.validate("abc");\ndv.validate("abcd");\ndv.getResult()`,
    hints: [
      'validate just stores the input, it does not run validation yet',
      'getResult runs the validation function on the stored input',
      'Only the last validate call matters (simulates debounce)',
    ],
    tags: ['forms', 'validation', 'debounce'],
  },

  {
    id: 'fe-js-field-dependencies',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'hard',
    title: 'Field Dependency Validation',
    text: 'Write a validateWithDeps(data, rules) function. Each rule is keyed by field name and is a function (fieldValue, allData) => errorString|null. The rule receives the full form data so it can compare against other fields. Return an object of field->error for failed validations.',
    setup: 'Form data and cross-field rules.',
    setupCode: `// Form data with cross-field dependencies\nconst formData = {\n  password: "abc123",\n  confirmPassword: "abc124",\n  startDate: "2024-03-01",\n  endDate: "2024-02-01"\n};\n// Rules that reference other fields\nconst rules = {\n  confirmPassword: (val, all) => val !== all.password ? "Passwords must match" : null,\n  endDate: (val, all) => val <= all.startDate ? "End must be after start" : null\n};`,
    expected: { confirmPassword: 'Passwords must match', endDate: 'End must be after start' },
    sample: `function validateWithDeps(data, rules) {\n  const errors = {};\n  for (const [field, ruleFn] of Object.entries(rules)) {\n    const error = ruleFn(data[field], data);\n    if (error) errors[field] = error;\n  }\n  return errors;\n}\nvalidateWithDeps(formData, rules)`,
    hints: [
      'Iterate over rules entries: [fieldName, ruleFn]',
      'Pass both data[field] and the full data object to each rule',
      'Collect non-null errors into the errors object',
    ],
    tags: ['forms', 'validation', 'dependencies', 'cross-field'],
  },

  {
    id: 'fe-js-touched-fields',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'easy',
    title: 'Touched Fields Tracker',
    text: 'Write a createTouchedTracker(fields) returning {touch(field), getTouched()}. Initialize all fields as false. touch(field) sets it to true. Create a tracker for three fields, touch two of them, and return the touched state.',
    setup: 'No setup needed.',
    setupCode: `// Implement a touched field tracker`,
    expected: { name: true, email: true, age: false },
    sample: `function createTouchedTracker(fields) {\n  const touched = {};\n  fields.forEach(f => touched[f] = false);\n  return {\n    touch(field) { touched[field] = true; },\n    getTouched() { return { ...touched }; }\n  };\n}\nconst tracker = createTouchedTracker(["name", "email", "age"]);\ntracker.touch("name");\ntracker.touch("email");\ntracker.getTouched()`,
    hints: [
      'Initialize each field to false in the touched object',
      'touch() sets the field to true',
      'getTouched returns a copy of the state',
    ],
    tags: ['forms', 'touched', 'tracking'],
  },

  {
    id: 'fe-js-form-reset',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'easy',
    title: 'Form Reset to Defaults',
    text: 'Write a createForm(defaults) returning {update(field, value), reset(), getValues()}. update modifies a field. reset restores all fields to the original defaults. Update two fields, capture state, reset, capture again, and return both states.',
    setup: 'No setup needed.',
    setupCode: `// Implement form state with reset capability`,
    expected: {
      before: { name: 'Alice', email: 'alice@test.com', age: '' },
      after: { name: '', email: '', age: '' },
    },
    sample: `function createForm(defaults) {\n  let current = { ...defaults };\n  return {\n    update(field, value) { current[field] = value; },\n    reset() { current = { ...defaults }; },\n    getValues() { return { ...current }; }\n  };\n}\nconst form = createForm({ name: "", email: "", age: "" });\nform.update("name", "Alice");\nform.update("email", "alice@test.com");\nconst beforeReset = form.getValues();\nform.reset();\nconst afterReset = form.getValues();\n({ before: beforeReset, after: afterReset })`,
    hints: [
      'Spread defaults to create a working copy',
      'reset re-spreads the original defaults',
      'getValues returns a copy to prevent external mutation',
    ],
    tags: ['forms', 'reset', 'state'],
  },

  {
    id: 'fe-js-async-validation',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'hard',
    title: 'Async Field Validation',
    text: 'Write a validateFields(data, validators) function. validators is an object mapping field names to validation functions. Each validator takes a value and returns an error string or null. Collect non-null errors into a results object. Also write checkUsername (against a taken list) and checkEmail (blocking @spam.com).',
    setup: 'A list of taken usernames.',
    setupCode: `// Mock server data: taken usernames\nconst takenUsernames = ["admin", "root", "test"];`,
    expected: { username: 'Username taken' },
    sample: `function checkUsername(name) {\n  return takenUsernames.includes(name) ? "Username taken" : null;\n}\nfunction checkEmail(email) {\n  return email.endsWith("@spam.com") ? "Blocked domain" : null;\n}\nfunction validateFields(data, validators) {\n  const errors = {};\n  for (const [field, fn] of Object.entries(validators)) {\n    const error = fn(data[field]);\n    if (error) errors[field] = error;\n  }\n  return errors;\n}\nconst data = { username: "admin", email: "user@good.com" };\nconst validators = { username: checkUsername, email: checkEmail };\nvalidateFields(data, validators)`,
    hints: [
      'Each validator returns an error string or null',
      'Iterate over validators entries and call each with data[field]',
      'Only add to errors if the result is non-null',
    ],
    tags: ['forms', 'validation', 'server'],
  },

  {
    id: 'fe-js-schema-validation',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'hard',
    title: 'Schema-Based Validation',
    text: 'Write a validateSchema(data, schema) function. The schema maps field names to rules: {type, required, min}. Check required first (empty/null/undefined), then type (typeof check), then min (for numbers). Return {valid, errors} where errors is an array of {field, error}.',
    setup: 'A schema definition.',
    setupCode: `// Schema with type, required, and min constraints\nconst schema = {\n  name: { type: "string", required: true },\n  age: { type: "number", required: true, min: 0 },\n  email: { type: "string", required: false }\n};`,
    expected: {
      valid: false,
      errors: [{ field: 'age', error: 'invalid-type' }],
    },
    sample: `function validateSchema(data, schema) {\n  const errors = [];\n  for (const [field, rules] of Object.entries(schema)) {\n    const value = data[field];\n    if (rules.required && (value === undefined || value === null || value === "")) {\n      errors.push({ field, error: "required" });\n      continue;\n    }\n    if (value !== undefined && value !== null && rules.type) {\n      if (rules.type === "number" && typeof value !== "number") errors.push({ field, error: "invalid-type" });\n      if (rules.type === "string" && typeof value !== "string") errors.push({ field, error: "invalid-type" });\n    }\n    if (rules.min !== undefined && typeof value === "number" && value < rules.min) {\n      errors.push({ field, error: "below-min" });\n    }\n  }\n  return { valid: errors.length === 0, errors };\n}\nvalidateSchema({ name: "Alice", age: "thirty" }, schema)`,
    hints: [
      'Check required first; if missing, skip other checks (continue)',
      'Use typeof to check against rules.type',
      'valid is true only when errors array is empty',
    ],
    tags: ['forms', 'schema', 'validation', 'types'],
  },

  {
    id: 'fe-js-form-array-fields',
    framework: 'native-js',
    category: 'Forms & Validation',
    difficulty: 'medium',
    title: 'Dynamic Array Fields',
    text: 'Write a createArrayField(initial) returning {add(item), remove(index), getAll()}. add appends to the array. remove splices at the given index. getAll returns a copy. Start with ["js","react"], add "vue" and "angular", remove index 1 ("react"), add "svelte". Return the final list.',
    setup: 'No setup needed.',
    setupCode: `// Implement dynamic array field management`,
    expected: ['js', 'vue', 'angular', 'svelte'],
    sample: `function createArrayField(initial) {\n  const items = [...initial];\n  return {\n    add(item) { items.push(item); },\n    remove(index) { items.splice(index, 1); },\n    getAll() { return [...items]; }\n  };\n}\nconst tags = createArrayField(["js", "react"]);\ntags.add("vue");\ntags.add("angular");\ntags.remove(1);\ntags.add("svelte");\ntags.getAll()`,
    hints: [
      'Spread initial to create a working copy',
      'add uses push, remove uses splice(index, 1)',
      'getAll returns a spread copy to prevent external mutation',
    ],
    tags: ['forms', 'dynamic', 'array', 'fields'],
  },
];
