import type { Method } from '../types';

export const goMethods: Method[] = [
  // Slice Operations
  { name: 'append', category: 'Slice Operations', syntax: 'append(slice, elements...)', description: 'Appends elements to a slice and returns the updated slice.', arguments: [{ name: 'slice', type: '[]T', description: 'Slice to append to' }, { name: 'elements', type: 'T...', description: 'Elements to append' }], returns: { type: '[]T', description: 'Updated slice' }, examples: [{ code: 's := []int{1, 2}\ns = append(s, 3, 4)', output: '[1, 2, 3, 4]' }], timeComplexity: 'O(n) amortized', spaceComplexity: 'O(n)', relatedMethods: ['copy', 'make'] },
  { name: 'len', category: 'Slice Operations', syntax: 'len(slice)', description: 'Returns the length of a slice, array, map, string, or channel.', arguments: [{ name: 'v', type: 'T', description: 'Value to measure' }], returns: { type: 'int', description: 'Length' }, examples: [{ code: 'len([]int{1, 2, 3})', output: '3' }], timeComplexity: 'O(1)', spaceComplexity: 'O(1)', relatedMethods: ['cap'] },
  { name: 'cap', category: 'Slice Operations', syntax: 'cap(slice)', description: 'Returns the capacity of a slice or array.', arguments: [{ name: 'v', type: '[]T', description: 'Slice to check' }], returns: { type: 'int', description: 'Capacity' }, examples: [{ code: 's := make([]int, 2, 5)\ncap(s)', output: '5' }], timeComplexity: 'O(1)', spaceComplexity: 'O(1)', relatedMethods: ['len', 'make'] },
  { name: 'make', category: 'Slice Operations', syntax: 'make([]T, length, capacity)', description: 'Creates a slice, map, or channel with specified dimensions.', arguments: [{ name: 'type', type: 'T', description: 'Type to create' }, { name: 'length', type: 'int', description: 'Initial length' }, { name: 'capacity', type: 'int', description: 'Capacity', optional: true }], returns: { type: 'T', description: 'Initialized value' }, examples: [{ code: 'make([]int, 5)', output: '[0, 0, 0, 0, 0]' }, { code: 'make(map[string]int)', output: '{}' }], timeComplexity: 'O(n)', spaceComplexity: 'O(n)', relatedMethods: ['new', 'append'] },
  { name: 'copy', category: 'Slice Operations', syntax: 'copy(dst, src)', description: 'Copies elements from source slice to destination slice.', arguments: [{ name: 'dst', type: '[]T', description: 'Destination' }, { name: 'src', type: '[]T', description: 'Source' }], returns: { type: 'int', description: 'Number of elements copied' }, examples: [{ code: 'dst := make([]int, 3)\nsrc := []int{1, 2, 3}\ncopy(dst, src)', output: '3, dst = [1, 2, 3]' }], timeComplexity: 'O(n)', spaceComplexity: 'O(1)', relatedMethods: ['append'] },
  { name: 'slicing', category: 'Slice Operations', syntax: 'slice[low:high]', description: 'Creates a new slice from an existing slice or array.', arguments: [{ name: 'low', type: 'int', description: 'Start index (inclusive)' }, { name: 'high', type: 'int', description: 'End index (exclusive)' }], returns: { type: '[]T', description: 'New slice' }, examples: [{ code: 's := []int{0, 1, 2, 3, 4}\ns[1:4]', output: '[1, 2, 3]' }, { code: 's[:2]', output: '[0, 1]' }, { code: 's[2:]', output: '[2, 3, 4]' }], timeComplexity: 'O(1)', spaceComplexity: 'O(1)', relatedMethods: ['append', 'copy'] },

  // String Functions
  { name: 'strings.Split', category: 'String Functions', syntax: 'strings.Split(s, sep)', description: 'Splits string s around each instance of sep.', arguments: [{ name: 's', type: 'string', description: 'String to split' }, { name: 'sep', type: 'string', description: 'Separator' }], returns: { type: '[]string', description: 'Slice of substrings' }, examples: [{ code: 'strings.Split("a,b,c", ",")', output: '["a", "b", "c"]' }], timeComplexity: 'O(n)', spaceComplexity: 'O(n)', relatedMethods: ['strings.Join', 'strings.SplitN'] },
  { name: 'strings.Join', category: 'String Functions', syntax: 'strings.Join(elems, sep)', description: 'Concatenates elements with separator between.', arguments: [{ name: 'elems', type: '[]string', description: 'Elements to join' }, { name: 'sep', type: 'string', description: 'Separator' }], returns: { type: 'string', description: 'Joined string' }, examples: [{ code: 'strings.Join([]string{"a", "b", "c"}, "-")', output: '"a-b-c"' }], timeComplexity: 'O(n)', spaceComplexity: 'O(n)', relatedMethods: ['strings.Split'] },
  { name: 'strings.Contains', category: 'String Functions', syntax: 'strings.Contains(s, substr)', description: 'Reports whether substr is within s.', arguments: [{ name: 's', type: 'string', description: 'String to search' }, { name: 'substr', type: 'string', description: 'Substring to find' }], returns: { type: 'bool', description: 'true if found' }, examples: [{ code: 'strings.Contains("hello", "ell")', output: 'true' }], timeComplexity: 'O(n * m)', spaceComplexity: 'O(1)', relatedMethods: ['strings.Index', 'strings.HasPrefix'] },
  { name: 'strings.HasPrefix', category: 'String Functions', syntax: 'strings.HasPrefix(s, prefix)', description: 'Tests whether string s begins with prefix.', arguments: [{ name: 's', type: 'string', description: 'String to test' }, { name: 'prefix', type: 'string', description: 'Prefix to check' }], returns: { type: 'bool', description: 'true if s starts with prefix' }, examples: [{ code: 'strings.HasPrefix("hello", "he")', output: 'true' }], timeComplexity: 'O(len(prefix))', spaceComplexity: 'O(1)', relatedMethods: ['strings.HasSuffix', 'strings.TrimPrefix'] },
  { name: 'strings.HasSuffix', category: 'String Functions', syntax: 'strings.HasSuffix(s, suffix)', description: 'Tests whether string s ends with suffix.', arguments: [{ name: 's', type: 'string', description: 'String to test' }, { name: 'suffix', type: 'string', description: 'Suffix to check' }], returns: { type: 'bool', description: 'true if s ends with suffix' }, examples: [{ code: 'strings.HasSuffix("hello", "lo")', output: 'true' }], timeComplexity: 'O(len(suffix))', spaceComplexity: 'O(1)', relatedMethods: ['strings.HasPrefix', 'strings.TrimSuffix'] },
  { name: 'strings.ToUpper', category: 'String Functions', syntax: 'strings.ToUpper(s)', description: 'Returns s with all characters mapped to uppercase.', arguments: [{ name: 's', type: 'string', description: 'Input string' }], returns: { type: 'string', description: 'Uppercase string' }, examples: [{ code: 'strings.ToUpper("hello")', output: '"HELLO"' }], timeComplexity: 'O(n)', spaceComplexity: 'O(n)', relatedMethods: ['strings.ToLower'] },
  { name: 'strings.ToLower', category: 'String Functions', syntax: 'strings.ToLower(s)', description: 'Returns s with all characters mapped to lowercase.', arguments: [{ name: 's', type: 'string', description: 'Input string' }], returns: { type: 'string', description: 'Lowercase string' }, examples: [{ code: 'strings.ToLower("HELLO")', output: '"hello"' }], timeComplexity: 'O(n)', spaceComplexity: 'O(n)', relatedMethods: ['strings.ToUpper'] },
  { name: 'strings.TrimSpace', category: 'String Functions', syntax: 'strings.TrimSpace(s)', description: 'Returns s without leading and trailing whitespace.', arguments: [{ name: 's', type: 'string', description: 'String to trim' }], returns: { type: 'string', description: 'Trimmed string' }, examples: [{ code: 'strings.TrimSpace("  hello  ")', output: '"hello"' }], timeComplexity: 'O(n)', spaceComplexity: 'O(n)', relatedMethods: ['strings.Trim', 'strings.TrimLeft'] },
  { name: 'strings.Replace', category: 'String Functions', syntax: 'strings.Replace(s, old, new, n)', description: 'Replaces the first n occurrences of old with new.', arguments: [{ name: 's', type: 'string', description: 'Input string' }, { name: 'old', type: 'string', description: 'Substring to replace' }, { name: 'new', type: 'string', description: 'Replacement' }, { name: 'n', type: 'int', description: '-1 for all' }], returns: { type: 'string', description: 'Modified string' }, examples: [{ code: 'strings.Replace("oink oink", "oink", "moo", -1)', output: '"moo moo"' }], timeComplexity: 'O(n)', spaceComplexity: 'O(n)', relatedMethods: ['strings.ReplaceAll'] },
  { name: 'strings.Index', category: 'String Functions', syntax: 'strings.Index(s, substr)', description: 'Returns index of first instance of substr, or -1.', arguments: [{ name: 's', type: 'string', description: 'String to search' }, { name: 'substr', type: 'string', description: 'Substring to find' }], returns: { type: 'int', description: 'Index or -1' }, examples: [{ code: 'strings.Index("hello", "ll")', output: '2' }], timeComplexity: 'O(n * m)', spaceComplexity: 'O(1)', relatedMethods: ['strings.LastIndex', 'strings.Contains'] },

  // Map Operations
  { name: 'map[key]', category: 'Map Operations', syntax: 'value := m[key]', description: 'Retrieves value associated with key.', arguments: [{ name: 'key', type: 'K', description: 'Key to look up' }], returns: { type: 'V', description: 'Value or zero value' }, examples: [{ code: 'm := map[string]int{"a": 1}\nm["a"]', output: '1' }], timeComplexity: 'O(1) average', spaceComplexity: 'O(1)', relatedMethods: ['delete', 'make'] },
  { name: 'map[key] = value', category: 'Map Operations', syntax: 'm[key] = value', description: 'Sets or updates a key-value pair.', arguments: [{ name: 'key', type: 'K', description: 'Key' }, { name: 'value', type: 'V', description: 'Value' }], returns: { type: 'void', description: 'No return' }, examples: [{ code: 'm := make(map[string]int)\nm["a"] = 1', output: 'm["a"] = 1' }], timeComplexity: 'O(1) average', spaceComplexity: 'O(1)', relatedMethods: ['delete'] },
  { name: 'delete', category: 'Map Operations', syntax: 'delete(m, key)', description: 'Removes the element with the specified key.', arguments: [{ name: 'm', type: 'map[K]V', description: 'Map to modify' }, { name: 'key', type: 'K', description: 'Key to delete' }], returns: { type: 'void', description: 'No return' }, examples: [{ code: 'm := map[string]int{"a": 1}\ndelete(m, "a")', output: 'm is now empty' }], timeComplexity: 'O(1) average', spaceComplexity: 'O(1)', relatedMethods: ['make'] },
  { name: 'value, ok := m[key]', category: 'Map Operations', syntax: 'value, ok := m[key]', description: 'Checks if key exists and retrieves value.', arguments: [{ name: 'key', type: 'K', description: 'Key to check' }], returns: { type: '(V, bool)', description: 'Value and existence flag' }, examples: [{ code: 'm := map[string]int{"a": 1}\nif val, ok := m["a"]; ok { ... }', output: 'val=1, ok=true' }], timeComplexity: 'O(1) average', spaceComplexity: 'O(1)', relatedMethods: ['delete'] },

  // Sort Package
  { name: 'sort.Ints', category: 'Sort Package', syntax: 'sort.Ints(a)', description: 'Sorts a slice of ints in ascending order.', arguments: [{ name: 'a', type: '[]int', description: 'Slice to sort' }], returns: { type: 'void', description: 'Sorts in place' }, examples: [{ code: 'a := []int{3, 1, 2}\nsort.Ints(a)', output: '[1, 2, 3]' }], timeComplexity: 'O(n log n)', spaceComplexity: 'O(log n)', relatedMethods: ['sort.Strings', 'sort.Float64s'] },
  { name: 'sort.Strings', category: 'Sort Package', syntax: 'sort.Strings(a)', description: 'Sorts a slice of strings in ascending order.', arguments: [{ name: 'a', type: '[]string', description: 'Slice to sort' }], returns: { type: 'void', description: 'Sorts in place' }, examples: [{ code: 'a := []string{"c", "a", "b"}\nsort.Strings(a)', output: '["a", "b", "c"]' }], timeComplexity: 'O(n log n)', spaceComplexity: 'O(log n)', relatedMethods: ['sort.Ints', 'sort.Slice'] },
  { name: 'sort.Slice', category: 'Sort Package', syntax: 'sort.Slice(x, less)', description: 'Sorts a slice using a provided less function.', arguments: [{ name: 'x', type: 'interface{}', description: 'Slice to sort' }, { name: 'less', type: 'func(i, j int) bool', description: 'Comparison function' }], returns: { type: 'void', description: 'Sorts in place' }, examples: [{ code: 'people := []Person{{Name: "Bob"}, {Name: "Alice"}}\nsort.Slice(people, func(i, j int) bool { return people[i].Name < people[j].Name })', output: 'Sorted by name' }], timeComplexity: 'O(n log n)', spaceComplexity: 'O(log n)', relatedMethods: ['sort.SliceStable'], sinceVersion: 'Go 1.8' },
  { name: 'sort.Search', category: 'Sort Package', syntax: 'sort.Search(n, f)', description: 'Binary search for smallest index i where f(i) is true.', arguments: [{ name: 'n', type: 'int', description: 'Length of search space' }, { name: 'f', type: 'func(int) bool', description: 'Predicate function' }], returns: { type: 'int', description: 'Index found' }, examples: [{ code: 'a := []int{1, 3, 6, 10}\ni := sort.Search(len(a), func(i int) bool { return a[i] >= 6 })', output: '2' }], timeComplexity: 'O(log n)', spaceComplexity: 'O(1)', relatedMethods: ['sort.SearchInts'] },

  // strconv Package
  { name: 'strconv.Itoa', category: 'strconv Package', syntax: 'strconv.Itoa(i)', description: 'Converts an integer to a string.', arguments: [{ name: 'i', type: 'int', description: 'Integer to convert' }], returns: { type: 'string', description: 'String representation' }, examples: [{ code: 'strconv.Itoa(42)', output: '"42"' }], timeComplexity: 'O(log n)', spaceComplexity: 'O(log n)', relatedMethods: ['strconv.Atoi', 'strconv.FormatInt'] },
  { name: 'strconv.Atoi', category: 'strconv Package', syntax: 'strconv.Atoi(s)', description: 'Converts a string to an integer.', arguments: [{ name: 's', type: 'string', description: 'String to convert' }], returns: { type: '(int, error)', description: 'Integer and error' }, examples: [{ code: 'i, err := strconv.Atoi("42")', output: '42, nil' }], timeComplexity: 'O(n)', spaceComplexity: 'O(1)', relatedMethods: ['strconv.Itoa', 'strconv.ParseInt'] },

  // fmt Package
  { name: 'fmt.Sprintf', category: 'fmt Package', syntax: 'fmt.Sprintf(format, args...)', description: 'Returns a formatted string.', arguments: [{ name: 'format', type: 'string', description: 'Format string' }, { name: 'args', type: '...interface{}', description: 'Values to format' }], returns: { type: 'string', description: 'Formatted string' }, examples: [{ code: 'fmt.Sprintf("Hello %s, you are %d", "Alice", 30)', output: '"Hello Alice, you are 30"' }], timeComplexity: 'O(n)', spaceComplexity: 'O(n)', relatedMethods: ['fmt.Printf', 'fmt.Println'] },
];

export default goMethods;
