import type { Problem } from '../types';

/**
 * Haskell problems for coding drills
 * Covers list functions, string functions, higher-order functions, Maybe/Either handling, and list comprehensions
 * Total: 50 problems (20 easy, 20 medium, 10 hard)
 */

export const haskellProblems: Problem[] = [
  // ============================================================
  // LIST FUNCTIONS - map, filter, foldr, foldl, zip, zipWith, take, drop, head, tail
  // ============================================================
  {
    id: 'haskell-list-001',
    category: 'List Functions',
    difficulty: 'easy',
    title: 'Double Each Number with Map',
    text: 'Use map to double each number in the list',
    setup: 'numbers = [1, 2, 3, 4, 5]',
    setupCode: 'numbers = [1, 2, 3, 4, 5]',
    expected: [2, 4, 6, 8, 10],
    sample: 'map (*2) numbers',
    hints: ['Use map with a function that multiplies by 2', 'You can use (*2) as a section'],
    validPatterns: [/map\s*\(\s*\*\s*2\s*\)\s*numbers/, /map\s*\(\s*\\x\s*->\s*x\s*\*\s*2\s*\)\s*numbers/],
    tags: ['map', 'list', 'basic'],
  },
  {
    id: 'haskell-list-002',
    category: 'List Functions',
    difficulty: 'easy',
    title: 'Square Each Number',
    text: 'Use map to square each number in the list',
    setup: 'numbers = [1, 2, 3, 4, 5]',
    setupCode: 'numbers = [1, 2, 3, 4, 5]',
    expected: [1, 4, 9, 16, 25],
    sample: 'map (^2) numbers',
    hints: ['Use the exponentiation operator ^', 'Create a section with (^2)'],
    validPatterns: [/map\s*\(\s*\^\s*2\s*\)\s*numbers/, /map\s*\(\s*\\x\s*->\s*x\s*\^\s*2\s*\)\s*numbers/],
    tags: ['map', 'list', 'math'],
  },
  {
    id: 'haskell-list-003',
    category: 'List Functions',
    difficulty: 'easy',
    title: 'Filter Even Numbers',
    text: 'Use filter to keep only even numbers from the list',
    setup: 'numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]',
    setupCode: 'numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]',
    expected: [2, 4, 6, 8, 10],
    sample: 'filter even numbers',
    hints: ['Use the built-in even function', 'filter takes a predicate and a list'],
    validPatterns: [/filter\s+even\s+numbers/, /filter\s*\(\s*\\x\s*->\s*even\s+x\s*\)\s*numbers/],
    tags: ['filter', 'list', 'basic'],
  },
  {
    id: 'haskell-list-004',
    category: 'List Functions',
    difficulty: 'easy',
    title: 'Filter Odd Numbers',
    text: 'Use filter to keep only odd numbers from the list',
    setup: 'numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]',
    setupCode: 'numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]',
    expected: [1, 3, 5, 7, 9],
    sample: 'filter odd numbers',
    hints: ['Use the built-in odd function', 'filter keeps elements where predicate returns True'],
    validPatterns: [/filter\s+odd\s+numbers/, /filter\s*\(\s*\\x\s*->\s*odd\s+x\s*\)\s*numbers/],
    tags: ['filter', 'list', 'basic'],
  },
  {
    id: 'haskell-list-005',
    category: 'List Functions',
    difficulty: 'easy',
    title: 'Sum with Foldr',
    text: 'Use foldr to sum all numbers in the list',
    setup: 'numbers = [1, 2, 3, 4, 5]',
    setupCode: 'numbers = [1, 2, 3, 4, 5]',
    expected: 15,
    sample: 'foldr (+) 0 numbers',
    hints: ['foldr takes a binary function, initial value, and list', 'Use (+) as the combining function'],
    validPatterns: [/foldr\s*\(\+\)\s*0\s+numbers/, /foldl\s*\(\+\)\s*0\s+numbers/, /sum\s+numbers/],
    tags: ['foldr', 'fold', 'list'],
  },
  {
    id: 'haskell-list-006',
    category: 'List Functions',
    difficulty: 'easy',
    title: 'Product with Foldl',
    text: 'Use foldl to calculate the product of all numbers',
    setup: 'numbers = [1, 2, 3, 4, 5]',
    setupCode: 'numbers = [1, 2, 3, 4, 5]',
    expected: 120,
    sample: 'foldl (*) 1 numbers',
    hints: ['Use 1 as the initial value for multiplication', 'foldl processes from left to right'],
    validPatterns: [/foldl\s*\(\*\)\s*1\s+numbers/, /foldr\s*\(\*\)\s*1\s+numbers/, /product\s+numbers/],
    tags: ['foldl', 'fold', 'list'],
  },
  {
    id: 'haskell-list-007',
    category: 'List Functions',
    difficulty: 'easy',
    title: 'Take First Three Elements',
    text: 'Use take to get the first 3 elements from the list',
    setup: 'numbers = [1, 2, 3, 4, 5, 6, 7]',
    setupCode: 'numbers = [1, 2, 3, 4, 5, 6, 7]',
    expected: [1, 2, 3],
    sample: 'take 3 numbers',
    hints: ['take n returns the first n elements', 'take is safe on lists shorter than n'],
    validPatterns: [/take\s+3\s+numbers/],
    tags: ['take', 'list', 'basic'],
  },
  {
    id: 'haskell-list-008',
    category: 'List Functions',
    difficulty: 'easy',
    title: 'Drop First Three Elements',
    text: 'Use drop to remove the first 3 elements from the list',
    setup: 'numbers = [1, 2, 3, 4, 5, 6, 7]',
    setupCode: 'numbers = [1, 2, 3, 4, 5, 6, 7]',
    expected: [4, 5, 6, 7],
    sample: 'drop 3 numbers',
    hints: ['drop n removes the first n elements', 'Returns remaining elements'],
    validPatterns: [/drop\s+3\s+numbers/],
    tags: ['drop', 'list', 'basic'],
  },
  {
    id: 'haskell-list-009',
    category: 'List Functions',
    difficulty: 'easy',
    title: 'Get Head of List',
    text: 'Use head to get the first element of the list',
    setup: 'numbers = [10, 20, 30, 40, 50]',
    setupCode: 'numbers = [10, 20, 30, 40, 50]',
    expected: 10,
    sample: 'head numbers',
    hints: ['head returns the first element', 'Be careful: head fails on empty lists'],
    validPatterns: [/head\s+numbers/],
    tags: ['head', 'list', 'basic'],
  },
  {
    id: 'haskell-list-010',
    category: 'List Functions',
    difficulty: 'easy',
    title: 'Get Tail of List',
    text: 'Use tail to get all elements except the first',
    setup: 'numbers = [10, 20, 30, 40, 50]',
    setupCode: 'numbers = [10, 20, 30, 40, 50]',
    expected: [20, 30, 40, 50],
    sample: 'tail numbers',
    hints: ['tail returns everything except the first element', 'tail fails on empty lists'],
    validPatterns: [/tail\s+numbers/, /drop\s+1\s+numbers/],
    tags: ['tail', 'list', 'basic'],
  },
  {
    id: 'haskell-list-011',
    category: 'List Functions',
    difficulty: 'medium',
    title: 'Zip Two Lists',
    text: 'Use zip to pair elements from two lists',
    setup: 'names = ["Alice", "Bob", "Carol"]\nages = [25, 30, 35]',
    setupCode: 'names = ["Alice", "Bob", "Carol"]\nages = [25, 30, 35]',
    expected: [['Alice', 25], ['Bob', 30], ['Carol', 35]],
    sample: 'zip names ages',
    hints: ['zip pairs corresponding elements', 'Result length matches shorter list'],
    validPatterns: [/zip\s+names\s+ages/],
    tags: ['zip', 'list', 'tuples'],
  },
  {
    id: 'haskell-list-012',
    category: 'List Functions',
    difficulty: 'medium',
    title: 'ZipWith Addition',
    text: 'Use zipWith to add corresponding elements of two lists',
    setup: 'list1 = [1, 2, 3]\nlist2 = [10, 20, 30]',
    setupCode: 'list1 = [1, 2, 3]\nlist2 = [10, 20, 30]',
    expected: [11, 22, 33],
    sample: 'zipWith (+) list1 list2',
    hints: ['zipWith applies a function to corresponding pairs', 'Use (+) as the combining function'],
    validPatterns: [/zipWith\s*\(\+\)\s*list1\s+list2/],
    tags: ['zipWith', 'list', 'higher-order'],
  },
  {
    id: 'haskell-list-013',
    category: 'List Functions',
    difficulty: 'medium',
    title: 'Filter Numbers Greater Than',
    text: 'Use filter to keep only numbers greater than 5',
    setup: 'numbers = [1, 3, 5, 7, 9, 11]',
    setupCode: 'numbers = [1, 3, 5, 7, 9, 11]',
    expected: [7, 9, 11],
    sample: 'filter (>5) numbers',
    hints: ['Use a section (>5) for comparison', 'Sections are partially applied operators'],
    validPatterns: [/filter\s*\(\s*>\s*5\s*\)\s*numbers/, /filter\s*\(\s*\\x\s*->\s*x\s*>\s*5\s*\)\s*numbers/],
    tags: ['filter', 'list', 'sections'],
  },
  {
    id: 'haskell-list-014',
    category: 'List Functions',
    difficulty: 'medium',
    title: 'Concatenate Lists with Foldr',
    text: 'Use foldr to concatenate a list of lists into a single list',
    setup: 'lists = [[1, 2], [3, 4], [5, 6]]',
    setupCode: 'lists = [[1, 2], [3, 4], [5, 6]]',
    expected: [1, 2, 3, 4, 5, 6],
    sample: 'foldr (++) [] lists',
    hints: ['Use (++) to concatenate lists', 'Start with an empty list as initial value'],
    validPatterns: [/foldr\s*\(\+\+\)\s*\[\]\s*lists/, /concat\s+lists/],
    tags: ['foldr', 'concatenate', 'list'],
  },
  {
    id: 'haskell-list-015',
    category: 'List Functions',
    difficulty: 'hard',
    title: 'Maximum with Foldl1',
    text: 'Use foldl1 to find the maximum element in the list',
    setup: 'numbers = [3, 7, 2, 9, 4, 1]',
    setupCode: 'numbers = [3, 7, 2, 9, 4, 1]',
    expected: 9,
    sample: 'foldl1 max numbers',
    hints: ['foldl1 uses the first element as initial value', 'max compares two values'],
    validPatterns: [/foldl1\s+max\s+numbers/, /foldr1\s+max\s+numbers/, /maximum\s+numbers/],
    tags: ['foldl1', 'fold', 'list'],
  },

  // ============================================================
  // STRING FUNCTIONS - words, unwords, lines, unlines, reverse
  // ============================================================
  {
    id: 'haskell-string-001',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Split into Words',
    text: 'Use words to split a string into a list of words',
    setup: 'sentence = "Hello Haskell World"',
    setupCode: 'sentence = "Hello Haskell World"',
    expected: ['Hello', 'Haskell', 'World'],
    sample: 'words sentence',
    hints: ['words splits on whitespace', 'Returns a list of strings'],
    validPatterns: [/words\s+sentence/],
    tags: ['words', 'string', 'basic'],
  },
  {
    id: 'haskell-string-002',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Join Words with Spaces',
    text: 'Use unwords to join a list of words with spaces',
    setup: 'wordList = ["Functional", "Programming", "Rocks"]',
    setupCode: 'wordList = ["Functional", "Programming", "Rocks"]',
    expected: 'Functional Programming Rocks',
    sample: 'unwords wordList',
    hints: ['unwords is the inverse of words', 'Joins with single spaces'],
    validPatterns: [/unwords\s+wordList/],
    tags: ['unwords', 'string', 'basic'],
  },
  {
    id: 'haskell-string-003',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Split into Lines',
    text: 'Use lines to split a multi-line string into a list of lines',
    setup: 'text = "Line1\\nLine2\\nLine3"',
    setupCode: 'text = "Line1\\nLine2\\nLine3"',
    expected: ['Line1', 'Line2', 'Line3'],
    sample: 'lines text',
    hints: ['lines splits on newline characters', 'Each line becomes a list element'],
    validPatterns: [/lines\s+text/],
    tags: ['lines', 'string', 'basic'],
  },
  {
    id: 'haskell-string-004',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Join Lines with Newlines',
    text: 'Use unlines to join a list of strings with newlines',
    setup: 'lineList = ["First", "Second", "Third"]',
    setupCode: 'lineList = ["First", "Second", "Third"]',
    expected: 'First\nSecond\nThird\n',
    sample: 'unlines lineList',
    hints: ['unlines is the inverse of lines', 'Adds newline after each element'],
    validPatterns: [/unlines\s+lineList/],
    tags: ['unlines', 'string', 'basic'],
  },
  {
    id: 'haskell-string-005',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Reverse a String',
    text: 'Use reverse to reverse the characters in a string',
    setup: 'str = "Haskell"',
    setupCode: 'str = "Haskell"',
    expected: 'lleksaH',
    sample: 'reverse str',
    hints: ['Strings are lists of characters', 'reverse works on any list'],
    validPatterns: [/reverse\s+str/],
    tags: ['reverse', 'string', 'basic'],
  },
  {
    id: 'haskell-string-006',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Reverse Each Word',
    text: 'Reverse each word in the sentence while keeping word order',
    setup: 'sentence = "Hello World"',
    setupCode: 'sentence = "Hello World"',
    expected: 'olleH dlroW',
    sample: 'unwords (map reverse (words sentence))',
    hints: ['Split into words, reverse each, rejoin', 'Combine words, map, and unwords'],
    validPatterns: [/unwords\s*\(\s*map\s+reverse\s*\(\s*words\s+sentence\s*\)\s*\)/, /unwords\s*\.\s*map\s+reverse\s*\.\s*words/],
    tags: ['words', 'unwords', 'map', 'reverse'],
  },
  {
    id: 'haskell-string-007',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Count Words',
    text: 'Count the number of words in the sentence',
    setup: 'sentence = "The quick brown fox jumps"',
    setupCode: 'sentence = "The quick brown fox jumps"',
    expected: 5,
    sample: 'length (words sentence)',
    hints: ['First split into words, then count', 'length gives the size of a list'],
    validPatterns: [/length\s*\(\s*words\s+sentence\s*\)/, /length\s*\.\s*words/],
    tags: ['words', 'length', 'string'],
  },
  {
    id: 'haskell-string-008',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Count Lines',
    text: 'Count the number of lines in the text',
    setup: 'text = "Line1\\nLine2\\nLine3\\nLine4"',
    setupCode: 'text = "Line1\\nLine2\\nLine3\\nLine4"',
    expected: 4,
    sample: 'length (lines text)',
    hints: ['Split into lines first', 'Then count with length'],
    validPatterns: [/length\s*\(\s*lines\s+text\s*\)/, /length\s*\.\s*lines/],
    tags: ['lines', 'length', 'string'],
  },
  {
    id: 'haskell-string-009',
    category: 'String Functions',
    difficulty: 'hard',
    title: 'Sort Words Alphabetically',
    text: 'Sort the words in the sentence alphabetically',
    setup: 'sentence = "banana apple cherry date"',
    setupCode: 'sentence = "banana apple cherry date"',
    expected: 'apple banana cherry date',
    sample: 'unwords (sort (words sentence))',
    hints: ['Import Data.List for sort', 'Split, sort, then rejoin'],
    validPatterns: [/unwords\s*\(\s*sort\s*\(\s*words\s+sentence\s*\)\s*\)/, /unwords\s*\.\s*sort\s*\.\s*words/],
    tags: ['words', 'sort', 'unwords', 'string'],
  },
  {
    id: 'haskell-string-010',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Reverse Word Order',
    text: 'Reverse the order of words in the sentence',
    setup: 'sentence = "Haskell is awesome"',
    setupCode: 'sentence = "Haskell is awesome"',
    expected: 'awesome is Haskell',
    sample: 'unwords (reverse (words sentence))',
    hints: ['Split into words, reverse the list, rejoin', 'Use composition for elegance'],
    validPatterns: [/unwords\s*\(\s*reverse\s*\(\s*words\s+sentence\s*\)\s*\)/, /unwords\s*\.\s*reverse\s*\.\s*words/],
    tags: ['words', 'reverse', 'unwords', 'string'],
  },

  // ============================================================
  // HIGHER ORDER FUNCTIONS - composition, partial application, curry
  // ============================================================
  {
    id: 'haskell-hof-001',
    category: 'Higher Order Functions',
    difficulty: 'medium',
    title: 'Function Composition',
    text: 'Use function composition to double then add 1 to each number',
    setup: 'numbers = [1, 2, 3, 4, 5]',
    setupCode: 'numbers = [1, 2, 3, 4, 5]',
    expected: [3, 5, 7, 9, 11],
    sample: 'map ((+1) . (*2)) numbers',
    hints: ['Use (.) for function composition', 'Right function applies first'],
    validPatterns: [/map\s*\(\s*\(\+1\)\s*\.\s*\(\*2\)\s*\)\s*numbers/, /map\s*\(\s*\\x\s*->\s*x\s*\*\s*2\s*\+\s*1\s*\)\s*numbers/],
    tags: ['composition', 'map', 'higher-order'],
  },
  {
    id: 'haskell-hof-002',
    category: 'Higher Order Functions',
    difficulty: 'easy',
    title: 'Partial Application',
    text: 'Use partial application to create a function that adds 10, then map it',
    setup: 'numbers = [1, 2, 3, 4, 5]',
    setupCode: 'numbers = [1, 2, 3, 4, 5]',
    expected: [11, 12, 13, 14, 15],
    sample: 'map (+10) numbers',
    hints: ['(+10) is a partially applied function', 'It adds 10 to its argument'],
    validPatterns: [/map\s*\(\+10\)\s*numbers/, /map\s*\(\+\s*10\)\s*numbers/],
    tags: ['partial-application', 'sections', 'map'],
  },
  {
    id: 'haskell-hof-003',
    category: 'Higher Order Functions',
    difficulty: 'medium',
    title: 'Compose Filter and Map',
    text: 'Double the even numbers using composition of filter and map',
    setup: 'numbers = [1, 2, 3, 4, 5, 6]',
    setupCode: 'numbers = [1, 2, 3, 4, 5, 6]',
    expected: [4, 8, 12],
    sample: 'map (*2) (filter even numbers)',
    hints: ['First filter, then map', 'Or use composition with (.)'],
    validPatterns: [/map\s*\(\*2\)\s*\(\s*filter\s+even\s+numbers\s*\)/, /map\s*\(\*2\)\s*\.\s*filter\s+even/],
    tags: ['composition', 'filter', 'map'],
  },
  {
    id: 'haskell-hof-004',
    category: 'Higher Order Functions',
    difficulty: 'medium',
    title: 'Apply Function Twice',
    text: 'Apply the double function twice to each number',
    setup: 'numbers = [1, 2, 3]\ndouble x = x * 2',
    setupCode: 'numbers = [1, 2, 3]\ndouble x = x * 2',
    expected: [4, 8, 12],
    sample: 'map (double . double) numbers',
    hints: ['Compose double with itself', 'Or use a lambda'],
    validPatterns: [/map\s*\(\s*double\s*\.\s*double\s*\)\s*numbers/, /map\s*\(\s*\\x\s*->\s*double\s*\(\s*double\s+x\s*\)\s*\)\s*numbers/],
    tags: ['composition', 'higher-order'],
  },
  {
    id: 'haskell-hof-005',
    category: 'Higher Order Functions',
    difficulty: 'hard',
    title: 'Point-Free Style',
    text: 'Express sum of doubled numbers in point-free style',
    setup: 'numbers = [1, 2, 3, 4, 5]',
    setupCode: 'numbers = [1, 2, 3, 4, 5]',
    expected: 30,
    sample: '(sum . map (*2)) numbers',
    hints: ['Compose sum with map (*2)', 'Point-free omits the argument'],
    validPatterns: [/\(\s*sum\s*\.\s*map\s*\(\*2\)\s*\)\s*numbers/, /sum\s*\(\s*map\s*\(\*2\)\s+numbers\s*\)/],
    tags: ['point-free', 'composition', 'higher-order'],
  },
  {
    id: 'haskell-hof-006',
    category: 'Higher Order Functions',
    difficulty: 'hard',
    title: 'Curry and Uncurry',
    text: 'Use uncurry to apply (+) to a tuple',
    setup: 'pair = (3, 4)',
    setupCode: 'pair = (3, 4)',
    expected: 7,
    sample: 'uncurry (+) pair',
    hints: ['uncurry converts a curried function to work on tuples', 'It takes a function and a pair'],
    validPatterns: [/uncurry\s*\(\+\)\s*pair/],
    tags: ['curry', 'uncurry', 'tuples'],
  },
  {
    id: 'haskell-hof-007',
    category: 'Higher Order Functions',
    difficulty: 'medium',
    title: 'Flip Arguments',
    text: 'Use flip to reverse the argument order of division',
    setup: 'dividend = 2\ndivisor = 10',
    setupCode: 'dividend = 2\ndivisor = 10',
    expected: 5,
    sample: 'flip div dividend divisor',
    hints: ['flip reverses the first two arguments', 'flip div b a = div a b'],
    validPatterns: [/flip\s+div\s+dividend\s+divisor/],
    tags: ['flip', 'higher-order'],
  },
  {
    id: 'haskell-hof-008',
    category: 'Higher Order Functions',
    difficulty: 'medium',
    title: 'Apply Function to All Pairs',
    text: 'Use map and uncurry to sum pairs from a list of tuples',
    setup: 'pairs = [(1, 2), (3, 4), (5, 6)]',
    setupCode: 'pairs = [(1, 2), (3, 4), (5, 6)]',
    expected: [3, 7, 11],
    sample: 'map (uncurry (+)) pairs',
    hints: ['uncurry (+) works on tuples', 'map applies it to each pair'],
    validPatterns: [/map\s*\(\s*uncurry\s*\(\+\)\s*\)\s*pairs/],
    tags: ['uncurry', 'map', 'tuples'],
  },
  {
    id: 'haskell-hof-009',
    category: 'Higher Order Functions',
    difficulty: 'hard',
    title: 'Triple Composition',
    text: 'Compose three functions: negate, (*2), and (+1)',
    setup: 'numbers = [1, 2, 3]',
    setupCode: 'numbers = [1, 2, 3]',
    expected: [-4, -6, -8],
    sample: 'map (negate . (*2) . (+1)) numbers',
    hints: ['Functions apply right to left', 'First +1, then *2, then negate'],
    validPatterns: [/map\s*\(\s*negate\s*\.\s*\(\*2\)\s*\.\s*\(\+1\)\s*\)\s*numbers/],
    tags: ['composition', 'higher-order'],
  },
  {
    id: 'haskell-hof-010',
    category: 'Higher Order Functions',
    difficulty: 'medium',
    title: 'Dollar Operator',
    text: 'Use $ to apply a composed function without parentheses',
    setup: 'numbers = [1, 2, 3, 4, 5]',
    setupCode: 'numbers = [1, 2, 3, 4, 5]',
    expected: 30,
    sample: 'sum $ map (*2) numbers',
    hints: ['$ has low precedence and is right-associative', 'Avoids nested parentheses'],
    validPatterns: [/sum\s*\$\s*map\s*\(\*2\)\s*numbers/, /sum\s*\(\s*map\s*\(\*2\)\s*numbers\s*\)/],
    tags: ['dollar', 'operators', 'higher-order'],
  },

  // ============================================================
  // MAYBE/EITHER HANDLING - maybe, fromMaybe, either
  // ============================================================
  {
    id: 'haskell-maybe-001',
    category: 'Maybe/Either',
    difficulty: 'easy',
    title: 'Extract from Maybe with Default',
    text: 'Use fromMaybe to extract a value or provide a default',
    setup: 'maybeVal = Just 42',
    setupCode: 'maybeVal = Just 42',
    expected: 42,
    sample: 'fromMaybe 0 maybeVal',
    hints: ['fromMaybe takes a default and a Maybe', 'Returns the value if Just, default if Nothing'],
    validPatterns: [/fromMaybe\s+0\s+maybeVal/],
    tags: ['maybe', 'fromMaybe', 'monads'],
  },
  {
    id: 'haskell-maybe-002',
    category: 'Maybe/Either',
    difficulty: 'easy',
    title: 'Handle Nothing Case',
    text: 'Use fromMaybe to provide a default when value is Nothing',
    setup: 'maybeVal = Nothing',
    setupCode: 'maybeVal = Nothing',
    expected: -1,
    sample: 'fromMaybe (-1) maybeVal',
    hints: ['Nothing has no value', 'Default is used when value is Nothing'],
    validPatterns: [/fromMaybe\s*\(\s*-1\s*\)\s*maybeVal/],
    tags: ['maybe', 'fromMaybe', 'monads'],
  },
  {
    id: 'haskell-maybe-003',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'Maybe with Function',
    text: 'Use maybe to apply a function or return default',
    setup: 'maybeVal = Just 5',
    setupCode: 'maybeVal = Just 5',
    expected: 10,
    sample: 'maybe 0 (*2) maybeVal',
    hints: ['maybe takes default, function, and Maybe', 'Applies function to Just value'],
    validPatterns: [/maybe\s+0\s*\(\*2\)\s*maybeVal/],
    tags: ['maybe', 'higher-order', 'monads'],
  },
  {
    id: 'haskell-maybe-004',
    category: 'Maybe/Either',
    difficulty: 'hard',
    title: 'Either Left Case',
    text: 'Use either to handle the Left case',
    setup: 'result = Left "error"',
    setupCode: 'result = Left "error"',
    expected: 'Error: error',
    sample: 'either (("Error: " ++) ) show result',
    hints: ['either takes two functions', 'First function handles Left'],
    validPatterns: [/either\s*\(\s*\(\s*"Error:\s*"\s*\+\+\s*\)\s*\)/],
    tags: ['either', 'error-handling', 'monads'],
  },
  {
    id: 'haskell-maybe-005',
    category: 'Maybe/Either',
    difficulty: 'hard',
    title: 'Either Right Case',
    text: 'Use either to handle the Right case and double the value',
    setup: 'result = Right 21',
    setupCode: 'result = Right 21',
    expected: 42,
    sample: 'either (const 0) (*2) result',
    hints: ['Second function handles Right', 'const ignores the Left value'],
    validPatterns: [/either\s*\(\s*const\s+0\s*\)\s*\(\*2\)\s*result/],
    tags: ['either', 'error-handling', 'monads'],
  },
  {
    id: 'haskell-maybe-006',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'Map Over Maybe',
    text: 'Use fmap to apply a function inside Maybe',
    setup: 'maybeVal = Just 10',
    setupCode: 'maybeVal = Just 10',
    expected: 'Just 20',
    sample: 'fmap (*2) maybeVal',
    hints: ['fmap works on any Functor', 'Maybe is a Functor'],
    validPatterns: [/fmap\s*\(\*2\)\s*maybeVal/, /\(\*2\)\s*<\$>\s*maybeVal/],
    tags: ['fmap', 'functor', 'maybe'],
  },
  {
    id: 'haskell-maybe-007',
    category: 'Maybe/Either',
    difficulty: 'hard',
    title: 'Chain Maybe Operations',
    text: 'Use >>= to chain Maybe operations (safe division)',
    setup: 'safeDiv x y = if y == 0 then Nothing else Just (x `div` y)\nstart = Just 100',
    setupCode: 'safeDiv x y = if y == 0 then Nothing else Just (x `div` y)\nstart = Just 100',
    expected: 'Just 10',
    sample: 'start >>= (\\x -> safeDiv x 10)',
    hints: ['>>= is monadic bind', 'Chains computations that might fail'],
    validPatterns: [/start\s*>>=\s*\(\s*\\x\s*->\s*safeDiv\s+x\s+10\s*\)/, /start\s*>>=\s*flip\s+safeDiv\s+10/],
    tags: ['bind', 'monad', 'maybe'],
  },
  {
    id: 'haskell-maybe-008',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'Filter Maybe Values',
    text: 'Use catMaybes to extract Just values from a list',
    setup: 'maybes = [Just 1, Nothing, Just 2, Nothing, Just 3]',
    setupCode: 'maybes = [Just 1, Nothing, Just 2, Nothing, Just 3]',
    expected: [1, 2, 3],
    sample: 'catMaybes maybes',
    hints: ['catMaybes is from Data.Maybe', 'It filters out Nothing values'],
    validPatterns: [/catMaybes\s+maybes/],
    tags: ['catMaybes', 'maybe', 'list'],
  },
  {
    id: 'haskell-maybe-009',
    category: 'Maybe/Either',
    difficulty: 'hard',
    title: 'Map Maybe with mapMaybe',
    text: 'Use mapMaybe to filter and transform in one step',
    setup: 'numbers = [1, 2, 3, 4, 5, 6]\nsafeEven x = if even x then Just (x * 2) else Nothing',
    setupCode: 'numbers = [1, 2, 3, 4, 5, 6]\nsafeEven x = if even x then Just (x * 2) else Nothing',
    expected: [4, 8, 12],
    sample: 'mapMaybe safeEven numbers',
    hints: ['mapMaybe combines map and catMaybes', 'Filters and transforms simultaneously'],
    validPatterns: [/mapMaybe\s+safeEven\s+numbers/],
    tags: ['mapMaybe', 'maybe', 'filter'],
  },

  // ============================================================
  // LIST COMPREHENSIONS
  // ============================================================
  {
    id: 'haskell-comp-001',
    category: 'List Comprehensions',
    difficulty: 'easy',
    title: 'Basic List Comprehension',
    text: 'Use a list comprehension to double each number',
    setup: 'numbers = [1, 2, 3, 4, 5]',
    setupCode: 'numbers = [1, 2, 3, 4, 5]',
    expected: [2, 4, 6, 8, 10],
    sample: '[x * 2 | x <- numbers]',
    hints: ['Use the pattern [expression | generator]', 'x <- numbers draws from the list'],
    validPatterns: [/\[\s*x\s*\*\s*2\s*\|\s*x\s*<-\s*numbers\s*\]/],
    tags: ['list-comprehension', 'basic'],
  },
  {
    id: 'haskell-comp-002',
    category: 'List Comprehensions',
    difficulty: 'easy',
    title: 'List Comprehension with Filter',
    text: 'Use a list comprehension to get even numbers',
    setup: 'numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]',
    setupCode: 'numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]',
    expected: [2, 4, 6, 8, 10],
    sample: '[x | x <- numbers, even x]',
    hints: ['Add a guard after the generator', 'Guards filter which elements to include'],
    validPatterns: [/\[\s*x\s*\|\s*x\s*<-\s*numbers\s*,\s*even\s+x\s*\]/],
    tags: ['list-comprehension', 'filter'],
  },
  {
    id: 'haskell-comp-003',
    category: 'List Comprehensions',
    difficulty: 'medium',
    title: 'Transform and Filter',
    text: 'Double only the even numbers using a list comprehension',
    setup: 'numbers = [1, 2, 3, 4, 5, 6]',
    setupCode: 'numbers = [1, 2, 3, 4, 5, 6]',
    expected: [4, 8, 12],
    sample: '[x * 2 | x <- numbers, even x]',
    hints: ['Combine transformation in expression with filter guard', 'Guard comes after generator'],
    validPatterns: [/\[\s*x\s*\*\s*2\s*\|\s*x\s*<-\s*numbers\s*,\s*even\s+x\s*\]/],
    tags: ['list-comprehension', 'filter', 'transform'],
  },
  {
    id: 'haskell-comp-004',
    category: 'List Comprehensions',
    difficulty: 'medium',
    title: 'Cartesian Product',
    text: 'Generate all pairs from two lists',
    setup: 'xs = [1, 2]\nys = [3, 4]',
    setupCode: 'xs = [1, 2]\nys = [3, 4]',
    expected: [[1, 3], [1, 4], [2, 3], [2, 4]],
    sample: '[(x, y) | x <- xs, y <- ys]',
    hints: ['Use multiple generators', 'Each combination is generated'],
    validPatterns: [/\[\s*\(\s*x\s*,\s*y\s*\)\s*\|\s*x\s*<-\s*xs\s*,\s*y\s*<-\s*ys\s*\]/],
    tags: ['list-comprehension', 'cartesian', 'tuples'],
  },
  {
    id: 'haskell-comp-005',
    category: 'List Comprehensions',
    difficulty: 'hard',
    title: 'Pythagorean Triples',
    text: 'Generate Pythagorean triples up to 10',
    setup: 'limit = 10',
    setupCode: 'limit = 10',
    expected: [[3, 4, 5], [6, 8, 10]],
    sample: '[(a,b,c) | c <- [1..limit], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2]',
    hints: ['Use three generators with constraints', 'Guard checks the Pythagorean property'],
    validPatterns: [/\[\s*\(\s*a\s*,\s*b\s*,\s*c\s*\)\s*\|.*a\s*\^\s*2\s*\+\s*b\s*\^\s*2\s*==\s*c\s*\^\s*2\s*\]/],
    tags: ['list-comprehension', 'math', 'triples'],
  },
  {
    id: 'haskell-comp-006',
    category: 'List Comprehensions',
    difficulty: 'medium',
    title: 'String Comprehension',
    text: 'Convert a string to uppercase using comprehension',
    setup: 'str = "hello"',
    setupCode: 'str = "hello"',
    expected: 'HELLO',
    sample: '[toUpper c | c <- str]',
    hints: ['Strings are lists of Char', 'toUpper is from Data.Char'],
    validPatterns: [/\[\s*toUpper\s+c\s*\|\s*c\s*<-\s*str\s*\]/],
    tags: ['list-comprehension', 'string', 'char'],
  },
];
