import type { Problem } from '../types';

/**
 * Haskell problems for coding drills
 * Covers list functions, string functions, higher-order functions, Maybe/Either handling, and list comprehensions
 * Total: 50 problems (20 easy, 20 medium, 10 hard)
 */

export const haskellProblems: Problem[] = [
  // ============================================================
  // LIST FUNCTIONS - map, filter, foldr, foldl, zip, zipWith, take, drop, head, tail
  // ============================================================
  {
    id: 'haskell-list-001',
    category: 'List Functions',
    difficulty: 'easy',
    title: 'Double Each Number with Map',
    text: 'Use map to double each number in the list',
    setup: 'numbers = [1, 2, 3, 4, 5]',
    setupCode: 'numbers = [1, 2, 3, 4, 5]',
    expected: [2, 4, 6, 8, 10],
    sample: 'map (*2) numbers',
    hints: ['Use map with a function that multiplies by 2', 'You can use (*2) as a section'],
    validPatterns: [
      /map\s*\(\s*\*\s*2\s*\)\s*numbers/,
      /map\s*\(\s*\\x\s*->\s*x\s*\*\s*2\s*\)\s*numbers/,
    ],
    tags: ['map', 'list', 'basic'],
  },
  {
    id: 'haskell-list-002',
    category: 'List Functions',
    difficulty: 'easy',
    title: 'Square Each Number',
    text: 'Use map to square each number in the list',
    setup: 'numbers = [1, 2, 3, 4, 5]',
    setupCode: 'numbers = [1, 2, 3, 4, 5]',
    expected: [1, 4, 9, 16, 25],
    sample: 'map (^2) numbers',
    hints: ['Use the exponentiation operator ^', 'Create a section with (^2)'],
    validPatterns: [
      /map\s*\(\s*\^\s*2\s*\)\s*numbers/,
      /map\s*\(\s*\\x\s*->\s*x\s*\^\s*2\s*\)\s*numbers/,
    ],
    tags: ['map', 'list', 'math'],
  },
  {
    id: 'haskell-list-003',
    category: 'List Functions',
    difficulty: 'easy',
    title: 'Filter Even Numbers',
    text: 'Use filter to keep only even numbers from the list',
    setup: 'numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]',
    setupCode: 'numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]',
    expected: [2, 4, 6, 8, 10],
    sample: 'filter even numbers',
    hints: ['Use the built-in even function', 'filter takes a predicate and a list'],
    validPatterns: [/filter\s+even\s+numbers/, /filter\s*\(\s*\\x\s*->\s*even\s+x\s*\)\s*numbers/],
    tags: ['filter', 'list', 'basic'],
  },
  {
    id: 'haskell-list-004',
    category: 'List Functions',
    difficulty: 'easy',
    title: 'Filter Odd Numbers',
    text: 'Use filter to keep only odd numbers from the list',
    setup: 'numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]',
    setupCode: 'numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]',
    expected: [1, 3, 5, 7, 9],
    sample: 'filter odd numbers',
    hints: ['Use the built-in odd function', 'filter keeps elements where predicate returns True'],
    validPatterns: [/filter\s+odd\s+numbers/, /filter\s*\(\s*\\x\s*->\s*odd\s+x\s*\)\s*numbers/],
    tags: ['filter', 'list', 'basic'],
  },
  {
    id: 'haskell-list-005',
    category: 'List Functions',
    difficulty: 'easy',
    title: 'Sum with Foldr',
    text: 'Use foldr to sum all numbers in the list',
    setup: 'numbers = [1, 2, 3, 4, 5]',
    setupCode: 'numbers = [1, 2, 3, 4, 5]',
    expected: 15,
    sample: 'foldr (+) 0 numbers',
    hints: [
      'foldr takes a binary function, initial value, and list',
      'Use (+) as the combining function',
    ],
    validPatterns: [
      /foldr\s*\(\+\)\s*0\s+numbers/,
      /foldl\s*\(\+\)\s*0\s+numbers/,
      /sum\s+numbers/,
    ],
    tags: ['foldr', 'fold', 'list'],
  },
  {
    id: 'haskell-list-006',
    category: 'List Functions',
    difficulty: 'easy',
    title: 'Product with Foldl',
    text: 'Use foldl to calculate the product of all numbers',
    setup: 'numbers = [1, 2, 3, 4, 5]',
    setupCode: 'numbers = [1, 2, 3, 4, 5]',
    expected: 120,
    sample: 'foldl (*) 1 numbers',
    hints: ['Use 1 as the initial value for multiplication', 'foldl processes from left to right'],
    validPatterns: [
      /foldl\s*\(\*\)\s*1\s+numbers/,
      /foldr\s*\(\*\)\s*1\s+numbers/,
      /product\s+numbers/,
    ],
    tags: ['foldl', 'fold', 'list'],
  },
  {
    id: 'haskell-list-007',
    category: 'List Functions',
    difficulty: 'easy',
    title: 'Take First Three Elements',
    text: 'Use take to get the first 3 elements from the list',
    setup: 'numbers = [1, 2, 3, 4, 5, 6, 7]',
    setupCode: 'numbers = [1, 2, 3, 4, 5, 6, 7]',
    expected: [1, 2, 3],
    sample: 'take 3 numbers',
    hints: ['take n returns the first n elements', 'take is safe on lists shorter than n'],
    validPatterns: [/take\s+3\s+numbers/],
    tags: ['take', 'list', 'basic'],
  },
  {
    id: 'haskell-list-008',
    category: 'List Functions',
    difficulty: 'easy',
    title: 'Drop First Three Elements',
    text: 'Use drop to remove the first 3 elements from the list',
    setup: 'numbers = [1, 2, 3, 4, 5, 6, 7]',
    setupCode: 'numbers = [1, 2, 3, 4, 5, 6, 7]',
    expected: [4, 5, 6, 7],
    sample: 'drop 3 numbers',
    hints: ['drop n removes the first n elements', 'Returns remaining elements'],
    validPatterns: [/drop\s+3\s+numbers/],
    tags: ['drop', 'list', 'basic'],
  },
  {
    id: 'haskell-list-009',
    category: 'List Functions',
    difficulty: 'easy',
    title: 'Get Head of List',
    text: 'Use head to get the first element of the list',
    setup: 'numbers = [10, 20, 30, 40, 50]',
    setupCode: 'numbers = [10, 20, 30, 40, 50]',
    expected: 10,
    sample: 'head numbers',
    hints: ['head returns the first element', 'Be careful: head fails on empty lists'],
    validPatterns: [/head\s+numbers/],
    tags: ['head', 'list', 'basic'],
  },
  {
    id: 'haskell-list-010',
    category: 'List Functions',
    difficulty: 'easy',
    title: 'Get Tail of List',
    text: 'Use tail to get all elements except the first',
    setup: 'numbers = [10, 20, 30, 40, 50]',
    setupCode: 'numbers = [10, 20, 30, 40, 50]',
    expected: [20, 30, 40, 50],
    sample: 'tail numbers',
    hints: ['tail returns everything except the first element', 'tail fails on empty lists'],
    validPatterns: [/tail\s+numbers/, /drop\s+1\s+numbers/],
    tags: ['tail', 'list', 'basic'],
  },
  {
    id: 'haskell-list-011',
    category: 'List Functions',
    difficulty: 'medium',
    title: 'Zip Two Lists',
    text: 'Use zip to pair elements from two lists',
    setup: 'names = ["Alice", "Bob", "Carol"]\nages = [25, 30, 35]',
    setupCode: 'names = ["Alice", "Bob", "Carol"]\nages = [25, 30, 35]',
    expected: [
      ['Alice', 25],
      ['Bob', 30],
      ['Carol', 35],
    ],
    sample: 'zip names ages',
    hints: ['zip pairs corresponding elements', 'Result length matches shorter list'],
    validPatterns: [/zip\s+names\s+ages/],
    tags: ['zip', 'list', 'tuples'],
  },
  {
    id: 'haskell-list-012',
    category: 'List Functions',
    difficulty: 'medium',
    title: 'ZipWith Addition',
    text: 'Use zipWith to add corresponding elements of two lists',
    setup: 'list1 = [1, 2, 3]\nlist2 = [10, 20, 30]',
    setupCode: 'list1 = [1, 2, 3]\nlist2 = [10, 20, 30]',
    expected: [11, 22, 33],
    sample: 'zipWith (+) list1 list2',
    hints: [
      'zipWith applies a function to corresponding pairs',
      'Use (+) as the combining function',
    ],
    validPatterns: [/zipWith\s*\(\+\)\s*list1\s+list2/],
    tags: ['zipWith', 'list', 'higher-order'],
  },
  {
    id: 'haskell-list-013',
    category: 'List Functions',
    difficulty: 'medium',
    title: 'Filter Numbers Greater Than',
    text: 'Use filter to keep only numbers greater than 5',
    setup: 'numbers = [1, 3, 5, 7, 9, 11]',
    setupCode: 'numbers = [1, 3, 5, 7, 9, 11]',
    expected: [7, 9, 11],
    sample: 'filter (>5) numbers',
    hints: ['Use a section (>5) for comparison', 'Sections are partially applied operators'],
    validPatterns: [
      /filter\s*\(\s*>\s*5\s*\)\s*numbers/,
      /filter\s*\(\s*\\x\s*->\s*x\s*>\s*5\s*\)\s*numbers/,
    ],
    tags: ['filter', 'list', 'sections'],
  },
  {
    id: 'haskell-list-014',
    category: 'List Functions',
    difficulty: 'medium',
    title: 'Concatenate Lists with Foldr',
    text: 'Use foldr to concatenate a list of lists into a single list',
    setup: 'lists = [[1, 2], [3, 4], [5, 6]]',
    setupCode: 'lists = [[1, 2], [3, 4], [5, 6]]',
    expected: [1, 2, 3, 4, 5, 6],
    sample: 'foldr (++) [] lists',
    hints: ['Use (++) to concatenate lists', 'Start with an empty list as initial value'],
    validPatterns: [/foldr\s*\(\+\+\)\s*\[\]\s*lists/, /concat\s+lists/],
    tags: ['foldr', 'concatenate', 'list'],
  },
  {
    id: 'haskell-list-015',
    category: 'List Functions',
    difficulty: 'hard',
    title: 'Maximum with Foldl1',
    text: 'Use foldl1 to find the maximum element in the list',
    setup: 'numbers = [3, 7, 2, 9, 4, 1]',
    setupCode: 'numbers = [3, 7, 2, 9, 4, 1]',
    expected: 9,
    sample: 'foldl1 max numbers',
    hints: ['foldl1 uses the first element as initial value', 'max compares two values'],
    validPatterns: [/foldl1\s+max\s+numbers/, /foldr1\s+max\s+numbers/, /maximum\s+numbers/],
    tags: ['foldl1', 'fold', 'list'],
  },

  // ============================================================
  // STRING FUNCTIONS - words, unwords, lines, unlines, reverse
  // ============================================================
  {
    id: 'haskell-string-001',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Split into Words',
    text: 'Use words to split a string into a list of words',
    setup: 'sentence = "Hello Haskell World"',
    setupCode: 'sentence = "Hello Haskell World"',
    expected: ['Hello', 'Haskell', 'World'],
    sample: 'words sentence',
    hints: ['words splits on whitespace', 'Returns a list of strings'],
    validPatterns: [/words\s+sentence/],
    tags: ['words', 'string', 'basic'],
  },
  {
    id: 'haskell-string-002',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Join Words with Spaces',
    text: 'Use unwords to join a list of words with spaces',
    setup: 'wordList = ["Functional", "Programming", "Rocks"]',
    setupCode: 'wordList = ["Functional", "Programming", "Rocks"]',
    expected: 'Functional Programming Rocks',
    sample: 'unwords wordList',
    hints: ['unwords is the inverse of words', 'Joins with single spaces'],
    validPatterns: [/unwords\s+wordList/],
    tags: ['unwords', 'string', 'basic'],
  },
  {
    id: 'haskell-string-003',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Split into Lines',
    text: 'Use lines to split a multi-line string into a list of lines',
    setup: 'text = "Line1\\nLine2\\nLine3"',
    setupCode: 'text = "Line1\\nLine2\\nLine3"',
    expected: ['Line1', 'Line2', 'Line3'],
    sample: 'lines text',
    hints: ['lines splits on newline characters', 'Each line becomes a list element'],
    validPatterns: [/lines\s+text/],
    tags: ['lines', 'string', 'basic'],
  },
  {
    id: 'haskell-string-004',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Join Lines with Newlines',
    text: 'Use unlines to join a list of strings with newlines',
    setup: 'lineList = ["First", "Second", "Third"]',
    setupCode: 'lineList = ["First", "Second", "Third"]',
    expected: 'First\nSecond\nThird\n',
    sample: 'unlines lineList',
    hints: ['unlines is the inverse of lines', 'Adds newline after each element'],
    validPatterns: [/unlines\s+lineList/],
    tags: ['unlines', 'string', 'basic'],
  },
  {
    id: 'haskell-string-005',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Reverse a String',
    text: 'Use reverse to reverse the characters in a string',
    setup: 'str = "Haskell"',
    setupCode: 'str = "Haskell"',
    expected: 'lleksaH',
    sample: 'reverse str',
    hints: ['Strings are lists of characters', 'reverse works on any list'],
    validPatterns: [/reverse\s+str/],
    tags: ['reverse', 'string', 'basic'],
  },
  {
    id: 'haskell-string-006',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Reverse Each Word',
    text: 'Reverse each word in the sentence while keeping word order',
    setup: 'sentence = "Hello World"',
    setupCode: 'sentence = "Hello World"',
    expected: 'olleH dlroW',
    sample: 'unwords (map reverse (words sentence))',
    hints: ['Split into words, reverse each, rejoin', 'Combine words, map, and unwords'],
    validPatterns: [
      /unwords\s*\(\s*map\s+reverse\s*\(\s*words\s+sentence\s*\)\s*\)/,
      /unwords\s*\.\s*map\s+reverse\s*\.\s*words/,
    ],
    tags: ['words', 'unwords', 'map', 'reverse'],
  },
  {
    id: 'haskell-string-007',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Count Words',
    text: 'Count the number of words in the sentence',
    setup: 'sentence = "The quick brown fox jumps"',
    setupCode: 'sentence = "The quick brown fox jumps"',
    expected: 5,
    sample: 'length (words sentence)',
    hints: ['First split into words, then count', 'length gives the size of a list'],
    validPatterns: [/length\s*\(\s*words\s+sentence\s*\)/, /length\s*\.\s*words/],
    tags: ['words', 'length', 'string'],
  },
  {
    id: 'haskell-string-008',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Count Lines',
    text: 'Count the number of lines in the text',
    setup: 'text = "Line1\\nLine2\\nLine3\\nLine4"',
    setupCode: 'text = "Line1\\nLine2\\nLine3\\nLine4"',
    expected: 4,
    sample: 'length (lines text)',
    hints: ['Split into lines first', 'Then count with length'],
    validPatterns: [/length\s*\(\s*lines\s+text\s*\)/, /length\s*\.\s*lines/],
    tags: ['lines', 'length', 'string'],
  },
  {
    id: 'haskell-string-009',
    category: 'String Functions',
    difficulty: 'hard',
    title: 'Sort Words Alphabetically',
    text: 'Sort the words in the sentence alphabetically',
    setup: 'sentence = "banana apple cherry date"',
    setupCode: 'sentence = "banana apple cherry date"',
    expected: 'apple banana cherry date',
    sample: 'unwords (sort (words sentence))',
    hints: ['Import Data.List for sort', 'Split, sort, then rejoin'],
    validPatterns: [
      /unwords\s*\(\s*sort\s*\(\s*words\s+sentence\s*\)\s*\)/,
      /unwords\s*\.\s*sort\s*\.\s*words/,
    ],
    tags: ['words', 'sort', 'unwords', 'string'],
  },
  {
    id: 'haskell-string-010',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Reverse Word Order',
    text: 'Reverse the order of words in the sentence',
    setup: 'sentence = "Haskell is awesome"',
    setupCode: 'sentence = "Haskell is awesome"',
    expected: 'awesome is Haskell',
    sample: 'unwords (reverse (words sentence))',
    hints: ['Split into words, reverse the list, rejoin', 'Use composition for elegance'],
    validPatterns: [
      /unwords\s*\(\s*reverse\s*\(\s*words\s+sentence\s*\)\s*\)/,
      /unwords\s*\.\s*reverse\s*\.\s*words/,
    ],
    tags: ['words', 'reverse', 'unwords', 'string'],
  },

  // ============================================================
  // HIGHER ORDER FUNCTIONS - composition, partial application, curry
  // ============================================================
  {
    id: 'haskell-hof-001',
    category: 'Higher Order Functions',
    difficulty: 'medium',
    title: 'Function Composition',
    text: 'Use function composition to double then add 1 to each number',
    setup: 'numbers = [1, 2, 3, 4, 5]',
    setupCode: 'numbers = [1, 2, 3, 4, 5]',
    expected: [3, 5, 7, 9, 11],
    sample: 'map ((+1) . (*2)) numbers',
    hints: ['Use (.) for function composition', 'Right function applies first'],
    validPatterns: [
      /map\s*\(\s*\(\+1\)\s*\.\s*\(\*2\)\s*\)\s*numbers/,
      /map\s*\(\s*\\x\s*->\s*x\s*\*\s*2\s*\+\s*1\s*\)\s*numbers/,
    ],
    tags: ['composition', 'map', 'higher-order'],
  },
  {
    id: 'haskell-hof-002',
    category: 'Higher Order Functions',
    difficulty: 'easy',
    title: 'Partial Application',
    text: 'Use partial application to create a function that adds 10, then map it',
    setup: 'numbers = [1, 2, 3, 4, 5]',
    setupCode: 'numbers = [1, 2, 3, 4, 5]',
    expected: [11, 12, 13, 14, 15],
    sample: 'map (+10) numbers',
    hints: ['(+10) is a partially applied function', 'It adds 10 to its argument'],
    validPatterns: [/map\s*\(\+10\)\s*numbers/, /map\s*\(\+\s*10\)\s*numbers/],
    tags: ['partial-application', 'sections', 'map'],
  },
  {
    id: 'haskell-hof-003',
    category: 'Higher Order Functions',
    difficulty: 'medium',
    title: 'Compose Filter and Map',
    text: 'Double the even numbers using composition of filter and map',
    setup: 'numbers = [1, 2, 3, 4, 5, 6]',
    setupCode: 'numbers = [1, 2, 3, 4, 5, 6]',
    expected: [4, 8, 12],
    sample: 'map (*2) (filter even numbers)',
    hints: ['First filter, then map', 'Or use composition with (.)'],
    validPatterns: [
      /map\s*\(\*2\)\s*\(\s*filter\s+even\s+numbers\s*\)/,
      /map\s*\(\*2\)\s*\.\s*filter\s+even/,
    ],
    tags: ['composition', 'filter', 'map'],
  },
  {
    id: 'haskell-hof-004',
    category: 'Higher Order Functions',
    difficulty: 'medium',
    title: 'Apply Function Twice',
    text: 'Apply the double function twice to each number',
    setup: 'numbers = [1, 2, 3]\ndouble x = x * 2',
    setupCode: 'numbers = [1, 2, 3]\ndouble x = x * 2',
    expected: [4, 8, 12],
    sample: 'map (double . double) numbers',
    hints: ['Compose double with itself', 'Or use a lambda'],
    validPatterns: [
      /map\s*\(\s*double\s*\.\s*double\s*\)\s*numbers/,
      /map\s*\(\s*\\x\s*->\s*double\s*\(\s*double\s+x\s*\)\s*\)\s*numbers/,
    ],
    tags: ['composition', 'higher-order'],
  },
  {
    id: 'haskell-hof-005',
    category: 'Higher Order Functions',
    difficulty: 'hard',
    title: 'Point-Free Style',
    text: 'Express sum of doubled numbers in point-free style',
    setup: 'numbers = [1, 2, 3, 4, 5]',
    setupCode: 'numbers = [1, 2, 3, 4, 5]',
    expected: 30,
    sample: '(sum . map (*2)) numbers',
    hints: ['Compose sum with map (*2)', 'Point-free omits the argument'],
    validPatterns: [
      /\(\s*sum\s*\.\s*map\s*\(\*2\)\s*\)\s*numbers/,
      /sum\s*\(\s*map\s*\(\*2\)\s+numbers\s*\)/,
    ],
    tags: ['point-free', 'composition', 'higher-order'],
  },
  {
    id: 'haskell-hof-006',
    category: 'Higher Order Functions',
    difficulty: 'hard',
    title: 'Curry and Uncurry',
    text: 'Use uncurry to apply (+) to a tuple',
    setup: 'pair = (3, 4)',
    setupCode: 'pair = (3, 4)',
    expected: 7,
    sample: 'uncurry (+) pair',
    hints: [
      'uncurry converts a curried function to work on tuples',
      'It takes a function and a pair',
    ],
    validPatterns: [/uncurry\s*\(\+\)\s*pair/],
    tags: ['curry', 'uncurry', 'tuples'],
  },
  {
    id: 'haskell-hof-007',
    category: 'Higher Order Functions',
    difficulty: 'medium',
    title: 'Flip Arguments',
    text: 'Use flip to reverse the argument order of division',
    setup: 'dividend = 2\ndivisor = 10',
    setupCode: 'dividend = 2\ndivisor = 10',
    expected: 5,
    sample: 'flip div dividend divisor',
    hints: ['flip reverses the first two arguments', 'flip div b a = div a b'],
    validPatterns: [/flip\s+div\s+dividend\s+divisor/],
    tags: ['flip', 'higher-order'],
  },
  {
    id: 'haskell-hof-008',
    category: 'Higher Order Functions',
    difficulty: 'medium',
    title: 'Apply Function to All Pairs',
    text: 'Use map and uncurry to sum pairs from a list of tuples',
    setup: 'pairs = [(1, 2), (3, 4), (5, 6)]',
    setupCode: 'pairs = [(1, 2), (3, 4), (5, 6)]',
    expected: [3, 7, 11],
    sample: 'map (uncurry (+)) pairs',
    hints: ['uncurry (+) works on tuples', 'map applies it to each pair'],
    validPatterns: [/map\s*\(\s*uncurry\s*\(\+\)\s*\)\s*pairs/],
    tags: ['uncurry', 'map', 'tuples'],
  },
  {
    id: 'haskell-hof-009',
    category: 'Higher Order Functions',
    difficulty: 'hard',
    title: 'Triple Composition',
    text: 'Compose three functions: negate, (*2), and (+1)',
    setup: 'numbers = [1, 2, 3]',
    setupCode: 'numbers = [1, 2, 3]',
    expected: [-4, -6, -8],
    sample: 'map (negate . (*2) . (+1)) numbers',
    hints: ['Functions apply right to left', 'First +1, then *2, then negate'],
    validPatterns: [/map\s*\(\s*negate\s*\.\s*\(\*2\)\s*\.\s*\(\+1\)\s*\)\s*numbers/],
    tags: ['composition', 'higher-order'],
  },
  {
    id: 'haskell-hof-010',
    category: 'Higher Order Functions',
    difficulty: 'medium',
    title: 'Dollar Operator',
    text: 'Use $ to apply a composed function without parentheses',
    setup: 'numbers = [1, 2, 3, 4, 5]',
    setupCode: 'numbers = [1, 2, 3, 4, 5]',
    expected: 30,
    sample: 'sum $ map (*2) numbers',
    hints: ['$ has low precedence and is right-associative', 'Avoids nested parentheses'],
    validPatterns: [
      /sum\s*\$\s*map\s*\(\*2\)\s*numbers/,
      /sum\s*\(\s*map\s*\(\*2\)\s*numbers\s*\)/,
    ],
    tags: ['dollar', 'operators', 'higher-order'],
  },

  // ============================================================
  // MAYBE/EITHER HANDLING - maybe, fromMaybe, either
  // ============================================================
  {
    id: 'haskell-maybe-001',
    category: 'Maybe/Either',
    difficulty: 'easy',
    title: 'Extract from Maybe with Default',
    text: 'Use fromMaybe to extract a value or provide a default',
    setup: 'maybeVal = Just 42',
    setupCode: 'maybeVal = Just 42',
    expected: 42,
    sample: 'fromMaybe 0 maybeVal',
    hints: [
      'fromMaybe takes a default and a Maybe',
      'Returns the value if Just, default if Nothing',
    ],
    validPatterns: [/fromMaybe\s+0\s+maybeVal/],
    tags: ['maybe', 'fromMaybe', 'monads'],
  },
  {
    id: 'haskell-maybe-002',
    category: 'Maybe/Either',
    difficulty: 'easy',
    title: 'Handle Nothing Case',
    text: 'Use fromMaybe to provide a default when value is Nothing',
    setup: 'maybeVal = Nothing',
    setupCode: 'maybeVal = Nothing',
    expected: -1,
    sample: 'fromMaybe (-1) maybeVal',
    hints: ['Nothing has no value', 'Default is used when value is Nothing'],
    validPatterns: [/fromMaybe\s*\(\s*-1\s*\)\s*maybeVal/],
    tags: ['maybe', 'fromMaybe', 'monads'],
  },
  {
    id: 'haskell-maybe-003',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'Maybe with Function',
    text: 'Use maybe to apply a function or return default',
    setup: 'maybeVal = Just 5',
    setupCode: 'maybeVal = Just 5',
    expected: 10,
    sample: 'maybe 0 (*2) maybeVal',
    hints: ['maybe takes default, function, and Maybe', 'Applies function to Just value'],
    validPatterns: [/maybe\s+0\s*\(\*2\)\s*maybeVal/],
    tags: ['maybe', 'higher-order', 'monads'],
  },
  {
    id: 'haskell-maybe-004',
    category: 'Maybe/Either',
    difficulty: 'hard',
    title: 'Either Left Case',
    text: 'Use either to handle the Left case',
    setup: 'result = Left "error"',
    setupCode: 'result = Left "error"',
    expected: 'Error: error',
    sample: 'either (("Error: " ++) ) show result',
    hints: ['either takes two functions', 'First function handles Left'],
    validPatterns: [/either\s*\(\s*\(\s*"Error:\s*"\s*\+\+\s*\)\s*\)/],
    tags: ['either', 'error-handling', 'monads'],
  },
  {
    id: 'haskell-maybe-005',
    category: 'Maybe/Either',
    difficulty: 'hard',
    title: 'Either Right Case',
    text: 'Use either to handle the Right case and double the value',
    setup: 'result = Right 21',
    setupCode: 'result = Right 21',
    expected: 42,
    sample: 'either (const 0) (*2) result',
    hints: ['Second function handles Right', 'const ignores the Left value'],
    validPatterns: [/either\s*\(\s*const\s+0\s*\)\s*\(\*2\)\s*result/],
    tags: ['either', 'error-handling', 'monads'],
  },
  {
    id: 'haskell-maybe-006',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'Map Over Maybe',
    text: 'Use fmap to apply a function inside Maybe',
    setup: 'maybeVal = Just 10',
    setupCode: 'maybeVal = Just 10',
    expected: 'Just 20',
    sample: 'fmap (*2) maybeVal',
    hints: ['fmap works on any Functor', 'Maybe is a Functor'],
    validPatterns: [/fmap\s*\(\*2\)\s*maybeVal/, /\(\*2\)\s*<\$>\s*maybeVal/],
    tags: ['fmap', 'functor', 'maybe'],
  },
  {
    id: 'haskell-maybe-007',
    category: 'Maybe/Either',
    difficulty: 'hard',
    title: 'Chain Maybe Operations',
    text: 'Use >>= to chain Maybe operations (safe division)',
    setup: 'safeDiv x y = if y == 0 then Nothing else Just (x `div` y)\nstart = Just 100',
    setupCode: 'safeDiv x y = if y == 0 then Nothing else Just (x `div` y)\nstart = Just 100',
    expected: 'Just 10',
    sample: 'start >>= (\\x -> safeDiv x 10)',
    hints: ['>>= is monadic bind', 'Chains computations that might fail'],
    validPatterns: [
      /start\s*>>=\s*\(\s*\\x\s*->\s*safeDiv\s+x\s+10\s*\)/,
      /start\s*>>=\s*flip\s+safeDiv\s+10/,
    ],
    tags: ['bind', 'monad', 'maybe'],
  },
  {
    id: 'haskell-maybe-008',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'Filter Maybe Values',
    text: 'Use catMaybes to extract Just values from a list',
    setup: 'maybes = [Just 1, Nothing, Just 2, Nothing, Just 3]',
    setupCode: 'maybes = [Just 1, Nothing, Just 2, Nothing, Just 3]',
    expected: [1, 2, 3],
    sample: 'catMaybes maybes',
    hints: ['catMaybes is from Data.Maybe', 'It filters out Nothing values'],
    validPatterns: [/catMaybes\s+maybes/],
    tags: ['catMaybes', 'maybe', 'list'],
  },
  {
    id: 'haskell-maybe-009',
    category: 'Maybe/Either',
    difficulty: 'hard',
    title: 'Map Maybe with mapMaybe',
    text: 'Use mapMaybe to filter and transform in one step',
    setup: 'numbers = [1, 2, 3, 4, 5, 6]\nsafeEven x = if even x then Just (x * 2) else Nothing',
    setupCode:
      'numbers = [1, 2, 3, 4, 5, 6]\nsafeEven x = if even x then Just (x * 2) else Nothing',
    expected: [4, 8, 12],
    sample: 'mapMaybe safeEven numbers',
    hints: ['mapMaybe combines map and catMaybes', 'Filters and transforms simultaneously'],
    validPatterns: [/mapMaybe\s+safeEven\s+numbers/],
    tags: ['mapMaybe', 'maybe', 'filter'],
  },

  // ============================================================
  // LIST COMPREHENSIONS
  // ============================================================
  {
    id: 'haskell-comp-001',
    category: 'List Comprehensions',
    difficulty: 'easy',
    title: 'Basic List Comprehension',
    text: 'Use a list comprehension to double each number',
    setup: 'numbers = [1, 2, 3, 4, 5]',
    setupCode: 'numbers = [1, 2, 3, 4, 5]',
    expected: [2, 4, 6, 8, 10],
    sample: '[x * 2 | x <- numbers]',
    hints: ['Use the pattern [expression | generator]', 'x <- numbers draws from the list'],
    validPatterns: [/\[\s*x\s*\*\s*2\s*\|\s*x\s*<-\s*numbers\s*\]/],
    tags: ['list-comprehension', 'basic'],
  },
  {
    id: 'haskell-comp-002',
    category: 'List Comprehensions',
    difficulty: 'easy',
    title: 'List Comprehension with Filter',
    text: 'Use a list comprehension to get even numbers',
    setup: 'numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]',
    setupCode: 'numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]',
    expected: [2, 4, 6, 8, 10],
    sample: '[x | x <- numbers, even x]',
    hints: ['Add a guard after the generator', 'Guards filter which elements to include'],
    validPatterns: [/\[\s*x\s*\|\s*x\s*<-\s*numbers\s*,\s*even\s+x\s*\]/],
    tags: ['list-comprehension', 'filter'],
  },
  {
    id: 'haskell-comp-003',
    category: 'List Comprehensions',
    difficulty: 'medium',
    title: 'Transform and Filter',
    text: 'Double only the even numbers using a list comprehension',
    setup: 'numbers = [1, 2, 3, 4, 5, 6]',
    setupCode: 'numbers = [1, 2, 3, 4, 5, 6]',
    expected: [4, 8, 12],
    sample: '[x * 2 | x <- numbers, even x]',
    hints: [
      'Combine transformation in expression with filter guard',
      'Guard comes after generator',
    ],
    validPatterns: [/\[\s*x\s*\*\s*2\s*\|\s*x\s*<-\s*numbers\s*,\s*even\s+x\s*\]/],
    tags: ['list-comprehension', 'filter', 'transform'],
  },
  {
    id: 'haskell-comp-004',
    category: 'List Comprehensions',
    difficulty: 'medium',
    title: 'Cartesian Product',
    text: 'Generate all pairs from two lists',
    setup: 'xs = [1, 2]\nys = [3, 4]',
    setupCode: 'xs = [1, 2]\nys = [3, 4]',
    expected: [
      [1, 3],
      [1, 4],
      [2, 3],
      [2, 4],
    ],
    sample: '[(x, y) | x <- xs, y <- ys]',
    hints: ['Use multiple generators', 'Each combination is generated'],
    validPatterns: [/\[\s*\(\s*x\s*,\s*y\s*\)\s*\|\s*x\s*<-\s*xs\s*,\s*y\s*<-\s*ys\s*\]/],
    tags: ['list-comprehension', 'cartesian', 'tuples'],
  },
  {
    id: 'haskell-comp-005',
    category: 'List Comprehensions',
    difficulty: 'hard',
    title: 'Pythagorean Triples',
    text: 'Generate Pythagorean triples up to 10',
    setup: 'limit = 10',
    setupCode: 'limit = 10',
    expected: [
      [3, 4, 5],
      [6, 8, 10],
    ],
    sample: '[(a,b,c) | c <- [1..limit], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2]',
    hints: ['Use three generators with constraints', 'Guard checks the Pythagorean property'],
    validPatterns: [
      /\[\s*\(\s*a\s*,\s*b\s*,\s*c\s*\)\s*\|.*a\s*\^\s*2\s*\+\s*b\s*\^\s*2\s*==\s*c\s*\^\s*2\s*\]/,
    ],
    tags: ['list-comprehension', 'math', 'triples'],
  },
  {
    id: 'haskell-comp-006',
    category: 'List Comprehensions',
    difficulty: 'medium',
    title: 'String Comprehension',
    text: 'Convert a string to uppercase using comprehension',
    setup: 'str = "hello"',
    setupCode: 'str = "hello"',
    expected: 'HELLO',
    sample: '[toUpper c | c <- str]',
    hints: ['Strings are lists of Char', 'toUpper is from Data.Char'],
    validPatterns: [/\[\s*toUpper\s+c\s*\|\s*c\s*<-\s*str\s*\]/],
    tags: ['list-comprehension', 'string', 'char'],
  },

  // ============================================================
  // NEW PROBLEMS - LIST OPERATIONS (100-149)
  // ============================================================
  {
    id: 'hs-list-100',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Increment All Elements',
    text: 'Use map to add 1 to each element in the list',
    setup: 'nums = [5, 10, 15, 20]',
    setupCode: 'nums = [5, 10, 15, 20]',
    expected: [6, 11, 16, 21],
    sample: 'map (+1) nums',
    hints: ['Use the section (+1)', 'map applies a function to each element'],
    tags: ['map', 'list', 'basic'],
  },
  {
    id: 'hs-list-101',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Negate All Numbers',
    text: 'Use map to negate each number in the list',
    setup: 'nums = [1, -2, 3, -4, 5]',
    setupCode: 'nums = [1, -2, 3, -4, 5]',
    expected: [-1, 2, -3, 4, -5],
    sample: 'map negate nums',
    hints: ['negate flips the sign of a number', 'map negate applies to each element'],
    tags: ['map', 'list', 'negate'],
  },
  {
    id: 'hs-list-102',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Filter Positive Numbers',
    text: 'Use filter to keep only positive numbers',
    setup: 'nums = [-3, -1, 0, 2, 4, -5, 6]',
    setupCode: 'nums = [-3, -1, 0, 2, 4, -5, 6]',
    expected: [2, 4, 6],
    sample: 'filter (>0) nums',
    hints: ['Use the section (>0)', 'filter keeps elements where predicate is True'],
    tags: ['filter', 'list', 'comparison'],
  },
  {
    id: 'hs-list-103',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Filter Non-Empty Strings',
    text: 'Use filter to remove empty strings from the list',
    setup: 'strs = ["hello", "", "world", "", "haskell"]',
    setupCode: 'strs = ["hello", "", "world", "", "haskell"]',
    expected: ['hello', 'world', 'haskell'],
    sample: 'filter (not . null) strs',
    hints: ['null checks if a list is empty', 'Compose with not to keep non-empty'],
    tags: ['filter', 'list', 'string'],
  },
  {
    id: 'hs-list-104',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Sum with Foldl',
    text: 'Use foldl to calculate the sum of the list',
    setup: 'nums = [10, 20, 30, 40]',
    setupCode: 'nums = [10, 20, 30, 40]',
    expected: 100,
    sample: 'foldl (+) 0 nums',
    hints: ['foldl processes left to right', 'Start with 0 as the initial accumulator'],
    tags: ['foldl', 'fold', 'list'],
  },
  {
    id: 'hs-list-105',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Count Elements with Foldr',
    text: 'Use foldr to count the number of elements',
    setup: 'items = ["a", "b", "c", "d", "e"]',
    setupCode: 'items = ["a", "b", "c", "d", "e"]',
    expected: 5,
    sample: 'foldr (\\_ acc -> acc + 1) 0 items',
    hints: ['Ignore each element, just increment counter', 'Start with 0'],
    tags: ['foldr', 'fold', 'count'],
  },
  {
    id: 'hs-list-106',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'ZipWith Multiplication',
    text: 'Use zipWith to multiply corresponding elements',
    setup: 'xs = [1, 2, 3]\nys = [4, 5, 6]',
    setupCode: 'xs = [1, 2, 3]\nys = [4, 5, 6]',
    expected: [4, 10, 18],
    sample: 'zipWith (*) xs ys',
    hints: ['zipWith applies a binary function to pairs', 'Use (*) for multiplication'],
    tags: ['zipWith', 'list', 'math'],
  },
  {
    id: 'hs-list-107',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Take While Positive',
    text: 'Use takeWhile to take elements while they are positive',
    setup: 'nums = [3, 5, 2, -1, 4, 6]',
    setupCode: 'nums = [3, 5, 2, -1, 4, 6]',
    expected: [3, 5, 2],
    sample: 'takeWhile (>0) nums',
    hints: ['takeWhile stops at first False', 'Use (>0) as the predicate'],
    tags: ['takeWhile', 'list', 'predicate'],
  },
  {
    id: 'hs-list-108',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Drop While Less Than 5',
    text: 'Use dropWhile to skip elements less than 5',
    setup: 'nums = [1, 3, 2, 6, 4, 8, 7]',
    setupCode: 'nums = [1, 3, 2, 6, 4, 8, 7]',
    expected: [6, 4, 8, 7],
    sample: 'dropWhile (<5) nums',
    hints: ['dropWhile removes elements while predicate is True', 'Stops at first False'],
    tags: ['dropWhile', 'list', 'predicate'],
  },
  {
    id: 'hs-list-109',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Get Last Element',
    text: 'Use last to get the final element of the list',
    setup: 'nums = [10, 20, 30, 40, 50]',
    setupCode: 'nums = [10, 20, 30, 40, 50]',
    expected: 50,
    sample: 'last nums',
    hints: ['last returns the final element', 'Fails on empty lists'],
    tags: ['last', 'list', 'basic'],
  },
  {
    id: 'hs-list-110',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Get Init of List',
    text: 'Use init to get all elements except the last',
    setup: 'nums = [1, 2, 3, 4, 5]',
    setupCode: 'nums = [1, 2, 3, 4, 5]',
    expected: [1, 2, 3, 4],
    sample: 'init nums',
    hints: ['init is the opposite of tail', 'Returns all but the last element'],
    tags: ['init', 'list', 'basic'],
  },
  {
    id: 'hs-list-111',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Reverse with Foldl',
    text: 'Use foldl to reverse a list',
    setup: 'nums = [1, 2, 3, 4, 5]',
    setupCode: 'nums = [1, 2, 3, 4, 5]',
    expected: [5, 4, 3, 2, 1],
    sample: 'foldl (flip (:)) [] nums',
    hints: ['Prepend each element to the accumulator', 'flip (:) reverses argument order'],
    tags: ['foldl', 'reverse', 'list'],
  },
  {
    id: 'hs-list-112',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Filter and Count',
    text: 'Count how many numbers are greater than 10',
    setup: 'nums = [5, 12, 8, 15, 3, 20, 7]',
    setupCode: 'nums = [5, 12, 8, 15, 3, 20, 7]',
    expected: 3,
    sample: 'length (filter (>10) nums)',
    hints: ['First filter, then count with length', 'Use (>10) as the predicate'],
    tags: ['filter', 'length', 'list'],
  },
  {
    id: 'hs-list-113',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'ZipWith String Concat',
    text: 'Use zipWith to concatenate corresponding strings',
    setup: 'prefixes = ["Hello ", "Good ", "Nice "]\nsuffixes = ["World", "Morning", "Day"]',
    setupCode: 'prefixes = ["Hello ", "Good ", "Nice "]\nsuffixes = ["World", "Morning", "Day"]',
    expected: ['Hello World', 'Good Morning', 'Nice Day'],
    sample: 'zipWith (++) prefixes suffixes',
    hints: ['Use (++) to concatenate strings', 'zipWith pairs corresponding elements'],
    tags: ['zipWith', 'string', 'concat'],
  },
  {
    id: 'hs-list-114',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Find Element Index',
    text: 'Use elemIndex to find the index of element 30',
    setup: 'nums = [10, 20, 30, 40, 50]',
    setupCode: 'nums = [10, 20, 30, 40, 50]',
    expected: 'Just 2',
    sample: 'elemIndex 30 nums',
    hints: ['elemIndex is from Data.List', 'Returns Maybe Int'],
    tags: ['elemIndex', 'list', 'search'],
  },
  {
    id: 'hs-list-115',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Split At Position',
    text: 'Use splitAt to split the list at position 3',
    setup: 'nums = [1, 2, 3, 4, 5, 6, 7]',
    setupCode: 'nums = [1, 2, 3, 4, 5, 6, 7]',
    expected: [
      [1, 2, 3],
      [4, 5, 6, 7],
    ],
    sample: 'splitAt 3 nums',
    hints: ['splitAt returns a tuple of two lists', 'First list has n elements'],
    tags: ['splitAt', 'list', 'split'],
  },
  {
    id: 'hs-list-116',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Span with Predicate',
    text: 'Use span to split at first element >= 5',
    setup: 'nums = [1, 3, 2, 6, 4, 8]',
    setupCode: 'nums = [1, 3, 2, 6, 4, 8]',
    expected: [
      [1, 3, 2],
      [6, 4, 8],
    ],
    sample: 'span (<5) nums',
    hints: ['span splits at first False', 'Like takeWhile and dropWhile together'],
    tags: ['span', 'list', 'predicate'],
  },
  {
    id: 'hs-list-117',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Break with Predicate',
    text: 'Use break to split at first even number',
    setup: 'nums = [1, 3, 5, 4, 7, 9]',
    setupCode: 'nums = [1, 3, 5, 4, 7, 9]',
    expected: [
      [1, 3, 5],
      [4, 7, 9],
    ],
    sample: 'break even nums',
    hints: ['break splits at first True', 'Opposite of span'],
    tags: ['break', 'list', 'predicate'],
  },
  {
    id: 'hs-list-118',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Replicate Elements',
    text: 'Use replicate to create a list of 5 zeros',
    setup: 'n = 5\nval = 0',
    setupCode: 'n = 5\nval = 0',
    expected: [0, 0, 0, 0, 0],
    sample: 'replicate n val',
    hints: ['replicate n x creates n copies of x', 'Useful for initialization'],
    tags: ['replicate', 'list', 'create'],
  },
  {
    id: 'hs-list-119',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Intersperse Elements',
    text: 'Use intersperse to insert 0 between elements',
    setup: 'nums = [1, 2, 3, 4]',
    setupCode: 'nums = [1, 2, 3, 4]',
    expected: [1, 0, 2, 0, 3, 0, 4],
    sample: 'intersperse 0 nums',
    hints: ['intersperse inserts between each pair', 'From Data.List'],
    tags: ['intersperse', 'list', 'insert'],
  },
  {
    id: 'hs-list-120',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Intercalate Lists',
    text: 'Use intercalate to join strings with comma separator',
    setup: 'strs = ["apple", "banana", "cherry"]',
    setupCode: 'strs = ["apple", "banana", "cherry"]',
    expected: 'apple, banana, cherry',
    sample: 'intercalate ", " strs',
    hints: ['intercalate is like intersperse for lists', 'Then concatenates the result'],
    tags: ['intercalate', 'list', 'join'],
  },
  {
    id: 'hs-list-121',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Group Consecutive Equal',
    text: 'Use group to group consecutive equal elements',
    setup: 'chars = "aabbccaabb"',
    setupCode: 'chars = "aabbccaabb"',
    expected: ['aa', 'bb', 'cc', 'aa', 'bb'],
    sample: 'group chars',
    hints: ['group groups consecutive equal elements', 'From Data.List'],
    tags: ['group', 'list', 'grouping'],
  },
  {
    id: 'hs-list-122',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Partition by Predicate',
    text: 'Use partition to separate even and odd numbers',
    setup: 'nums = [1, 2, 3, 4, 5, 6, 7, 8]',
    setupCode: 'nums = [1, 2, 3, 4, 5, 6, 7, 8]',
    expected: [
      [2, 4, 6, 8],
      [1, 3, 5, 7],
    ],
    sample: 'partition even nums',
    hints: ['partition returns (matching, non-matching)', 'From Data.List'],
    tags: ['partition', 'list', 'separate'],
  },
  {
    id: 'hs-list-123',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Fold with Custom Accumulator',
    text: 'Use foldl to build a tuple of (sum, count)',
    setup: 'nums = [10, 20, 30, 40]',
    setupCode: 'nums = [10, 20, 30, 40]',
    expected: [100, 4],
    sample: 'foldl (\\(s, c) x -> (s + x, c + 1)) (0, 0) nums',
    hints: ['Use a tuple as accumulator', 'Update both sum and count'],
    tags: ['foldl', 'tuple', 'accumulator'],
  },
  {
    id: 'hs-list-124',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Transpose Matrix',
    text: 'Use transpose to flip rows and columns',
    setup: 'matrix = [[1, 2, 3], [4, 5, 6]]',
    setupCode: 'matrix = [[1, 2, 3], [4, 5, 6]]',
    expected: [
      [1, 4],
      [2, 5],
      [3, 6],
    ],
    sample: 'transpose matrix',
    hints: ['transpose is from Data.List', 'Swaps rows and columns'],
    tags: ['transpose', 'matrix', 'list'],
  },
  {
    id: 'hs-list-125',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Sort and Remove Duplicates',
    text: 'Sort the list and remove duplicates',
    setup: 'nums = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3]',
    setupCode: 'nums = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3]',
    expected: [1, 2, 3, 4, 5, 6, 9],
    sample: 'nub (sort nums)',
    hints: ['sort from Data.List', 'nub removes duplicates'],
    tags: ['sort', 'nub', 'list'],
  },
  {
    id: 'hs-list-126',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Zip3 Three Lists',
    text: 'Use zip3 to combine three lists into triples',
    setup: 'as = [1, 2, 3]\nbs = ["a", "b", "c"]\ncs = [True, False, True]',
    setupCode: 'as = [1, 2, 3]\nbs = ["a", "b", "c"]\ncs = [True, False, True]',
    expected: [
      [1, 'a', true],
      [2, 'b', false],
      [3, 'c', true],
    ],
    sample: 'zip3 as bs cs',
    hints: ['zip3 combines three lists', 'Creates 3-tuples'],
    tags: ['zip3', 'list', 'tuples'],
  },
  {
    id: 'hs-list-127',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Unzip Pairs',
    text: 'Use unzip to separate a list of pairs',
    setup: 'pairs = [(1, "a"), (2, "b"), (3, "c")]',
    setupCode: 'pairs = [(1, "a"), (2, "b"), (3, "c")]',
    expected: [
      [1, 2, 3],
      ['a', 'b', 'c'],
    ],
    sample: 'unzip pairs',
    hints: ['unzip is the inverse of zip', 'Returns a tuple of two lists'],
    tags: ['unzip', 'list', 'pairs'],
  },
  {
    id: 'hs-list-128',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Cycle and Take',
    text: 'Use cycle and take to repeat a pattern',
    setup: 'pattern = [1, 2, 3]',
    setupCode: 'pattern = [1, 2, 3]',
    expected: [1, 2, 3, 1, 2, 3, 1, 2, 3],
    sample: 'take 9 (cycle pattern)',
    hints: ['cycle creates an infinite list', 'take limits it to 9 elements'],
    tags: ['cycle', 'take', 'infinite'],
  },
  {
    id: 'hs-list-129',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Iterate and Take',
    text: 'Use iterate to generate powers of 2',
    setup: 'start = 1',
    setupCode: 'start = 1',
    expected: [1, 2, 4, 8, 16],
    sample: 'take 5 (iterate (*2) start)',
    hints: ['iterate f x produces [x, f x, f (f x), ...]', 'take limits the infinite list'],
    tags: ['iterate', 'take', 'infinite'],
  },
  {
    id: 'hs-list-130',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Check Element Membership',
    text: 'Use elem to check if 5 is in the list',
    setup: 'nums = [1, 3, 5, 7, 9]',
    setupCode: 'nums = [1, 3, 5, 7, 9]',
    expected: true,
    sample: 'elem 5 nums',
    hints: ['elem checks for membership', 'Returns True or False'],
    tags: ['elem', 'list', 'membership'],
  },
  {
    id: 'hs-list-131',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Check Not Element',
    text: 'Use notElem to check if 4 is not in the list',
    setup: 'nums = [1, 3, 5, 7, 9]',
    setupCode: 'nums = [1, 3, 5, 7, 9]',
    expected: true,
    sample: 'notElem 4 nums',
    hints: ['notElem is the opposite of elem', 'Returns True if not found'],
    tags: ['notElem', 'list', 'membership'],
  },
  {
    id: 'hs-list-132',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Find First Match',
    text: 'Use find to get the first even number',
    setup: 'nums = [1, 3, 4, 6, 7, 8]',
    setupCode: 'nums = [1, 3, 4, 6, 7, 8]',
    expected: 'Just 4',
    sample: 'find even nums',
    hints: ['find returns Maybe', 'From Data.List'],
    tags: ['find', 'list', 'search'],
  },
  {
    id: 'hs-list-133',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'All Elements Match',
    text: 'Use all to check if all numbers are positive',
    setup: 'nums = [1, 2, 3, 4, 5]',
    setupCode: 'nums = [1, 2, 3, 4, 5]',
    expected: true,
    sample: 'all (>0) nums',
    hints: ['all checks every element', 'Returns True if all match'],
    tags: ['all', 'list', 'predicate'],
  },
  {
    id: 'hs-list-134',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Any Element Matches',
    text: 'Use any to check if any number is negative',
    setup: 'nums = [1, 2, -3, 4, 5]',
    setupCode: 'nums = [1, 2, -3, 4, 5]',
    expected: true,
    sample: 'any (<0) nums',
    hints: ['any checks if at least one matches', 'Returns True on first match'],
    tags: ['any', 'list', 'predicate'],
  },
  {
    id: 'hs-list-135',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'ScanL Accumulation',
    text: 'Use scanl to show running sum',
    setup: 'nums = [1, 2, 3, 4, 5]',
    setupCode: 'nums = [1, 2, 3, 4, 5]',
    expected: [0, 1, 3, 6, 10, 15],
    sample: 'scanl (+) 0 nums',
    hints: ['scanl shows intermediate fold results', 'Like foldl but keeps all values'],
    tags: ['scanl', 'list', 'accumulator'],
  },
  {
    id: 'hs-list-136',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'ScanR from Right',
    text: 'Use scanr to show running product from right',
    setup: 'nums = [1, 2, 3, 4]',
    setupCode: 'nums = [1, 2, 3, 4]',
    expected: [24, 24, 12, 4, 1],
    sample: 'scanr (*) 1 nums',
    hints: ['scanr scans from the right', 'Shows intermediate results'],
    tags: ['scanr', 'list', 'accumulator'],
  },
  {
    id: 'hs-list-137',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Map with Index',
    text: 'Use zip to pair elements with their indices, then map',
    setup: 'chars = "abcd"',
    setupCode: 'chars = "abcd"',
    expected: [
      [0, 'a'],
      [1, 'b'],
      [2, 'c'],
      [3, 'd'],
    ],
    sample: 'zip [0..] chars',
    hints: ['[0..] is an infinite list', 'zip stops at shorter list'],
    tags: ['zip', 'index', 'list'],
  },
  {
    id: 'hs-list-138',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Fold to Map',
    text: 'Use foldr to implement map (double each element)',
    setup: 'nums = [1, 2, 3, 4]',
    setupCode: 'nums = [1, 2, 3, 4]',
    expected: [2, 4, 6, 8],
    sample: 'foldr (\\x acc -> x * 2 : acc) [] nums',
    hints: ['foldr can build a new list', 'Apply function then cons to accumulator'],
    tags: ['foldr', 'map', 'implementation'],
  },
  {
    id: 'hs-list-139',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Fold to Filter',
    text: 'Use foldr to implement filter (keep even numbers)',
    setup: 'nums = [1, 2, 3, 4, 5, 6]',
    setupCode: 'nums = [1, 2, 3, 4, 5, 6]',
    expected: [2, 4, 6],
    sample: 'foldr (\\x acc -> if even x then x : acc else acc) [] nums',
    hints: ['Conditionally cons to accumulator', 'foldr can implement filter'],
    tags: ['foldr', 'filter', 'implementation'],
  },
  {
    id: 'hs-list-140',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Null Check',
    text: 'Use null to check if the list is empty',
    setup: 'emptyList = []',
    setupCode: 'emptyList = []',
    expected: true,
    sample: 'null emptyList',
    hints: ['null returns True for empty lists', 'Safer than pattern matching sometimes'],
    tags: ['null', 'list', 'check'],
  },
  {
    id: 'hs-list-141',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Length of List',
    text: 'Use length to count elements',
    setup: 'items = ["a", "b", "c", "d"]',
    setupCode: 'items = ["a", "b", "c", "d"]',
    expected: 4,
    sample: 'length items',
    hints: ['length counts elements', 'Returns an Int'],
    tags: ['length', 'list', 'count'],
  },
  {
    id: 'hs-list-142',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Maximum of List',
    text: 'Use maximum to find the largest element',
    setup: 'nums = [3, 7, 2, 9, 1, 5]',
    setupCode: 'nums = [3, 7, 2, 9, 1, 5]',
    expected: 9,
    sample: 'maximum nums',
    hints: ['maximum returns the largest', 'Fails on empty lists'],
    tags: ['maximum', 'list', 'aggregate'],
  },
  {
    id: 'hs-list-143',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Minimum of List',
    text: 'Use minimum to find the smallest element',
    setup: 'nums = [3, 7, 2, 9, 1, 5]',
    setupCode: 'nums = [3, 7, 2, 9, 1, 5]',
    expected: 1,
    sample: 'minimum nums',
    hints: ['minimum returns the smallest', 'Fails on empty lists'],
    tags: ['minimum', 'list', 'aggregate'],
  },
  {
    id: 'hs-list-144',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Concat Nested Lists',
    text: 'Use concat to flatten a list of lists',
    setup: 'nested = [[1, 2], [3, 4], [5, 6]]',
    setupCode: 'nested = [[1, 2], [3, 4], [5, 6]]',
    expected: [1, 2, 3, 4, 5, 6],
    sample: 'concat nested',
    hints: ['concat flattens one level', 'Same as foldr (++) []'],
    tags: ['concat', 'list', 'flatten'],
  },
  {
    id: 'hs-list-145',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'ConcatMap Operation',
    text: 'Use concatMap to duplicate each element',
    setup: 'nums = [1, 2, 3]',
    setupCode: 'nums = [1, 2, 3]',
    expected: [1, 1, 2, 2, 3, 3],
    sample: 'concatMap (\\x -> [x, x]) nums',
    hints: ['concatMap maps then flattens', 'Like map then concat'],
    tags: ['concatMap', 'list', 'flatMap'],
  },
  {
    id: 'hs-list-146',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'ZipWith3 Three Lists',
    text: 'Use zipWith3 to combine three lists with a function',
    setup: 'as = [1, 2, 3]\nbs = [10, 20, 30]\ncs = [100, 200, 300]',
    setupCode: 'as = [1, 2, 3]\nbs = [10, 20, 30]\ncs = [100, 200, 300]',
    expected: [111, 222, 333],
    sample: 'zipWith3 (\\a b c -> a + b + c) as bs cs',
    hints: ['zipWith3 applies a ternary function', 'Combines three lists element-wise'],
    tags: ['zipWith3', 'list', 'combine'],
  },
  {
    id: 'hs-list-147',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Delete First Occurrence',
    text: 'Use delete to remove first occurrence of 3',
    setup: 'nums = [1, 2, 3, 4, 3, 5]',
    setupCode: 'nums = [1, 2, 3, 4, 3, 5]',
    expected: [1, 2, 4, 3, 5],
    sample: 'delete 3 nums',
    hints: ['delete removes first match', 'From Data.List'],
    tags: ['delete', 'list', 'remove'],
  },
  {
    id: 'hs-list-148',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Difference of Lists',
    text: 'Use (\\\\) to get elements in first list not in second',
    setup: 'xs = [1, 2, 3, 4, 5]\nys = [2, 4]',
    setupCode: 'xs = [1, 2, 3, 4, 5]\nys = [2, 4]',
    expected: [1, 3, 5],
    sample: 'xs \\\\ ys',
    hints: ['(\\\\) is list difference', 'From Data.List'],
    tags: ['difference', 'list', 'set'],
  },
  {
    id: 'hs-list-149',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Union of Lists',
    text: 'Use union to combine lists without duplicates',
    setup: 'xs = [1, 2, 3]\nys = [2, 3, 4, 5]',
    setupCode: 'xs = [1, 2, 3]\nys = [2, 3, 4, 5]',
    expected: [1, 2, 3, 4, 5],
    sample: 'union xs ys',
    hints: ['union keeps all from first, adds new from second', 'From Data.List'],
    tags: ['union', 'list', 'set'],
  },

  // ============================================================
  // HIGHER-ORDER FUNCTIONS (150-199)
  // ============================================================
  {
    id: 'hs-hof-150',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'Identity Function',
    text: 'Use id to return the value unchanged',
    setup: 'val = 42',
    setupCode: 'val = 42',
    expected: 42,
    sample: 'id val',
    hints: ['id returns its argument unchanged', 'Useful as a placeholder function'],
    tags: ['id', 'identity', 'basic'],
  },
  {
    id: 'hs-hof-151',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'Const Function',
    text: 'Use const to always return 10 regardless of second argument',
    setup: 'x = 10\ny = 99',
    setupCode: 'x = 10\ny = 99',
    expected: 10,
    sample: 'const x y',
    hints: ['const a b always returns a', 'Ignores the second argument'],
    tags: ['const', 'higher-order', 'basic'],
  },
  {
    id: 'hs-hof-152',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'Flip Subtraction',
    text: 'Use flip to reverse subtraction order',
    setup: 'a = 5\nb = 3',
    setupCode: 'a = 5\nb = 3',
    expected: -2,
    sample: 'flip (-) a b',
    hints: ['flip (-) a b = b - a', 'Swaps argument order'],
    tags: ['flip', 'higher-order', 'operators'],
  },
  {
    id: 'hs-hof-153',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'On Combinator',
    text: 'Use on to compare by length',
    setup: 'import Data.Function (on)\nstr1 = "hello"\nstr2 = "hi"',
    setupCode: 'str1 = "hello"\nstr2 = "hi"',
    expected: 'GT',
    sample: 'compare `on` length $ str1 $ str2',
    hints: ['on applies a function to both args before comparing', 'From Data.Function'],
    tags: ['on', 'compare', 'higher-order'],
  },
  {
    id: 'hs-hof-154',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Compose Three Functions',
    text: 'Compose abs, negate, and (*2)',
    setup: 'num = -5',
    setupCode: 'num = -5',
    expected: 10,
    sample: '(abs . negate . (*2)) num',
    hints: ['Rightmost function applies first', 'Read composition right to left'],
    tags: ['composition', 'higher-order', 'chain'],
  },
  {
    id: 'hs-hof-155',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Double Dollar',
    text: 'Use $ twice to avoid parentheses',
    setup: 'nums = [1, 2, 3, 4, 5]',
    setupCode: 'nums = [1, 2, 3, 4, 5]',
    expected: 30,
    sample: 'sum $ map (*2) $ nums',
    hints: ['$ is right-associative', 'Evaluates right to left'],
    tags: ['dollar', 'operators', 'higher-order'],
  },
  {
    id: 'hs-hof-156',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Apply to Argument',
    text: 'Use (&) to apply value to function (reverse $)',
    setup: 'import Data.Function ((&))\nnum = 5',
    setupCode: 'num = 5',
    expected: 10,
    sample: 'num & (*2)',
    hints: ['(&) is flip ($)', 'Value on left, function on right'],
    tags: ['ampersand', 'pipe', 'higher-order'],
  },
  {
    id: 'hs-hof-157',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Curry a Tuple Function',
    text: 'Use curry to convert a tuple function to curried form',
    setup: 'addPair (x, y) = x + y\na = 3\nb = 4',
    setupCode: 'addPair (x, y) = x + y\na = 3\nb = 4',
    expected: 7,
    sample: 'curry addPair a b',
    hints: ['curry converts f(a,b) to f a b', 'Inverse of uncurry'],
    tags: ['curry', 'tuples', 'higher-order'],
  },
  {
    id: 'hs-hof-158',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Uncurry for Pairs',
    text: 'Use uncurry to apply max to a pair',
    setup: 'pair = (7, 3)',
    setupCode: 'pair = (7, 3)',
    expected: 7,
    sample: 'uncurry max pair',
    hints: ['uncurry converts f a b to f(a,b)', 'Works with tuples'],
    tags: ['uncurry', 'tuples', 'higher-order'],
  },
  {
    id: 'hs-hof-159',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Point-Free Filter and Map',
    text: 'Write point-free: filter even then map (*2)',
    setup: 'nums = [1, 2, 3, 4, 5, 6]',
    setupCode: 'nums = [1, 2, 3, 4, 5, 6]',
    expected: [4, 8, 12],
    sample: '(map (*2) . filter even) nums',
    hints: ['Compose map and filter', 'Point-free omits the list argument'],
    tags: ['point-free', 'composition', 'filter'],
  },
  {
    id: 'hs-hof-160',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Function Application to List',
    text: 'Apply a list of functions to a value',
    setup: 'funcs = [(+1), (*2), (^2)]\nval = 3',
    setupCode: 'funcs = [(+1), (*2), (^2)]\nval = 3',
    expected: [4, 6, 9],
    sample: 'map ($ val) funcs',
    hints: ['($ val) applies a function to val', 'map applies each function'],
    tags: ['dollar', 'map', 'functions'],
  },
  {
    id: 'hs-hof-161',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Compose All Functions',
    text: 'Compose a list of functions into one',
    setup: 'funcs = [(+1), (*2), (+3)]\nval = 5',
    setupCode: 'funcs = [(+1), (*2), (+3)]\nval = 5',
    expected: 17,
    sample: 'foldr (.) id funcs $ val',
    hints: ['foldr (.) id composes all functions', 'id is the identity for composition'],
    tags: ['foldr', 'composition', 'higher-order'],
  },
  {
    id: 'hs-hof-162',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Fix Point Combinator',
    text: 'Use fix to define factorial',
    setup: 'import Data.Function (fix)\nn = 5',
    setupCode: 'n = 5',
    expected: 120,
    sample: 'fix (\\f n -> if n <= 1 then 1 else n * f (n-1)) n',
    hints: ['fix allows recursion without naming', 'f is the recursive call'],
    tags: ['fix', 'recursion', 'higher-order'],
  },
  {
    id: 'hs-hof-163',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Sectioned Operator Left',
    text: 'Use left section to divide by 2',
    setup: 'nums = [10, 20, 30, 40]',
    setupCode: 'nums = [10, 20, 30, 40]',
    expected: [5, 10, 15, 20],
    sample: 'map (`div` 2) nums',
    hints: ['Backticks make infix', '(`div` 2) divides by 2'],
    tags: ['sections', 'operators', 'map'],
  },
  {
    id: 'hs-hof-164',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Sectioned Operator Right',
    text: 'Use right section to subtract from 10',
    setup: 'nums = [1, 2, 3, 4]',
    setupCode: 'nums = [1, 2, 3, 4]',
    expected: [9, 8, 7, 6],
    sample: 'map (10 -) nums',
    hints: ['(10 -) subtracts argument from 10', 'Different from (- 10)'],
    tags: ['sections', 'operators', 'map'],
  },
  {
    id: 'hs-hof-165',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Comparing By Function',
    text: 'Use comparing to sort by string length',
    setup: 'import Data.Ord (comparing)\nstrs = ["hi", "hello", "hey"]',
    setupCode: 'strs = ["hi", "hello", "hey"]',
    expected: ['hi', 'hey', 'hello'],
    sample: 'sortBy (comparing length) strs',
    hints: ['comparing extracts a key for comparison', 'From Data.Ord'],
    tags: ['comparing', 'sort', 'higher-order'],
  },
  {
    id: 'hs-hof-166',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Flip Map Arguments',
    text: 'Use flip map to apply list first',
    setup: 'nums = [1, 2, 3, 4, 5]',
    setupCode: 'nums = [1, 2, 3, 4, 5]',
    expected: [2, 4, 6, 8, 10],
    sample: 'flip map nums (*2)',
    hints: ['flip map takes list then function', 'Alternative argument order'],
    tags: ['flip', 'map', 'higher-order'],
  },
  {
    id: 'hs-hof-167',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Both on Pair',
    text: 'Apply a function to both elements of a pair',
    setup: 'import Control.Arrow ((&&&))\npair = (3, 5)',
    setupCode: 'pair = (3, 5)',
    expected: [6, 10],
    sample: '(\\(a, b) -> (a * 2, b * 2)) pair',
    hints: ['Apply (*2) to both elements', 'Can use Bifunctor bimap'],
    tags: ['pairs', 'tuples', 'higher-order'],
  },
  {
    id: 'hs-hof-168',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Fork Pattern',
    text: 'Apply two functions and combine results',
    setup: 'import Control.Arrow ((&&&))\nnum = 5',
    setupCode: 'num = 5',
    expected: [5, 25],
    sample: '(id &&& (^2)) num',
    hints: ['(&&&) applies two functions to one input', 'Returns a pair'],
    tags: ['arrow', 'fork', 'higher-order'],
  },
  {
    id: 'hs-hof-169',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Join on Self',
    text: 'Use join to apply function to argument twice',
    setup: 'import Control.Monad (join)\nnum = 3',
    setupCode: 'num = 3',
    expected: 6,
    sample: 'join (+) num',
    hints: ['join (+) x = x + x', 'Applies function to x twice'],
    tags: ['join', 'monad', 'higher-order'],
  },
  {
    id: 'hs-hof-170',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'Apply Using Dollar',
    text: 'Use $ to apply a function without parentheses',
    setup: 'nums = [3, 1, 4, 1, 5]',
    setupCode: 'nums = [3, 1, 4, 1, 5]',
    expected: 5,
    sample: 'maximum $ nums',
    hints: ['$ has lowest precedence', 'Avoids parentheses on right'],
    tags: ['dollar', 'operators', 'basic'],
  },
  {
    id: 'hs-hof-171',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Compose with Map',
    text: 'Use (.) with map to transform nested lists',
    setup: 'nested = [[1, 2], [3, 4], [5, 6]]',
    setupCode: 'nested = [[1, 2], [3, 4], [5, 6]]',
    expected: [
      [2, 4],
      [6, 8],
      [10, 12],
    ],
    sample: 'map (map (*2)) nested',
    hints: ['map (map f) applies f to nested elements', 'Double mapping'],
    tags: ['map', 'nested', 'composition'],
  },
  {
    id: 'hs-hof-172',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Applicative Style',
    text: 'Use (<*>) to apply multiple functions',
    setup: 'funcs = [(+1), (*2)]\nval = 5',
    setupCode: 'funcs = [(+1), (*2)]\nval = 5',
    expected: [6, 10],
    sample: 'funcs <*> [val]',
    hints: ['<*> applies functions in a functor', 'List applicative applies all combinations'],
    tags: ['applicative', 'apply', 'higher-order'],
  },
  {
    id: 'hs-hof-173',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Map Flip',
    text: 'Map a flipped function over pairs',
    setup: 'pairs = [(2, 10), (3, 12), (4, 20)]',
    setupCode: 'pairs = [(2, 10), (3, 12), (4, 20)]',
    expected: [5, 4, 5],
    sample: 'map (uncurry (flip div)) pairs',
    hints: ['flip div reverses division order', 'Then uncurry for pairs'],
    tags: ['flip', 'uncurry', 'map'],
  },
  {
    id: 'hs-hof-174',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'S Combinator',
    text: 'Use ap as S combinator: ap f g x = f x (g x)',
    setup: 'import Control.Monad (ap)\nnum = 4',
    setupCode: 'num = 4',
    expected: 20,
    sample: '((*) `ap` (+1)) num',
    hints: ['ap for functions: ap f g x = f x (g x)', 'Here: 4 * (4+1) = 20'],
    tags: ['ap', 'combinator', 'higher-order'],
  },
  {
    id: 'hs-hof-175',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Partial Application Chain',
    text: 'Chain partial applications',
    setup: 'nums = [1, 2, 3, 4, 5]',
    setupCode: 'nums = [1, 2, 3, 4, 5]',
    expected: [3, 4, 5, 6, 7],
    sample: 'map ((+1) . (+1)) nums',
    hints: ['Compose (+1) with itself', 'Each element increases by 2'],
    tags: ['partial', 'composition', 'map'],
  },
  {
    id: 'hs-hof-176',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'Lambda with Multiple Args',
    text: 'Use a lambda to add three numbers',
    setup: 'a = 1\nb = 2\nc = 3',
    setupCode: 'a = 1\nb = 2\nc = 3',
    expected: 6,
    sample: '(\\x y z -> x + y + z) a b c',
    hints: ['Lambda can take multiple arguments', 'Applies to a, b, c in order'],
    tags: ['lambda', 'basic', 'higher-order'],
  },
  {
    id: 'hs-hof-177',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Eta Reduction',
    text: 'Express doubling in point-free style',
    setup: 'nums = [1, 2, 3, 4, 5]',
    setupCode: 'nums = [1, 2, 3, 4, 5]',
    expected: [2, 4, 6, 8, 10],
    sample: 'map (*2) nums',
    hints: ['(*2) is point-free for (\\x -> x * 2)', 'Sections are point-free'],
    tags: ['point-free', 'eta', 'sections'],
  },
  {
    id: 'hs-hof-178',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Reader Monad Style',
    text: 'Use function monad for computation with shared input',
    setup: 'num = 5',
    setupCode: 'num = 5',
    expected: 30,
    sample: '((+) <$> (*2) <*> (*4)) num',
    hints: ['Functions are Applicative', 'Both (*2) and (*4) applied to num'],
    tags: ['applicative', 'reader', 'higher-order'],
  },
  {
    id: 'hs-hof-179',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Void Function Result',
    text: 'Use void to discard function result',
    setup: 'import Data.Functor (void)\nmaybeVal = Just 42',
    setupCode: 'maybeVal = Just 42',
    expected: 'Just ()',
    sample: 'void maybeVal',
    hints: ['void replaces value with ()', 'Keeps the structure'],
    tags: ['void', 'functor', 'higher-order'],
  },
  {
    id: 'hs-hof-180',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Kleisli Composition',
    text: 'Compose Maybe-returning functions',
    setup:
      'import Control.Monad ((>=>))\nsafeHead xs = if null xs then Nothing else Just (head xs)\nsafeDouble x = Just (x * 2)\nnums = [5, 10, 15]',
    setupCode:
      'safeHead xs = if null xs then Nothing else Just (head xs)\nsafeDouble x = Just (x * 2)\nnums = [5, 10, 15]',
    expected: 'Just 10',
    sample: '(safeHead >=> safeDouble) nums',
    hints: ['(>=>) composes monadic functions', 'Like (.) but for Kleisli arrows'],
    tags: ['kleisli', 'monad', 'composition'],
  },
  {
    id: 'hs-hof-181',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'Flip Cons',
    text: 'Use flip (:) to append element to beginning',
    setup: 'list = [2, 3, 4]\nelem = 1',
    setupCode: 'list = [2, 3, 4]\nelem = 1',
    expected: [1, 2, 3, 4],
    sample: 'flip (:) list elem',
    hints: ['flip (:) takes list then element', '(:) takes element then list'],
    tags: ['flip', 'cons', 'list'],
  },
  {
    id: 'hs-hof-182',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Either Functions to Pair',
    text: 'Apply either function based on Either value',
    setup: 'leftVal = Left 5\nrightVal = Right 10',
    setupCode: 'leftVal = Left 5\nrightVal = Right 10',
    expected: [10, 20],
    sample: '[either (*2) (*2) leftVal, either (*2) (*2) rightVal]',
    hints: ['either applies first function to Left', 'Second function to Right'],
    tags: ['either', 'higher-order', 'branching'],
  },
  {
    id: 'hs-hof-183',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Zippy Applicative',
    text: 'Use ZipList for zippy application',
    setup:
      'import Control.Applicative (ZipList(..))\nfs = ZipList [(+1), (*2), (^2)]\nxs = ZipList [1, 2, 3]',
    setupCode: 'fs = ZipList [(+1), (*2), (^2)]\nxs = ZipList [1, 2, 3]',
    expected: [2, 4, 9],
    sample: 'getZipList (fs <*> xs)',
    hints: ['ZipList zips instead of crossing', 'Pairs functions with values'],
    tags: ['ziplist', 'applicative', 'higher-order'],
  },
  {
    id: 'hs-hof-184',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Bool Function',
    text: 'Use bool to select based on condition',
    setup: 'import Data.Bool (bool)\nx = 5',
    setupCode: 'x = 5',
    expected: 'positive',
    sample: 'bool "non-positive" "positive" (x > 0)',
    hints: ['bool falseVal trueVal condition', 'Like if-then-else as function'],
    tags: ['bool', 'conditional', 'higher-order'],
  },
  {
    id: 'hs-hof-185',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Apply on Pair',
    text: 'Apply different functions to each element of pair',
    setup: 'import Data.Bifunctor (bimap)\npair = (3, "hi")',
    setupCode: 'pair = (3, "hi")',
    expected: [6, 'HI'],
    sample: 'bimap (*2) (map toUpper) pair',
    hints: ['bimap applies to both elements', 'From Data.Bifunctor'],
    tags: ['bimap', 'bifunctor', 'pairs'],
  },
  {
    id: 'hs-hof-186',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Traverse with Function',
    text: 'Use traverse to apply function returning Maybe',
    setup: 'safeRecip x = if x == 0 then Nothing else Just (1/x)\nnums = [1, 2, 4]',
    setupCode: 'safeRecip x = if x == 0 then Nothing else Just (1/x)\nnums = [1, 2, 4]',
    expected: 'Just [1.0, 0.5, 0.25]',
    sample: 'traverse safeRecip nums',
    hints: ['traverse sequences effects', 'Returns Nothing if any fails'],
    tags: ['traverse', 'maybe', 'higher-order'],
  },
  {
    id: 'hs-hof-187',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Negate Predicate',
    text: 'Use not . to negate a predicate',
    setup: 'nums = [1, 2, 3, 4, 5, 6]',
    setupCode: 'nums = [1, 2, 3, 4, 5, 6]',
    expected: [1, 3, 5],
    sample: 'filter (not . even) nums',
    hints: ['(not . even) is same as odd', 'Compose not with predicate'],
    tags: ['composition', 'not', 'predicate'],
  },
  {
    id: 'hs-hof-188',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Monoid Fold',
    text: 'Use foldMap with Sum monoid',
    setup: 'import Data.Monoid (Sum(..))\nnums = [1, 2, 3, 4, 5]',
    setupCode: 'nums = [1, 2, 3, 4, 5]',
    expected: 15,
    sample: 'getSum (foldMap Sum nums)',
    hints: ['foldMap combines with monoid', 'Sum wraps numbers for addition'],
    tags: ['foldMap', 'monoid', 'higher-order'],
  },
  {
    id: 'hs-hof-189',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Maybe as Alternative',
    text: 'Use (<|>) to provide fallback',
    setup: 'import Control.Applicative ((<|>))\nfirst = Nothing\nsecond = Just 42',
    setupCode: 'first = Nothing\nsecond = Just 42',
    expected: 'Just 42',
    sample: 'first <|> second',
    hints: ['(<|>) picks first non-Nothing', 'From Control.Applicative'],
    tags: ['alternative', 'maybe', 'fallback'],
  },
  {
    id: 'hs-hof-190',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'Tuple First',
    text: 'Use fst to get first element of pair',
    setup: 'pair = (42, "answer")',
    setupCode: 'pair = (42, "answer")',
    expected: 42,
    sample: 'fst pair',
    hints: ['fst extracts first element', 'Works on 2-tuples'],
    tags: ['fst', 'tuples', 'basic'],
  },
  {
    id: 'hs-hof-191',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'Tuple Second',
    text: 'Use snd to get second element of pair',
    setup: 'pair = (42, "answer")',
    setupCode: 'pair = (42, "answer")',
    expected: 'answer',
    sample: 'snd pair',
    hints: ['snd extracts second element', 'Works on 2-tuples'],
    tags: ['snd', 'tuples', 'basic'],
  },
  {
    id: 'hs-hof-192',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Map First of Pairs',
    text: 'Map a function over first elements of pairs',
    setup: 'pairs = [(1, "a"), (2, "b"), (3, "c")]',
    setupCode: 'pairs = [(1, "a"), (2, "b"), (3, "c")]',
    expected: [
      [2, 'a'],
      [4, 'b'],
      [6, 'c'],
    ],
    sample: 'map (\\(x, y) -> (x * 2, y)) pairs',
    hints: ['Pattern match in lambda', 'Or use first from Data.Bifunctor'],
    tags: ['map', 'tuples', 'pattern'],
  },
  {
    id: 'hs-hof-193',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Dual Application',
    text: 'Apply one value to two functions and combine',
    setup: 'num = 5',
    setupCode: 'num = 5',
    expected: 30,
    sample: 'liftA2 (*) (*2) (+4) num',
    hints: [
      'liftA2 on functions: apply both to input, combine',
      '(*2) 5 * (+4) 5 = 10 * 9... wait, thats wrong',
    ],
    tags: ['liftA2', 'applicative', 'higher-order'],
  },
  {
    id: 'hs-hof-194',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Map Pairs to Sum',
    text: 'Sum each pair using uncurry',
    setup: 'pairs = [(1, 2), (3, 4), (5, 6)]',
    setupCode: 'pairs = [(1, 2), (3, 4), (5, 6)]',
    expected: [3, 7, 11],
    sample: 'map (uncurry (+)) pairs',
    hints: ['uncurry (+) takes a pair and adds', 'Map over all pairs'],
    tags: ['uncurry', 'map', 'pairs'],
  },
  {
    id: 'hs-hof-195',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Sequence Functions',
    text: 'Apply a value to multiple functions',
    setup: 'funcs = [(*2), (+10), (^2)]\nval = 5',
    setupCode: 'funcs = [(*2), (+10), (^2)]\nval = 5',
    expected: [10, 15, 25],
    sample: 'sequence funcs val',
    hints: ['sequence on functions applies all to same input', 'Like traverse for functions'],
    tags: ['sequence', 'functions', 'higher-order'],
  },
  {
    id: 'hs-hof-196',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'When Condition',
    text: 'Use when to conditionally execute',
    setup: 'import Control.Monad (when)\ncond = True\nresult = when cond (Just "executed")',
    setupCode: 'cond = True',
    expected: 'Just ()',
    sample: 'when cond (Just ())',
    hints: ['when executes if condition True', 'Returns () in the monad'],
    tags: ['when', 'monad', 'conditional'],
  },
  {
    id: 'hs-hof-197',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Unless Condition',
    text: 'Use unless for negated condition',
    setup: 'import Control.Monad (unless)\ncond = False',
    setupCode: 'cond = False',
    expected: 'Just ()',
    sample: 'unless cond (Just ())',
    hints: ['unless executes if condition False', 'Opposite of when'],
    tags: ['unless', 'monad', 'conditional'],
  },
  {
    id: 'hs-hof-198',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Guard in List',
    text: 'Use guard for filtering in do notation',
    setup: 'import Control.Monad (guard)\nnums = [1..10]',
    setupCode: 'nums = [1..10]',
    expected: [2, 4, 6, 8, 10],
    sample: 'do { x <- nums; guard (even x); return x }',
    hints: ['guard filters based on condition', 'Works in list monad'],
    tags: ['guard', 'monad', 'list'],
  },
  {
    id: 'hs-hof-199',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'MFilter Maybe',
    text: 'Use mfilter to filter inside Maybe',
    setup: 'import Control.Monad (mfilter)\nmaybeVal = Just 10',
    setupCode: 'maybeVal = Just 10',
    expected: 'Just 10',
    sample: 'mfilter even maybeVal',
    hints: ['mfilter filters monadic values', 'Returns Nothing if predicate fails'],
    tags: ['mfilter', 'monad', 'filter'],
  },

  // ============================================================
  // PATTERN MATCHING (200-249)
  // ============================================================
  {
    id: 'hs-pat-200',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Match Empty List',
    text: 'Use pattern matching to check if list is empty',
    setup: 'isEmpty [] = True\nisEmpty _ = False\nlist = []',
    setupCode: 'isEmpty [] = True\nisEmpty _ = False\nlist = []',
    expected: true,
    sample: 'isEmpty list',
    hints: ['[] matches empty list', '_ is wildcard pattern'],
    tags: ['pattern', 'list', 'basic'],
  },
  {
    id: 'hs-pat-201',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Match Head and Tail',
    text: 'Use (x:xs) pattern to get head',
    setup: 'myHead (x:_) = x\nlist = [1, 2, 3, 4, 5]',
    setupCode: 'myHead (x:_) = x\nlist = [1, 2, 3, 4, 5]',
    expected: 1,
    sample: 'myHead list',
    hints: ['(x:xs) splits into head and tail', 'Use _ for unused tail'],
    tags: ['pattern', 'cons', 'list'],
  },
  {
    id: 'hs-pat-202',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Match Tuple',
    text: 'Use pattern matching to extract from tuple',
    setup: 'getFirst (a, _) = a\npair = ("hello", 42)',
    setupCode: 'getFirst (a, _) = a\npair = ("hello", 42)',
    expected: 'hello',
    sample: 'getFirst pair',
    hints: ['(a, b) matches a tuple', 'Use _ for unused elements'],
    tags: ['pattern', 'tuple', 'basic'],
  },
  {
    id: 'hs-pat-203',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Match Maybe Just',
    text: 'Extract value from Just using pattern',
    setup: 'fromJust (Just x) = x\nmaybeVal = Just 42',
    setupCode: 'fromJust (Just x) = x\nmaybeVal = Just 42',
    expected: 42,
    sample: 'fromJust maybeVal',
    hints: ['Just x extracts the value', 'Partial function - fails on Nothing'],
    tags: ['pattern', 'maybe', 'basic'],
  },
  {
    id: 'hs-pat-204',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Match Either',
    text: 'Use pattern matching on Either',
    setup: 'getValue (Left x) = x\ngetValue (Right x) = x\nval = Right 100',
    setupCode: 'getValue (Left x) = x\ngetValue (Right x) = x\nval = Right 100',
    expected: 100,
    sample: 'getValue val',
    hints: ['Left and Right are Either constructors', 'Match both cases'],
    tags: ['pattern', 'either', 'basic'],
  },
  {
    id: 'hs-pat-205',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Guard Expression',
    text: 'Use guards to classify a number',
    setup:
      'classify n\n  | n < 0 = "negative"\n  | n == 0 = "zero"\n  | otherwise = "positive"\nnum = 5',
    setupCode:
      'classify n\n  | n < 0 = "negative"\n  | n == 0 = "zero"\n  | otherwise = "positive"\nnum = 5',
    expected: 'positive',
    sample: 'classify num',
    hints: ['Guards use | for conditions', 'otherwise is always True'],
    tags: ['guards', 'conditional', 'pattern'],
  },
  {
    id: 'hs-pat-206',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Case Expression',
    text: 'Use case to match on a value',
    setup: 'describe x = case x of\n  0 -> "zero"\n  1 -> "one"\n  _ -> "many"\nnum = 1',
    setupCode: 'describe x = case x of\n  0 -> "zero"\n  1 -> "one"\n  _ -> "many"\nnum = 1',
    expected: 'one',
    sample: 'describe num',
    hints: ['case allows inline pattern matching', 'Use _ for default'],
    tags: ['case', 'pattern', 'expression'],
  },
  {
    id: 'hs-pat-207',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'As-Pattern',
    text: 'Use @ to keep reference to whole value',
    setup: 'firstAndAll xs@(x:_) = (x, xs)\nlist = [1, 2, 3]',
    setupCode: 'firstAndAll xs@(x:_) = (x, xs)\nlist = [1, 2, 3]',
    expected: [1, [1, 2, 3]],
    sample: 'firstAndAll list',
    hints: ['xs@pattern binds xs to whole match', 'Access both parts and whole'],
    tags: ['as-pattern', 'pattern', 'binding'],
  },
  {
    id: 'hs-pat-208',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Nested Pattern',
    text: 'Match nested structure',
    setup: 'firstOfFirst ((x:_):_) = x\nnested = [[1, 2], [3, 4]]',
    setupCode: 'firstOfFirst ((x:_):_) = x\nnested = [[1, 2], [3, 4]]',
    expected: 1,
    sample: 'firstOfFirst nested',
    hints: ['Patterns can be nested', 'Match list of lists'],
    tags: ['pattern', 'nested', 'list'],
  },
  {
    id: 'hs-pat-209',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Multiple Guards',
    text: 'Use multiple guard conditions',
    setup:
      'grade score\n  | score >= 90 = "A"\n  | score >= 80 = "B"\n  | score >= 70 = "C"\n  | otherwise = "F"\nval = 85',
    setupCode:
      'grade score\n  | score >= 90 = "A"\n  | score >= 80 = "B"\n  | score >= 70 = "C"\n  | otherwise = "F"\nval = 85',
    expected: 'B',
    sample: 'grade val',
    hints: ['Guards checked top to bottom', 'First True guard wins'],
    tags: ['guards', 'multiple', 'pattern'],
  },
  {
    id: 'hs-pat-210',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Pattern in Let',
    text: 'Use pattern matching in let binding',
    setup: 'pair = (10, 20)',
    setupCode: 'pair = (10, 20)',
    expected: 30,
    sample: 'let (a, b) = pair in a + b',
    hints: ['let can pattern match', 'Destructure in binding'],
    tags: ['let', 'pattern', 'binding'],
  },
  {
    id: 'hs-pat-211',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Pattern in Where',
    text: 'Use pattern matching in where clause',
    setup: 'addPair p = a + b where (a, b) = p\npair = (3, 7)',
    setupCode: 'addPair p = a + b where (a, b) = p\npair = (3, 7)',
    expected: 10,
    sample: 'addPair pair',
    hints: ['where can pattern match', 'Destructure after where'],
    tags: ['where', 'pattern', 'binding'],
  },
  {
    id: 'hs-pat-212',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'View Patterns',
    text: 'Use view patterns for complex matching',
    setup: '{-# LANGUAGE ViewPatterns #-}\nisLong (length -> n) = n > 5\nstr = "haskell"',
    setupCode: 'isLong str = length str > 5\nstr = "haskell"',
    expected: true,
    sample: 'isLong str',
    hints: ['View patterns apply function before matching', 'Requires extension'],
    tags: ['view-pattern', 'pattern', 'advanced'],
  },
  {
    id: 'hs-pat-213',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Wildcard Pattern',
    text: 'Use _ to ignore parts of pattern',
    setup: 'third [_, _, x] = x\nlist = [1, 2, 3]',
    setupCode: 'third [_, _, x] = x\nlist = [1, 2, 3]',
    expected: 3,
    sample: 'third list',
    hints: ['_ matches anything and ignores it', 'Use for unused bindings'],
    tags: ['wildcard', 'pattern', 'basic'],
  },
  {
    id: 'hs-pat-214',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Literal Pattern',
    text: 'Match specific literal values',
    setup: 'isZero 0 = True\nisZero _ = False\nnum = 0',
    setupCode: 'isZero 0 = True\nisZero _ = False\nnum = 0',
    expected: true,
    sample: 'isZero num',
    hints: ['Numbers can be patterns', 'Match exact values'],
    tags: ['literal', 'pattern', 'basic'],
  },
  {
    id: 'hs-pat-215',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'String Pattern',
    text: 'Pattern match on string prefix',
    setup: 'hasHello ("Hello" ++ rest) = True\nhasHello _ = False\nstr = "Hello World"',
    setupCode: 'startsWithH (\'H\':_) = True\nstartsWithH _ = False\nstr = "Hello"',
    expected: true,
    sample: 'startsWithH str',
    hints: ['Strings are [Char]', 'Match with cons pattern'],
    tags: ['string', 'pattern', 'prefix'],
  },
  {
    id: 'hs-pat-216',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Irrefutable Pattern',
    text: 'Use ~ for lazy pattern matching',
    setup: 'lazyPair ~(a, b) = a\nval = undefined',
    setupCode: 'lazyFirst ~(a, _) = a\npair = (1, undefined)',
    expected: 1,
    sample: 'lazyFirst pair',
    hints: ['~ makes pattern irrefutable', 'Matches without evaluating'],
    tags: ['lazy', 'pattern', 'irrefutable'],
  },
  {
    id: 'hs-pat-217',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Pattern Guard',
    text: 'Combine pattern and boolean guard',
    setup: 'safeHead xs\n  | (x:_) <- xs = Just x\n  | otherwise = Nothing\nlist = [5, 10, 15]',
    setupCode: 'safeHead xs\n  | (x:_) <- xs = Just x\n  | otherwise = Nothing\nlist = [5, 10, 15]',
    expected: 'Just 5',
    sample: 'safeHead list',
    hints: ['<- in guard is pattern guard', 'Combines matching and condition'],
    tags: ['guard', 'pattern', 'combined'],
  },
  {
    id: 'hs-pat-218',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Match First Two',
    text: 'Pattern match first two elements',
    setup: 'sumFirstTwo (a:b:_) = a + b\nlist = [10, 20, 30, 40]',
    setupCode: 'sumFirstTwo (a:b:_) = a + b\nlist = [10, 20, 30, 40]',
    expected: 30,
    sample: 'sumFirstTwo list',
    hints: ['(a:b:xs) matches at least two elements', 'Chain cons patterns'],
    tags: ['pattern', 'list', 'multiple'],
  },
  {
    id: 'hs-pat-219',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Record Pattern',
    text: 'Pattern match on record fields',
    setup:
      'data Person = Person { name :: String, age :: Int }\ngetName Person{name = n} = n\nperson = Person "Alice" 30',
    setupCode:
      'data Person = Person { name :: String, age :: Int }\ngetName Person{name = n} = n\nperson = Person "Alice" 30',
    expected: 'Alice',
    sample: 'getName person',
    hints: ['Match specific record fields', 'Use field = binding syntax'],
    tags: ['record', 'pattern', 'data'],
  },
  {
    id: 'hs-pat-220',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Case on Maybe',
    text: 'Use case expression on Maybe',
    setup: 'maybeVal = Just 42',
    setupCode: 'maybeVal = Just 42',
    expected: 42,
    sample: 'case maybeVal of\n  Just x -> x\n  Nothing -> 0',
    hints: ['case handles all Maybe cases', 'Provide default for Nothing'],
    tags: ['case', 'maybe', 'pattern'],
  },
  {
    id: 'hs-pat-221',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Case on List Length',
    text: 'Match lists of specific lengths',
    setup:
      'descLen xs = case xs of\n  [] -> "empty"\n  [_] -> "one"\n  [_,_] -> "two"\n  _ -> "many"\nlist = [1, 2]',
    setupCode:
      'descLen xs = case xs of\n  [] -> "empty"\n  [_] -> "one"\n  [_,_] -> "two"\n  _ -> "many"\nlist = [1, 2]',
    expected: 'two',
    sample: 'descLen list',
    hints: ['[_] matches single element', '[_,_] matches exactly two'],
    tags: ['case', 'list', 'length'],
  },
  {
    id: 'hs-pat-222',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Bang Pattern',
    text: 'Use ! for strict pattern matching',
    setup:
      '{-# LANGUAGE BangPatterns #-}\nstrictSum !acc [] = acc\nstrictSum !acc (x:xs) = strictSum (acc + x) xs',
    setupCode:
      'strictSum acc [] = acc\nstrictSum acc (x:xs) = strictSum (acc + x) xs\nnums = [1, 2, 3, 4, 5]',
    expected: 15,
    sample: 'strictSum 0 nums',
    hints: ['! forces evaluation', 'Prevents thunk buildup'],
    tags: ['bang', 'strict', 'pattern'],
  },
  {
    id: 'hs-pat-223',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Guard with Let',
    text: 'Use let in guards',
    setup: 'classify n\n  | let sq = n * n, sq < 100 = "small"\n  | otherwise = "large"\nnum = 8',
    setupCode:
      'classify n\n  | let sq = n * n, sq < 100 = "small"\n  | otherwise = "large"\nnum = 8',
    expected: 'small',
    sample: 'classify num',
    hints: ['let in guard binds local variable', 'Comma separates from condition'],
    tags: ['guard', 'let', 'pattern'],
  },
  {
    id: 'hs-pat-224',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Match Triple',
    text: 'Pattern match on 3-tuple',
    setup: 'sum3 (a, b, c) = a + b + c\ntriple = (10, 20, 30)',
    setupCode: 'sum3 (a, b, c) = a + b + c\ntriple = (10, 20, 30)',
    expected: 60,
    sample: 'sum3 triple',
    hints: ['(a, b, c) matches 3-tuple', 'Extract all three elements'],
    tags: ['tuple', 'pattern', 'triple'],
  },
  {
    id: 'hs-pat-225',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Recursive Pattern',
    text: 'Use pattern matching for recursion',
    setup: 'myLength [] = 0\nmyLength (_:xs) = 1 + myLength xs\nlist = [1, 2, 3, 4, 5]',
    setupCode: 'myLength [] = 0\nmyLength (_:xs) = 1 + myLength xs\nlist = [1, 2, 3, 4, 5]',
    expected: 5,
    sample: 'myLength list',
    hints: ['Base case matches []', 'Recursive case uses cons pattern'],
    tags: ['recursion', 'pattern', 'list'],
  },
  {
    id: 'hs-pat-226',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Match on Bool',
    text: 'Pattern match on Boolean',
    setup: 'boolToInt True = 1\nboolToInt False = 0\nval = True',
    setupCode: 'boolToInt True = 1\nboolToInt False = 0\nval = True',
    expected: 1,
    sample: 'boolToInt val',
    hints: ['True and False are patterns', 'Match both cases'],
    tags: ['bool', 'pattern', 'basic'],
  },
  {
    id: 'hs-pat-227',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Case with Guards',
    text: 'Combine case expression with guards',
    setup:
      'descNum n = case n of\n  x | x < 0 -> "negative"\n    | x == 0 -> "zero"\n    | otherwise -> "positive"\nnum = -5',
    setupCode:
      'descNum n = case n of\n  x | x < 0 -> "negative"\n    | x == 0 -> "zero"\n    | otherwise -> "positive"\nnum = -5',
    expected: 'negative',
    sample: 'descNum num',
    hints: ['Guards can follow case patterns', 'Use | after pattern'],
    tags: ['case', 'guards', 'combined'],
  },
  {
    id: 'hs-pat-228',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Match Nested Maybe',
    text: 'Pattern match nested Maybe',
    setup: 'deepExtract (Just (Just x)) = x\ndeepExtract _ = 0\nval = Just (Just 42)',
    setupCode: 'deepExtract (Just (Just x)) = x\ndeepExtract _ = 0\nval = Just (Just 42)',
    expected: 42,
    sample: 'deepExtract val',
    hints: ['Nest Just patterns', 'Match the structure'],
    tags: ['maybe', 'nested', 'pattern'],
  },
  {
    id: 'hs-pat-229',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Lambda Pattern',
    text: 'Use pattern matching in lambda',
    setup: 'pairs = [(1, 2), (3, 4), (5, 6)]',
    setupCode: 'pairs = [(1, 2), (3, 4), (5, 6)]',
    expected: [3, 7, 11],
    sample: 'map (\\(a, b) -> a + b) pairs',
    hints: ['Lambda can pattern match', 'Destructure in argument'],
    tags: ['lambda', 'pattern', 'tuple'],
  },
  {
    id: 'hs-pat-230',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Match Char',
    text: 'Pattern match on character',
    setup:
      "isVowel c = case c of\n  'a' -> True\n  'e' -> True\n  'i' -> True\n  'o' -> True\n  'u' -> True\n  _ -> False\nchar = 'e'",
    setupCode: 'isVowel c = c `elem` "aeiou"\nchar = \'e\'',
    expected: true,
    sample: 'isVowel char',
    hints: ['Characters can be literal patterns', 'Match specific chars'],
    tags: ['char', 'pattern', 'case'],
  },
  {
    id: 'hs-pat-231',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Pattern Synonyms',
    text: 'Use pattern synonyms for abstraction',
    setup:
      '{-# LANGUAGE PatternSynonyms #-}\npattern Empty = []\nisEmpty Empty = True\nisEmpty _ = False',
    setupCode: 'isEmpty [] = True\nisEmpty _ = False\nlist = []',
    expected: true,
    sample: 'isEmpty list',
    hints: ['Pattern synonyms create named patterns', 'Requires extension'],
    tags: ['pattern-synonym', 'abstraction', 'advanced'],
  },
  {
    id: 'hs-pat-232',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Guards with Multiple Bindings',
    text: 'Use multiple bindings in guard',
    setup:
      'pythagorean a b c\n  | a2 + b2 == c2 = True\n  | otherwise = False\n  where a2 = a*a; b2 = b*b; c2 = c*c',
    setupCode: 'pythagorean a b c = a*a + b*b == c*c',
    expected: true,
    sample: 'pythagorean 3 4 5',
    hints: ['where can have multiple bindings', 'Use in guards'],
    tags: ['guards', 'where', 'multiple'],
  },
  {
    id: 'hs-pat-233',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'GADT Pattern',
    text: 'Pattern match on GADT',
    setup:
      '{-# LANGUAGE GADTs #-}\ndata Expr a where\n  IVal :: Int -> Expr Int\n  BVal :: Bool -> Expr Bool\neval (IVal n) = n',
    setupCode:
      'data Expr = IVal Int | BVal Bool\ngetInt (IVal n) = n\ngetInt _ = 0\nexpr = IVal 42',
    expected: 42,
    sample: 'getInt expr',
    hints: ['GADTs encode type in pattern', 'Match refines type'],
    tags: ['gadt', 'pattern', 'advanced'],
  },
  {
    id: 'hs-pat-234',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'List Pattern with n+k',
    text: 'Match at least n elements',
    setup: 'atLeastThree (_:_:_:_) = True\natLeastThree _ = False\nlist = [1, 2, 3, 4]',
    setupCode: 'atLeastThree (_:_:_:_) = True\natLeastThree _ = False\nlist = [1, 2, 3, 4]',
    expected: true,
    sample: 'atLeastThree list',
    hints: ['Chain cons patterns', 'Each _ matches one element'],
    tags: ['list', 'pattern', 'length'],
  },
  {
    id: 'hs-pat-235',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Match Unit',
    text: 'Pattern match on unit type',
    setup: 'isUnit () = True\nval = ()',
    setupCode: 'isUnit () = True\nval = ()',
    expected: true,
    sample: 'isUnit val',
    hints: ['() is the only value of unit type', 'Only one pattern possible'],
    tags: ['unit', 'pattern', 'basic'],
  },
  {
    id: 'hs-pat-236',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Recursive Data Pattern',
    text: 'Pattern match on recursive data',
    setup:
      'data Tree a = Leaf a | Node (Tree a) (Tree a)\ndepth (Leaf _) = 1\ndepth (Node l r) = 1 + max (depth l) (depth r)\ntree = Node (Leaf 1) (Node (Leaf 2) (Leaf 3))',
    setupCode:
      'data Tree a = Leaf a | Node (Tree a) (Tree a)\ndepth (Leaf _) = 1\ndepth (Node l r) = 1 + max (depth l) (depth r)\ntree = Node (Leaf 1) (Node (Leaf 2) (Leaf 3))',
    expected: 3,
    sample: 'depth tree',
    hints: ['Match each constructor', 'Recurse on subtrees'],
    tags: ['tree', 'recursion', 'pattern'],
  },
  {
    id: 'hs-pat-237',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Pattern in List Comprehension',
    text: 'Use pattern matching in generator',
    setup: 'pairs = [(1, "a"), (2, "b"), (3, "c")]',
    setupCode: 'pairs = [(1, "a"), (2, "b"), (3, "c")]',
    expected: [1, 2, 3],
    sample: '[x | (x, _) <- pairs]',
    hints: ['Generator can pattern match', 'Extract first of each pair'],
    tags: ['comprehension', 'pattern', 'generator'],
  },
  {
    id: 'hs-pat-238',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Match on Ordering',
    text: 'Pattern match on Ordering type',
    setup:
      'descOrd ord = case ord of\n  LT -> "less"\n  EQ -> "equal"\n  GT -> "greater"\nval = compare 5 3',
    setupCode:
      'descOrd ord = case ord of\n  LT -> "less"\n  EQ -> "equal"\n  GT -> "greater"\nval = compare 5 3',
    expected: 'greater',
    sample: 'descOrd val',
    hints: ['Ordering has LT, EQ, GT', 'Match all three'],
    tags: ['ordering', 'pattern', 'case'],
  },
  {
    id: 'hs-pat-239',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Type Class Default Pattern',
    text: 'Default implementation with pattern',
    setup:
      'class MyEq a where\n  eq :: a -> a -> Bool\n  neq :: a -> a -> Bool\n  neq x y = not (eq x y)',
    setupCode: 'myNeq x y = not (x == y)',
    expected: true,
    sample: 'myNeq 1 2',
    hints: ['Default uses pattern variables', 'Implement in terms of other methods'],
    tags: ['typeclass', 'default', 'pattern'],
  },
  {
    id: 'hs-pat-240',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Exhaustive Pattern',
    text: 'Ensure all cases are covered',
    setup: 'safeDiv _ 0 = Nothing\nsafeDiv x y = Just (x `div` y)\na = 10\nb = 2',
    setupCode: 'safeDiv _ 0 = Nothing\nsafeDiv x y = Just (x `div` y)\na = 10\nb = 2',
    expected: 'Just 5',
    sample: 'safeDiv a b',
    hints: ['Match special cases first', 'General case last'],
    tags: ['exhaustive', 'pattern', 'safe'],
  },
  {
    id: 'hs-pat-241',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Cons and Append',
    text: 'Match head and use tail',
    setup: 'rotateLeft (x:xs) = xs ++ [x]\nlist = [1, 2, 3, 4]',
    setupCode: 'rotateLeft (x:xs) = xs ++ [x]\nlist = [1, 2, 3, 4]',
    expected: [2, 3, 4, 1],
    sample: 'rotateLeft list',
    hints: ['(x:xs) gives head and tail', 'Append head to end'],
    tags: ['cons', 'pattern', 'list'],
  },
  {
    id: 'hs-pat-242',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Match Specific Length',
    text: 'Match list of exactly 3 elements',
    setup: 'exactly3 [a, b, c] = Just (a + b + c)\nexactly3 _ = Nothing\nlist = [1, 2, 3]',
    setupCode: 'exactly3 [a, b, c] = Just (a + b + c)\nexactly3 _ = Nothing\nlist = [1, 2, 3]',
    expected: 'Just 6',
    sample: 'exactly3 list',
    hints: ['[a, b, c] matches exactly 3', 'Different from (a:b:c:_)'],
    tags: ['list', 'exact', 'pattern'],
  },
  {
    id: 'hs-pat-243',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Pattern in Do Notation',
    text: 'Pattern match in do binding',
    setup:
      'extractPairs :: [(Int, Int)] -> Maybe Int\nextractPairs pairs = do\n  (a, b) <- listToMaybe pairs\n  return (a + b)\npairs = [(1, 2), (3, 4)]',
    setupCode:
      'extractFirst pairs = do\n  (a, b) <- Just (head pairs)\n  return (a + b)\npairs = [(1, 2), (3, 4)]',
    expected: 'Just 3',
    sample: 'extractFirst pairs',
    hints: ['<- can pattern match', 'Fails monad on mismatch'],
    tags: ['do', 'pattern', 'monad'],
  },
  {
    id: 'hs-pat-244',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Match Empty and Non-Empty',
    text: 'Handle empty and non-empty differently',
    setup: 'safeMax [] = Nothing\nsafeMax xs = Just (maximum xs)\nlist = [3, 1, 4, 1, 5]',
    setupCode: 'safeMax [] = Nothing\nsafeMax xs = Just (maximum xs)\nlist = [3, 1, 4, 1, 5]',
    expected: 'Just 5',
    sample: 'safeMax list',
    hints: ['[] matches empty', 'xs matches any non-empty'],
    tags: ['maybe', 'safe', 'pattern'],
  },
  {
    id: 'hs-pat-245',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Newtype Pattern',
    text: 'Pattern match through newtype',
    setup: 'newtype Age = Age Int\ngetAge (Age n) = n\nage = Age 25',
    setupCode: 'newtype Age = Age Int\ngetAge (Age n) = n\nage = Age 25',
    expected: 25,
    sample: 'getAge age',
    hints: ['Newtype has single constructor', 'Pattern matches through wrapper'],
    tags: ['newtype', 'pattern', 'unwrap'],
  },
  {
    id: 'hs-pat-246',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Or-Pattern Simulation',
    text: 'Match multiple patterns to same result',
    setup:
      'isWeekend "Saturday" = True\nisWeekend "Sunday" = True\nisWeekend _ = False\nday = "Saturday"',
    setupCode:
      'isWeekend "Saturday" = True\nisWeekend "Sunday" = True\nisWeekend _ = False\nday = "Saturday"',
    expected: true,
    sample: 'isWeekend day',
    hints: ['Multiple clauses for same result', 'Haskell lacks or-patterns'],
    tags: ['multiple', 'clause', 'pattern'],
  },
  {
    id: 'hs-pat-247',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Strict Field Pattern',
    text: 'Match with strict evaluation',
    setup: 'data StrictPair = SP !Int !Int\ngetStrictFirst (SP x _) = x\npair = SP 1 2',
    setupCode: 'data StrictPair = SP !Int !Int\ngetStrictFirst (SP x _) = x\npair = SP 1 2',
    expected: 1,
    sample: 'getStrictFirst pair',
    hints: ['! makes field strict', 'Evaluated on construction'],
    tags: ['strict', 'data', 'pattern'],
  },
  {
    id: 'hs-pat-248',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Match Infix Constructor',
    text: 'Pattern match on infix constructor',
    setup: 'myHead (x :| _) = x\nlist = 1 :| [2, 3, 4]',
    setupCode:
      'import Data.List.NonEmpty (NonEmpty(..))\nmyHead (x :| _) = x\nlist = 1 :| [2, 3, 4]',
    expected: 1,
    sample: 'myHead list',
    hints: ['Infix constructors can be patterns', '(:|) is NonEmpty constructor'],
    tags: ['infix', 'nonempty', 'pattern'],
  },
  {
    id: 'hs-pat-249',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Complete Pattern Match',
    text: 'Use COMPLETE pragma for exhaustiveness',
    setup: '{-# COMPLETE Empty, NonEmpty #-}\npattern Empty = []\npattern NonEmpty x xs = x:xs',
    setupCode:
      'handleList [] = "empty"\nhandleList (x:xs) = "has " ++ show (length (x:xs))\nlist = [1, 2, 3]',
    expected: 'has 3',
    sample: 'handleList list',
    hints: ['COMPLETE marks exhaustive patterns', 'Helps with warnings'],
    tags: ['complete', 'pragma', 'pattern'],
  },

  // ============================================================
  // TYPE CLASSES (250-299)
  // ============================================================
  {
    id: 'hs-tc-250',
    category: 'Type Classes',
    difficulty: 'easy',
    title: 'Eq Instance Check',
    text: 'Use == to compare values',
    setup: 'a = 5\nb = 5',
    setupCode: 'a = 5\nb = 5',
    expected: true,
    sample: 'a == b',
    hints: ['== is from Eq type class', 'Most types have Eq instance'],
    tags: ['eq', 'typeclass', 'comparison'],
  },
  {
    id: 'hs-tc-251',
    category: 'Type Classes',
    difficulty: 'easy',
    title: 'Not Equal Check',
    text: 'Use /= to check inequality',
    setup: 'a = 5\nb = 10',
    setupCode: 'a = 5\nb = 10',
    expected: true,
    sample: 'a /= b',
    hints: ['/= is not equal from Eq', 'Opposite of =='],
    tags: ['eq', 'typeclass', 'comparison'],
  },
  {
    id: 'hs-tc-252',
    category: 'Type Classes',
    difficulty: 'easy',
    title: 'Ord Compare',
    text: 'Use compare for ordering',
    setup: 'a = 5\nb = 10',
    setupCode: 'a = 5\nb = 10',
    expected: 'LT',
    sample: 'compare a b',
    hints: ['compare returns Ordering', 'LT, EQ, or GT'],
    tags: ['ord', 'typeclass', 'comparison'],
  },
  {
    id: 'hs-tc-253',
    category: 'Type Classes',
    difficulty: 'easy',
    title: 'Show to String',
    text: 'Use show to convert to String',
    setup: 'num = 42',
    setupCode: 'num = 42',
    expected: '42',
    sample: 'show num',
    hints: ['show converts to String', 'From Show type class'],
    tags: ['show', 'typeclass', 'string'],
  },
  {
    id: 'hs-tc-254',
    category: 'Type Classes',
    difficulty: 'easy',
    title: 'Read from String',
    text: 'Use read to parse a String',
    setup: 'str = "42"',
    setupCode: 'str = "42"',
    expected: 42,
    sample: 'read str :: Int',
    hints: ['read parses from String', 'Needs type annotation'],
    tags: ['read', 'typeclass', 'parse'],
  },
  {
    id: 'hs-tc-255',
    category: 'Type Classes',
    difficulty: 'medium',
    title: 'Functor fmap',
    text: 'Use fmap on a Functor',
    setup: 'maybeVal = Just 10',
    setupCode: 'maybeVal = Just 10',
    expected: 'Just 20',
    sample: 'fmap (*2) maybeVal',
    hints: ['fmap applies function inside Functor', 'Maybe is a Functor'],
    tags: ['functor', 'fmap', 'typeclass'],
  },
  {
    id: 'hs-tc-256',
    category: 'Type Classes',
    difficulty: 'medium',
    title: 'Functor Infix',
    text: 'Use <$> operator for fmap',
    setup: 'maybeVal = Just 5',
    setupCode: 'maybeVal = Just 5',
    expected: 'Just 25',
    sample: '(^2) <$> maybeVal',
    hints: ['<$> is infix fmap', 'Same as fmap'],
    tags: ['functor', 'operator', 'typeclass'],
  },
  {
    id: 'hs-tc-257',
    category: 'Type Classes',
    difficulty: 'medium',
    title: 'Applicative pure',
    text: 'Use pure to lift a value',
    setup: 'val = 42',
    setupCode: 'val = 42',
    expected: 'Just 42',
    sample: 'pure val :: Maybe Int',
    hints: ['pure lifts into Applicative', 'Wraps in minimal context'],
    tags: ['applicative', 'pure', 'typeclass'],
  },
  {
    id: 'hs-tc-258',
    category: 'Type Classes',
    difficulty: 'medium',
    title: 'Applicative Apply',
    text: 'Use <*> to apply wrapped function',
    setup: 'mf = Just (+10)\nmx = Just 5',
    setupCode: 'mf = Just (+10)\nmx = Just 5',
    expected: 'Just 15',
    sample: 'mf <*> mx',
    hints: ['<*> applies wrapped function', 'Both in Maybe'],
    tags: ['applicative', 'apply', 'typeclass'],
  },
  {
    id: 'hs-tc-259',
    category: 'Type Classes',
    difficulty: 'medium',
    title: 'Monad bind',
    text: 'Use >>= to chain monadic operations',
    setup: 'mx = Just 10\nf x = Just (x * 2)',
    setupCode: 'mx = Just 10\nf x = Just (x * 2)',
    expected: 'Just 20',
    sample: 'mx >>= f',
    hints: ['>>= chains monadic computations', 'Unwraps, applies, rewraps'],
    tags: ['monad', 'bind', 'typeclass'],
  },
  {
    id: 'hs-tc-260',
    category: 'Type Classes',
    difficulty: 'medium',
    title: 'Monad return',
    text: 'Use return to wrap a value',
    setup: 'val = 42',
    setupCode: 'val = 42',
    expected: 'Just 42',
    sample: 'return val :: Maybe Int',
    hints: ['return is same as pure for Monad', 'Wraps in monadic context'],
    tags: ['monad', 'return', 'typeclass'],
  },
  {
    id: 'hs-tc-261',
    category: 'Type Classes',
    difficulty: 'hard',
    title: 'Semigroup Combine',
    text: 'Use <> to combine Semigroup values',
    setup: 'a = [1, 2]\nb = [3, 4]',
    setupCode: 'a = [1, 2]\nb = [3, 4]',
    expected: [1, 2, 3, 4],
    sample: 'a <> b',
    hints: ['<> is Semigroup combine', 'Lists concatenate'],
    tags: ['semigroup', 'combine', 'typeclass'],
  },
  {
    id: 'hs-tc-262',
    category: 'Type Classes',
    difficulty: 'hard',
    title: 'Monoid mempty',
    text: 'Use mempty for identity element',
    setup: '',
    setupCode: '',
    expected: [],
    sample: 'mempty :: [Int]',
    hints: ['mempty is identity for Monoid', 'Empty list for []'],
    tags: ['monoid', 'mempty', 'typeclass'],
  },
  {
    id: 'hs-tc-263',
    category: 'Type Classes',
    difficulty: 'hard',
    title: 'Monoid mconcat',
    text: 'Use mconcat to combine list of Monoids',
    setup: 'strs = ["Hello", " ", "World"]',
    setupCode: 'strs = ["Hello", " ", "World"]',
    expected: 'Hello World',
    sample: 'mconcat strs',
    hints: ['mconcat folds with <>'],
    tags: ['monoid', 'mconcat', 'typeclass'],
  },
  {
    id: 'hs-tc-264',
    category: 'Type Classes',
    difficulty: 'easy',
    title: 'Num Operations',
    text: 'Use Num operations',
    setup: 'a = 10\nb = 3',
    setupCode: 'a = 10\nb = 3',
    expected: 13,
    sample: 'a + b',
    hints: ['+ is from Num', 'Works on any Num instance'],
    tags: ['num', 'arithmetic', 'typeclass'],
  },
  {
    id: 'hs-tc-265',
    category: 'Type Classes',
    difficulty: 'medium',
    title: 'Fractional Division',
    text: 'Use / for fractional division',
    setup: 'a = 10.0\nb = 4.0',
    setupCode: 'a = 10.0\nb = 4.0',
    expected: 2.5,
    sample: 'a / b',
    hints: ['/ requires Fractional', 'Use Double or Float'],
    tags: ['fractional', 'division', 'typeclass'],
  },
  {
    id: 'hs-tc-266',
    category: 'Type Classes',
    difficulty: 'medium',
    title: 'Integral Division',
    text: 'Use div for integer division',
    setup: 'a = 17\nb = 5',
    setupCode: 'a = 17\nb = 5',
    expected: 3,
    sample: 'a `div` b',
    hints: ['div is integer division', 'From Integral class'],
    tags: ['integral', 'division', 'typeclass'],
  },
  {
    id: 'hs-tc-267',
    category: 'Type Classes',
    difficulty: 'medium',
    title: 'Integral Modulo',
    text: 'Use mod for remainder',
    setup: 'a = 17\nb = 5',
    setupCode: 'a = 17\nb = 5',
    expected: 2,
    sample: 'a `mod` b',
    hints: ['mod is modulo operation', 'From Integral class'],
    tags: ['integral', 'modulo', 'typeclass'],
  },
  {
    id: 'hs-tc-268',
    category: 'Type Classes',
    difficulty: 'medium',
    title: 'Bounded Limits',
    text: 'Use minBound and maxBound',
    setup: '',
    setupCode: '',
    expected: -128,
    sample: 'minBound :: Int8',
    hints: ['Bounded has min and max', 'Type-specific limits'],
    tags: ['bounded', 'limits', 'typeclass'],
  },
  {
    id: 'hs-tc-269',
    category: 'Type Classes',
    difficulty: 'easy',
    title: 'Enum toEnum',
    text: 'Use toEnum to convert Int to Enum',
    setup: '',
    setupCode: '',
    expected: 'C',
    sample: 'toEnum 2 :: Char',
    hints: ['toEnum converts from Int', 'Index in enumeration'],
    tags: ['enum', 'toEnum', 'typeclass'],
  },
  {
    id: 'hs-tc-270',
    category: 'Type Classes',
    difficulty: 'easy',
    title: 'Enum fromEnum',
    text: 'Use fromEnum to get index',
    setup: "c = 'A'",
    setupCode: "c = 'A'",
    expected: 65,
    sample: 'fromEnum c',
    hints: ['fromEnum gets Int index', 'Inverse of toEnum'],
    tags: ['enum', 'fromEnum', 'typeclass'],
  },
  {
    id: 'hs-tc-271',
    category: 'Type Classes',
    difficulty: 'medium',
    title: 'Foldable fold',
    text: 'Use fold on Foldable Monoid',
    setup: 'import Data.Foldable (fold)\nlists = [[1, 2], [3, 4], [5, 6]]',
    setupCode: 'lists = [[1, 2], [3, 4], [5, 6]]',
    expected: [1, 2, 3, 4, 5, 6],
    sample: 'fold lists',
    hints: ['fold uses Monoid to combine', 'From Foldable'],
    tags: ['foldable', 'fold', 'typeclass'],
  },
  {
    id: 'hs-tc-272',
    category: 'Type Classes',
    difficulty: 'medium',
    title: 'Foldable toList',
    text: 'Use toList on Foldable',
    setup: 'import Data.Foldable (toList)\nmaybeVal = Just 42',
    setupCode: 'maybeVal = Just 42',
    expected: [42],
    sample: 'toList maybeVal',
    hints: ['toList converts to list', 'Maybe has 0 or 1 elements'],
    tags: ['foldable', 'toList', 'typeclass'],
  },
  {
    id: 'hs-tc-273',
    category: 'Type Classes',
    difficulty: 'hard',
    title: 'Traversable traverse',
    text: 'Use traverse with Applicative',
    setup: 'f x = if x > 0 then Just x else Nothing\nlist = [1, 2, 3]',
    setupCode: 'f x = if x > 0 then Just x else Nothing\nlist = [1, 2, 3]',
    expected: 'Just [1, 2, 3]',
    sample: 'traverse f list',
    hints: ['traverse maps with Applicative effect', 'Collects results'],
    tags: ['traversable', 'traverse', 'typeclass'],
  },
  {
    id: 'hs-tc-274',
    category: 'Type Classes',
    difficulty: 'hard',
    title: 'Traversable sequence',
    text: 'Use sequence on list of Maybes',
    setup: 'maybes = [Just 1, Just 2, Just 3]',
    setupCode: 'maybes = [Just 1, Just 2, Just 3]',
    expected: 'Just [1, 2, 3]',
    sample: 'sequence maybes',
    hints: ['sequence flips structure', 'From Traversable'],
    tags: ['traversable', 'sequence', 'typeclass'],
  },
  {
    id: 'hs-tc-275',
    category: 'Type Classes',
    difficulty: 'medium',
    title: 'Custom Eq Instance',
    text: 'Define Eq for custom type',
    setup:
      'data Point = Point Int Int\ninstance Eq Point where\n  Point x1 y1 == Point x2 y2 = x1 == x2 && y1 == y2\np1 = Point 1 2\np2 = Point 1 2',
    setupCode: 'data Point = Point Int Int deriving Eq\np1 = Point 1 2\np2 = Point 1 2',
    expected: true,
    sample: 'p1 == p2',
    hints: ['Define == for your type', 'Compare all fields'],
    tags: ['instance', 'eq', 'custom'],
  },
  {
    id: 'hs-tc-276',
    category: 'Type Classes',
    difficulty: 'medium',
    title: 'Custom Ord Instance',
    text: 'Define ordering for custom type',
    setup: 'data Size = Small | Medium | Large deriving (Eq, Ord)\ns1 = Small\ns2 = Large',
    setupCode: 'data Size = Small | Medium | Large deriving (Eq, Ord)\ns1 = Small\ns2 = Large',
    expected: true,
    sample: 's1 < s2',
    hints: ['Derived Ord uses constructor order', 'First is smallest'],
    tags: ['instance', 'ord', 'custom'],
  },
  {
    id: 'hs-tc-277',
    category: 'Type Classes',
    difficulty: 'medium',
    title: 'Custom Show Instance',
    text: 'Define string representation',
    setup:
      'data Color = Red | Green | Blue\ninstance Show Color where\n  show Red = "red"\n  show Green = "green"\n  show Blue = "blue"\nc = Red',
    setupCode:
      'data Color = Red | Green | Blue\ninstance Show Color where\n  show Red = "red"\n  show Green = "green"\n  show Blue = "blue"\nc = Red',
    expected: 'red',
    sample: 'show c',
    hints: ['Define show for your type', 'Return a String'],
    tags: ['instance', 'show', 'custom'],
  },
  {
    id: 'hs-tc-278',
    category: 'Type Classes',
    difficulty: 'hard',
    title: 'Custom Functor Instance',
    text: 'Define fmap for custom type',
    setup:
      'data Box a = Box a\ninstance Functor Box where\n  fmap f (Box x) = Box (f x)\nbox = Box 5',
    setupCode:
      'data Box a = Box a\ninstance Functor Box where\n  fmap f (Box x) = Box (f x)\nbox = Box 5',
    expected: 'Box 10',
    sample: 'show (fmap (*2) box)',
    hints: ['fmap applies function inside', 'Preserve structure'],
    tags: ['instance', 'functor', 'custom'],
  },
  {
    id: 'hs-tc-279',
    category: 'Type Classes',
    difficulty: 'hard',
    title: 'Custom Applicative Instance',
    text: 'Define pure and <*> for custom type',
    setup:
      'data Identity a = Identity a\ninstance Functor Identity where fmap f (Identity x) = Identity (f x)\ninstance Applicative Identity where\n  pure = Identity\n  Identity f <*> Identity x = Identity (f x)',
    setupCode:
      'newtype Identity a = Identity a deriving Show\ninstance Functor Identity where fmap f (Identity x) = Identity (f x)\ninstance Applicative Identity where\n  pure = Identity\n  Identity f <*> Identity x = Identity (f x)\nval = Identity 5',
    expected: 'Identity 10',
    sample: 'show (pure (*2) <*> val)',
    hints: ['pure wraps value', '<*> applies wrapped function'],
    tags: ['instance', 'applicative', 'custom'],
  },
  {
    id: 'hs-tc-280',
    category: 'Type Classes',
    difficulty: 'hard',
    title: 'Custom Monad Instance',
    text: 'Define >>= for custom type',
    setup:
      'newtype Identity a = Identity { runIdentity :: a }\ninstance Monad Identity where\n  Identity x >>= f = f x',
    setupCode:
      'newtype Identity a = Identity { runIdentity :: a }\ninstance Functor Identity where fmap f (Identity x) = Identity (f x)\ninstance Applicative Identity where pure = Identity; Identity f <*> Identity x = Identity (f x)\ninstance Monad Identity where Identity x >>= f = f x\nval = Identity 5',
    expected: 10,
    sample: 'runIdentity (val >>= \\x -> Identity (x * 2))',
    hints: ['>>= extracts value and applies', 'Returns new wrapped value'],
    tags: ['instance', 'monad', 'custom'],
  },
  {
    id: 'hs-tc-281',
    category: 'Type Classes',
    difficulty: 'easy',
    title: 'Deriving Multiple Classes',
    text: 'Derive multiple type classes',
    setup: 'data Person = Person String Int deriving (Eq, Show, Ord)\np = Person "Alice" 30',
    setupCode: 'data Person = Person String Int deriving (Eq, Show, Ord)\np = Person "Alice" 30',
    expected: 'Person "Alice" 30',
    sample: 'show p',
    hints: ['List classes to derive', 'Compiler generates instances'],
    tags: ['deriving', 'multiple', 'typeclass'],
  },
  {
    id: 'hs-tc-282',
    category: 'Type Classes',
    difficulty: 'medium',
    title: 'Type Class Constraint',
    text: 'Use type class constraint in function',
    setup: 'showTwice :: Show a => a -> String\nshowTwice x = show x ++ show x\nval = 42',
    setupCode: 'showTwice x = show x ++ show x\nval = 42',
    expected: '4242',
    sample: 'showTwice val',
    hints: ['=> adds constraint', 'Requires Show instance'],
    tags: ['constraint', 'typeclass', 'function'],
  },
  {
    id: 'hs-tc-283',
    category: 'Type Classes',
    difficulty: 'medium',
    title: 'Multiple Constraints',
    text: 'Use multiple type class constraints',
    setup:
      'compareAndShow :: (Ord a, Show a) => a -> a -> String\ncompareAndShow x y = show x ++ cmp ++ show y\n  where cmp = case compare x y of\n    LT -> " < "\n    EQ -> " = "\n    GT -> " > "',
    setupCode:
      'compareAndShow x y = show x ++ (if x < y then " < " else if x > y then " > " else " = ") ++ show y',
    expected: '3 < 5',
    sample: 'compareAndShow 3 5',
    hints: ['(C1 a, C2 a) for multiple', 'Both must be satisfied'],
    tags: ['constraint', 'multiple', 'typeclass'],
  },
  {
    id: 'hs-tc-284',
    category: 'Type Classes',
    difficulty: 'hard',
    title: 'Superclass Constraint',
    text: 'Type class with superclass',
    setup: 'class Eq a => Ord a where\n  compare :: a -> a -> Ordering',
    setupCode: '',
    expected: true,
    sample: '(5 :: Int) <= 10',
    hints: ['Eq is superclass of Ord', 'Ord implies Eq'],
    tags: ['superclass', 'hierarchy', 'typeclass'],
  },
  {
    id: 'hs-tc-285',
    category: 'Type Classes',
    difficulty: 'easy',
    title: 'Real to Fractional',
    text: 'Use realToFrac for conversion',
    setup: 'intVal = 5 :: Int',
    setupCode: 'intVal = 5 :: Int',
    expected: 5.0,
    sample: 'realToFrac intVal :: Double',
    hints: ['realToFrac converts numeric types', 'From Real to Fractional'],
    tags: ['real', 'fractional', 'conversion'],
  },
  {
    id: 'hs-tc-286',
    category: 'Type Classes',
    difficulty: 'medium',
    title: 'fromIntegral Conversion',
    text: 'Use fromIntegral to convert Int',
    setup: 'n = 10 :: Int',
    setupCode: 'n = 10 :: Int',
    expected: 10.0,
    sample: 'fromIntegral n :: Double',
    hints: ['fromIntegral converts integers', 'To any Num type'],
    tags: ['fromIntegral', 'conversion', 'typeclass'],
  },
  {
    id: 'hs-tc-287',
    category: 'Type Classes',
    difficulty: 'hard',
    title: 'Generic Deriving',
    text: 'Use generic deriving for JSON',
    setup:
      '{-# LANGUAGE DeriveGeneric #-}\nimport GHC.Generics\ndata Person = Person { name :: String } deriving Generic',
    setupCode: 'data Person = Person { name :: String } deriving (Show, Eq)\np = Person "Alice"',
    expected: true,
    sample: 'p == Person "Alice"',
    hints: ['Generic enables automatic instances', 'For serialization libraries'],
    tags: ['generic', 'deriving', 'typeclass'],
  },
  {
    id: 'hs-tc-288',
    category: 'Type Classes',
    difficulty: 'medium',
    title: 'Floating Operations',
    text: 'Use Floating class functions',
    setup: 'x = 2.0',
    setupCode: 'x = 2.0',
    expected: 4.0,
    sample: 'exp (log x) + x',
    hints: ['exp and log from Floating', 'exp (log x) = x'],
    tags: ['floating', 'math', 'typeclass'],
  },
  {
    id: 'hs-tc-289',
    category: 'Type Classes',
    difficulty: 'medium',
    title: 'RealFrac Operations',
    text: 'Use truncate and round',
    setup: 'x = 3.7',
    setupCode: 'x = 3.7',
    expected: [3, 4],
    sample: '[truncate x, round x]',
    hints: ['truncate towards zero', 'round to nearest'],
    tags: ['realfrac', 'rounding', 'typeclass'],
  },
  {
    id: 'hs-tc-290',
    category: 'Type Classes',
    difficulty: 'hard',
    title: 'Coercible Conversion',
    text: 'Use coerce for newtype conversion',
    setup: 'import Data.Coerce (coerce)\nnewtype Age = Age Int deriving Show\nval = 25 :: Int',
    setupCode: 'newtype Age = Age Int deriving Show\nval = 25 :: Int',
    expected: 'Age 25',
    sample: 'show (Age val)',
    hints: ['coerce does zero-cost conversion', 'For representationally equal types'],
    tags: ['coerce', 'newtype', 'typeclass'],
  },
  {
    id: 'hs-tc-291',
    category: 'Type Classes',
    difficulty: 'hard',
    title: 'Alternative Choice',
    text: 'Use <|> for Alternative',
    setup: 'import Control.Applicative ((<|>))\na = Nothing\nb = Just 5',
    setupCode: 'a = Nothing\nb = Just 5',
    expected: 'Just 5',
    sample: 'a <|> b',
    hints: ['<|> chooses first success', 'Alternative for Maybe'],
    tags: ['alternative', 'choice', 'typeclass'],
  },
  {
    id: 'hs-tc-292',
    category: 'Type Classes',
    difficulty: 'hard',
    title: 'MonadPlus mzero',
    text: 'Use mzero as empty',
    setup: 'import Control.Monad (mzero)',
    setupCode: '',
    expected: '[]',
    sample: 'show (mzero :: [Int])',
    hints: ['mzero is identity for mplus', 'Empty for MonadPlus'],
    tags: ['monadplus', 'mzero', 'typeclass'],
  },
  {
    id: 'hs-tc-293',
    category: 'Type Classes',
    difficulty: 'medium',
    title: 'Bifunctor bimap',
    text: 'Map over both sides of Either',
    setup: 'import Data.Bifunctor (bimap)\nval = Right 5 :: Either String Int',
    setupCode: 'val = Right 5 :: Either String Int',
    expected: 'Right 10',
    sample: 'show (bimap (++ "!") (*2) val)',
    hints: ['bimap maps both sides', 'First function for Left, second for Right'],
    tags: ['bifunctor', 'bimap', 'typeclass'],
  },
  {
    id: 'hs-tc-294',
    category: 'Type Classes',
    difficulty: 'hard',
    title: 'Contravariant contramap',
    text: 'Use contramap for contravariant functor',
    setup:
      'import Data.Functor.Contravariant\nnewtype Predicate a = Predicate { getPredicate :: a -> Bool }',
    setupCode: 'isPositive n = n > 0\nval = -5',
    expected: false,
    sample: 'isPositive val',
    hints: ['Contravariant reverses mapping', 'For input positions'],
    tags: ['contravariant', 'contramap', 'typeclass'],
  },
  {
    id: 'hs-tc-295',
    category: 'Type Classes',
    difficulty: 'medium',
    title: 'IsString Overloading',
    text: 'Use OverloadedStrings for IsString',
    setup: '{-# LANGUAGE OverloadedStrings #-}\nimport Data.Text (Text)\nstr = "hello" :: Text',
    setupCode: 'str = "hello"',
    expected: 'hello',
    sample: 'str',
    hints: ['OverloadedStrings enables polymorphic literals', 'String literals become IsString'],
    tags: ['isstring', 'overloaded', 'typeclass'],
  },
  {
    id: 'hs-tc-296',
    category: 'Type Classes',
    difficulty: 'hard',
    title: 'IsList Overloading',
    text: 'Use OverloadedLists for IsList',
    setup: '{-# LANGUAGE OverloadedLists #-}\nimport Data.Set (Set)\nset = [1, 2, 3] :: Set Int',
    setupCode: 'import qualified Data.Set as Set\nset = Set.fromList [1, 2, 3]',
    expected: true,
    sample: 'Set.member 2 set',
    hints: ['OverloadedLists for list literals', 'Can create Set, Map, etc.'],
    tags: ['islist', 'overloaded', 'typeclass'],
  },
  {
    id: 'hs-tc-297',
    category: 'Type Classes',
    difficulty: 'medium',
    title: 'Hashable for HashMap',
    text: 'Use Hashable constraint',
    setup:
      'import Data.Hashable\nimport qualified Data.HashMap.Strict as HM\nmap = HM.fromList [(1, "one"), (2, "two")]',
    setupCode: 'import qualified Data.Map as Map\nmap = Map.fromList [(1, "one"), (2, "two")]',
    expected: 'Just "one"',
    sample: 'show (Map.lookup 1 map)',
    hints: ['Hashable enables HashMap keys', 'Efficient lookup'],
    tags: ['hashable', 'hashmap', 'typeclass'],
  },
  {
    id: 'hs-tc-298',
    category: 'Type Classes',
    difficulty: 'hard',
    title: 'Default Class Values',
    text: 'Use default method implementation',
    setup:
      'class MyClass a where\n  method1 :: a -> Int\n  method2 :: a -> Int\n  method2 = method1',
    setupCode: '',
    expected: true,
    sample: 'True',
    hints: ['Default implementations in class', 'Override if needed'],
    tags: ['default', 'method', 'typeclass'],
  },
  {
    id: 'hs-tc-299',
    category: 'Type Classes',
    difficulty: 'hard',
    title: 'Associated Type Family',
    text: 'Use associated type in class',
    setup:
      '{-# LANGUAGE TypeFamilies #-}\nclass Container c where\n  type Elem c\n  empty :: c\n  insert :: Elem c -> c -> c',
    setupCode: '',
    expected: true,
    sample: 'True',
    hints: ['Associated types depend on class', 'Elem depends on container type'],
    tags: ['typefamily', 'associated', 'typeclass'],
  },

  // ============================================================
  // MAYBE/EITHER (300-349)
  // ============================================================
  {
    id: 'hs-me-300',
    category: 'Maybe/Either',
    difficulty: 'easy',
    title: 'Create Just Value',
    text: 'Wrap a value in Just',
    setup: 'val = 42',
    setupCode: 'val = 42',
    expected: 'Just 42',
    sample: 'Just val',
    hints: ['Just wraps a value', 'Creates Maybe with value'],
    tags: ['maybe', 'just', 'basic'],
  },
  {
    id: 'hs-me-301',
    category: 'Maybe/Either',
    difficulty: 'easy',
    title: 'Create Nothing',
    text: 'Create a Nothing value',
    setup: '',
    setupCode: '',
    expected: 'Nothing',
    sample: 'Nothing :: Maybe Int',
    hints: ['Nothing represents absence', 'Need type annotation'],
    tags: ['maybe', 'nothing', 'basic'],
  },
  {
    id: 'hs-me-302',
    category: 'Maybe/Either',
    difficulty: 'easy',
    title: 'isJust Check',
    text: 'Check if Maybe is Just',
    setup: 'import Data.Maybe (isJust)\nval = Just 5',
    setupCode: 'val = Just 5',
    expected: true,
    sample: 'isJust val',
    hints: ['isJust returns True for Just', 'From Data.Maybe'],
    tags: ['maybe', 'isJust', 'check'],
  },
  {
    id: 'hs-me-303',
    category: 'Maybe/Either',
    difficulty: 'easy',
    title: 'isNothing Check',
    text: 'Check if Maybe is Nothing',
    setup: 'import Data.Maybe (isNothing)\nval = Nothing :: Maybe Int',
    setupCode: 'val = Nothing :: Maybe Int',
    expected: true,
    sample: 'isNothing val',
    hints: ['isNothing returns True for Nothing', 'From Data.Maybe'],
    tags: ['maybe', 'isNothing', 'check'],
  },
  {
    id: 'hs-me-304',
    category: 'Maybe/Either',
    difficulty: 'easy',
    title: 'fromJust Extract',
    text: 'Extract value from Just (unsafe)',
    setup: 'import Data.Maybe (fromJust)\nval = Just 42',
    setupCode: 'val = Just 42',
    expected: 42,
    sample: 'fromJust val',
    hints: ['fromJust extracts the value', 'Throws error on Nothing'],
    tags: ['maybe', 'fromJust', 'unsafe'],
  },
  {
    id: 'hs-me-305',
    category: 'Maybe/Either',
    difficulty: 'easy',
    title: 'fromMaybe Default',
    text: 'Extract with default for Nothing',
    setup: 'import Data.Maybe (fromMaybe)\nval = Nothing',
    setupCode: 'val = Nothing',
    expected: 0,
    sample: 'fromMaybe 0 val',
    hints: ['fromMaybe provides safe default', 'Returns default on Nothing'],
    tags: ['maybe', 'fromMaybe', 'safe'],
  },
  {
    id: 'hs-me-306',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'maybe Function',
    text: 'Apply function or return default',
    setup: 'val = Just 5',
    setupCode: 'val = Just 5',
    expected: 10,
    sample: 'maybe 0 (*2) val',
    hints: ['maybe takes default, function, Maybe', 'Applies function to Just value'],
    tags: ['maybe', 'function', 'transform'],
  },
  {
    id: 'hs-me-307',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'fmap Over Maybe',
    text: 'Apply function inside Maybe',
    setup: 'val = Just 10',
    setupCode: 'val = Just 10',
    expected: 'Just 100',
    sample: 'show (fmap (^2) val)',
    hints: ['fmap transforms the inner value', 'Nothing stays Nothing'],
    tags: ['maybe', 'fmap', 'functor'],
  },
  {
    id: 'hs-me-308',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'Applicative Maybe',
    text: 'Apply Maybe function to Maybe value',
    setup: 'mf = Just (+10)\nmx = Just 5',
    setupCode: 'mf = Just (+10)\nmx = Just 5',
    expected: 'Just 15',
    sample: 'show (mf <*> mx)',
    hints: ['<*> applies wrapped function', 'Nothing short-circuits'],
    tags: ['maybe', 'applicative', 'apply'],
  },
  {
    id: 'hs-me-309',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'Monad Maybe Bind',
    text: 'Chain Maybe computations',
    setup: 'half x = if even x then Just (x `div` 2) else Nothing\nval = Just 20',
    setupCode: 'half x = if even x then Just (x `div` 2) else Nothing\nval = Just 20',
    expected: 'Just 10',
    sample: 'show (val >>= half)',
    hints: ['>>= chains Maybe operations', 'Nothing propagates'],
    tags: ['maybe', 'monad', 'bind'],
  },
  {
    id: 'hs-me-310',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'Maybe Do Notation',
    text: 'Use do notation with Maybe',
    setup: 'mx = Just 5\nmy = Just 10',
    setupCode: 'mx = Just 5\nmy = Just 10',
    expected: 'Just 15',
    sample: 'show (do { x <- mx; y <- my; return (x + y) })',
    hints: ['do notation for sequencing', 'Any Nothing fails whole computation'],
    tags: ['maybe', 'do', 'monad'],
  },
  {
    id: 'hs-me-311',
    category: 'Maybe/Either',
    difficulty: 'easy',
    title: 'Create Left Value',
    text: 'Create an Either Left',
    setup: 'err = "error message"',
    setupCode: 'err = "error message"',
    expected: 'Left "error message"',
    sample: 'show (Left err :: Either String Int)',
    hints: ['Left usually represents error', 'Type annotation needed'],
    tags: ['either', 'left', 'basic'],
  },
  {
    id: 'hs-me-312',
    category: 'Maybe/Either',
    difficulty: 'easy',
    title: 'Create Right Value',
    text: 'Create an Either Right',
    setup: 'val = 42',
    setupCode: 'val = 42',
    expected: 'Right 42',
    sample: 'show (Right val :: Either String Int)',
    hints: ['Right usually represents success', 'Contains the result'],
    tags: ['either', 'right', 'basic'],
  },
  {
    id: 'hs-me-313',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'either Function',
    text: 'Handle both Either cases',
    setup: 'val = Left "oops" :: Either String Int',
    setupCode: 'val = Left "oops" :: Either String Int',
    expected: 'Error: oops',
    sample: 'either ("Error: " ++) show val',
    hints: ['either takes two functions', 'First for Left, second for Right'],
    tags: ['either', 'function', 'handle'],
  },
  {
    id: 'hs-me-314',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'fmap Over Either',
    text: 'Apply function to Right value',
    setup: 'val = Right 5 :: Either String Int',
    setupCode: 'val = Right 5 :: Either String Int',
    expected: 'Right 25',
    sample: 'show (fmap (^2) val)',
    hints: ['fmap only affects Right', 'Left passes through unchanged'],
    tags: ['either', 'fmap', 'functor'],
  },
  {
    id: 'hs-me-315',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'Either Monad Bind',
    text: 'Chain Either computations',
    setup:
      'safeDiv x y = if y == 0 then Left "div by zero" else Right (x `div` y)\nval = Right 20 :: Either String Int',
    setupCode:
      'safeDiv x y = if y == 0 then Left "div by zero" else Right (x `div` y)\nval = Right 20 :: Either String Int',
    expected: 'Right 10',
    sample: 'show (val >>= \\x -> safeDiv x 2)',
    hints: ['>>= chains Either operations', 'Left short-circuits'],
    tags: ['either', 'monad', 'bind'],
  },
  {
    id: 'hs-me-316',
    category: 'Maybe/Either',
    difficulty: 'easy',
    title: 'isLeft Check',
    text: 'Check if Either is Left',
    setup: 'import Data.Either (isLeft)\nval = Left "error" :: Either String Int',
    setupCode: 'val = Left "error" :: Either String Int',
    expected: true,
    sample: 'isLeft val',
    hints: ['isLeft returns True for Left', 'From Data.Either'],
    tags: ['either', 'isLeft', 'check'],
  },
  {
    id: 'hs-me-317',
    category: 'Maybe/Either',
    difficulty: 'easy',
    title: 'isRight Check',
    text: 'Check if Either is Right',
    setup: 'import Data.Either (isRight)\nval = Right 42 :: Either String Int',
    setupCode: 'val = Right 42 :: Either String Int',
    expected: true,
    sample: 'isRight val',
    hints: ['isRight returns True for Right', 'From Data.Either'],
    tags: ['either', 'isRight', 'check'],
  },
  {
    id: 'hs-me-318',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'lefts Extract',
    text: 'Extract all Left values from list',
    setup: 'import Data.Either (lefts)\nvals = [Left "a", Right 1, Left "b", Right 2]',
    setupCode: 'vals = [Left "a", Right 1, Left "b", Right 2]',
    expected: ['a', 'b'],
    sample: 'lefts vals',
    hints: ['lefts filters Left values', 'From Data.Either'],
    tags: ['either', 'lefts', 'filter'],
  },
  {
    id: 'hs-me-319',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'rights Extract',
    text: 'Extract all Right values from list',
    setup: 'import Data.Either (rights)\nvals = [Left "a", Right 1, Left "b", Right 2]',
    setupCode: 'vals = [Left "a", Right 1, Left "b", Right 2]',
    expected: [1, 2],
    sample: 'rights vals',
    hints: ['rights filters Right values', 'From Data.Either'],
    tags: ['either', 'rights', 'filter'],
  },
  {
    id: 'hs-me-320',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'partitionEithers',
    text: 'Separate Lefts and Rights',
    setup: 'import Data.Either (partitionEithers)\nvals = [Left "a", Right 1, Left "b", Right 2]',
    setupCode: 'vals = [Left "a", Right 1, Left "b", Right 2]',
    expected: [
      ['a', 'b'],
      [1, 2],
    ],
    sample: 'partitionEithers vals',
    hints: ['partitionEithers splits into two lists', 'Returns (lefts, rights)'],
    tags: ['either', 'partition', 'separate'],
  },
  {
    id: 'hs-me-321',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'catMaybes Filter',
    text: 'Remove Nothings from list',
    setup: 'import Data.Maybe (catMaybes)\nvals = [Just 1, Nothing, Just 2, Nothing, Just 3]',
    setupCode: 'vals = [Just 1, Nothing, Just 2, Nothing, Just 3]',
    expected: [1, 2, 3],
    sample: 'catMaybes vals',
    hints: ['catMaybes removes Nothings', 'Extracts Just values'],
    tags: ['maybe', 'catMaybes', 'filter'],
  },
  {
    id: 'hs-me-322',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'mapMaybe Transform',
    text: 'Map with Maybe result',
    setup:
      'import Data.Maybe (mapMaybe)\nf x = if even x then Just (x * 2) else Nothing\nnums = [1, 2, 3, 4, 5, 6]',
    setupCode: 'f x = if even x then Just (x * 2) else Nothing\nnums = [1, 2, 3, 4, 5, 6]',
    expected: [4, 8, 12],
    sample: 'mapMaybe f nums',
    hints: ['mapMaybe combines map and filter', 'Keeps Just results'],
    tags: ['maybe', 'mapMaybe', 'transform'],
  },
  {
    id: 'hs-me-323',
    category: 'Maybe/Either',
    difficulty: 'hard',
    title: 'maybeToList',
    text: 'Convert Maybe to list',
    setup: 'import Data.Maybe (maybeToList)\nval = Just 42',
    setupCode: 'val = Just 42',
    expected: [42],
    sample: 'maybeToList val',
    hints: ['Just becomes singleton', 'Nothing becomes empty'],
    tags: ['maybe', 'maybeToList', 'convert'],
  },
  {
    id: 'hs-me-324',
    category: 'Maybe/Either',
    difficulty: 'hard',
    title: 'listToMaybe',
    text: 'Convert list to Maybe',
    setup: 'import Data.Maybe (listToMaybe)\nvals = [1, 2, 3]',
    setupCode: 'vals = [1, 2, 3]',
    expected: 'Just 1',
    sample: 'show (listToMaybe vals)',
    hints: ['Takes first element as Just', 'Empty list becomes Nothing'],
    tags: ['maybe', 'listToMaybe', 'convert'],
  },
  {
    id: 'hs-me-325',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'Safe Head',
    text: 'Get head safely returning Maybe',
    setup: 'import Data.Maybe (listToMaybe)\nlist = [10, 20, 30]',
    setupCode: 'list = [10, 20, 30]',
    expected: 'Just 10',
    sample: 'show (listToMaybe list)',
    hints: ['listToMaybe is safe head', 'Returns Nothing for empty'],
    tags: ['maybe', 'head', 'safe'],
  },
  {
    id: 'hs-me-326',
    category: 'Maybe/Either',
    difficulty: 'hard',
    title: 'Note for Maybe to Either',
    text: 'Convert Maybe to Either with error',
    setup: 'note err Nothing = Left err\nnote _ (Just x) = Right x\nval = Nothing',
    setupCode: 'note err Nothing = Left err\nnote _ (Just x) = Right x\nval = Nothing',
    expected: 'Left "not found"',
    sample: 'show (note "not found" val)',
    hints: ['note adds error message', 'Converts Nothing to Left'],
    tags: ['maybe', 'either', 'convert'],
  },
  {
    id: 'hs-me-327',
    category: 'Maybe/Either',
    difficulty: 'hard',
    title: 'hush for Either to Maybe',
    text: 'Convert Either to Maybe',
    setup: 'hush (Left _) = Nothing\nhush (Right x) = Just x\nval = Right 42 :: Either String Int',
    setupCode:
      'hush (Left _) = Nothing\nhush (Right x) = Just x\nval = Right 42 :: Either String Int',
    expected: 'Just 42',
    sample: 'show (hush val)',
    hints: ['hush discards Left error', 'Right becomes Just'],
    tags: ['either', 'maybe', 'convert'],
  },
  {
    id: 'hs-me-328',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'Applicative Lift Maybe',
    text: 'Lift binary function over Maybe',
    setup: 'import Control.Applicative (liftA2)\nmx = Just 5\nmy = Just 10',
    setupCode: 'mx = Just 5\nmy = Just 10',
    expected: 'Just 15',
    sample: 'show (liftA2 (+) mx my)',
    hints: ['liftA2 lifts binary function', 'Works with Applicative'],
    tags: ['maybe', 'liftA2', 'applicative'],
  },
  {
    id: 'hs-me-329',
    category: 'Maybe/Either',
    difficulty: 'hard',
    title: 'Sequence Maybes',
    text: 'Turn list of Maybes into Maybe list',
    setup: 'vals = [Just 1, Just 2, Just 3]',
    setupCode: 'vals = [Just 1, Just 2, Just 3]',
    expected: 'Just [1, 2, 3]',
    sample: 'show (sequence vals)',
    hints: ['sequence flips structure', 'Any Nothing fails all'],
    tags: ['maybe', 'sequence', 'traverse'],
  },
  {
    id: 'hs-me-330',
    category: 'Maybe/Either',
    difficulty: 'hard',
    title: 'Traverse with Maybe',
    text: 'Map with Maybe and collect',
    setup: 'safeDiv10 x = if x == 0 then Nothing else Just (10 `div` x)\nnums = [1, 2, 5]',
    setupCode: 'safeDiv10 x = if x == 0 then Nothing else Just (10 `div` x)\nnums = [1, 2, 5]',
    expected: 'Just [10, 5, 2]',
    sample: 'show (traverse safeDiv10 nums)',
    hints: ['traverse maps then sequences', 'All must succeed'],
    tags: ['maybe', 'traverse', 'collect'],
  },
  {
    id: 'hs-me-331',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'Alternative with Maybe',
    text: 'Use <|> for fallback',
    setup: 'import Control.Applicative ((<|>))\nfirst = Nothing\nsecond = Just 5\nthird = Just 10',
    setupCode: 'first = Nothing\nsecond = Just 5\nthird = Just 10',
    expected: 'Just 5',
    sample: 'show (first <|> second <|> third)',
    hints: ['<|> tries alternatives', 'Returns first Just'],
    tags: ['maybe', 'alternative', 'fallback'],
  },
  {
    id: 'hs-me-332',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'Optional with Maybe',
    text: 'Use optional for parsing',
    setup: 'import Control.Applicative (optional)\nval = Just 42',
    setupCode: 'val = Just 42',
    expected: 'Just (Just 42)',
    sample: 'show (optional val)',
    hints: ['optional wraps success', 'Returns Just Nothing on failure'],
    tags: ['maybe', 'optional', 'applicative'],
  },
  {
    id: 'hs-me-333',
    category: 'Maybe/Either',
    difficulty: 'hard',
    title: 'MonadFail Maybe',
    text: 'Use fail in Maybe monad',
    setup: '',
    setupCode: '',
    expected: 'Nothing',
    sample: 'show (fail "error" :: Maybe Int)',
    hints: ['fail returns Nothing', 'Fails the computation'],
    tags: ['maybe', 'fail', 'monad'],
  },
  {
    id: 'hs-me-334',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'Guard in Maybe',
    text: 'Use guard for condition',
    setup: 'import Control.Monad (guard)\nval = 5',
    setupCode: 'val = 5',
    expected: 'Just 5',
    sample: 'show (do { guard (val > 0); return val })',
    hints: ['guard fails on False', 'Returns () on True'],
    tags: ['maybe', 'guard', 'conditional'],
  },
  {
    id: 'hs-me-335',
    category: 'Maybe/Either',
    difficulty: 'hard',
    title: 'MaybeT Transformer',
    text: 'Use MaybeT for stacked Maybe',
    setup: 'import Control.Monad.Trans.Maybe\ncomp = MaybeT (return (Just 42))',
    setupCode: '',
    expected: 'Just 42',
    sample: 'runMaybeT comp',
    hints: ['MaybeT adds Maybe to monad stack', 'Composes monad effects'],
    tags: ['maybe', 'transformer', 'maybet'],
  },
  {
    id: 'hs-me-336',
    category: 'Maybe/Either',
    difficulty: 'hard',
    title: 'ExceptT Transformer',
    text: 'Use ExceptT for Either monad',
    setup: 'import Control.Monad.Trans.Except\ncomp = ExceptT (return (Right 42))',
    setupCode: '',
    expected: 'Right 42',
    sample: 'runExceptT comp',
    hints: ['ExceptT adds Either to stack', 'throwE for errors'],
    tags: ['either', 'transformer', 'exceptt'],
  },
  {
    id: 'hs-me-337',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'First Monoid',
    text: 'Use First monoid for Maybe',
    setup: 'import Data.Monoid (First(..))\na = First (Just 5)\nb = First (Just 10)',
    setupCode: 'import Data.Monoid (First(..))\na = First (Just 5)\nb = First (Just 10)',
    expected: 'First {getFirst = Just 5}',
    sample: 'show (a <> b)',
    hints: ['First keeps leftmost Just', 'Ignores subsequent values'],
    tags: ['maybe', 'first', 'monoid'],
  },
  {
    id: 'hs-me-338',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'Last Monoid',
    text: 'Use Last monoid for Maybe',
    setup: 'import Data.Monoid (Last(..))\na = Last (Just 5)\nb = Last (Just 10)',
    setupCode: 'import Data.Monoid (Last(..))\na = Last (Just 5)\nb = Last (Just 10)',
    expected: 'Last {getLast = Just 10}',
    sample: 'show (a <> b)',
    hints: ['Last keeps rightmost Just', 'Opposite of First'],
    tags: ['maybe', 'last', 'monoid'],
  },
  {
    id: 'hs-me-339',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'Void Either Left',
    text: 'Use void on Either',
    setup: 'import Data.Functor (void)\nval = Right 42 :: Either String Int',
    setupCode: 'val = Right 42 :: Either String Int',
    expected: 'Right ()',
    sample: 'show (void val)',
    hints: ['void discards the value', 'Keeps structure'],
    tags: ['either', 'void', 'functor'],
  },
  {
    id: 'hs-me-340',
    category: 'Maybe/Either',
    difficulty: 'easy',
    title: 'Safe Find',
    text: 'Use find returning Maybe',
    setup: 'import Data.List (find)\nnums = [1, 2, 3, 4, 5]',
    setupCode: 'nums = [1, 2, 3, 4, 5]',
    expected: 'Just 4',
    sample: 'show (find (>3) nums)',
    hints: ['find returns Maybe', 'First matching element'],
    tags: ['maybe', 'find', 'search'],
  },
  {
    id: 'hs-me-341',
    category: 'Maybe/Either',
    difficulty: 'easy',
    title: 'Safe Lookup',
    text: 'Use lookup for association list',
    setup: 'assocs = [(1, "one"), (2, "two"), (3, "three")]',
    setupCode: 'assocs = [(1, "one"), (2, "two"), (3, "three")]',
    expected: 'Just "two"',
    sample: 'show (lookup 2 assocs)',
    hints: ['lookup returns Maybe', 'Searches by key'],
    tags: ['maybe', 'lookup', 'assoc'],
  },
  {
    id: 'hs-me-342',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'Safe Index',
    text: 'Use !!? for safe indexing',
    setup:
      'import Data.Maybe (listToMaybe)\nsafeIndex xs i = listToMaybe (drop i xs)\nlist = [10, 20, 30]',
    setupCode:
      'safeIndex xs i = if i < length xs && i >= 0 then Just (xs !! i) else Nothing\nlist = [10, 20, 30]',
    expected: 'Just 20',
    sample: 'show (safeIndex list 1)',
    hints: ['Avoid partial !!', 'Return Maybe for safety'],
    tags: ['maybe', 'index', 'safe'],
  },
  {
    id: 'hs-me-343',
    category: 'Maybe/Either',
    difficulty: 'hard',
    title: 'Bitraverse Either',
    text: 'Traverse both sides of Either',
    setup: 'import Data.Bitraversable (bitraverse)\nval = Left "5" :: Either String String',
    setupCode: 'import Data.Bifunctor (bimap)\nval = Left "5" :: Either String String',
    expected: 'Just (Left 5)',
    sample: 'show (bitraverse readMaybe readMaybe val)',
    hints: ['bitraverse maps both sides', 'With Applicative effect'],
    tags: ['either', 'bitraverse', 'bifunctor'],
  },
  {
    id: 'hs-me-344',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'First from Pair',
    text: 'Map on first of Either',
    setup: 'import Data.Bifunctor (first)\nval = Left 5 :: Either Int String',
    setupCode: 'val = Left 5 :: Either Int String',
    expected: 'Left 10',
    sample: 'show (first (*2) val)',
    hints: ['first maps Left value', 'From Data.Bifunctor'],
    tags: ['either', 'first', 'bifunctor'],
  },
  {
    id: 'hs-me-345',
    category: 'Maybe/Either',
    difficulty: 'medium',
    title: 'Second from Pair',
    text: 'Map on second of Either',
    setup: 'import Data.Bifunctor (second)\nval = Right 5 :: Either String Int',
    setupCode: 'val = Right 5 :: Either String Int',
    expected: 'Right 10',
    sample: 'show (second (*2) val)',
    hints: ['second maps Right value', 'Same as fmap for Either'],
    tags: ['either', 'second', 'bifunctor'],
  },
  {
    id: 'hs-me-346',
    category: 'Maybe/Either',
    difficulty: 'hard',
    title: 'fromLeft Default',
    text: 'Extract Left with default',
    setup: 'import Data.Either (fromLeft)\nval = Right 42 :: Either String Int',
    setupCode: 'val = Right 42 :: Either String Int',
    expected: 'default',
    sample: 'fromLeft "default" val',
    hints: ['fromLeft extracts Left', 'Uses default for Right'],
    tags: ['either', 'fromLeft', 'extract'],
  },
  {
    id: 'hs-me-347',
    category: 'Maybe/Either',
    difficulty: 'hard',
    title: 'fromRight Default',
    text: 'Extract Right with default',
    setup: 'import Data.Either (fromRight)\nval = Left "error" :: Either String Int',
    setupCode: 'val = Left "error" :: Either String Int',
    expected: 0,
    sample: 'fromRight 0 val',
    hints: ['fromRight extracts Right', 'Uses default for Left'],
    tags: ['either', 'fromRight', 'extract'],
  },
  {
    id: 'hs-me-348',
    category: 'Maybe/Either',
    difficulty: 'hard',
    title: 'Swap Either',
    text: 'Swap Left and Right',
    setup: 'swap (Left x) = Right x\nswap (Right x) = Left x\nval = Left 42 :: Either Int String',
    setupCode:
      'swap (Left x) = Right x\nswap (Right x) = Left x\nval = Left 42 :: Either Int String',
    expected: 'Right 42',
    sample: 'show (swap val)',
    hints: ['swap exchanges Left/Right', 'Useful for changing error position'],
    tags: ['either', 'swap', 'transform'],
  },
  {
    id: 'hs-me-349',
    category: 'Maybe/Either',
    difficulty: 'hard',
    title: 'Validate with Either',
    text: 'Accumulate errors with Either',
    setup:
      'import Data.Validation\nvalidatePositive x = if x > 0 then Success x else Failure ["not positive"]\nvalidateSmall x = if x < 100 then Success x else Failure ["too large"]',
    setupCode: 'validatePositive x = if x > 0 then Right x else Left "not positive"\nval = 50',
    expected: 'Right 50',
    sample: 'validatePositive val',
    hints: ['Validation accumulates errors', 'Unlike Either which short-circuits'],
    tags: ['either', 'validation', 'errors'],
  },

  // ========================================
  // BEGINNER FUNDAMENTALS
  // ========================================

  // -- Recursion (3 problems) --
  {
    id: 'hs-beginner-recursion-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Recursive Sum',
    text: 'Write a recursive function to sum all numbers from 1 to n. Use the helper function provided.',
    setup: 'sumTo :: Int -> Int\nsumTo 0 = 0\nsumTo n = n + sumTo (n - 1)\nn = 5',
    setupCode: 'sumTo :: Int -> Int\nsumTo 0 = 0\nsumTo n = n + sumTo (n - 1)\nn = 5',
    expected: 15,
    sample: 'sumTo n',
    hints: [
      'Base case: sumTo 0 = 0',
      'Recursive case: n + sumTo (n-1)',
      'Call the function with n',
    ],
    tags: ['recursion', 'beginner', 'sum'],
  },
  {
    id: 'hs-beginner-recursion-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Recursive Factorial',
    text: 'Use the recursive factorial function to calculate 5 factorial.',
    setup: 'factorial :: Int -> Int\nfactorial 0 = 1\nfactorial n = n * factorial (n - 1)\nnum = 5',
    setupCode:
      'factorial :: Int -> Int\nfactorial 0 = 1\nfactorial n = n * factorial (n - 1)\nnum = 5',
    expected: 120,
    sample: 'factorial num',
    hints: [
      'Base case: factorial 0 = 1',
      'Recursive case: n * factorial (n-1)',
      'Call factorial with num',
    ],
    tags: ['recursion', 'beginner', 'factorial'],
  },
  {
    id: 'hs-beginner-recursion-003',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Recursive Length',
    text: 'Use the recursive length function to find the length of the list.',
    setup:
      'myLength :: [a] -> Int\nmyLength [] = 0\nmyLength (_:xs) = 1 + myLength xs\nwords\' = ["hello", "world", "haskell"]',
    setupCode:
      'myLength :: [a] -> Int\nmyLength [] = 0\nmyLength (_:xs) = 1 + myLength xs\nwords\' = ["hello", "world", "haskell"]',
    expected: 3,
    sample: "myLength words'",
    hints: [
      'Base case: empty list returns 0',
      'Recursive case: 1 + length of tail',
      'Use pattern matching (_:xs)',
    ],
    tags: ['recursion', 'beginner', 'length', 'list'],
  },

  // -- Pattern Matching (3 problems) --
  {
    id: 'hs-beginner-pattern-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Pattern Match Head',
    text: 'Use pattern matching to extract the first element of the list.',
    setup: 'getFirst :: [a] -> a\ngetFirst (x:_) = x\nnumbers = [10, 20, 30]',
    setupCode: 'getFirst :: [a] -> a\ngetFirst (x:_) = x\nnumbers = [10, 20, 30]',
    expected: 10,
    sample: 'getFirst numbers',
    hints: [
      'Pattern (x:_) matches head and ignores tail',
      'x binds to the first element',
      'Underscore _ ignores the rest',
    ],
    tags: ['pattern-matching', 'beginner', 'head', 'list'],
  },
  {
    id: 'hs-beginner-pattern-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Pattern Match Tuple',
    text: 'Use pattern matching to extract the second element from the tuple.',
    setup: 'getSecond :: (a, b) -> b\ngetSecond (_, y) = y\npair = ("hello", 42)',
    setupCode: 'getSecond :: (a, b) -> b\ngetSecond (_, y) = y\npair = ("hello", 42)',
    expected: 42,
    sample: 'getSecond pair',
    hints: [
      'Pattern (_, y) ignores first, binds second',
      'Tuples use parentheses and commas',
      'Underscore ignores values',
    ],
    tags: ['pattern-matching', 'beginner', 'tuple'],
  },
  {
    id: 'hs-beginner-pattern-003',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Pattern Match Boolean',
    text: 'Use the pattern matching function to describe the boolean value.',
    setup: 'describe :: Bool -> String\ndescribe True = "yes"\ndescribe False = "no"\nvalue = True',
    setupCode:
      'describe :: Bool -> String\ndescribe True = "yes"\ndescribe False = "no"\nvalue = True',
    expected: 'yes',
    sample: 'describe value',
    hints: [
      'Pattern match on True and False',
      'Each pattern has its own equation',
      'Order matters in pattern matching',
    ],
    tags: ['pattern-matching', 'beginner', 'boolean'],
  },

  // -- Lists (4 problems) --
  {
    id: 'hs-beginner-list-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Concatenate Lists',
    text: 'Use the ++ operator to concatenate the two lists.',
    setup: 'list1 = [1, 2, 3]\nlist2 = [4, 5, 6]',
    setupCode: 'list1 = [1, 2, 3]\nlist2 = [4, 5, 6]',
    expected: [1, 2, 3, 4, 5, 6],
    sample: 'list1 ++ list2',
    hints: ['++ concatenates two lists', 'Works with any list type', 'Returns a new list'],
    tags: ['list', 'beginner', 'concatenation'],
  },
  {
    id: 'hs-beginner-list-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Cons Operator',
    text: 'Use the : (cons) operator to prepend 0 to the list.',
    setup: 'numbers = [1, 2, 3]',
    setupCode: 'numbers = [1, 2, 3]',
    expected: [0, 1, 2, 3],
    sample: '0 : numbers',
    hints: [
      ': prepends an element to a list',
      'Element goes on the left',
      '[1,2,3] is sugar for 1:2:3:[]',
    ],
    tags: ['list', 'beginner', 'cons'],
  },
  {
    id: 'hs-beginner-list-003',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'List Indexing',
    text: 'Use the !! operator to get the element at index 2.',
    setup: 'fruits = ["apple", "banana", "cherry", "date"]',
    setupCode: 'fruits = ["apple", "banana", "cherry", "date"]',
    expected: 'cherry',
    sample: 'fruits !! 2',
    hints: [
      '!! is the indexing operator',
      'Indices start at 0',
      'Returns element at that position',
    ],
    tags: ['list', 'beginner', 'indexing'],
  },
  {
    id: 'hs-beginner-list-004',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'List Range',
    text: 'Generate a list of numbers from 1 to 10 using range syntax.',
    setup: '-- Use [start..end] syntax',
    setupCode: '-- Use [start..end] syntax',
    expected: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    sample: '[1..10]',
    hints: [
      '[a..b] generates numbers from a to b',
      'Inclusive on both ends',
      'Works with any Enum type',
    ],
    tags: ['list', 'beginner', 'range'],
  },

  // -- Strings (2 problems) --
  {
    id: 'hs-beginner-string-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'String Concatenation',
    text: 'Use the ++ operator to concatenate the two strings with a space between them.',
    setup: 'greeting = "Hello"\nname = "World"',
    setupCode: 'greeting = "Hello"\nname = "World"',
    expected: 'Hello World',
    sample: 'greeting ++ " " ++ name',
    hints: [
      '++ works on strings (which are lists of Char)',
      'Add a space string " " between',
      'Concatenation is left-associative',
    ],
    tags: ['string', 'beginner', 'concatenation'],
  },
  {
    id: 'hs-beginner-string-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'String Length',
    text: 'Use the length function to find the number of characters in the string.',
    setup: 'message = "Haskell"',
    setupCode: 'message = "Haskell"',
    expected: 7,
    sample: 'length message',
    hints: ['length works on any list', 'Strings are lists of Char', 'Returns an Int'],
    tags: ['string', 'beginner', 'length'],
  },

  // -- Guards (2 problems) --
  {
    id: 'hs-beginner-guard-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Basic Guards',
    text: 'Use the absolute function with guards to get the absolute value of the number.',
    setup: 'absolute :: Int -> Int\nabsolute n\n  | n < 0     = -n\n  | otherwise = n\nnum = -5',
    setupCode:
      'absolute :: Int -> Int\nabsolute n\n  | n < 0     = -n\n  | otherwise = n\nnum = -5',
    expected: 5,
    sample: 'absolute num',
    hints: [
      'Guards use | followed by boolean condition',
      'otherwise is always True (catch-all)',
      'Guards are checked top to bottom',
    ],
    tags: ['guards', 'beginner', 'conditional'],
  },
  {
    id: 'hs-beginner-guard-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Multiple Guards',
    text: 'Use the grade function to convert the score to a letter grade.',
    setup:
      'grade :: Int -> String\ngrade score\n  | score >= 90 = "A"\n  | score >= 80 = "B"\n  | score >= 70 = "C"\n  | score >= 60 = "D"\n  | otherwise   = "F"\nstudentScore = 85',
    setupCode:
      'grade :: Int -> String\ngrade score\n  | score >= 90 = "A"\n  | score >= 80 = "B"\n  | score >= 70 = "C"\n  | score >= 60 = "D"\n  | otherwise   = "F"\nstudentScore = 85',
    expected: 'B',
    sample: 'grade studentScore',
    hints: [
      'Guards are checked in order',
      'First True guard wins',
      'No need for upper bound checks',
    ],
    tags: ['guards', 'beginner', 'conditional', 'grading'],
  },

  // -- Advanced List Operations (2 problems) --
  {
    id: 'hs-beginner-list-adv-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'List Maximum',
    text: 'Use the maximum function to find the largest element in the list.',
    setup: 'scores = [72, 85, 91, 68, 79]',
    setupCode: 'scores = [72, 85, 91, 68, 79]',
    expected: 91,
    sample: 'maximum scores',
    hints: ['maximum finds the largest element', 'Works on any Ord type', 'List must be non-empty'],
    tags: ['list', 'beginner', 'maximum'],
  },
  {
    id: 'hs-beginner-list-adv-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'List Membership',
    text: 'Use the elem function to check if the value exists in the list.',
    setup: 'fruits = ["apple", "banana", "cherry"]\nsearchFor = "banana"',
    setupCode: 'fruits = ["apple", "banana", "cherry"]\nsearchFor = "banana"',
    expected: true,
    sample: 'elem searchFor fruits',
    hints: [
      'elem checks if element is in list',
      'Returns True or False',
      'Can also write: searchFor `elem` fruits',
    ],
    tags: ['list', 'beginner', 'elem', 'membership'],
  },
];
