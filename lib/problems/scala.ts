/**
 * Scala Coding Drills Problems
 *
 * Comprehensive collection of Scala problems covering:
 * - List Operations (filter, map, flatMap, fold, reduce, head, tail, take, drop)
 * - String Methods (length, toLowerCase, toUpperCase, split, contains, replace)
 * - Option Handling (map, flatMap, getOrElse, fold, isDefined)
 * - Map Operations (get, getOrElse, keys, values, filterKeys)
 * - Pattern Matching basics
 *
 * Distribution: 20 easy, 20 medium, 10 hard
 */

import type { Problem } from '../types';

export const scalaProblems: Problem[] = [
  // ============================================================
  // List Operations (12 problems: 5 easy, 5 medium, 2 hard)
  // ============================================================

  {
    id: 'scala-list-001',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Filter Even Numbers',
    text: 'Filter the list to keep only even numbers.',
    setup: 'val numbers = List(1, 2, 3, 4, 5, 6)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5, 6)',
    expected: [2, 4, 6],
    sample: 'numbers.filter(_ % 2 == 0)',
    hints: ['Use filter with a predicate', 'The underscore _ represents each element'],
    validPatterns: [/\.filter\s*\(/, /\.filter\s*\{/],
    tags: ['filter', 'collections', 'predicate'],
  },

  {
    id: 'scala-list-002',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Map to Squares',
    text: 'Transform each number to its square.',
    setup: 'val numbers = List(1, 2, 3, 4, 5)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5)',
    expected: [1, 4, 9, 16, 25],
    sample: 'numbers.map(x => x * x)',
    hints: ['Use map to transform elements', 'You can also use _ * _ shorthand'],
    validPatterns: [/\.map\s*\(/, /\.map\s*\{/],
    tags: ['map', 'transform', 'collections'],
  },

  {
    id: 'scala-list-003',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Get First Element',
    text: 'Get the first element of the list using head.',
    setup: 'val fruits = List("apple", "banana", "cherry")',
    setupCode: 'val fruits = List("apple", "banana", "cherry")',
    expected: 'apple',
    sample: 'fruits.head',
    hints: ['head returns the first element', 'Throws exception on empty list'],
    validPatterns: [/\.head(?!\w)/],
    tags: ['head', 'access', 'first'],
  },

  {
    id: 'scala-list-004',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Get Tail of List',
    text: 'Get all elements except the first one.',
    setup: 'val numbers = List(1, 2, 3, 4, 5)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5)',
    expected: [2, 3, 4, 5],
    sample: 'numbers.tail',
    hints: ['tail returns all elements except head', 'Returns a new List'],
    validPatterns: [/\.tail(?!\w)/],
    tags: ['tail', 'slice', 'collections'],
  },

  {
    id: 'scala-list-005',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Take First N Elements',
    text: 'Take the first 3 elements from the list.',
    setup: 'val numbers = List(10, 20, 30, 40, 50)',
    setupCode: 'val numbers = List(10, 20, 30, 40, 50)',
    expected: [10, 20, 30],
    sample: 'numbers.take(3)',
    hints: ['take(n) returns first n elements', 'Safe on lists shorter than n'],
    validPatterns: [/\.take\s*\(\s*3\s*\)/],
    tags: ['take', 'slice', 'collections'],
  },

  {
    id: 'scala-list-006',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Drop First N Elements',
    text: 'Skip the first 2 elements and return the rest.',
    setup: 'val numbers = List(1, 2, 3, 4, 5)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5)',
    expected: [3, 4, 5],
    sample: 'numbers.drop(2)',
    hints: ['drop(n) skips first n elements', 'Returns remaining elements'],
    validPatterns: [/\.drop\s*\(\s*2\s*\)/],
    tags: ['drop', 'skip', 'collections'],
  },

  {
    id: 'scala-list-007',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Sum with Reduce',
    text: 'Calculate the sum of all numbers using reduce.',
    setup: 'val numbers = List(1, 2, 3, 4, 5)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5)',
    expected: 15,
    sample: 'numbers.reduce(_ + _)',
    hints: ['reduce combines elements pairwise', 'The underscores represent accumulator and current'],
    validPatterns: [/\.reduce\s*\(/, /\.reduce\s*\{/],
    tags: ['reduce', 'aggregation', 'sum'],
  },

  {
    id: 'scala-list-008',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Fold with Initial Value',
    text: 'Calculate the sum starting from 100 using foldLeft.',
    setup: 'val numbers = List(1, 2, 3, 4, 5)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5)',
    expected: 115,
    sample: 'numbers.foldLeft(100)(_ + _)',
    hints: ['foldLeft takes initial value', 'First parameter is accumulator, second is element'],
    validPatterns: [/\.foldLeft\s*\(\s*100\s*\)/],
    tags: ['foldLeft', 'fold', 'aggregation'],
  },

  {
    id: 'scala-list-009',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'FlatMap Nested Lists',
    text: 'Flatten a list of lists into a single list.',
    setup: 'val nested = List(List(1, 2), List(3, 4), List(5, 6))',
    setupCode: 'val nested = List(List(1, 2), List(3, 4), List(5, 6))',
    expected: [1, 2, 3, 4, 5, 6],
    sample: 'nested.flatMap(identity)',
    hints: ['flatMap flattens while mapping', 'identity returns elements unchanged'],
    validPatterns: [/\.flatMap\s*\(/, /\.flatten(?!\w)/],
    tags: ['flatMap', 'flatten', 'nested'],
  },

  {
    id: 'scala-list-010',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Filter and Map Combined',
    text: 'Filter numbers greater than 2, then double them.',
    setup: 'val numbers = List(1, 2, 3, 4, 5)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5)',
    expected: [6, 8, 10],
    sample: 'numbers.filter(_ > 2).map(_ * 2)',
    hints: ['Chain filter and map operations', 'Filter first to reduce elements'],
    validPatterns: [/\.filter\s*\(.*\)\.map\s*\(/],
    tags: ['filter', 'map', 'chaining'],
  },

  {
    id: 'scala-list-011',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'FoldRight Operation',
    text: 'Concatenate strings from right to left using foldRight.',
    setup: 'val words = List("a", "b", "c")',
    setupCode: 'val words = List("a", "b", "c")',
    expected: 'abc',
    sample: 'words.foldRight("")(_ + _)',
    hints: ['foldRight processes from right to left', 'Order of parameters differs from foldLeft'],
    validPatterns: [/\.foldRight\s*\(\s*""\s*\)/],
    tags: ['foldRight', 'fold', 'aggregation'],
  },

  {
    id: 'scala-list-012',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Custom Reduce with FlatMap',
    text: 'Generate pairs (x, x*2) for each number and flatten.',
    setup: 'val numbers = List(1, 2, 3)',
    setupCode: 'val numbers = List(1, 2, 3)',
    expected: [1, 2, 2, 4, 3, 6],
    sample: 'numbers.flatMap(x => List(x, x * 2))',
    hints: ['flatMap applies function and flattens', 'Return a List from the function'],
    validPatterns: [/\.flatMap\s*\(/],
    tags: ['flatMap', 'transform', 'pairs'],
  },

  // ============================================================
  // String Methods (10 problems: 5 easy, 4 medium, 1 hard)
  // ============================================================

  {
    id: 'scala-string-001',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Get String Length',
    text: 'Get the length of the string.',
    setup: 'val text = "Hello Scala"',
    setupCode: 'val text = "Hello Scala"',
    expected: 11,
    sample: 'text.length',
    hints: ['length returns number of characters', 'Includes spaces'],
    validPatterns: [/\.length(?!\w)/],
    tags: ['length', 'string', 'basics'],
  },

  {
    id: 'scala-string-002',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Convert to Lowercase',
    text: 'Convert the string to all lowercase characters.',
    setup: 'val text = "HELLO WORLD"',
    setupCode: 'val text = "HELLO WORLD"',
    expected: 'hello world',
    sample: 'text.toLowerCase',
    hints: ['toLowerCase converts all characters', 'Returns a new String'],
    validPatterns: [/\.toLowerCase(?!\w)/],
    tags: ['toLowerCase', 'case', 'string'],
  },

  {
    id: 'scala-string-003',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Convert to Uppercase',
    text: 'Convert the string to all uppercase characters.',
    setup: 'val text = "hello scala"',
    setupCode: 'val text = "hello scala"',
    expected: 'HELLO SCALA',
    sample: 'text.toUpperCase',
    hints: ['toUpperCase converts all characters', 'Returns a new String'],
    validPatterns: [/\.toUpperCase(?!\w)/],
    tags: ['toUpperCase', 'case', 'string'],
  },

  {
    id: 'scala-string-004',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Split String',
    text: 'Split the string by comma into an array.',
    setup: 'val csv = "apple,banana,cherry"',
    setupCode: 'val csv = "apple,banana,cherry"',
    expected: ['apple', 'banana', 'cherry'],
    sample: 'csv.split(",")',
    hints: ['split returns Array[String]', 'Can split by regex pattern'],
    validPatterns: [/\.split\s*\(\s*","\s*\)/],
    tags: ['split', 'parse', 'string'],
  },

  {
    id: 'scala-string-005',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Check Contains Substring',
    text: 'Check if the string contains "Scala".',
    setup: 'val text = "I love Scala programming"',
    setupCode: 'val text = "I love Scala programming"',
    expected: true,
    sample: 'text.contains("Scala")',
    hints: ['contains returns Boolean', 'Case-sensitive search'],
    validPatterns: [/\.contains\s*\(\s*"Scala"\s*\)/],
    tags: ['contains', 'search', 'string'],
  },

  {
    id: 'scala-string-006',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Replace Characters',
    text: 'Replace all spaces with underscores.',
    setup: 'val text = "Hello Scala World"',
    setupCode: 'val text = "Hello Scala World"',
    expected: 'Hello_Scala_World',
    sample: 'text.replace(" ", "_")',
    hints: ['replace replaces all occurrences', 'Returns new String'],
    validPatterns: [/\.replace\s*\(\s*" "\s*,\s*"_"\s*\)/],
    tags: ['replace', 'substitution', 'string'],
  },

  {
    id: 'scala-string-007',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Split and Transform',
    text: 'Split by space and convert each word to uppercase.',
    setup: 'val text = "hello world scala"',
    setupCode: 'val text = "hello world scala"',
    expected: ['HELLO', 'WORLD', 'SCALA'],
    sample: 'text.split(" ").map(_.toUpperCase)',
    hints: ['Chain split with map', 'split returns Array, map transforms'],
    validPatterns: [/\.split\s*\(.*\)\.map\s*\(/],
    tags: ['split', 'map', 'transform'],
  },

  {
    id: 'scala-string-008',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'String Interpolation',
    text: 'Create a string "Name: Alice, Age: 25" using string interpolation.',
    setup: 'val name = "Alice"\nval age = 25',
    setupCode: 'val name = "Alice"\nval age = 25',
    expected: 'Name: Alice, Age: 25',
    sample: 's"Name: $name, Age: $age"',
    hints: ['Use s-interpolator with $variable', 'Prefix string with s'],
    validPatterns: [/s".*\$name.*\$age.*"/],
    tags: ['interpolation', 'format', 'string'],
  },

  {
    id: 'scala-string-009',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Trim and Check Empty',
    text: 'Trim the string and check if it is empty.',
    setup: 'val text = "   "',
    setupCode: 'val text = "   "',
    expected: true,
    sample: 'text.trim.isEmpty',
    hints: ['trim removes leading/trailing whitespace', 'isEmpty checks for empty string'],
    validPatterns: [/\.trim\.isEmpty/],
    tags: ['trim', 'isEmpty', 'validation'],
  },

  {
    id: 'scala-string-010',
    category: 'String Methods',
    difficulty: 'hard',
    title: 'Regex Replace',
    text: 'Replace all digits with "X" using regex.',
    setup: 'val text = "Phone: 123-456-7890"',
    setupCode: 'val text = "Phone: 123-456-7890"',
    expected: 'Phone: XXX-XXX-XXXX',
    sample: 'text.replaceAll("\\\\d", "X")',
    hints: ['Use replaceAll for regex patterns', 'Double escape backslash in Scala'],
    validPatterns: [/\.replaceAll\s*\(/],
    tags: ['replaceAll', 'regex', 'string'],
  },

  // ============================================================
  // Option Handling (10 problems: 4 easy, 4 medium, 2 hard)
  // ============================================================

  {
    id: 'scala-option-001',
    category: 'Option Handling',
    difficulty: 'easy',
    title: 'Get Value or Default',
    text: 'Get the value from Option or return 0 as default.',
    setup: 'val maybeNumber: Option[Int] = Some(42)',
    setupCode: 'val maybeNumber: Option[Int] = Some(42)',
    expected: 42,
    sample: 'maybeNumber.getOrElse(0)',
    hints: ['getOrElse returns value or default', 'Safe way to extract Option value'],
    validPatterns: [/\.getOrElse\s*\(\s*0\s*\)/],
    tags: ['getOrElse', 'option', 'default'],
  },

  {
    id: 'scala-option-002',
    category: 'Option Handling',
    difficulty: 'easy',
    title: 'Check if Defined',
    text: 'Check if the Option contains a value.',
    setup: 'val maybeValue: Option[String] = Some("hello")',
    setupCode: 'val maybeValue: Option[String] = Some("hello")',
    expected: true,
    sample: 'maybeValue.isDefined',
    hints: ['isDefined returns true for Some', 'Returns false for None'],
    validPatterns: [/\.isDefined(?!\w)/],
    tags: ['isDefined', 'option', 'check'],
  },

  {
    id: 'scala-option-003',
    category: 'Option Handling',
    difficulty: 'easy',
    title: 'Map Over Option',
    text: 'Double the value inside the Option if present.',
    setup: 'val maybeNumber: Option[Int] = Some(21)',
    setupCode: 'val maybeNumber: Option[Int] = Some(21)',
    expected: 42,
    sample: 'maybeNumber.map(_ * 2).getOrElse(0)',
    hints: ['map transforms the value inside Option', 'Returns None if Option is empty'],
    validPatterns: [/\.map\s*\(.*\*\s*2/],
    tags: ['map', 'option', 'transform'],
  },

  {
    id: 'scala-option-004',
    category: 'Option Handling',
    difficulty: 'easy',
    title: 'Check if Empty',
    text: 'Check if the Option is empty (None).',
    setup: 'val maybeValue: Option[Int] = None',
    setupCode: 'val maybeValue: Option[Int] = None',
    expected: true,
    sample: 'maybeValue.isEmpty',
    hints: ['isEmpty returns true for None', 'Opposite of isDefined'],
    validPatterns: [/\.isEmpty(?!\w)/],
    tags: ['isEmpty', 'option', 'check'],
  },

  {
    id: 'scala-option-005',
    category: 'Option Handling',
    difficulty: 'medium',
    title: 'FlatMap Nested Options',
    text: 'Extract nested Option value using flatMap.',
    setup: 'val nested: Option[Option[Int]] = Some(Some(42))',
    setupCode: 'val nested: Option[Option[Int]] = Some(Some(42))',
    expected: 42,
    sample: 'nested.flatMap(identity).getOrElse(0)',
    hints: ['flatMap flattens nested Options', 'identity returns the inner Option'],
    validPatterns: [/\.flatMap\s*\(/],
    tags: ['flatMap', 'option', 'nested'],
  },

  {
    id: 'scala-option-006',
    category: 'Option Handling',
    difficulty: 'medium',
    title: 'Option Fold',
    text: 'Return "empty" if None, or the uppercase value if Some.',
    setup: 'val maybeText: Option[String] = Some("hello")',
    setupCode: 'val maybeText: Option[String] = Some("hello")',
    expected: 'HELLO',
    sample: 'maybeText.fold("empty")(_.toUpperCase)',
    hints: ['fold takes default and transform function', 'First argument is for None case'],
    validPatterns: [/\.fold\s*\(\s*"empty"\s*\)/],
    tags: ['fold', 'option', 'transform'],
  },

  {
    id: 'scala-option-007',
    category: 'Option Handling',
    difficulty: 'medium',
    title: 'Chain Option Operations',
    text: 'Parse a string to Int and double it if valid.',
    setup: 'val text = "21"',
    setupCode: 'val text = "21"',
    expected: 42,
    sample: 'text.toIntOption.map(_ * 2).getOrElse(0)',
    hints: ['toIntOption returns Option[Int]', 'Chain map for transformation'],
    validPatterns: [/\.toIntOption\.map\s*\(/],
    tags: ['toIntOption', 'map', 'option'],
  },

  {
    id: 'scala-option-008',
    category: 'Option Handling',
    difficulty: 'medium',
    title: 'Filter Option',
    text: 'Keep the Option value only if it is greater than 10.',
    setup: 'val maybeNumber: Option[Int] = Some(25)',
    setupCode: 'val maybeNumber: Option[Int] = Some(25)',
    expected: 25,
    sample: 'maybeNumber.filter(_ > 10).getOrElse(0)',
    hints: ['filter returns None if predicate fails', 'Keeps value only if condition is true'],
    validPatterns: [/\.filter\s*\(.*>\s*10/],
    tags: ['filter', 'option', 'predicate'],
  },

  {
    id: 'scala-option-009',
    category: 'Option Handling',
    difficulty: 'hard',
    title: 'Option For-Comprehension',
    text: 'Combine two Options using for-comprehension.',
    setup: 'val a: Option[Int] = Some(10)\nval b: Option[Int] = Some(20)',
    setupCode: 'val a: Option[Int] = Some(10)\nval b: Option[Int] = Some(20)',
    expected: 30,
    sample: '(for { x <- a; y <- b } yield x + y).getOrElse(0)',
    hints: ['for-comprehension unwraps Options', 'yield produces the result'],
    validPatterns: [/for\s*\{.*<-.*\}\s*yield/],
    tags: ['for-comprehension', 'option', 'combine'],
  },

  {
    id: 'scala-option-010',
    category: 'Option Handling',
    difficulty: 'hard',
    title: 'OrElse Chaining',
    text: 'Try first Option, fallback to second if None.',
    setup: 'val first: Option[Int] = None\nval second: Option[Int] = Some(42)',
    setupCode: 'val first: Option[Int] = None\nval second: Option[Int] = Some(42)',
    expected: 42,
    sample: 'first.orElse(second).getOrElse(0)',
    hints: ['orElse provides fallback Option', 'Chain multiple orElse for priority'],
    validPatterns: [/\.orElse\s*\(\s*second\s*\)/],
    tags: ['orElse', 'option', 'fallback'],
  },

  // ============================================================
  // Map Operations (10 problems: 4 easy, 4 medium, 2 hard)
  // ============================================================

  {
    id: 'scala-map-001',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Get Value from Map',
    text: 'Get the value for key "name" from the map.',
    setup: 'val person = Map("name" -> "Alice", "city" -> "NYC")',
    setupCode: 'val person = Map("name" -> "Alice", "city" -> "NYC")',
    expected: 'Alice',
    sample: 'person("name")',
    hints: ['Use apply method with key', 'Throws exception if key not found'],
    validPatterns: [/person\s*\(\s*"name"\s*\)/],
    tags: ['get', 'map', 'access'],
  },

  {
    id: 'scala-map-002',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Safe Get with Option',
    text: 'Safely get the value for key "age", returning None if missing.',
    setup: 'val person = Map("name" -> "Alice")',
    setupCode: 'val person = Map("name" -> "Alice")',
    expected: null,
    sample: 'person.get("age")',
    hints: ['get returns Option[V]', 'Returns None for missing keys'],
    validPatterns: [/\.get\s*\(\s*"age"\s*\)/],
    tags: ['get', 'option', 'map'],
  },

  {
    id: 'scala-map-003',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Get with Default Value',
    text: 'Get value for key "age" or return 0 as default.',
    setup: 'val person = Map("name" -> "Alice")',
    setupCode: 'val person = Map("name" -> "Alice")',
    expected: 0,
    sample: 'person.getOrElse("age", 0)',
    hints: ['getOrElse provides default for missing key', 'Safer than apply method'],
    validPatterns: [/\.getOrElse\s*\(\s*"age"\s*,\s*0\s*\)/],
    tags: ['getOrElse', 'default', 'map'],
  },

  {
    id: 'scala-map-004',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Get All Keys',
    text: 'Get all keys from the map.',
    setup: 'val scores = Map("math" -> 90, "english" -> 85, "science" -> 92)',
    setupCode: 'val scores = Map("math" -> 90, "english" -> 85, "science" -> 92)',
    expected: ['math', 'english', 'science'],
    sample: 'scores.keys.toList',
    hints: ['keys returns an Iterable', 'Convert to List with toList'],
    validPatterns: [/\.keys(?!\w)/],
    tags: ['keys', 'map', 'access'],
  },

  {
    id: 'scala-map-005',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Get All Values',
    text: 'Get all values from the map.',
    setup: 'val scores = Map("math" -> 90, "english" -> 85, "science" -> 92)',
    setupCode: 'val scores = Map("math" -> 90, "english" -> 85, "science" -> 92)',
    expected: [90, 85, 92],
    sample: 'scores.values.toList',
    hints: ['values returns an Iterable', 'Convert to List with toList'],
    validPatterns: [/\.values(?!\w)/],
    tags: ['values', 'map', 'access'],
  },

  {
    id: 'scala-map-006',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Filter Map by Value',
    text: 'Filter to keep only entries with value greater than 85.',
    setup: 'val scores = Map("math" -> 90, "english" -> 80, "science" -> 92)',
    setupCode: 'val scores = Map("math" -> 90, "english" -> 80, "science" -> 92)',
    expected: { math: 90, science: 92 },
    sample: 'scores.filter(_._2 > 85)',
    hints: ['filter takes a predicate on (key, value)', '_._2 accesses the value'],
    validPatterns: [/\.filter\s*\(.*\._2\s*>\s*85/],
    tags: ['filter', 'map', 'predicate'],
  },

  {
    id: 'scala-map-007',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Filter by Key',
    text: 'Keep only entries where key starts with "s".',
    setup: 'val data = Map("scala" -> 1, "java" -> 2, "swift" -> 3)',
    setupCode: 'val data = Map("scala" -> 1, "java" -> 2, "swift" -> 3)',
    expected: { scala: 1, swift: 3 },
    sample: 'data.filter(_._1.startsWith("s"))',
    hints: ['_._1 accesses the key', 'Use string methods on key'],
    validPatterns: [/\.filter\s*\(.*\._1\.startsWith/],
    tags: ['filter', 'filterKeys', 'map'],
  },

  {
    id: 'scala-map-008',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Check Key Exists',
    text: 'Check if the map contains key "scala".',
    setup: 'val langs = Map("scala" -> "JVM", "python" -> "Interpreter")',
    setupCode: 'val langs = Map("scala" -> "JVM", "python" -> "Interpreter")',
    expected: true,
    sample: 'langs.contains("scala")',
    hints: ['contains checks for key existence', 'Returns Boolean'],
    validPatterns: [/\.contains\s*\(\s*"scala"\s*\)/],
    tags: ['contains', 'check', 'map'],
  },

  {
    id: 'scala-map-009',
    category: 'Map Operations',
    difficulty: 'hard',
    title: 'Map Values Transform',
    text: 'Double all values in the map.',
    setup: 'val prices = Map("apple" -> 1, "banana" -> 2, "cherry" -> 3)',
    setupCode: 'val prices = Map("apple" -> 1, "banana" -> 2, "cherry" -> 3)',
    expected: { apple: 2, banana: 4, cherry: 6 },
    sample: 'prices.view.mapValues(_ * 2).toMap',
    hints: ['mapValues transforms values keeping keys', 'Use view for lazy evaluation in Scala 2.13+'],
    validPatterns: [/\.mapValues\s*\(/, /\.map\s*\{.*=>/],
    tags: ['mapValues', 'transform', 'map'],
  },

  {
    id: 'scala-map-010',
    category: 'Map Operations',
    difficulty: 'hard',
    title: 'Group List into Map',
    text: 'Group words by their first character.',
    setup: 'val words = List("apple", "apricot", "banana", "blueberry")',
    setupCode: 'val words = List("apple", "apricot", "banana", "blueberry")',
    expected: { a: ['apple', 'apricot'], b: ['banana', 'blueberry'] },
    sample: 'words.groupBy(_.head)',
    hints: ['groupBy creates Map[K, List[V]]', 'head gets first character'],
    validPatterns: [/\.groupBy\s*\(.*\.head/],
    tags: ['groupBy', 'map', 'aggregate'],
  },

  // ============================================================
  // Pattern Matching (8 problems: 2 easy, 3 medium, 3 hard)
  // ============================================================

  {
    id: 'scala-pattern-001',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Match on Value',
    text: 'Match number 1-3 to their word representation.',
    setup: 'val num = 2',
    setupCode: 'val num = 2',
    expected: 'two',
    sample: 'num match { case 1 => "one"; case 2 => "two"; case 3 => "three"; case _ => "unknown" }',
    hints: ['Use match expression', 'Underscore _ is wildcard pattern'],
    validPatterns: [/num\s+match\s*\{/],
    tags: ['match', 'pattern', 'basics'],
  },

  {
    id: 'scala-pattern-002',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Match Option',
    text: 'Match on Option to extract value or return "none".',
    setup: 'val maybeValue: Option[String] = Some("hello")',
    setupCode: 'val maybeValue: Option[String] = Some("hello")',
    expected: 'hello',
    sample: 'maybeValue match { case Some(v) => v; case None => "none" }',
    hints: ['Match Some(value) to extract', 'Handle None case explicitly'],
    validPatterns: [/match\s*\{.*case\s+Some\(/],
    tags: ['match', 'option', 'extraction'],
  },

  {
    id: 'scala-pattern-003',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Match with Guard',
    text: 'Match if number is positive, negative, or zero.',
    setup: 'val num = -5',
    setupCode: 'val num = -5',
    expected: 'negative',
    sample: 'num match { case n if n > 0 => "positive"; case n if n < 0 => "negative"; case _ => "zero" }',
    hints: ['Use if guard after pattern', 'Guard adds condition to pattern'],
    validPatterns: [/match\s*\{.*case.*if\s+/],
    tags: ['match', 'guard', 'condition'],
  },

  {
    id: 'scala-pattern-004',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Match List Patterns',
    text: 'Extract head and tail from a list using pattern matching.',
    setup: 'val numbers = List(1, 2, 3, 4, 5)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5)',
    expected: [1, [2, 3, 4, 5]],
    sample: 'numbers match { case head :: tail => (head, tail); case Nil => (0, Nil) }',
    hints: ['Use :: to match head and tail', 'Nil matches empty list'],
    validPatterns: [/match\s*\{.*case\s+\w+\s*::\s*\w+/],
    tags: ['match', 'list', 'destructure'],
  },

  {
    id: 'scala-pattern-005',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Match Tuple',
    text: 'Match on tuple and return sum of elements.',
    setup: 'val pair = (10, 20)',
    setupCode: 'val pair = (10, 20)',
    expected: 30,
    sample: 'pair match { case (a, b) => a + b }',
    hints: ['Destructure tuple in pattern', 'Access individual elements'],
    validPatterns: [/match\s*\{.*case\s*\(\s*\w+\s*,\s*\w+\s*\)/],
    tags: ['match', 'tuple', 'destructure'],
  },

  {
    id: 'scala-pattern-006',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Match Type',
    text: 'Match on the type of Any value.',
    setup: 'val value: Any = "hello"',
    setupCode: 'val value: Any = "hello"',
    expected: 'string: hello',
    sample: 'value match { case s: String => s"string: $s"; case i: Int => s"int: $i"; case _ => "unknown" }',
    hints: ['Use : Type to match on type', 'Variable binding with type'],
    validPatterns: [/match\s*\{.*case\s+\w+:\s*String/],
    tags: ['match', 'type', 'casting'],
  },

  {
    id: 'scala-pattern-007',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Match Case Class',
    text: 'Extract name and age from Person case class.',
    setup: 'case class Person(name: String, age: Int)\nval person = Person("Alice", 30)',
    setupCode: 'case class Person(name: String, age: Int)\nval person = Person("Alice", 30)',
    expected: 'Alice is 30',
    sample: 'person match { case Person(name, age) => s"$name is $age" }',
    hints: ['Case classes have unapply method', 'Destructure in pattern'],
    validPatterns: [/match\s*\{.*case\s+Person\s*\(/],
    tags: ['match', 'case-class', 'destructure'],
  },

  {
    id: 'scala-pattern-008',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Nested Pattern Matching',
    text: 'Extract value from nested Option inside a tuple.',
    setup: 'val data: (String, Option[Int]) = ("count", Some(42))',
    setupCode: 'val data: (String, Option[Int]) = ("count", Some(42))',
    expected: 42,
    sample: 'data match { case (_, Some(n)) => n; case _ => 0 }',
    hints: ['Nest patterns for complex structures', 'Use _ to ignore parts'],
    validPatterns: [/match\s*\{.*case\s*\(.*Some\(/],
    tags: ['match', 'nested', 'destructure'],
  },
];

export default scalaProblems;
