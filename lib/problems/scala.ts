/**
 * Scala Coding Drills Problems
 *
 * Comprehensive collection of Scala problems covering:
 * - List Operations (filter, map, flatMap, fold, reduce, head, tail, take, drop)
 * - String Methods (length, toLowerCase, toUpperCase, split, contains, replace)
 * - Option Handling (map, flatMap, getOrElse, fold, isDefined)
 * - Map Operations (get, getOrElse, keys, values, filterKeys)
 * - Pattern Matching basics
 *
 * Distribution: 20 easy, 20 medium, 10 hard
 */

import type { Problem } from '../types';

export const scalaProblems: Problem[] = [
  // ============================================================
  // List Operations (12 problems: 5 easy, 5 medium, 2 hard)
  // ============================================================

  {
    id: 'scala-list-001',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Filter Even Numbers',
    text: 'Filter the list to keep only even numbers.',
    setup: 'val numbers = List(1, 2, 3, 4, 5, 6)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5, 6)',
    expected: [2, 4, 6],
    sample: 'numbers.filter(_ % 2 == 0)',
    hints: ['Use filter with a predicate', 'The underscore _ represents each element'],
    validPatterns: [/\.filter\s*\(/, /\.filter\s*\{/],
    tags: ['filter', 'collections', 'predicate'],
  },

  {
    id: 'scala-list-002',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Map to Squares',
    text: 'Transform each number to its square.',
    setup: 'val numbers = List(1, 2, 3, 4, 5)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5)',
    expected: [1, 4, 9, 16, 25],
    sample: 'numbers.map(x => x * x)',
    hints: ['Use map to transform elements', 'You can also use _ * _ shorthand'],
    validPatterns: [/\.map\s*\(/, /\.map\s*\{/],
    tags: ['map', 'transform', 'collections'],
  },

  {
    id: 'scala-list-003',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Get First Element',
    text: 'Get the first element of the list using head.',
    setup: 'val fruits = List("apple", "banana", "cherry")',
    setupCode: 'val fruits = List("apple", "banana", "cherry")',
    expected: 'apple',
    sample: 'fruits.head',
    hints: ['head returns the first element', 'Throws exception on empty list'],
    validPatterns: [/\.head(?!\w)/],
    tags: ['head', 'access', 'first'],
  },

  {
    id: 'scala-list-004',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Get Tail of List',
    text: 'Get all elements except the first one.',
    setup: 'val numbers = List(1, 2, 3, 4, 5)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5)',
    expected: [2, 3, 4, 5],
    sample: 'numbers.tail',
    hints: ['tail returns all elements except head', 'Returns a new List'],
    validPatterns: [/\.tail(?!\w)/],
    tags: ['tail', 'slice', 'collections'],
  },

  {
    id: 'scala-list-005',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Take First N Elements',
    text: 'Take the first 3 elements from the list.',
    setup: 'val numbers = List(10, 20, 30, 40, 50)',
    setupCode: 'val numbers = List(10, 20, 30, 40, 50)',
    expected: [10, 20, 30],
    sample: 'numbers.take(3)',
    hints: ['take(n) returns first n elements', 'Safe on lists shorter than n'],
    validPatterns: [/\.take\s*\(\s*3\s*\)/],
    tags: ['take', 'slice', 'collections'],
  },

  {
    id: 'scala-list-006',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Drop First N Elements',
    text: 'Skip the first 2 elements and return the rest.',
    setup: 'val numbers = List(1, 2, 3, 4, 5)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5)',
    expected: [3, 4, 5],
    sample: 'numbers.drop(2)',
    hints: ['drop(n) skips first n elements', 'Returns remaining elements'],
    validPatterns: [/\.drop\s*\(\s*2\s*\)/],
    tags: ['drop', 'skip', 'collections'],
  },

  {
    id: 'scala-list-007',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Sum with Reduce',
    text: 'Calculate the sum of all numbers using reduce.',
    setup: 'val numbers = List(1, 2, 3, 4, 5)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5)',
    expected: 15,
    sample: 'numbers.reduce(_ + _)',
    hints: [
      'reduce combines elements pairwise',
      'The underscores represent accumulator and current',
    ],
    validPatterns: [/\.reduce\s*\(/, /\.reduce\s*\{/],
    tags: ['reduce', 'aggregation', 'sum'],
  },

  {
    id: 'scala-list-008',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Fold with Initial Value',
    text: 'Calculate the sum starting from 100 using foldLeft.',
    setup: 'val numbers = List(1, 2, 3, 4, 5)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5)',
    expected: 115,
    sample: 'numbers.foldLeft(100)(_ + _)',
    hints: ['foldLeft takes initial value', 'First parameter is accumulator, second is element'],
    validPatterns: [/\.foldLeft\s*\(\s*100\s*\)/],
    tags: ['foldLeft', 'fold', 'aggregation'],
  },

  {
    id: 'scala-list-009',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'FlatMap Nested Lists',
    text: 'Flatten a list of lists into a single list.',
    setup: 'val nested = List(List(1, 2), List(3, 4), List(5, 6))',
    setupCode: 'val nested = List(List(1, 2), List(3, 4), List(5, 6))',
    expected: [1, 2, 3, 4, 5, 6],
    sample: 'nested.flatMap(identity)',
    hints: ['flatMap flattens while mapping', 'identity returns elements unchanged'],
    validPatterns: [/\.flatMap\s*\(/, /\.flatten(?!\w)/],
    tags: ['flatMap', 'flatten', 'nested'],
  },

  {
    id: 'scala-list-010',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Filter and Map Combined',
    text: 'Filter numbers greater than 2, then double them.',
    setup: 'val numbers = List(1, 2, 3, 4, 5)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5)',
    expected: [6, 8, 10],
    sample: 'numbers.filter(_ > 2).map(_ * 2)',
    hints: ['Chain filter and map operations', 'Filter first to reduce elements'],
    validPatterns: [/\.filter\s*\(.*\)\.map\s*\(/],
    tags: ['filter', 'map', 'chaining'],
  },

  {
    id: 'scala-list-011',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'FoldRight Operation',
    text: 'Concatenate strings from right to left using foldRight.',
    setup: 'val words = List("a", "b", "c")',
    setupCode: 'val words = List("a", "b", "c")',
    expected: 'abc',
    sample: 'words.foldRight("")(_ + _)',
    hints: ['foldRight processes from right to left', 'Order of parameters differs from foldLeft'],
    validPatterns: [/\.foldRight\s*\(\s*""\s*\)/],
    tags: ['foldRight', 'fold', 'aggregation'],
  },

  {
    id: 'scala-list-012',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Custom Reduce with FlatMap',
    text: 'Generate pairs (x, x*2) for each number and flatten.',
    setup: 'val numbers = List(1, 2, 3)',
    setupCode: 'val numbers = List(1, 2, 3)',
    expected: [1, 2, 2, 4, 3, 6],
    sample: 'numbers.flatMap(x => List(x, x * 2))',
    hints: ['flatMap applies function and flattens', 'Return a List from the function'],
    validPatterns: [/\.flatMap\s*\(/],
    tags: ['flatMap', 'transform', 'pairs'],
  },

  // ============================================================
  // String Methods (10 problems: 5 easy, 4 medium, 1 hard)
  // ============================================================

  {
    id: 'scala-string-001',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Get String Length',
    text: 'Get the length of the string.',
    setup: 'val text = "Hello Scala"',
    setupCode: 'val text = "Hello Scala"',
    expected: 11,
    sample: 'text.length',
    hints: ['length returns number of characters', 'Includes spaces'],
    validPatterns: [/\.length(?!\w)/],
    tags: ['length', 'string', 'basics'],
  },

  {
    id: 'scala-string-002',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Convert to Lowercase',
    text: 'Convert the string to all lowercase characters.',
    setup: 'val text = "HELLO WORLD"',
    setupCode: 'val text = "HELLO WORLD"',
    expected: 'hello world',
    sample: 'text.toLowerCase',
    hints: ['toLowerCase converts all characters', 'Returns a new String'],
    validPatterns: [/\.toLowerCase(?!\w)/],
    tags: ['toLowerCase', 'case', 'string'],
  },

  {
    id: 'scala-string-003',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Convert to Uppercase',
    text: 'Convert the string to all uppercase characters.',
    setup: 'val text = "hello scala"',
    setupCode: 'val text = "hello scala"',
    expected: 'HELLO SCALA',
    sample: 'text.toUpperCase',
    hints: ['toUpperCase converts all characters', 'Returns a new String'],
    validPatterns: [/\.toUpperCase(?!\w)/],
    tags: ['toUpperCase', 'case', 'string'],
  },

  {
    id: 'scala-string-004',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Split String',
    text: 'Split the string by comma into an array.',
    setup: 'val csv = "apple,banana,cherry"',
    setupCode: 'val csv = "apple,banana,cherry"',
    expected: ['apple', 'banana', 'cherry'],
    sample: 'csv.split(",")',
    hints: ['split returns Array[String]', 'Can split by regex pattern'],
    validPatterns: [/\.split\s*\(\s*","\s*\)/],
    tags: ['split', 'parse', 'string'],
  },

  {
    id: 'scala-string-005',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Check Contains Substring',
    text: 'Check if the string contains "Scala".',
    setup: 'val text = "I love Scala programming"',
    setupCode: 'val text = "I love Scala programming"',
    expected: true,
    sample: 'text.contains("Scala")',
    hints: ['contains returns Boolean', 'Case-sensitive search'],
    validPatterns: [/\.contains\s*\(\s*"Scala"\s*\)/],
    tags: ['contains', 'search', 'string'],
  },

  {
    id: 'scala-string-006',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Replace Characters',
    text: 'Replace all spaces with underscores.',
    setup: 'val text = "Hello Scala World"',
    setupCode: 'val text = "Hello Scala World"',
    expected: 'Hello_Scala_World',
    sample: 'text.replace(" ", "_")',
    hints: ['replace replaces all occurrences', 'Returns new String'],
    validPatterns: [/\.replace\s*\(\s*" "\s*,\s*"_"\s*\)/],
    tags: ['replace', 'substitution', 'string'],
  },

  {
    id: 'scala-string-007',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Split and Transform',
    text: 'Split by space and convert each word to uppercase.',
    setup: 'val text = "hello world scala"',
    setupCode: 'val text = "hello world scala"',
    expected: ['HELLO', 'WORLD', 'SCALA'],
    sample: 'text.split(" ").map(_.toUpperCase)',
    hints: ['Chain split with map', 'split returns Array, map transforms'],
    validPatterns: [/\.split\s*\(.*\)\.map\s*\(/],
    tags: ['split', 'map', 'transform'],
  },

  {
    id: 'scala-string-008',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'String Interpolation',
    text: 'Create a string "Name: Alice, Age: 25" using string interpolation.',
    setup: 'val name = "Alice"\nval age = 25',
    setupCode: 'val name = "Alice"\nval age = 25',
    expected: 'Name: Alice, Age: 25',
    sample: 's"Name: $name, Age: $age"',
    hints: ['Use s-interpolator with $variable', 'Prefix string with s'],
    validPatterns: [/s".*\$name.*\$age.*"/],
    tags: ['interpolation', 'format', 'string'],
  },

  {
    id: 'scala-string-009',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Trim and Check Empty',
    text: 'Trim the string and check if it is empty.',
    setup: 'val text = "   "',
    setupCode: 'val text = "   "',
    expected: true,
    sample: 'text.trim.isEmpty',
    hints: ['trim removes leading/trailing whitespace', 'isEmpty checks for empty string'],
    validPatterns: [/\.trim\.isEmpty/],
    tags: ['trim', 'isEmpty', 'validation'],
  },

  {
    id: 'scala-string-010',
    category: 'String Methods',
    difficulty: 'hard',
    title: 'Regex Replace',
    text: 'Replace all digits with "X" using regex.',
    setup: 'val text = "Phone: 123-456-7890"',
    setupCode: 'val text = "Phone: 123-456-7890"',
    expected: 'Phone: XXX-XXX-XXXX',
    sample: 'text.replaceAll("\\\\d", "X")',
    hints: ['Use replaceAll for regex patterns', 'Double escape backslash in Scala'],
    validPatterns: [/\.replaceAll\s*\(/],
    tags: ['replaceAll', 'regex', 'string'],
  },

  // ============================================================
  // Option Handling (10 problems: 4 easy, 4 medium, 2 hard)
  // ============================================================

  {
    id: 'scala-option-001',
    category: 'Option Handling',
    difficulty: 'easy',
    title: 'Get Value or Default',
    text: 'Get the value from Option or return 0 as default.',
    setup: 'val maybeNumber: Option[Int] = Some(42)',
    setupCode: 'val maybeNumber: Option[Int] = Some(42)',
    expected: 42,
    sample: 'maybeNumber.getOrElse(0)',
    hints: ['getOrElse returns value or default', 'Safe way to extract Option value'],
    validPatterns: [/\.getOrElse\s*\(\s*0\s*\)/],
    tags: ['getOrElse', 'option', 'default'],
  },

  {
    id: 'scala-option-002',
    category: 'Option Handling',
    difficulty: 'easy',
    title: 'Check if Defined',
    text: 'Check if the Option contains a value.',
    setup: 'val maybeValue: Option[String] = Some("hello")',
    setupCode: 'val maybeValue: Option[String] = Some("hello")',
    expected: true,
    sample: 'maybeValue.isDefined',
    hints: ['isDefined returns true for Some', 'Returns false for None'],
    validPatterns: [/\.isDefined(?!\w)/],
    tags: ['isDefined', 'option', 'check'],
  },

  {
    id: 'scala-option-003',
    category: 'Option Handling',
    difficulty: 'easy',
    title: 'Map Over Option',
    text: 'Double the value inside the Option if present.',
    setup: 'val maybeNumber: Option[Int] = Some(21)',
    setupCode: 'val maybeNumber: Option[Int] = Some(21)',
    expected: 42,
    sample: 'maybeNumber.map(_ * 2).getOrElse(0)',
    hints: ['map transforms the value inside Option', 'Returns None if Option is empty'],
    validPatterns: [/\.map\s*\(.*\*\s*2/],
    tags: ['map', 'option', 'transform'],
  },

  {
    id: 'scala-option-004',
    category: 'Option Handling',
    difficulty: 'easy',
    title: 'Check if Empty',
    text: 'Check if the Option is empty (None).',
    setup: 'val maybeValue: Option[Int] = None',
    setupCode: 'val maybeValue: Option[Int] = None',
    expected: true,
    sample: 'maybeValue.isEmpty',
    hints: ['isEmpty returns true for None', 'Opposite of isDefined'],
    validPatterns: [/\.isEmpty(?!\w)/],
    tags: ['isEmpty', 'option', 'check'],
  },

  {
    id: 'scala-option-005',
    category: 'Option Handling',
    difficulty: 'medium',
    title: 'FlatMap Nested Options',
    text: 'Extract nested Option value using flatMap.',
    setup: 'val nested: Option[Option[Int]] = Some(Some(42))',
    setupCode: 'val nested: Option[Option[Int]] = Some(Some(42))',
    expected: 42,
    sample: 'nested.flatMap(identity).getOrElse(0)',
    hints: ['flatMap flattens nested Options', 'identity returns the inner Option'],
    validPatterns: [/\.flatMap\s*\(/],
    tags: ['flatMap', 'option', 'nested'],
  },

  {
    id: 'scala-option-006',
    category: 'Option Handling',
    difficulty: 'medium',
    title: 'Option Fold',
    text: 'Return "empty" if None, or the uppercase value if Some.',
    setup: 'val maybeText: Option[String] = Some("hello")',
    setupCode: 'val maybeText: Option[String] = Some("hello")',
    expected: 'HELLO',
    sample: 'maybeText.fold("empty")(_.toUpperCase)',
    hints: ['fold takes default and transform function', 'First argument is for None case'],
    validPatterns: [/\.fold\s*\(\s*"empty"\s*\)/],
    tags: ['fold', 'option', 'transform'],
  },

  {
    id: 'scala-option-007',
    category: 'Option Handling',
    difficulty: 'medium',
    title: 'Chain Option Operations',
    text: 'Parse a string to Int and double it if valid.',
    setup: 'val text = "21"',
    setupCode: 'val text = "21"',
    expected: 42,
    sample: 'text.toIntOption.map(_ * 2).getOrElse(0)',
    hints: ['toIntOption returns Option[Int]', 'Chain map for transformation'],
    validPatterns: [/\.toIntOption\.map\s*\(/],
    tags: ['toIntOption', 'map', 'option'],
  },

  {
    id: 'scala-option-008',
    category: 'Option Handling',
    difficulty: 'medium',
    title: 'Filter Option',
    text: 'Keep the Option value only if it is greater than 10.',
    setup: 'val maybeNumber: Option[Int] = Some(25)',
    setupCode: 'val maybeNumber: Option[Int] = Some(25)',
    expected: 25,
    sample: 'maybeNumber.filter(_ > 10).getOrElse(0)',
    hints: ['filter returns None if predicate fails', 'Keeps value only if condition is true'],
    validPatterns: [/\.filter\s*\(.*>\s*10/],
    tags: ['filter', 'option', 'predicate'],
  },

  {
    id: 'scala-option-009',
    category: 'Option Handling',
    difficulty: 'hard',
    title: 'Option For-Comprehension',
    text: 'Combine two Options using for-comprehension.',
    setup: 'val a: Option[Int] = Some(10)\nval b: Option[Int] = Some(20)',
    setupCode: 'val a: Option[Int] = Some(10)\nval b: Option[Int] = Some(20)',
    expected: 30,
    sample: '(for { x <- a; y <- b } yield x + y).getOrElse(0)',
    hints: ['for-comprehension unwraps Options', 'yield produces the result'],
    validPatterns: [/for\s*\{.*<-.*\}\s*yield/],
    tags: ['for-comprehension', 'option', 'combine'],
  },

  {
    id: 'scala-option-010',
    category: 'Option Handling',
    difficulty: 'hard',
    title: 'OrElse Chaining',
    text: 'Try first Option, fallback to second if None.',
    setup: 'val first: Option[Int] = None\nval second: Option[Int] = Some(42)',
    setupCode: 'val first: Option[Int] = None\nval second: Option[Int] = Some(42)',
    expected: 42,
    sample: 'first.orElse(second).getOrElse(0)',
    hints: ['orElse provides fallback Option', 'Chain multiple orElse for priority'],
    validPatterns: [/\.orElse\s*\(\s*second\s*\)/],
    tags: ['orElse', 'option', 'fallback'],
  },

  // ============================================================
  // Map Operations (10 problems: 4 easy, 4 medium, 2 hard)
  // ============================================================

  {
    id: 'scala-map-001',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Get Value from Map',
    text: 'Get the value for key "name" from the map.',
    setup: 'val person = Map("name" -> "Alice", "city" -> "NYC")',
    setupCode: 'val person = Map("name" -> "Alice", "city" -> "NYC")',
    expected: 'Alice',
    sample: 'person("name")',
    hints: ['Use apply method with key', 'Throws exception if key not found'],
    validPatterns: [/person\s*\(\s*"name"\s*\)/],
    tags: ['get', 'map', 'access'],
  },

  {
    id: 'scala-map-002',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Safe Get with Option',
    text: 'Safely get the value for key "age", returning None if missing.',
    setup: 'val person = Map("name" -> "Alice")',
    setupCode: 'val person = Map("name" -> "Alice")',
    expected: null,
    sample: 'person.get("age")',
    hints: ['get returns Option[V]', 'Returns None for missing keys'],
    validPatterns: [/\.get\s*\(\s*"age"\s*\)/],
    tags: ['get', 'option', 'map'],
  },

  {
    id: 'scala-map-003',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Get with Default Value',
    text: 'Get value for key "age" or return 0 as default.',
    setup: 'val person = Map("name" -> "Alice")',
    setupCode: 'val person = Map("name" -> "Alice")',
    expected: 0,
    sample: 'person.getOrElse("age", 0)',
    hints: ['getOrElse provides default for missing key', 'Safer than apply method'],
    validPatterns: [/\.getOrElse\s*\(\s*"age"\s*,\s*0\s*\)/],
    tags: ['getOrElse', 'default', 'map'],
  },

  {
    id: 'scala-map-004',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Get All Keys',
    text: 'Get all keys from the map.',
    setup: 'val scores = Map("math" -> 90, "english" -> 85, "science" -> 92)',
    setupCode: 'val scores = Map("math" -> 90, "english" -> 85, "science" -> 92)',
    expected: ['math', 'english', 'science'],
    sample: 'scores.keys.toList',
    hints: ['keys returns an Iterable', 'Convert to List with toList'],
    validPatterns: [/\.keys(?!\w)/],
    tags: ['keys', 'map', 'access'],
  },

  {
    id: 'scala-map-005',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Get All Values',
    text: 'Get all values from the map.',
    setup: 'val scores = Map("math" -> 90, "english" -> 85, "science" -> 92)',
    setupCode: 'val scores = Map("math" -> 90, "english" -> 85, "science" -> 92)',
    expected: [90, 85, 92],
    sample: 'scores.values.toList',
    hints: ['values returns an Iterable', 'Convert to List with toList'],
    validPatterns: [/\.values(?!\w)/],
    tags: ['values', 'map', 'access'],
  },

  {
    id: 'scala-map-006',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Filter Map by Value',
    text: 'Filter to keep only entries with value greater than 85.',
    setup: 'val scores = Map("math" -> 90, "english" -> 80, "science" -> 92)',
    setupCode: 'val scores = Map("math" -> 90, "english" -> 80, "science" -> 92)',
    expected: { math: 90, science: 92 },
    sample: 'scores.filter(_._2 > 85)',
    hints: ['filter takes a predicate on (key, value)', '_._2 accesses the value'],
    validPatterns: [/\.filter\s*\(.*\._2\s*>\s*85/],
    tags: ['filter', 'map', 'predicate'],
  },

  {
    id: 'scala-map-007',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Filter by Key',
    text: 'Keep only entries where key starts with "s".',
    setup: 'val data = Map("scala" -> 1, "java" -> 2, "swift" -> 3)',
    setupCode: 'val data = Map("scala" -> 1, "java" -> 2, "swift" -> 3)',
    expected: { scala: 1, swift: 3 },
    sample: 'data.filter(_._1.startsWith("s"))',
    hints: ['_._1 accesses the key', 'Use string methods on key'],
    validPatterns: [/\.filter\s*\(.*\._1\.startsWith/],
    tags: ['filter', 'filterKeys', 'map'],
  },

  {
    id: 'scala-map-008',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Check Key Exists',
    text: 'Check if the map contains key "scala".',
    setup: 'val langs = Map("scala" -> "JVM", "python" -> "Interpreter")',
    setupCode: 'val langs = Map("scala" -> "JVM", "python" -> "Interpreter")',
    expected: true,
    sample: 'langs.contains("scala")',
    hints: ['contains checks for key existence', 'Returns Boolean'],
    validPatterns: [/\.contains\s*\(\s*"scala"\s*\)/],
    tags: ['contains', 'check', 'map'],
  },

  {
    id: 'scala-map-009',
    category: 'Map Operations',
    difficulty: 'hard',
    title: 'Map Values Transform',
    text: 'Double all values in the map.',
    setup: 'val prices = Map("apple" -> 1, "banana" -> 2, "cherry" -> 3)',
    setupCode: 'val prices = Map("apple" -> 1, "banana" -> 2, "cherry" -> 3)',
    expected: { apple: 2, banana: 4, cherry: 6 },
    sample: 'prices.view.mapValues(_ * 2).toMap',
    hints: [
      'mapValues transforms values keeping keys',
      'Use view for lazy evaluation in Scala 2.13+',
    ],
    validPatterns: [/\.mapValues\s*\(/, /\.map\s*\{.*=>/],
    tags: ['mapValues', 'transform', 'map'],
  },

  {
    id: 'scala-map-010',
    category: 'Map Operations',
    difficulty: 'hard',
    title: 'Group List into Map',
    text: 'Group words by their first character.',
    setup: 'val words = List("apple", "apricot", "banana", "blueberry")',
    setupCode: 'val words = List("apple", "apricot", "banana", "blueberry")',
    expected: { a: ['apple', 'apricot'], b: ['banana', 'blueberry'] },
    sample: 'words.groupBy(_.head)',
    hints: ['groupBy creates Map[K, List[V]]', 'head gets first character'],
    validPatterns: [/\.groupBy\s*\(.*\.head/],
    tags: ['groupBy', 'map', 'aggregate'],
  },

  // ============================================================
  // Pattern Matching (8 problems: 2 easy, 3 medium, 3 hard)
  // ============================================================

  {
    id: 'scala-pattern-001',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Match on Value',
    text: 'Match number 1-3 to their word representation.',
    setup: 'val num = 2',
    setupCode: 'val num = 2',
    expected: 'two',
    sample:
      'num match { case 1 => "one"; case 2 => "two"; case 3 => "three"; case _ => "unknown" }',
    hints: ['Use match expression', 'Underscore _ is wildcard pattern'],
    validPatterns: [/num\s+match\s*\{/],
    tags: ['match', 'pattern', 'basics'],
  },

  {
    id: 'scala-pattern-002',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Match Option',
    text: 'Match on Option to extract value or return "none".',
    setup: 'val maybeValue: Option[String] = Some("hello")',
    setupCode: 'val maybeValue: Option[String] = Some("hello")',
    expected: 'hello',
    sample: 'maybeValue match { case Some(v) => v; case None => "none" }',
    hints: ['Match Some(value) to extract', 'Handle None case explicitly'],
    validPatterns: [/match\s*\{.*case\s+Some\(/],
    tags: ['match', 'option', 'extraction'],
  },

  {
    id: 'scala-pattern-003',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Match with Guard',
    text: 'Match if number is positive, negative, or zero.',
    setup: 'val num = -5',
    setupCode: 'val num = -5',
    expected: 'negative',
    sample:
      'num match { case n if n > 0 => "positive"; case n if n < 0 => "negative"; case _ => "zero" }',
    hints: ['Use if guard after pattern', 'Guard adds condition to pattern'],
    validPatterns: [/match\s*\{.*case.*if\s+/],
    tags: ['match', 'guard', 'condition'],
  },

  {
    id: 'scala-pattern-004',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Match List Patterns',
    text: 'Extract head and tail from a list using pattern matching.',
    setup: 'val numbers = List(1, 2, 3, 4, 5)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5)',
    expected: [1, [2, 3, 4, 5]],
    sample: 'numbers match { case head :: tail => (head, tail); case Nil => (0, Nil) }',
    hints: ['Use :: to match head and tail', 'Nil matches empty list'],
    validPatterns: [/match\s*\{.*case\s+\w+\s*::\s*\w+/],
    tags: ['match', 'list', 'destructure'],
  },

  {
    id: 'scala-pattern-005',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Match Tuple',
    text: 'Match on tuple and return sum of elements.',
    setup: 'val pair = (10, 20)',
    setupCode: 'val pair = (10, 20)',
    expected: 30,
    sample: 'pair match { case (a, b) => a + b }',
    hints: ['Destructure tuple in pattern', 'Access individual elements'],
    validPatterns: [/match\s*\{.*case\s*\(\s*\w+\s*,\s*\w+\s*\)/],
    tags: ['match', 'tuple', 'destructure'],
  },

  {
    id: 'scala-pattern-006',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Match Type',
    text: 'Match on the type of Any value.',
    setup: 'val value: Any = "hello"',
    setupCode: 'val value: Any = "hello"',
    expected: 'string: hello',
    sample:
      'value match { case s: String => s"string: $s"; case i: Int => s"int: $i"; case _ => "unknown" }',
    hints: ['Use : Type to match on type', 'Variable binding with type'],
    validPatterns: [/match\s*\{.*case\s+\w+:\s*String/],
    tags: ['match', 'type', 'casting'],
  },

  {
    id: 'scala-pattern-007',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Match Case Class',
    text: 'Extract name and age from Person case class.',
    setup: 'case class Person(name: String, age: Int)\nval person = Person("Alice", 30)',
    setupCode: 'case class Person(name: String, age: Int)\nval person = Person("Alice", 30)',
    expected: 'Alice is 30',
    sample: 'person match { case Person(name, age) => s"$name is $age" }',
    hints: ['Case classes have unapply method', 'Destructure in pattern'],
    validPatterns: [/match\s*\{.*case\s+Person\s*\(/],
    tags: ['match', 'case-class', 'destructure'],
  },

  {
    id: 'scala-pattern-008',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Nested Pattern Matching',
    text: 'Extract value from nested Option inside a tuple.',
    setup: 'val data: (String, Option[Int]) = ("count", Some(42))',
    setupCode: 'val data: (String, Option[Int]) = ("count", Some(42))',
    expected: 42,
    sample: 'data match { case (_, Some(n)) => n; case _ => 0 }',
    hints: ['Nest patterns for complex structures', 'Use _ to ignore parts'],
    validPatterns: [/match\s*\{.*case\s*\(.*Some\(/],
    tags: ['match', 'nested', 'destructure'],
  },

  // ============================================================
  // NEW PROBLEMS - List Operations (50 problems)
  // ============================================================

  {
    id: 'scala-list-100',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Map to String Length',
    text: 'Transform each string to its length.',
    setup: 'val words = List("cat", "elephant", "dog")',
    setupCode: 'val words = List("cat", "elephant", "dog")',
    expected: [3, 8, 3],
    sample: 'words.map(_.length)',
    hints: ['Use map to transform elements', 'length gives string size'],
    tags: ['map', 'transform', 'length'],
  },

  {
    id: 'scala-list-101',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Filter Positive Numbers',
    text: 'Keep only positive numbers from the list.',
    setup: 'val numbers = List(-3, -1, 0, 2, 5)',
    setupCode: 'val numbers = List(-3, -1, 0, 2, 5)',
    expected: [2, 5],
    sample: 'numbers.filter(_ > 0)',
    hints: ['Use filter with a predicate', 'Positive means greater than 0'],
    tags: ['filter', 'predicate', 'collections'],
  },

  {
    id: 'scala-list-102',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Collect Even Numbers Doubled',
    text: 'Use collect to filter even numbers and double them.',
    setup: 'val numbers = List(1, 2, 3, 4, 5, 6)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5, 6)',
    expected: [4, 8, 12],
    sample: 'numbers.collect { case n if n % 2 == 0 => n * 2 }',
    hints: ['collect combines filter and map', 'Use partial function syntax'],
    tags: ['collect', 'partial-function', 'transform'],
  },

  {
    id: 'scala-list-103',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'FlatMap Split Words',
    text: 'Split each sentence into words and flatten.',
    setup: 'val sentences = List("hello world", "scala is fun")',
    setupCode: 'val sentences = List("hello world", "scala is fun")',
    expected: ['hello', 'world', 'scala', 'is', 'fun'],
    sample: 'sentences.flatMap(_.split(" "))',
    hints: ['flatMap applies function and flattens', 'split returns Array'],
    tags: ['flatMap', 'split', 'flatten'],
  },

  {
    id: 'scala-list-104',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Sum with FoldLeft',
    text: 'Calculate sum using foldLeft starting from 0.',
    setup: 'val numbers = List(1, 2, 3, 4)',
    setupCode: 'val numbers = List(1, 2, 3, 4)',
    expected: 10,
    sample: 'numbers.foldLeft(0)(_ + _)',
    hints: ['foldLeft takes initial value', 'Accumulator is first parameter'],
    tags: ['foldLeft', 'sum', 'aggregation'],
  },

  {
    id: 'scala-list-105',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Filter Strings by Length',
    text: 'Keep only strings with length greater than 3.',
    setup: 'val words = List("a", "cat", "elephant", "dog", "hi")',
    setupCode: 'val words = List("a", "cat", "elephant", "dog", "hi")',
    expected: ['elephant'],
    sample: 'words.filter(_.length > 3)',
    hints: ['Use filter with length check', 'Combine method calls'],
    tags: ['filter', 'length', 'strings'],
  },

  {
    id: 'scala-list-106',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Map to Boolean',
    text: 'Transform numbers to true if even, false if odd.',
    setup: 'val numbers = List(1, 2, 3, 4)',
    setupCode: 'val numbers = List(1, 2, 3, 4)',
    expected: [false, true, false, true],
    sample: 'numbers.map(_ % 2 == 0)',
    hints: ['Use map with modulo check', 'Returns List[Boolean]'],
    tags: ['map', 'boolean', 'transform'],
  },

  {
    id: 'scala-list-107',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Reverse List',
    text: 'Reverse the order of elements in the list.',
    setup: 'val numbers = List(1, 2, 3, 4, 5)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5)',
    expected: [5, 4, 3, 2, 1],
    sample: 'numbers.reverse',
    hints: ['Use reverse method', 'Returns new list'],
    tags: ['reverse', 'order', 'collections'],
  },

  {
    id: 'scala-list-108',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Get Last Element',
    text: 'Get the last element of the list.',
    setup: 'val numbers = List(10, 20, 30, 40)',
    setupCode: 'val numbers = List(10, 20, 30, 40)',
    expected: 40,
    sample: 'numbers.last',
    hints: ['last returns final element', 'Throws on empty list'],
    tags: ['last', 'access', 'collections'],
  },

  {
    id: 'scala-list-109',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Check List Contains',
    text: 'Check if the list contains the number 3.',
    setup: 'val numbers = List(1, 2, 3, 4, 5)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5)',
    expected: true,
    sample: 'numbers.contains(3)',
    hints: ['contains checks membership', 'Returns Boolean'],
    tags: ['contains', 'membership', 'check'],
  },

  {
    id: 'scala-list-110',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Product with FoldLeft',
    text: 'Calculate the product of all numbers using foldLeft.',
    setup: 'val numbers = List(1, 2, 3, 4)',
    setupCode: 'val numbers = List(1, 2, 3, 4)',
    expected: 24,
    sample: 'numbers.foldLeft(1)(_ * _)',
    hints: ['Start with 1 for product', 'Multiply accumulator by each element'],
    tags: ['foldLeft', 'product', 'aggregation'],
  },

  {
    id: 'scala-list-111',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Count Elements Matching',
    text: 'Count how many numbers are greater than 3.',
    setup: 'val numbers = List(1, 2, 3, 4, 5, 6)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5, 6)',
    expected: 3,
    sample: 'numbers.count(_ > 3)',
    hints: ['count takes a predicate', 'Returns number of matches'],
    tags: ['count', 'predicate', 'aggregation'],
  },

  {
    id: 'scala-list-112',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Partition by Predicate',
    text: 'Partition numbers into even and odd lists.',
    setup: 'val numbers = List(1, 2, 3, 4, 5, 6)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5, 6)',
    expected: [
      [2, 4, 6],
      [1, 3, 5],
    ],
    sample: 'val (evens, odds) = numbers.partition(_ % 2 == 0); List(evens, odds)',
    hints: ['partition splits into two lists', 'Returns tuple of lists'],
    tags: ['partition', 'split', 'predicate'],
  },

  {
    id: 'scala-list-113',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'TakeWhile Predicate',
    text: 'Take elements while they are less than 4.',
    setup: 'val numbers = List(1, 2, 3, 4, 5, 1, 2)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5, 1, 2)',
    expected: [1, 2, 3],
    sample: 'numbers.takeWhile(_ < 4)',
    hints: ['takeWhile stops at first failure', 'Different from filter'],
    tags: ['takeWhile', 'predicate', 'slice'],
  },

  {
    id: 'scala-list-114',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'DropWhile Predicate',
    text: 'Drop elements while they are less than 4.',
    setup: 'val numbers = List(1, 2, 3, 4, 5, 1, 2)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5, 1, 2)',
    expected: [4, 5, 1, 2],
    sample: 'numbers.dropWhile(_ < 4)',
    hints: ['dropWhile removes from start', 'Keeps rest after first failure'],
    tags: ['dropWhile', 'predicate', 'slice'],
  },

  {
    id: 'scala-list-115',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Zip Two Lists',
    text: 'Combine two lists into pairs.',
    setup: 'val names = List("Alice", "Bob")\nval ages = List(25, 30)',
    setupCode: 'val names = List("Alice", "Bob")\nval ages = List(25, 30)',
    expected: [
      ['Alice', 25],
      ['Bob', 30],
    ],
    sample: 'names.zip(ages)',
    hints: ['zip pairs corresponding elements', 'Truncates to shorter list'],
    tags: ['zip', 'combine', 'pairs'],
  },

  {
    id: 'scala-list-116',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'ZipWithIndex',
    text: 'Add index to each element.',
    setup: 'val letters = List("a", "b", "c")',
    setupCode: 'val letters = List("a", "b", "c")',
    expected: [
      ['a', 0],
      ['b', 1],
      ['c', 2],
    ],
    sample: 'letters.zipWithIndex',
    hints: ['zipWithIndex adds 0-based index', 'Returns List of tuples'],
    tags: ['zipWithIndex', 'index', 'pairs'],
  },

  {
    id: 'scala-list-117',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Find First Match',
    text: 'Find the first number greater than 3.',
    setup: 'val numbers = List(1, 2, 3, 4, 5)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5)',
    expected: 4,
    sample: 'numbers.find(_ > 3).getOrElse(0)',
    hints: ['find returns Option', 'Use getOrElse for default'],
    tags: ['find', 'search', 'option'],
  },

  {
    id: 'scala-list-118',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Exists Predicate',
    text: 'Check if any number is greater than 10.',
    setup: 'val numbers = List(5, 15, 3, 8)',
    setupCode: 'val numbers = List(5, 15, 3, 8)',
    expected: true,
    sample: 'numbers.exists(_ > 10)',
    hints: ['exists checks if any match', 'Short-circuits on first match'],
    tags: ['exists', 'predicate', 'check'],
  },

  {
    id: 'scala-list-119',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'ForAll Predicate',
    text: 'Check if all numbers are positive.',
    setup: 'val numbers = List(1, 2, 3, 4, 5)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5)',
    expected: true,
    sample: 'numbers.forall(_ > 0)',
    hints: ['forall checks all elements', 'Returns false on first failure'],
    tags: ['forall', 'predicate', 'check'],
  },

  {
    id: 'scala-list-120',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Distinct Elements',
    text: 'Remove duplicate elements from the list.',
    setup: 'val numbers = List(1, 2, 2, 3, 3, 3, 4)',
    setupCode: 'val numbers = List(1, 2, 2, 3, 3, 3, 4)',
    expected: [1, 2, 3, 4],
    sample: 'numbers.distinct',
    hints: ['distinct removes duplicates', 'Preserves first occurrence order'],
    tags: ['distinct', 'unique', 'duplicates'],
  },

  {
    id: 'scala-list-121',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Sorted List',
    text: 'Sort the list in ascending order.',
    setup: 'val numbers = List(5, 2, 8, 1, 9)',
    setupCode: 'val numbers = List(5, 2, 8, 1, 9)',
    expected: [1, 2, 5, 8, 9],
    sample: 'numbers.sorted',
    hints: ['sorted uses natural ordering', 'Returns new sorted list'],
    tags: ['sorted', 'order', 'collections'],
  },

  {
    id: 'scala-list-122',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Sort Descending',
    text: 'Sort the list in descending order.',
    setup: 'val numbers = List(5, 2, 8, 1, 9)',
    setupCode: 'val numbers = List(5, 2, 8, 1, 9)',
    expected: [9, 8, 5, 2, 1],
    sample: 'numbers.sorted.reverse',
    hints: ['Combine sorted with reverse', 'Or use sortWith'],
    tags: ['sorted', 'reverse', 'order'],
  },

  {
    id: 'scala-list-123',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'SortBy Property',
    text: 'Sort strings by their length.',
    setup: 'val words = List("elephant", "cat", "dog", "hi")',
    setupCode: 'val words = List("elephant", "cat", "dog", "hi")',
    expected: ['hi', 'cat', 'dog', 'elephant'],
    sample: 'words.sortBy(_.length)',
    hints: ['sortBy takes key function', 'Sorts by extracted property'],
    tags: ['sortBy', 'order', 'property'],
  },

  {
    id: 'scala-list-124',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Max Element',
    text: 'Find the maximum element in the list.',
    setup: 'val numbers = List(5, 2, 8, 1, 9)',
    setupCode: 'val numbers = List(5, 2, 8, 1, 9)',
    expected: 9,
    sample: 'numbers.max',
    hints: ['max returns largest element', 'Throws on empty list'],
    tags: ['max', 'aggregation', 'collections'],
  },

  {
    id: 'scala-list-125',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Min Element',
    text: 'Find the minimum element in the list.',
    setup: 'val numbers = List(5, 2, 8, 1, 9)',
    setupCode: 'val numbers = List(5, 2, 8, 1, 9)',
    expected: 1,
    sample: 'numbers.min',
    hints: ['min returns smallest element', 'Throws on empty list'],
    tags: ['min', 'aggregation', 'collections'],
  },

  {
    id: 'scala-list-126',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'MaxBy Property',
    text: 'Find the longest string.',
    setup: 'val words = List("cat", "elephant", "dog")',
    setupCode: 'val words = List("cat", "elephant", "dog")',
    expected: 'elephant',
    sample: 'words.maxBy(_.length)',
    hints: ['maxBy compares by property', 'Returns element with max property'],
    tags: ['maxBy', 'property', 'aggregation'],
  },

  {
    id: 'scala-list-127',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Grouped Chunks',
    text: 'Split list into chunks of size 2.',
    setup: 'val numbers = List(1, 2, 3, 4, 5, 6)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5, 6)',
    expected: [
      [1, 2],
      [3, 4],
      [5, 6],
    ],
    sample: 'numbers.grouped(2).toList',
    hints: ['grouped creates iterator of chunks', 'Convert to List'],
    tags: ['grouped', 'chunk', 'split'],
  },

  {
    id: 'scala-list-128',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Sliding Window',
    text: 'Create sliding windows of size 3.',
    setup: 'val numbers = List(1, 2, 3, 4, 5)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5)',
    expected: [
      [1, 2, 3],
      [2, 3, 4],
      [3, 4, 5],
    ],
    sample: 'numbers.sliding(3).toList',
    hints: ['sliding creates overlapping windows', 'Window moves by 1'],
    tags: ['sliding', 'window', 'iterator'],
  },

  {
    id: 'scala-list-129',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'MkString Join',
    text: 'Join list elements with comma separator.',
    setup: 'val words = List("apple", "banana", "cherry")',
    setupCode: 'val words = List("apple", "banana", "cherry")',
    expected: 'apple,banana,cherry',
    sample: 'words.mkString(",")',
    hints: ['mkString joins elements', 'Takes separator argument'],
    tags: ['mkString', 'join', 'string'],
  },

  {
    id: 'scala-list-130',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'FoldLeft Build Map',
    text: 'Build a Map counting occurrences of each element.',
    setup: 'val letters = List("a", "b", "a", "c", "b", "a")',
    setupCode: 'val letters = List("a", "b", "a", "c", "b", "a")',
    expected: { a: 3, b: 2, c: 1 },
    sample:
      'letters.foldLeft(Map.empty[String, Int])((acc, x) => acc + (x -> (acc.getOrElse(x, 0) + 1)))',
    hints: ['Use foldLeft to build Map', 'getOrElse for default count'],
    tags: ['foldLeft', 'map', 'counting'],
  },

  {
    id: 'scala-list-131',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Collect Type Filter',
    text: 'Extract only integers from a list of Any.',
    setup: 'val mixed: List[Any] = List(1, "hello", 2, true, 3)',
    setupCode: 'val mixed: List[Any] = List(1, "hello", 2, true, 3)',
    expected: [1, 2, 3],
    sample: 'mixed.collect { case i: Int => i }',
    hints: ['collect with type pattern', 'Filters and casts in one step'],
    tags: ['collect', 'type', 'filter'],
  },

  {
    id: 'scala-list-132',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'FlatMap with Option',
    text: 'Parse strings to Int and keep only valid ones.',
    setup: 'val strings = List("1", "hello", "3", "world", "5")',
    setupCode: 'val strings = List("1", "hello", "3", "world", "5")',
    expected: [1, 3, 5],
    sample: 'strings.flatMap(_.toIntOption)',
    hints: ['toIntOption returns Option[Int]', 'flatMap flattens Options'],
    tags: ['flatMap', 'option', 'parsing'],
  },

  {
    id: 'scala-list-133',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Scan Running Total',
    text: 'Calculate running totals using scanLeft.',
    setup: 'val numbers = List(1, 2, 3, 4)',
    setupCode: 'val numbers = List(1, 2, 3, 4)',
    expected: [0, 1, 3, 6, 10],
    sample: 'numbers.scanLeft(0)(_ + _)',
    hints: ['scanLeft keeps intermediate results', 'Like foldLeft but returns all steps'],
    tags: ['scanLeft', 'running', 'aggregation'],
  },

  {
    id: 'scala-list-134',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'ReduceLeft Custom',
    text: 'Find the longest string using reduceLeft.',
    setup: 'val words = List("cat", "elephant", "dog")',
    setupCode: 'val words = List("cat", "elephant", "dog")',
    expected: 'elephant',
    sample: 'words.reduceLeft((a, b) => if (a.length >= b.length) a else b)',
    hints: ['reduceLeft combines pairwise', 'Compare lengths in function'],
    tags: ['reduceLeft', 'custom', 'comparison'],
  },

  {
    id: 'scala-list-135',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Combinations',
    text: 'Generate all 2-element combinations.',
    setup: 'val numbers = List(1, 2, 3)',
    setupCode: 'val numbers = List(1, 2, 3)',
    expected: [
      [1, 2],
      [1, 3],
      [2, 3],
    ],
    sample: 'numbers.combinations(2).toList',
    hints: ['combinations generates unique subsets', 'Order does not matter'],
    tags: ['combinations', 'subset', 'iterator'],
  },

  {
    id: 'scala-list-136',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Permutations',
    text: 'Generate all permutations of the list.',
    setup: 'val numbers = List(1, 2, 3)',
    setupCode: 'val numbers = List(1, 2, 3)',
    expected: [
      [1, 2, 3],
      [1, 3, 2],
      [2, 1, 3],
      [2, 3, 1],
      [3, 1, 2],
      [3, 2, 1],
    ],
    sample: 'numbers.permutations.toList',
    hints: ['permutations generates all orderings', 'Order matters'],
    tags: ['permutations', 'ordering', 'iterator'],
  },

  {
    id: 'scala-list-137',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Span Predicate Split',
    text: 'Split list at first element not less than 4.',
    setup: 'val numbers = List(1, 2, 3, 5, 4, 1)',
    setupCode: 'val numbers = List(1, 2, 3, 5, 4, 1)',
    expected: [
      [1, 2, 3],
      [5, 4, 1],
    ],
    sample: 'val (before, after) = numbers.span(_ < 4); List(before, after)',
    hints: ['span splits at first failure', 'Like takeWhile + dropWhile'],
    tags: ['span', 'split', 'predicate'],
  },

  {
    id: 'scala-list-138',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'SplitAt Index',
    text: 'Split the list at index 3.',
    setup: 'val numbers = List(1, 2, 3, 4, 5, 6)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5, 6)',
    expected: [
      [1, 2, 3],
      [4, 5, 6],
    ],
    sample: 'val (left, right) = numbers.splitAt(3); List(left, right)',
    hints: ['splitAt divides at index', 'Returns tuple of lists'],
    tags: ['splitAt', 'split', 'index'],
  },

  {
    id: 'scala-list-139',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Collect Partial Function',
    text: 'Extract and transform Some values from Options.',
    setup: 'val options = List(Some(1), None, Some(2), None, Some(3))',
    setupCode: 'val options = List(Some(1), None, Some(2), None, Some(3))',
    expected: [2, 4, 6],
    sample: 'options.collect { case Some(n) => n * 2 }',
    hints: ['collect filters and transforms', 'Pattern match on Some'],
    tags: ['collect', 'option', 'transform'],
  },

  {
    id: 'scala-list-140',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'FoldLeft String Builder',
    text: 'Concatenate strings with separator using foldLeft.',
    setup: 'val words = List("hello", "world", "scala")',
    setupCode: 'val words = List("hello", "world", "scala")',
    expected: 'hello-world-scala',
    sample: 'words.reduceLeft(_ + "-" + _)',
    hints: ['reduceLeft for no initial value', 'Concatenate with separator'],
    tags: ['reduceLeft', 'string', 'concatenation'],
  },

  {
    id: 'scala-list-141',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Unzip Pairs',
    text: 'Separate a list of tuples into two lists.',
    setup: 'val pairs = List(("a", 1), ("b", 2), ("c", 3))',
    setupCode: 'val pairs = List(("a", 1), ("b", 2), ("c", 3))',
    expected: [
      ['a', 'b', 'c'],
      [1, 2, 3],
    ],
    sample: 'val (letters, nums) = pairs.unzip; List(letters, nums)',
    hints: ['unzip separates tuple lists', 'Returns tuple of lists'],
    tags: ['unzip', 'tuple', 'separate'],
  },

  {
    id: 'scala-list-142',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Transpose Matrix',
    text: 'Transpose a list of lists (matrix).',
    setup: 'val matrix = List(List(1, 2, 3), List(4, 5, 6))',
    setupCode: 'val matrix = List(List(1, 2, 3), List(4, 5, 6))',
    expected: [
      [1, 4],
      [2, 5],
      [3, 6],
    ],
    sample: 'matrix.transpose',
    hints: ['transpose swaps rows and columns', 'All rows must have same length'],
    tags: ['transpose', 'matrix', 'nested'],
  },

  {
    id: 'scala-list-143',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Interleave Lists',
    text: 'Interleave two lists element by element.',
    setup: 'val a = List(1, 3, 5)\nval b = List(2, 4, 6)',
    setupCode: 'val a = List(1, 3, 5)\nval b = List(2, 4, 6)',
    expected: [1, 2, 3, 4, 5, 6],
    sample: 'a.zip(b).flatMap { case (x, y) => List(x, y) }',
    hints: ['zip then flatMap pairs', 'Create list from each pair'],
    tags: ['zip', 'flatMap', 'interleave'],
  },

  {
    id: 'scala-list-144',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Group Consecutive',
    text: 'Group consecutive equal elements.',
    setup: 'val numbers = List(1, 1, 2, 2, 2, 3, 1, 1)',
    setupCode: 'val numbers = List(1, 1, 2, 2, 2, 3, 1, 1)',
    expected: [[1, 1], [2, 2, 2], [3], [1, 1]],
    sample:
      'numbers.foldRight(List.empty[List[Int]]) { (x, acc) => acc match { case (h :: t) :: rest if h == x => (x :: h :: t) :: rest; case _ => List(x) :: acc } }',
    hints: ['foldRight to build groups', 'Check if head matches'],
    tags: ['foldRight', 'group', 'consecutive'],
  },

  {
    id: 'scala-list-145',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Indices Where',
    text: 'Find all indices where value is greater than 3.',
    setup: 'val numbers = List(1, 5, 2, 6, 3, 7)',
    setupCode: 'val numbers = List(1, 5, 2, 6, 3, 7)',
    expected: [1, 3, 5],
    sample: 'numbers.zipWithIndex.collect { case (n, i) if n > 3 => i }',
    hints: ['zipWithIndex adds indices', 'collect filters and extracts'],
    tags: ['zipWithIndex', 'collect', 'indices'],
  },

  {
    id: 'scala-list-146',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Flatten Deep Nested',
    text: 'Flatten a list containing mixed elements and lists.',
    setup: 'val nested = List(1, List(2, 3), List(List(4, 5), 6))',
    setupCode: 'val nested = List(1, List(2, 3), List(List(4, 5), 6))',
    expected: [1, 2, 3, 4, 5, 6],
    sample:
      'def flatten(xs: Any): List[Any] = xs match { case Nil => Nil; case (h: List[_]) :: t => flatten(h) ::: flatten(t); case h :: t => h :: flatten(t).asInstanceOf[List[Any]]; case _ => List(xs) }; flatten(nested).asInstanceOf[List[Int]]',
    hints: ['Recursive flatten function', 'Pattern match on structure'],
    tags: ['flatten', 'recursive', 'nested'],
  },

  {
    id: 'scala-list-147',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Running Max',
    text: 'Calculate running maximum using scanLeft.',
    setup: 'val numbers = List(3, 1, 4, 1, 5, 9, 2)',
    setupCode: 'val numbers = List(3, 1, 4, 1, 5, 9, 2)',
    expected: [3, 3, 4, 4, 5, 9, 9],
    sample: 'numbers.tail.scanLeft(numbers.head)(_ max _)',
    hints: ['scanLeft with max operation', 'Start with first element'],
    tags: ['scanLeft', 'max', 'running'],
  },

  {
    id: 'scala-list-148',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'Collect with Index',
    text: 'Extract elements at even indices.',
    setup: 'val letters = List("a", "b", "c", "d", "e", "f")',
    setupCode: 'val letters = List("a", "b", "c", "d", "e", "f")',
    expected: ['a', 'c', 'e'],
    sample: 'letters.zipWithIndex.collect { case (x, i) if i % 2 == 0 => x }',
    hints: ['zipWithIndex for indices', 'collect with guard on index'],
    tags: ['collect', 'index', 'filter'],
  },

  {
    id: 'scala-list-149',
    category: 'List Operations',
    difficulty: 'hard',
    title: 'FoldLeft Running Average',
    text: 'Calculate running average as list of doubles.',
    setup: 'val numbers = List(2, 4, 6, 8)',
    setupCode: 'val numbers = List(2, 4, 6, 8)',
    expected: [2.0, 3.0, 4.0, 5.0],
    sample:
      'numbers.zipWithIndex.scanLeft((0.0, 0)) { case ((sum, _), (n, i)) => (sum + n, i + 1) }.tail.map { case (sum, count) => sum / count }',
    hints: ['Track sum and count', 'Divide to get average'],
    tags: ['scanLeft', 'average', 'running'],
  },

  // ============================================================
  // NEW PROBLEMS - Option Type (40 problems)
  // ============================================================

  {
    id: 'scala-option-100',
    category: 'Option Type',
    difficulty: 'easy',
    title: 'Create Some Value',
    text: 'Create an Option containing the number 42.',
    setup: 'val number = 42',
    setupCode: 'val number = 42',
    expected: 42,
    sample: 'Some(number).getOrElse(0)',
    hints: ['Some wraps a value in Option', 'getOrElse extracts it'],
    tags: ['some', 'option', 'create'],
  },

  {
    id: 'scala-option-101',
    category: 'Option Type',
    difficulty: 'easy',
    title: 'Handle None Default',
    text: 'Get value from None with default "unknown".',
    setup: 'val name: Option[String] = None',
    setupCode: 'val name: Option[String] = None',
    expected: 'unknown',
    sample: 'name.getOrElse("unknown")',
    hints: ['getOrElse provides default', 'Used when Option is None'],
    tags: ['getOrElse', 'none', 'default'],
  },

  {
    id: 'scala-option-102',
    category: 'Option Type',
    difficulty: 'easy',
    title: 'Map Option Value',
    text: 'Add 10 to the value inside the Option.',
    setup: 'val maybeNum: Option[Int] = Some(5)',
    setupCode: 'val maybeNum: Option[Int] = Some(5)',
    expected: 15,
    sample: 'maybeNum.map(_ + 10).getOrElse(0)',
    hints: ['map transforms inside Option', 'Preserves None if empty'],
    tags: ['map', 'transform', 'option'],
  },

  {
    id: 'scala-option-103',
    category: 'Option Type',
    difficulty: 'easy',
    title: 'Check Option Non-Empty',
    text: 'Check if the Option has a value using nonEmpty.',
    setup: 'val value: Option[Int] = Some(100)',
    setupCode: 'val value: Option[Int] = Some(100)',
    expected: true,
    sample: 'value.nonEmpty',
    hints: ['nonEmpty is opposite of isEmpty', 'Same as isDefined'],
    tags: ['nonEmpty', 'check', 'option'],
  },

  {
    id: 'scala-option-104',
    category: 'Option Type',
    difficulty: 'easy',
    title: 'Convert to List',
    text: 'Convert Option to List.',
    setup: 'val maybeValue: Option[Int] = Some(42)',
    setupCode: 'val maybeValue: Option[Int] = Some(42)',
    expected: [42],
    sample: 'maybeValue.toList',
    hints: ['toList returns List with 0 or 1 element', 'None becomes empty List'],
    tags: ['toList', 'conversion', 'option'],
  },

  {
    id: 'scala-option-105',
    category: 'Option Type',
    difficulty: 'easy',
    title: 'FlatMap Nested Option',
    text: 'Extract value from Option[Option[Int]].',
    setup: 'val nested: Option[Option[Int]] = Some(Some(10))',
    setupCode: 'val nested: Option[Option[Int]] = Some(Some(10))',
    expected: 10,
    sample: 'nested.flatten.getOrElse(0)',
    hints: ['flatten removes one layer', 'Or use flatMap(identity)'],
    tags: ['flatten', 'nested', 'option'],
  },

  {
    id: 'scala-option-106',
    category: 'Option Type',
    difficulty: 'easy',
    title: 'Fold with Default',
    text: 'Use fold to double value or return -1 if empty.',
    setup: 'val maybeNum: Option[Int] = Some(21)',
    setupCode: 'val maybeNum: Option[Int] = Some(21)',
    expected: 42,
    sample: 'maybeNum.fold(-1)(_ * 2)',
    hints: ['fold takes default and transform', 'First arg for None case'],
    tags: ['fold', 'transform', 'option'],
  },

  {
    id: 'scala-option-107',
    category: 'Option Type',
    difficulty: 'easy',
    title: 'OrElse Alternative',
    text: 'Return first Option if defined, otherwise second.',
    setup: 'val a: Option[Int] = None\nval b: Option[Int] = Some(99)',
    setupCode: 'val a: Option[Int] = None\nval b: Option[Int] = Some(99)',
    expected: 99,
    sample: 'a.orElse(b).getOrElse(0)',
    hints: ['orElse provides fallback Option', 'Chain multiple fallbacks'],
    tags: ['orElse', 'fallback', 'option'],
  },

  {
    id: 'scala-option-108',
    category: 'Option Type',
    difficulty: 'easy',
    title: 'Filter Option',
    text: 'Keep value only if it is even.',
    setup: 'val maybeNum: Option[Int] = Some(4)',
    setupCode: 'val maybeNum: Option[Int] = Some(4)',
    expected: 4,
    sample: 'maybeNum.filter(_ % 2 == 0).getOrElse(0)',
    hints: ['filter returns None if predicate fails', 'Keeps value if true'],
    tags: ['filter', 'predicate', 'option'],
  },

  {
    id: 'scala-option-109',
    category: 'Option Type',
    difficulty: 'easy',
    title: 'Filter to None',
    text: 'Filter Option to None when predicate fails.',
    setup: 'val maybeNum: Option[Int] = Some(3)',
    setupCode: 'val maybeNum: Option[Int] = Some(3)',
    expected: 0,
    sample: 'maybeNum.filter(_ % 2 == 0).getOrElse(0)',
    hints: ['filter returns None if false', 'Default returned for None'],
    tags: ['filter', 'none', 'option'],
  },

  {
    id: 'scala-option-110',
    category: 'Option Type',
    difficulty: 'medium',
    title: 'FlatMap Chain',
    text: 'Chain two Option operations with flatMap.',
    setup:
      'def half(n: Int): Option[Int] = if (n % 2 == 0) Some(n / 2) else None\nval start: Option[Int] = Some(8)',
    setupCode:
      'def half(n: Int): Option[Int] = if (n % 2 == 0) Some(n / 2) else None\nval start: Option[Int] = Some(8)',
    expected: 2,
    sample: 'start.flatMap(half).flatMap(half).getOrElse(0)',
    hints: ['flatMap chains Option operations', 'Stops at first None'],
    tags: ['flatMap', 'chain', 'option'],
  },

  {
    id: 'scala-option-111',
    category: 'Option Type',
    difficulty: 'medium',
    title: 'Option Contains',
    text: 'Check if Option contains specific value.',
    setup: 'val maybeStr: Option[String] = Some("hello")',
    setupCode: 'val maybeStr: Option[String] = Some("hello")',
    expected: true,
    sample: 'maybeStr.contains("hello")',
    hints: ['contains checks equality', 'False for None'],
    tags: ['contains', 'equality', 'option'],
  },

  {
    id: 'scala-option-112',
    category: 'Option Type',
    difficulty: 'medium',
    title: 'Option Exists',
    text: 'Check if Option value satisfies predicate.',
    setup: 'val maybeNum: Option[Int] = Some(15)',
    setupCode: 'val maybeNum: Option[Int] = Some(15)',
    expected: true,
    sample: 'maybeNum.exists(_ > 10)',
    hints: ['exists tests predicate', 'False for None'],
    tags: ['exists', 'predicate', 'option'],
  },

  {
    id: 'scala-option-113',
    category: 'Option Type',
    difficulty: 'medium',
    title: 'Option ForAll',
    text: 'Check if Option value (if any) is positive.',
    setup: 'val maybeNum: Option[Int] = None',
    setupCode: 'val maybeNum: Option[Int] = None',
    expected: true,
    sample: 'maybeNum.forall(_ > 0)',
    hints: ['forall is true for None', 'Vacuous truth'],
    tags: ['forall', 'predicate', 'option'],
  },

  {
    id: 'scala-option-114',
    category: 'Option Type',
    difficulty: 'medium',
    title: 'Collect Partial Function',
    text: 'Use collect to transform and filter Option.',
    setup: 'val maybeNum: Option[Int] = Some(10)',
    setupCode: 'val maybeNum: Option[Int] = Some(10)',
    expected: 20,
    sample: 'maybeNum.collect { case n if n > 5 => n * 2 }.getOrElse(0)',
    hints: ['collect applies partial function', 'None if not defined'],
    tags: ['collect', 'partial', 'option'],
  },

  {
    id: 'scala-option-115',
    category: 'Option Type',
    difficulty: 'medium',
    title: 'Option Zip',
    text: 'Combine two Options into Option of tuple.',
    setup: 'val a: Option[Int] = Some(1)\nval b: Option[String] = Some("one")',
    setupCode: 'val a: Option[Int] = Some(1)\nval b: Option[String] = Some("one")',
    expected: [1, 'one'],
    sample: 'a.zip(b).map { case (n, s) => List(n, s) }.getOrElse(Nil)',
    hints: ['zip combines Options', 'None if either is None'],
    tags: ['zip', 'combine', 'option'],
  },

  {
    id: 'scala-option-116',
    category: 'Option Type',
    difficulty: 'medium',
    title: 'Option Unless',
    text: 'Create Option only when condition is false.',
    setup: 'val value = 42\nval isEmpty = false',
    setupCode: 'val value = 42\nval isEmpty = false',
    expected: 42,
    sample: 'Option.unless(isEmpty)(value).getOrElse(0)',
    hints: ['Option.unless creates Some when false', 'None when true'],
    tags: ['unless', 'conditional', 'option'],
  },

  {
    id: 'scala-option-117',
    category: 'Option Type',
    difficulty: 'medium',
    title: 'Option When',
    text: 'Create Option only when condition is true.',
    setup: 'val value = 42\nval isValid = true',
    setupCode: 'val value = 42\nval isValid = true',
    expected: 42,
    sample: 'Option.when(isValid)(value).getOrElse(0)',
    hints: ['Option.when creates Some when true', 'None when false'],
    tags: ['when', 'conditional', 'option'],
  },

  {
    id: 'scala-option-118',
    category: 'Option Type',
    difficulty: 'medium',
    title: 'Map with Function',
    text: 'Apply string length function to Option.',
    setup: 'val maybeStr: Option[String] = Some("hello")',
    setupCode: 'val maybeStr: Option[String] = Some("hello")',
    expected: 5,
    sample: 'maybeStr.map(_.length).getOrElse(0)',
    hints: ['map applies function inside', 'Returns Option of result'],
    tags: ['map', 'function', 'option'],
  },

  {
    id: 'scala-option-119',
    category: 'Option Type',
    difficulty: 'medium',
    title: 'Option FilterNot',
    text: 'Keep value only if it does NOT match predicate.',
    setup: 'val maybeNum: Option[Int] = Some(5)',
    setupCode: 'val maybeNum: Option[Int] = Some(5)',
    expected: 5,
    sample: 'maybeNum.filterNot(_ > 10).getOrElse(0)',
    hints: ['filterNot is negated filter', 'Keeps when predicate is false'],
    tags: ['filterNot', 'predicate', 'option'],
  },

  {
    id: 'scala-option-120',
    category: 'Option Type',
    difficulty: 'hard',
    title: 'For Comprehension Three Options',
    text: 'Combine three Options using for-comprehension.',
    setup:
      'val a: Option[Int] = Some(1)\nval b: Option[Int] = Some(2)\nval c: Option[Int] = Some(3)',
    setupCode:
      'val a: Option[Int] = Some(1)\nval b: Option[Int] = Some(2)\nval c: Option[Int] = Some(3)',
    expected: 6,
    sample: '(for { x <- a; y <- b; z <- c } yield x + y + z).getOrElse(0)',
    hints: ['for-comprehension chains flatMap', 'yield produces result'],
    tags: ['for-comprehension', 'combine', 'option'],
  },

  {
    id: 'scala-option-121',
    category: 'Option Type',
    difficulty: 'hard',
    title: 'Sequence Options',
    text: 'Convert List[Option[Int]] to Option[List[Int]].',
    setup: 'val options = List(Some(1), Some(2), Some(3))',
    setupCode: 'val options = List(Some(1), Some(2), Some(3))',
    expected: [1, 2, 3],
    sample: 'Option.sequence(options).getOrElse(Nil)',
    hints: ['sequence inverts List and Option', 'None if any is None'],
    tags: ['sequence', 'invert', 'option'],
  },

  {
    id: 'scala-option-122',
    category: 'Option Type',
    difficulty: 'hard',
    title: 'Traverse with Option',
    text: 'Parse list of strings and collect results.',
    setup: 'val strings = List("1", "2", "3")',
    setupCode: 'val strings = List("1", "2", "3")',
    expected: [1, 2, 3],
    sample:
      'strings.map(_.toIntOption).foldLeft(Option(List.empty[Int])) { (acc, opt) => for { list <- acc; n <- opt } yield list :+ n }.getOrElse(Nil)',
    hints: ['Combine traverse pattern', 'Accumulate in Option'],
    tags: ['traverse', 'parsing', 'option'],
  },

  {
    id: 'scala-option-123',
    category: 'Option Type',
    difficulty: 'hard',
    title: 'Option with Guard',
    text: 'Use for-comprehension with guard condition.',
    setup: 'val maybeNum: Option[Int] = Some(10)',
    setupCode: 'val maybeNum: Option[Int] = Some(10)',
    expected: 20,
    sample: '(for { n <- maybeNum if n > 5 } yield n * 2).getOrElse(0)',
    hints: ['if guard filters in for', 'Returns None if guard fails'],
    tags: ['for-comprehension', 'guard', 'option'],
  },

  {
    id: 'scala-option-124',
    category: 'Option Type',
    difficulty: 'hard',
    title: 'Option Tap Side Effect',
    text: 'Execute side effect if Option has value.',
    setup: 'var result = 0\nval maybeNum: Option[Int] = Some(42)',
    setupCode: 'var result = 0\nval maybeNum: Option[Int] = Some(42)',
    expected: 42,
    sample: 'maybeNum.foreach(n => result = n); result',
    hints: ['foreach executes side effect', 'Does nothing for None'],
    tags: ['foreach', 'side-effect', 'option'],
  },

  {
    id: 'scala-option-125',
    category: 'Option Type',
    difficulty: 'hard',
    title: 'Option Fold Complex',
    text: 'Fold Option to compute different results for Some/None.',
    setup: 'val maybeStr: Option[String] = Some("hello")',
    setupCode: 'val maybeStr: Option[String] = Some("hello")',
    expected: 'HELLO: 5',
    sample: 'maybeStr.fold("empty")(s => s"${s.toUpperCase}: ${s.length}")',
    hints: ['fold handles both cases', 'None returns first argument'],
    tags: ['fold', 'transform', 'option'],
  },

  {
    id: 'scala-option-126',
    category: 'Option Type',
    difficulty: 'hard',
    title: 'Chain Multiple OrElse',
    text: 'Chain multiple fallback Options.',
    setup: 'val a: Option[Int] = None\nval b: Option[Int] = None\nval c: Option[Int] = Some(42)',
    setupCode:
      'val a: Option[Int] = None\nval b: Option[Int] = None\nval c: Option[Int] = Some(42)',
    expected: 42,
    sample: 'a.orElse(b).orElse(c).getOrElse(0)',
    hints: ['Chain orElse for priority', 'First Some wins'],
    tags: ['orElse', 'chain', 'option'],
  },

  {
    id: 'scala-option-127',
    category: 'Option Type',
    difficulty: 'hard',
    title: 'Option Match Pattern',
    text: 'Pattern match on Option with type extraction.',
    setup: 'val maybeValue: Option[Any] = Some("hello")',
    setupCode: 'val maybeValue: Option[Any] = Some("hello")',
    expected: 'string: hello',
    sample:
      'maybeValue match { case Some(s: String) => s"string: $s"; case Some(n: Int) => s"int: $n"; case _ => "unknown" }',
    hints: ['Combine Option and type pattern', 'Match specific types inside'],
    tags: ['pattern-match', 'type', 'option'],
  },

  {
    id: 'scala-option-128',
    category: 'Option Type',
    difficulty: 'hard',
    title: 'Nested Option FlatMap',
    text: 'Navigate nested structure with flatMap.',
    setup:
      'case class Address(city: Option[String])\ncase class Person(address: Option[Address])\nval person = Person(Some(Address(Some("NYC"))))',
    setupCode:
      'case class Address(city: Option[String])\ncase class Person(address: Option[Address])\nval person = Person(Some(Address(Some("NYC"))))',
    expected: 'NYC',
    sample: 'person.address.flatMap(_.city).getOrElse("unknown")',
    hints: ['flatMap chains through Options', 'Safe navigation pattern'],
    tags: ['flatMap', 'nested', 'option'],
  },

  {
    id: 'scala-option-129',
    category: 'Option Type',
    difficulty: 'hard',
    title: 'Option ToRight/ToLeft',
    text: 'Convert Option to Either using toRight.',
    setup: 'val maybeValue: Option[Int] = Some(42)',
    setupCode: 'val maybeValue: Option[Int] = Some(42)',
    expected: 42,
    sample: 'maybeValue.toRight("error").getOrElse(0)',
    hints: ['toRight creates Right from Some', 'Left from None with given value'],
    tags: ['toRight', 'either', 'option'],
  },

  // ============================================================
  // NEW PROBLEMS - Either Type (30 problems)
  // ============================================================

  {
    id: 'scala-either-100',
    category: 'Either Type',
    difficulty: 'easy',
    title: 'Create Right Value',
    text: 'Create a Right containing the number 42.',
    setup: 'val value = 42',
    setupCode: 'val value = 42',
    expected: 42,
    sample: 'Right(value).getOrElse(0)',
    hints: ['Right wraps success value', 'getOrElse extracts from Right'],
    tags: ['right', 'create', 'either'],
  },

  {
    id: 'scala-either-101',
    category: 'Either Type',
    difficulty: 'easy',
    title: 'Create Left Value',
    text: 'Create a Left containing an error message.',
    setup: 'val error = "not found"',
    setupCode: 'val error = "not found"',
    expected: 'not found',
    sample: 'Left(error).left.getOrElse("")',
    hints: ['Left wraps error value', 'Use .left to access'],
    tags: ['left', 'create', 'either'],
  },

  {
    id: 'scala-either-102',
    category: 'Either Type',
    difficulty: 'easy',
    title: 'Map Right Value',
    text: 'Double the value inside Right.',
    setup: 'val result: Either[String, Int] = Right(21)',
    setupCode: 'val result: Either[String, Int] = Right(21)',
    expected: 42,
    sample: 'result.map(_ * 2).getOrElse(0)',
    hints: ['map transforms Right value', 'Left unchanged'],
    tags: ['map', 'transform', 'either'],
  },

  {
    id: 'scala-either-103',
    category: 'Either Type',
    difficulty: 'easy',
    title: 'Check isRight',
    text: 'Check if Either is a Right value.',
    setup: 'val result: Either[String, Int] = Right(42)',
    setupCode: 'val result: Either[String, Int] = Right(42)',
    expected: true,
    sample: 'result.isRight',
    hints: ['isRight returns Boolean', 'True for Right values'],
    tags: ['isRight', 'check', 'either'],
  },

  {
    id: 'scala-either-104',
    category: 'Either Type',
    difficulty: 'easy',
    title: 'Check isLeft',
    text: 'Check if Either is a Left value.',
    setup: 'val result: Either[String, Int] = Left("error")',
    setupCode: 'val result: Either[String, Int] = Left("error")',
    expected: true,
    sample: 'result.isLeft',
    hints: ['isLeft returns Boolean', 'True for Left values'],
    tags: ['isLeft', 'check', 'either'],
  },

  {
    id: 'scala-either-105',
    category: 'Either Type',
    difficulty: 'easy',
    title: 'Fold Either',
    text: 'Use fold to handle both Left and Right cases.',
    setup: 'val result: Either[String, Int] = Right(42)',
    setupCode: 'val result: Either[String, Int] = Right(42)',
    expected: '42',
    sample: 'result.fold(err => s"Error: $err", n => n.toString)',
    hints: ['fold handles both cases', 'First function for Left'],
    tags: ['fold', 'handle', 'either'],
  },

  {
    id: 'scala-either-106',
    category: 'Either Type',
    difficulty: 'easy',
    title: 'GetOrElse Default',
    text: 'Extract Right value or return default.',
    setup: 'val result: Either[String, Int] = Left("error")',
    setupCode: 'val result: Either[String, Int] = Left("error")',
    expected: -1,
    sample: 'result.getOrElse(-1)',
    hints: ['getOrElse returns default for Left', 'Safe extraction'],
    tags: ['getOrElse', 'default', 'either'],
  },

  {
    id: 'scala-either-107',
    category: 'Either Type',
    difficulty: 'easy',
    title: 'Convert to Option',
    text: 'Convert Right to Some and Left to None.',
    setup: 'val result: Either[String, Int] = Right(42)',
    setupCode: 'val result: Either[String, Int] = Right(42)',
    expected: 42,
    sample: 'result.toOption.getOrElse(0)',
    hints: ['toOption loses error info', 'Right becomes Some'],
    tags: ['toOption', 'convert', 'either'],
  },

  {
    id: 'scala-either-108',
    category: 'Either Type',
    difficulty: 'medium',
    title: 'FlatMap Chain',
    text: 'Chain Either operations with flatMap.',
    setup:
      'def divide(a: Int, b: Int): Either[String, Int] = if (b == 0) Left("div by zero") else Right(a / b)\nval a = 100\nval b = 2\nval c = 5',
    setupCode:
      'def divide(a: Int, b: Int): Either[String, Int] = if (b == 0) Left("div by zero") else Right(a / b)\nval a = 100\nval b = 2\nval c = 5',
    expected: 10,
    sample: 'divide(a, b).flatMap(r => divide(r, c)).getOrElse(0)',
    hints: ['flatMap chains operations', 'Stops at first Left'],
    tags: ['flatMap', 'chain', 'either'],
  },

  {
    id: 'scala-either-109',
    category: 'Either Type',
    difficulty: 'medium',
    title: 'Left Map',
    text: 'Transform the Left value.',
    setup: 'val result: Either[String, Int] = Left("error")',
    setupCode: 'val result: Either[String, Int] = Left("error")',
    expected: 'ERROR',
    sample: 'result.left.map(_.toUpperCase).left.getOrElse("")',
    hints: ['left.map transforms Left', 'Right unchanged'],
    tags: ['left', 'map', 'either'],
  },

  {
    id: 'scala-either-110',
    category: 'Either Type',
    difficulty: 'medium',
    title: 'Either Swap',
    text: 'Swap Left and Right.',
    setup: 'val result: Either[String, Int] = Right(42)',
    setupCode: 'val result: Either[String, Int] = Right(42)',
    expected: 42,
    sample: 'result.swap.left.getOrElse(0)',
    hints: ['swap exchanges Left and Right', 'Useful for left-biased ops'],
    tags: ['swap', 'convert', 'either'],
  },

  {
    id: 'scala-either-111',
    category: 'Either Type',
    difficulty: 'medium',
    title: 'For Comprehension',
    text: 'Use for-comprehension with Either.',
    setup: 'val a: Either[String, Int] = Right(10)\nval b: Either[String, Int] = Right(20)',
    setupCode: 'val a: Either[String, Int] = Right(10)\nval b: Either[String, Int] = Right(20)',
    expected: 30,
    sample: '(for { x <- a; y <- b } yield x + y).getOrElse(0)',
    hints: ['for-comprehension on Either', 'Right-biased in Scala 2.12+'],
    tags: ['for-comprehension', 'combine', 'either'],
  },

  {
    id: 'scala-either-112',
    category: 'Either Type',
    difficulty: 'medium',
    title: 'Either Contains',
    text: 'Check if Right contains specific value.',
    setup: 'val result: Either[String, Int] = Right(42)',
    setupCode: 'val result: Either[String, Int] = Right(42)',
    expected: true,
    sample: 'result.contains(42)',
    hints: ['contains checks Right value', 'False for Left'],
    tags: ['contains', 'check', 'either'],
  },

  {
    id: 'scala-either-113',
    category: 'Either Type',
    difficulty: 'medium',
    title: 'Either Exists',
    text: 'Check if Right value satisfies predicate.',
    setup: 'val result: Either[String, Int] = Right(50)',
    setupCode: 'val result: Either[String, Int] = Right(50)',
    expected: true,
    sample: 'result.exists(_ > 25)',
    hints: ['exists tests Right value', 'False for Left'],
    tags: ['exists', 'predicate', 'either'],
  },

  {
    id: 'scala-either-114',
    category: 'Either Type',
    difficulty: 'medium',
    title: 'Either FilterOrElse',
    text: 'Filter Right with fallback to Left.',
    setup: 'val result: Either[String, Int] = Right(5)',
    setupCode: 'val result: Either[String, Int] = Right(5)',
    expected: 'too small',
    sample: 'result.filterOrElse(_ > 10, "too small").fold(identity, _.toString)',
    hints: ['filterOrElse creates Left if false', 'Second arg is Left value'],
    tags: ['filterOrElse', 'filter', 'either'],
  },

  {
    id: 'scala-either-115',
    category: 'Either Type',
    difficulty: 'medium',
    title: 'OrElse Fallback',
    text: 'Provide fallback Either when Left.',
    setup: 'val a: Either[String, Int] = Left("error")\nval b: Either[String, Int] = Right(99)',
    setupCode: 'val a: Either[String, Int] = Left("error")\nval b: Either[String, Int] = Right(99)',
    expected: 99,
    sample: 'a.orElse(b).getOrElse(0)',
    hints: ['orElse provides fallback', 'Only used when Left'],
    tags: ['orElse', 'fallback', 'either'],
  },

  {
    id: 'scala-either-116',
    category: 'Either Type',
    difficulty: 'hard',
    title: 'Sequence Either List',
    text: 'Convert List[Either] to Either[List].',
    setup: 'val results: List[Either[String, Int]] = List(Right(1), Right(2), Right(3))',
    setupCode: 'val results: List[Either[String, Int]] = List(Right(1), Right(2), Right(3))',
    expected: [1, 2, 3],
    sample:
      'results.foldRight(Right(Nil): Either[String, List[Int]]) { (e, acc) => for { x <- e; xs <- acc } yield x :: xs }.getOrElse(Nil)',
    hints: ['Sequence pattern with foldRight', 'Build list in Either'],
    tags: ['sequence', 'fold', 'either'],
  },

  {
    id: 'scala-either-117',
    category: 'Either Type',
    difficulty: 'hard',
    title: 'Bimap Transform Both',
    text: 'Transform both Left and Right values.',
    setup: 'val result: Either[Int, String] = Right("hello")',
    setupCode: 'val result: Either[Int, String] = Right("hello")',
    expected: 5,
    sample: 'result.map(_.length).left.map(_ * 2).getOrElse(0)',
    hints: ['Chain map and left.map', 'Transform both sides'],
    tags: ['bimap', 'transform', 'either'],
  },

  {
    id: 'scala-either-118',
    category: 'Either Type',
    difficulty: 'hard',
    title: 'Merge Either',
    text: 'Merge Either when both types are same.',
    setup: 'val result: Either[String, String] = Right("success")',
    setupCode: 'val result: Either[String, String] = Right("success")',
    expected: 'success',
    sample: 'result.merge',
    hints: ['merge extracts when types match', 'Works for Either[A, A]'],
    tags: ['merge', 'extract', 'either'],
  },

  {
    id: 'scala-either-119',
    category: 'Either Type',
    difficulty: 'hard',
    title: 'Nested For Comprehension',
    text: 'Chain multiple Either operations.',
    setup:
      'def parse(s: String): Either[String, Int] = s.toIntOption.toRight("invalid")\ndef validate(n: Int): Either[String, Int] = if (n > 0) Right(n) else Left("negative")\ndef double(n: Int): Either[String, Int] = Right(n * 2)',
    setupCode:
      'def parse(s: String): Either[String, Int] = s.toIntOption.toRight("invalid")\ndef validate(n: Int): Either[String, Int] = if (n > 0) Right(n) else Left("negative")\ndef double(n: Int): Either[String, Int] = Right(n * 2)',
    expected: 42,
    sample: '(for { n <- parse("21"); v <- validate(n); d <- double(v) } yield d).getOrElse(0)',
    hints: ['Chain with for-comprehension', 'Each step can fail'],
    tags: ['for-comprehension', 'chain', 'either'],
  },

  {
    id: 'scala-either-120',
    category: 'Either Type',
    difficulty: 'hard',
    title: 'Either Pattern Match',
    text: 'Pattern match on Either with nested extraction.',
    setup: 'val result: Either[String, (Int, String)] = Right((42, "answer"))',
    setupCode: 'val result: Either[String, (Int, String)] = Right((42, "answer"))',
    expected: 'answer: 42',
    sample: 'result match { case Right((n, s)) => s"$s: $n"; case Left(e) => s"Error: $e" }',
    hints: ['Pattern match extracts values', 'Destructure tuple inside'],
    tags: ['pattern-match', 'destructure', 'either'],
  },

  {
    id: 'scala-either-121',
    category: 'Either Type',
    difficulty: 'hard',
    title: 'Recover from Left',
    text: 'Recover from specific error conditions.',
    setup: 'val result: Either[String, Int] = Left("not found")',
    setupCode: 'val result: Either[String, Int] = Left("not found")',
    expected: -1,
    sample: 'result.left.flatMap { case "not found" => Right(-1); case e => Left(e) }.getOrElse(0)',
    hints: ['Use left.flatMap to recover', 'Match specific errors'],
    tags: ['recover', 'error', 'either'],
  },

  {
    id: 'scala-either-122',
    category: 'Either Type',
    difficulty: 'hard',
    title: 'Either JoinRight',
    text: 'Flatten nested Either[A, Either[A, B]].',
    setup: 'val nested: Either[String, Either[String, Int]] = Right(Right(42))',
    setupCode: 'val nested: Either[String, Either[String, Int]] = Right(Right(42))',
    expected: 42,
    sample: 'nested.flatten.getOrElse(0)',
    hints: ['flatten removes nesting', 'Also called joinRight'],
    tags: ['flatten', 'nested', 'either'],
  },

  {
    id: 'scala-either-123',
    category: 'Either Type',
    difficulty: 'hard',
    title: 'Combine Either Results',
    text: 'Combine two Either results with function.',
    setup: 'val a: Either[String, Int] = Right(10)\nval b: Either[String, Int] = Right(20)',
    setupCode: 'val a: Either[String, Int] = Right(10)\nval b: Either[String, Int] = Right(20)',
    expected: 200,
    sample: 'a.flatMap(x => b.map(y => x * y)).getOrElse(0)',
    hints: ['flatMap and map to combine', 'Applicative pattern'],
    tags: ['combine', 'applicative', 'either'],
  },

  // ============================================================
  // NEW PROBLEMS - Try Type (20 problems)
  // ============================================================

  {
    id: 'scala-try-100',
    category: 'Try Type',
    difficulty: 'easy',
    title: 'Create Success',
    text: 'Create a Success containing a value.',
    setup: 'import scala.util.{Try, Success, Failure}\nval value = 42',
    setupCode: 'import scala.util.{Try, Success, Failure}\nval value = 42',
    expected: 42,
    sample: 'Success(value).getOrElse(0)',
    hints: ['Success wraps successful result', 'Part of Try type'],
    tags: ['success', 'create', 'try'],
  },

  {
    id: 'scala-try-101',
    category: 'Try Type',
    difficulty: 'easy',
    title: 'Try Division',
    text: 'Use Try to safely divide numbers.',
    setup: 'import scala.util.Try\nval a = 10\nval b = 2',
    setupCode: 'import scala.util.Try\nval a = 10\nval b = 2',
    expected: 5,
    sample: 'Try(a / b).getOrElse(0)',
    hints: ['Try catches exceptions', 'getOrElse for default'],
    tags: ['try', 'safe', 'division'],
  },

  {
    id: 'scala-try-102',
    category: 'Try Type',
    difficulty: 'easy',
    title: 'Map Try Value',
    text: 'Transform Success value with map.',
    setup: 'import scala.util.Try\nval result = Try(21)',
    setupCode: 'import scala.util.Try\nval result = Try(21)',
    expected: 42,
    sample: 'result.map(_ * 2).getOrElse(0)',
    hints: ['map transforms Success', 'Failure unchanged'],
    tags: ['map', 'transform', 'try'],
  },

  {
    id: 'scala-try-103',
    category: 'Try Type',
    difficulty: 'easy',
    title: 'Check isSuccess',
    text: 'Check if Try is a Success.',
    setup: 'import scala.util.Try\nval result = Try(42)',
    setupCode: 'import scala.util.Try\nval result = Try(42)',
    expected: true,
    sample: 'result.isSuccess',
    hints: ['isSuccess returns Boolean', 'True for Success'],
    tags: ['isSuccess', 'check', 'try'],
  },

  {
    id: 'scala-try-104',
    category: 'Try Type',
    difficulty: 'easy',
    title: 'Check isFailure',
    text: 'Check if Try is a Failure.',
    setup: 'import scala.util.Try\nval result = Try(1 / 0)',
    setupCode: 'import scala.util.Try\nval result = Try(1 / 0)',
    expected: true,
    sample: 'result.isFailure',
    hints: ['isFailure returns Boolean', 'True for Failure'],
    tags: ['isFailure', 'check', 'try'],
  },

  {
    id: 'scala-try-105',
    category: 'Try Type',
    difficulty: 'easy',
    title: 'Convert to Option',
    text: 'Convert Try to Option.',
    setup: 'import scala.util.Try\nval result = Try(42)',
    setupCode: 'import scala.util.Try\nval result = Try(42)',
    expected: 42,
    sample: 'result.toOption.getOrElse(0)',
    hints: ['toOption loses exception info', 'Success becomes Some'],
    tags: ['toOption', 'convert', 'try'],
  },

  {
    id: 'scala-try-106',
    category: 'Try Type',
    difficulty: 'medium',
    title: 'Recover from Failure',
    text: 'Recover from exception with default value.',
    setup: 'import scala.util.Try\nval result = Try(1 / 0)',
    setupCode: 'import scala.util.Try\nval result = Try(1 / 0)',
    expected: -1,
    sample: 'result.recover { case _: ArithmeticException => -1 }.getOrElse(0)',
    hints: ['recover handles specific exceptions', 'Partial function syntax'],
    tags: ['recover', 'exception', 'try'],
  },

  {
    id: 'scala-try-107',
    category: 'Try Type',
    difficulty: 'medium',
    title: 'FlatMap Chain',
    text: 'Chain Try operations with flatMap.',
    setup:
      'import scala.util.Try\ndef parse(s: String) = Try(s.toInt)\ndef double(n: Int) = Try(n * 2)',
    setupCode:
      'import scala.util.Try\ndef parse(s: String) = Try(s.toInt)\ndef double(n: Int) = Try(n * 2)',
    expected: 42,
    sample: 'parse("21").flatMap(double).getOrElse(0)',
    hints: ['flatMap chains Try operations', 'Stops at first Failure'],
    tags: ['flatMap', 'chain', 'try'],
  },

  {
    id: 'scala-try-108',
    category: 'Try Type',
    difficulty: 'medium',
    title: 'For Comprehension',
    text: 'Use for-comprehension with Try.',
    setup: 'import scala.util.Try\nval a = Try(10)\nval b = Try(5)',
    setupCode: 'import scala.util.Try\nval a = Try(10)\nval b = Try(5)',
    expected: 2,
    sample: '(for { x <- a; y <- b } yield x / y).getOrElse(0)',
    hints: ['for-comprehension on Try', 'Chains flatMap calls'],
    tags: ['for-comprehension', 'combine', 'try'],
  },

  {
    id: 'scala-try-109',
    category: 'Try Type',
    difficulty: 'medium',
    title: 'RecoverWith Alternative',
    text: 'Recover with alternative Try.',
    setup: 'import scala.util.Try\nval primary = Try(1 / 0)\nval fallback = Try(42)',
    setupCode: 'import scala.util.Try\nval primary = Try(1 / 0)\nval fallback = Try(42)',
    expected: 42,
    sample: 'primary.recoverWith { case _ => fallback }.getOrElse(0)',
    hints: ['recoverWith returns Try', 'Fallback can also fail'],
    tags: ['recoverWith', 'fallback', 'try'],
  },

  {
    id: 'scala-try-110',
    category: 'Try Type',
    difficulty: 'medium',
    title: 'Filter Try',
    text: 'Filter Try value with predicate.',
    setup: 'import scala.util.Try\nval result = Try(42)',
    setupCode: 'import scala.util.Try\nval result = Try(42)',
    expected: 42,
    sample: 'result.filter(_ > 10).getOrElse(0)',
    hints: ['filter creates Failure if false', 'NoSuchElementException'],
    tags: ['filter', 'predicate', 'try'],
  },

  {
    id: 'scala-try-111',
    category: 'Try Type',
    difficulty: 'medium',
    title: 'Fold Try',
    text: 'Fold Try to handle both cases.',
    setup: 'import scala.util.Try\nval result = Try(42)',
    setupCode: 'import scala.util.Try\nval result = Try(42)',
    expected: 'Value: 42',
    sample: 'result.fold(e => s"Error: ${e.getMessage}", v => s"Value: $v")',
    hints: ['fold handles Success and Failure', 'First for Failure'],
    tags: ['fold', 'handle', 'try'],
  },

  {
    id: 'scala-try-112',
    category: 'Try Type',
    difficulty: 'medium',
    title: 'Convert to Either',
    text: 'Convert Try to Either.',
    setup: 'import scala.util.Try\nval result = Try(42)',
    setupCode: 'import scala.util.Try\nval result = Try(42)',
    expected: 42,
    sample: 'result.toEither.getOrElse(0)',
    hints: ['toEither converts Try', 'Failure becomes Left'],
    tags: ['toEither', 'convert', 'try'],
  },

  {
    id: 'scala-try-113',
    category: 'Try Type',
    difficulty: 'hard',
    title: 'Sequence Try List',
    text: 'Convert List[Try] to Try[List].',
    setup: 'import scala.util.{Try, Success}\nval results = List(Try(1), Try(2), Try(3))',
    setupCode: 'import scala.util.{Try, Success}\nval results = List(Try(1), Try(2), Try(3))',
    expected: [1, 2, 3],
    sample:
      'results.foldRight(Success(Nil): Try[List[Int]]) { (t, acc) => for { x <- t; xs <- acc } yield x :: xs }.getOrElse(Nil)',
    hints: ['Sequence pattern with foldRight', 'Build list in Try'],
    tags: ['sequence', 'fold', 'try'],
  },

  {
    id: 'scala-try-114',
    category: 'Try Type',
    difficulty: 'hard',
    title: 'Transform Both Cases',
    text: 'Transform both Success and Failure.',
    setup: 'import scala.util.{Try, Success, Failure}\nval result = Try(42)',
    setupCode: 'import scala.util.{Try, Success, Failure}\nval result = Try(42)',
    expected: 84,
    sample: 'result.transform(v => Success(v * 2), e => Success(-1)).getOrElse(0)',
    hints: ['transform handles both cases', 'Returns new Try'],
    tags: ['transform', 'both', 'try'],
  },

  {
    id: 'scala-try-115',
    category: 'Try Type',
    difficulty: 'hard',
    title: 'Collect Partial',
    text: 'Use collect with partial function.',
    setup: 'import scala.util.Try\nval result = Try(10)',
    setupCode: 'import scala.util.Try\nval result = Try(10)',
    expected: 20,
    sample: 'result.collect { case n if n > 5 => n * 2 }.getOrElse(0)',
    hints: ['collect filters and transforms', 'Failure if not defined'],
    tags: ['collect', 'partial', 'try'],
  },

  {
    id: 'scala-try-116',
    category: 'Try Type',
    difficulty: 'hard',
    title: 'Get Exception',
    text: 'Extract exception from Failure.',
    setup:
      'import scala.util.{Try, Failure}\nval result: Try[Int] = Failure(new RuntimeException("test error"))',
    setupCode:
      'import scala.util.{Try, Failure}\nval result: Try[Int] = Failure(new RuntimeException("test error"))',
    expected: 'test error',
    sample: 'result.failed.map(_.getMessage).getOrElse("no error")',
    hints: ['failed inverts Try', 'Success contains exception'],
    tags: ['failed', 'exception', 'try'],
  },

  {
    id: 'scala-try-117',
    category: 'Try Type',
    difficulty: 'hard',
    title: 'Nested Try Flatten',
    text: 'Flatten nested Try[Try[A]].',
    setup: 'import scala.util.Try\nval nested = Try(Try(42))',
    setupCode: 'import scala.util.Try\nval nested = Try(Try(42))',
    expected: 42,
    sample: 'nested.flatten.getOrElse(0)',
    hints: ['flatten removes nesting', 'Outer Failure propagates'],
    tags: ['flatten', 'nested', 'try'],
  },

  {
    id: 'scala-try-118',
    category: 'Try Type',
    difficulty: 'hard',
    title: 'OrElse Chain',
    text: 'Chain multiple Try fallbacks.',
    setup: 'import scala.util.Try\nval a = Try(1 / 0)\nval b = Try("x".toInt)\nval c = Try(42)',
    setupCode: 'import scala.util.Try\nval a = Try(1 / 0)\nval b = Try("x".toInt)\nval c = Try(42)',
    expected: 42,
    sample: 'a.orElse(b).orElse(c).getOrElse(0)',
    hints: ['orElse provides fallback', 'First Success wins'],
    tags: ['orElse', 'chain', 'try'],
  },

  {
    id: 'scala-try-119',
    category: 'Try Type',
    difficulty: 'hard',
    title: 'Pattern Match Try',
    text: 'Pattern match on Try result.',
    setup: 'import scala.util.{Try, Success, Failure}\nval result = Try(42)',
    setupCode: 'import scala.util.{Try, Success, Failure}\nval result = Try(42)',
    expected: 42,
    sample: 'result match { case Success(v) => v; case Failure(_) => 0 }',
    hints: ['Match Success and Failure', 'Extract value or handle error'],
    tags: ['pattern-match', 'extract', 'try'],
  },

  // ============================================================
  // NEW PROBLEMS - Future (30 problems)
  // ============================================================

  {
    id: 'scala-future-100',
    category: 'Future',
    difficulty: 'easy',
    title: 'Create Successful Future',
    text: 'Create a Future that immediately succeeds with value 42.',
    setup:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global',
    setupCode:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global',
    expected: 42,
    sample: 'Future.successful(42)',
    hints: ['Future.successful creates completed Future', 'No async execution needed'],
    tags: ['future', 'successful', 'create'],
  },

  {
    id: 'scala-future-101',
    category: 'Future',
    difficulty: 'easy',
    title: 'Create Failed Future',
    text: 'Create a Future that immediately fails with an exception.',
    setup:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global',
    setupCode:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global',
    expected: true,
    sample: 'Future.failed(new Exception("error")).isCompleted',
    hints: ['Future.failed creates failed Future', 'Already completed'],
    tags: ['future', 'failed', 'create'],
  },

  {
    id: 'scala-future-102',
    category: 'Future',
    difficulty: 'easy',
    title: 'Map Future Value',
    text: 'Transform Future value by doubling it.',
    setup:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval f = Future.successful(21)',
    setupCode:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval f = Future.successful(21)',
    expected: 42,
    sample:
      'import scala.concurrent.Await\nimport scala.concurrent.duration._\nAwait.result(f.map(_ * 2), 1.second)',
    hints: ['map transforms Future value', 'Async transformation'],
    tags: ['future', 'map', 'transform'],
  },

  {
    id: 'scala-future-103',
    category: 'Future',
    difficulty: 'easy',
    title: 'FlatMap Futures',
    text: 'Chain two Future operations.',
    setup:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\ndef double(n: Int) = Future.successful(n * 2)',
    setupCode:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\ndef double(n: Int) = Future.successful(n * 2)',
    expected: 42,
    sample:
      'import scala.concurrent.Await\nimport scala.concurrent.duration._\nAwait.result(Future.successful(21).flatMap(double), 1.second)',
    hints: ['flatMap chains Futures', 'Avoids nested Future'],
    tags: ['future', 'flatMap', 'chain'],
  },

  {
    id: 'scala-future-104',
    category: 'Future',
    difficulty: 'easy',
    title: 'Recover from Failure',
    text: 'Recover failed Future with default value.',
    setup:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval f = Future.failed[Int](new Exception("error"))',
    setupCode:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval f = Future.failed[Int](new Exception("error"))',
    expected: -1,
    sample:
      'import scala.concurrent.Await\nimport scala.concurrent.duration._\nAwait.result(f.recover { case _ => -1 }, 1.second)',
    hints: ['recover handles exceptions', 'Partial function syntax'],
    tags: ['future', 'recover', 'error'],
  },

  {
    id: 'scala-future-105',
    category: 'Future',
    difficulty: 'medium',
    title: 'For Comprehension Futures',
    text: 'Combine Futures with for-comprehension.',
    setup:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval a = Future.successful(10)\nval b = Future.successful(20)',
    setupCode:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval a = Future.successful(10)\nval b = Future.successful(20)',
    expected: 30,
    sample:
      'import scala.concurrent.Await\nimport scala.concurrent.duration._\nAwait.result(for { x <- a; y <- b } yield x + y, 1.second)',
    hints: ['for-comprehension on Future', 'Sequential by default'],
    tags: ['future', 'for-comprehension', 'combine'],
  },

  {
    id: 'scala-future-106',
    category: 'Future',
    difficulty: 'medium',
    title: 'Sequence Futures',
    text: 'Convert List[Future] to Future[List].',
    setup:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval futures = List(Future.successful(1), Future.successful(2), Future.successful(3))',
    setupCode:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval futures = List(Future.successful(1), Future.successful(2), Future.successful(3))',
    expected: [1, 2, 3],
    sample:
      'import scala.concurrent.Await\nimport scala.concurrent.duration._\nAwait.result(Future.sequence(futures), 1.second)',
    hints: ['Future.sequence inverts types', 'Fails if any Future fails'],
    tags: ['future', 'sequence', 'list'],
  },

  {
    id: 'scala-future-107',
    category: 'Future',
    difficulty: 'medium',
    title: 'Traverse with Future',
    text: 'Apply async function to list elements.',
    setup:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval numbers = List(1, 2, 3)\ndef double(n: Int) = Future.successful(n * 2)',
    setupCode:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval numbers = List(1, 2, 3)\ndef double(n: Int) = Future.successful(n * 2)',
    expected: [2, 4, 6],
    sample:
      'import scala.concurrent.Await\nimport scala.concurrent.duration._\nAwait.result(Future.traverse(numbers)(double), 1.second)',
    hints: ['Future.traverse maps and sequences', 'Combines map and sequence'],
    tags: ['future', 'traverse', 'list'],
  },

  {
    id: 'scala-future-108',
    category: 'Future',
    difficulty: 'medium',
    title: 'RecoverWith Alternative',
    text: 'Recover with alternative Future.',
    setup:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval primary = Future.failed[Int](new Exception("error"))\nval fallback = Future.successful(42)',
    setupCode:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval primary = Future.failed[Int](new Exception("error"))\nval fallback = Future.successful(42)',
    expected: 42,
    sample:
      'import scala.concurrent.Await\nimport scala.concurrent.duration._\nAwait.result(primary.recoverWith { case _ => fallback }, 1.second)',
    hints: ['recoverWith returns Future', 'Fallback can also fail'],
    tags: ['future', 'recoverWith', 'fallback'],
  },

  {
    id: 'scala-future-109',
    category: 'Future',
    difficulty: 'medium',
    title: 'Transform Future',
    text: 'Transform both success and failure cases.',
    setup:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.util.{Success, Failure}\nval f = Future.successful(21)',
    setupCode:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.util.{Success, Failure}\nval f = Future.successful(21)',
    expected: 42,
    sample:
      'import scala.concurrent.Await\nimport scala.concurrent.duration._\nAwait.result(f.transform { case Success(v) => Success(v * 2); case Failure(e) => Success(-1) }, 1.second)',
    hints: ['transform handles Try', 'Can change success/failure'],
    tags: ['future', 'transform', 'try'],
  },

  {
    id: 'scala-future-110',
    category: 'Future',
    difficulty: 'medium',
    title: 'Filter Future',
    text: 'Filter Future value with predicate.',
    setup:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval f = Future.successful(42)',
    setupCode:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval f = Future.successful(42)',
    expected: 42,
    sample:
      'import scala.concurrent.Await\nimport scala.concurrent.duration._\nAwait.result(f.filter(_ > 10), 1.second)',
    hints: ['filter fails if predicate false', 'NoSuchElementException'],
    tags: ['future', 'filter', 'predicate'],
  },

  {
    id: 'scala-future-111',
    category: 'Future',
    difficulty: 'medium',
    title: 'Collect Partial Function',
    text: 'Apply partial function to Future.',
    setup:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval f = Future.successful(10)',
    setupCode:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval f = Future.successful(10)',
    expected: 20,
    sample:
      'import scala.concurrent.Await\nimport scala.concurrent.duration._\nAwait.result(f.collect { case n if n > 5 => n * 2 }, 1.second)',
    hints: ['collect filters and transforms', 'Fails if not defined'],
    tags: ['future', 'collect', 'partial'],
  },

  {
    id: 'scala-future-112',
    category: 'Future',
    difficulty: 'hard',
    title: 'Zip Futures',
    text: 'Combine two Futures into tuple.',
    setup:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval a = Future.successful(1)\nval b = Future.successful("one")',
    setupCode:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval a = Future.successful(1)\nval b = Future.successful("one")',
    expected: [1, 'one'],
    sample:
      'import scala.concurrent.Await\nimport scala.concurrent.duration._\nval result = Await.result(a.zip(b), 1.second); List(result._1, result._2)',
    hints: ['zip combines Futures', 'Runs in parallel'],
    tags: ['future', 'zip', 'parallel'],
  },

  {
    id: 'scala-future-113',
    category: 'Future',
    difficulty: 'hard',
    title: 'ZipWith Futures',
    text: 'Combine Futures with function.',
    setup:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval a = Future.successful(10)\nval b = Future.successful(20)',
    setupCode:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval a = Future.successful(10)\nval b = Future.successful(20)',
    expected: 30,
    sample:
      'import scala.concurrent.Await\nimport scala.concurrent.duration._\nAwait.result(a.zipWith(b)(_ + _), 1.second)',
    hints: ['zipWith applies function', 'Parallel combination'],
    tags: ['future', 'zipWith', 'combine'],
  },

  {
    id: 'scala-future-114',
    category: 'Future',
    difficulty: 'hard',
    title: 'FirstCompletedOf',
    text: 'Get first completed Future result.',
    setup:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval futures = List(Future.successful(1), Future.successful(2))',
    setupCode:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval futures = List(Future.successful(1), Future.successful(2))',
    expected: true,
    sample:
      'import scala.concurrent.Await\nimport scala.concurrent.duration._\nList(1, 2).contains(Await.result(Future.firstCompletedOf(futures), 1.second))',
    hints: ['firstCompletedOf races Futures', 'Returns first result'],
    tags: ['future', 'race', 'first'],
  },

  {
    id: 'scala-future-115',
    category: 'Future',
    difficulty: 'hard',
    title: 'FoldLeft Futures',
    text: 'Fold over list of Futures sequentially.',
    setup:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval futures = List(Future.successful(1), Future.successful(2), Future.successful(3))',
    setupCode:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval futures = List(Future.successful(1), Future.successful(2), Future.successful(3))',
    expected: 6,
    sample:
      'import scala.concurrent.Await\nimport scala.concurrent.duration._\nAwait.result(Future.foldLeft(futures)(0)(_ + _), 1.second)',
    hints: ['Future.foldLeft accumulates', 'Sequential processing'],
    tags: ['future', 'foldLeft', 'aggregate'],
  },

  {
    id: 'scala-future-116',
    category: 'Future',
    difficulty: 'hard',
    title: 'ReduceLeft Futures',
    text: 'Reduce list of Futures.',
    setup:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval futures = List(Future.successful(1), Future.successful(2), Future.successful(3))',
    setupCode:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval futures = List(Future.successful(1), Future.successful(2), Future.successful(3))',
    expected: 6,
    sample:
      'import scala.concurrent.Await\nimport scala.concurrent.duration._\nAwait.result(Future.reduceLeft(futures)(_ + _), 1.second)',
    hints: ['Future.reduceLeft without initial', 'Fails on empty list'],
    tags: ['future', 'reduceLeft', 'aggregate'],
  },

  {
    id: 'scala-future-117',
    category: 'Future',
    difficulty: 'hard',
    title: 'AndThen Side Effect',
    text: 'Execute side effect on Future completion.',
    setup:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.util.{Success, Failure}\nvar result = 0\nval f = Future.successful(42)',
    setupCode:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.util.{Success, Failure}\nvar result = 0\nval f = Future.successful(42)',
    expected: 42,
    sample:
      'import scala.concurrent.Await\nimport scala.concurrent.duration._\nAwait.result(f.andThen { case Success(v) => result = v }, 1.second); result',
    hints: ['andThen for side effects', 'Returns original Future'],
    tags: ['future', 'andThen', 'sideEffect'],
  },

  {
    id: 'scala-future-118',
    category: 'Future',
    difficulty: 'hard',
    title: 'Flatten Nested Future',
    text: 'Flatten Future[Future[A]] to Future[A].',
    setup:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval nested = Future.successful(Future.successful(42))',
    setupCode:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval nested = Future.successful(Future.successful(42))',
    expected: 42,
    sample:
      'import scala.concurrent.Await\nimport scala.concurrent.duration._\nAwait.result(nested.flatten, 1.second)',
    hints: ['flatten removes nesting', 'Equivalent to flatMap(identity)'],
    tags: ['future', 'flatten', 'nested'],
  },

  {
    id: 'scala-future-119',
    category: 'Future',
    difficulty: 'hard',
    title: 'Failed Projection',
    text: 'Get the exception from failed Future.',
    setup:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval f = Future.failed[Int](new RuntimeException("test error"))',
    setupCode:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval f = Future.failed[Int](new RuntimeException("test error"))',
    expected: 'test error',
    sample:
      'import scala.concurrent.Await\nimport scala.concurrent.duration._\nAwait.result(f.failed.map(_.getMessage), 1.second)',
    hints: ['failed inverts Future', 'Success contains exception'],
    tags: ['future', 'failed', 'exception'],
  },

  // ============================================================
  // NEW PROBLEMS - Pattern Matching Advanced (30 problems)
  // ============================================================

  {
    id: 'scala-pattern-100',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Match Sealed Trait',
    text: 'Match on sealed trait members.',
    setup:
      'sealed trait Shape\ncase class Circle(r: Double) extends Shape\ncase class Rectangle(w: Double, h: Double) extends Shape\nval shape: Shape = Circle(5.0)',
    setupCode:
      'sealed trait Shape\ncase class Circle(r: Double) extends Shape\ncase class Rectangle(w: Double, h: Double) extends Shape\nval shape: Shape = Circle(5.0)',
    expected: 5.0,
    sample: 'shape match { case Circle(r) => r; case Rectangle(w, h) => w * h }',
    hints: ['Sealed traits enable exhaustive matching', 'Compiler warns on missing cases'],
    tags: ['pattern-match', 'sealed', 'trait'],
  },

  {
    id: 'scala-pattern-101',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Match with Alias',
    text: 'Use @ to bind entire pattern.',
    setup: 'case class Person(name: String, age: Int)\nval person = Person("Alice", 30)',
    setupCode: 'case class Person(name: String, age: Int)\nval person = Person("Alice", 30)',
    expected: 'Alice',
    sample: 'person match { case p @ Person(_, age) if age > 18 => p.name; case _ => "minor" }',
    hints: ['@ binds the whole match', 'Access both parts and whole'],
    tags: ['pattern-match', 'alias', 'binding'],
  },

  {
    id: 'scala-pattern-102',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Match Sequence Pattern',
    text: 'Match first two elements of a sequence.',
    setup: 'val seq = Seq(1, 2, 3, 4, 5)',
    setupCode: 'val seq = Seq(1, 2, 3, 4, 5)',
    expected: 3,
    sample: 'seq match { case Seq(a, b, _*) => a + b; case _ => 0 }',
    hints: ['_* matches remaining elements', 'Seq pattern matching'],
    tags: ['pattern-match', 'sequence', 'varargs'],
  },

  {
    id: 'scala-pattern-103',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Match Alternative',
    text: 'Match multiple patterns with |.',
    setup: 'val day = "Saturday"',
    setupCode: 'val day = "Saturday"',
    expected: 'weekend',
    sample: 'day match { case "Saturday" | "Sunday" => "weekend"; case _ => "weekday" }',
    hints: ['| combines alternatives', 'Cannot bind variables in alternatives'],
    tags: ['pattern-match', 'alternative', 'or'],
  },

  {
    id: 'scala-pattern-104',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Match Constant Pattern',
    text: 'Match against constant values.',
    setup: 'val Pi = 3.14159\nval value = 3.14159',
    setupCode: 'val Pi = 3.14159\nval value = 3.14159',
    expected: 'pi',
    sample: 'value match { case Pi => "pi"; case _ => "other" }',
    hints: ['Uppercase names are constants', 'Lowercase creates variable'],
    tags: ['pattern-match', 'constant', 'stable'],
  },

  {
    id: 'scala-pattern-105',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Custom Extractor',
    text: 'Use custom extractor object.',
    setup:
      'object Even { def unapply(n: Int): Option[Int] = if (n % 2 == 0) Some(n / 2) else None }\nval number = 10',
    setupCode:
      'object Even { def unapply(n: Int): Option[Int] = if (n % 2 == 0) Some(n / 2) else None }\nval number = 10',
    expected: 5,
    sample: 'number match { case Even(half) => half; case _ => 0 }',
    hints: ['unapply enables extraction', 'Return Option for match'],
    tags: ['pattern-match', 'extractor', 'unapply'],
  },

  {
    id: 'scala-pattern-106',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Extractor with Boolean',
    text: 'Use extractor returning Boolean.',
    setup: 'object Positive { def unapply(n: Int): Boolean = n > 0 }\nval number = 5',
    setupCode: 'object Positive { def unapply(n: Int): Boolean = n > 0 }\nval number = 5',
    expected: 'positive',
    sample: 'number match { case Positive() => "positive"; case _ => "non-positive" }',
    hints: ['Boolean extractor uses empty parens', 'No value extraction'],
    tags: ['pattern-match', 'extractor', 'boolean'],
  },

  {
    id: 'scala-pattern-107',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Regex Extractor',
    text: 'Extract groups from regex match.',
    setup: 'val datePattern = """(\\d{4})-(\\d{2})-(\\d{2})""".r\nval date = "2024-01-15"',
    setupCode: 'val datePattern = """(\\d{4})-(\\d{2})-(\\d{2})""".r\nval date = "2024-01-15"',
    expected: '2024',
    sample: 'date match { case datePattern(year, month, day) => year; case _ => "unknown" }',
    hints: ['Regex has unapplySeq', 'Groups become variables'],
    tags: ['pattern-match', 'regex', 'extraction'],
  },

  {
    id: 'scala-pattern-108',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Match Infix Pattern',
    text: 'Use infix notation in pattern.',
    setup: 'val list = List(1, 2, 3)',
    setupCode: 'val list = List(1, 2, 3)',
    expected: 1,
    sample: 'list match { case head :: _ => head; case Nil => 0 }',
    hints: [':: is infix pattern', 'Same as ::(head, tail)'],
    tags: ['pattern-match', 'infix', 'list'],
  },

  {
    id: 'scala-pattern-109',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Match Typed Pattern',
    text: 'Match with type ascription.',
    setup: 'val value: Any = List(1, 2, 3)',
    setupCode: 'val value: Any = List(1, 2, 3)',
    expected: 3,
    sample: 'value match { case list: List[_] => list.length; case _ => 0 }',
    hints: ['Type pattern with : Type', 'Generic types are erased'],
    tags: ['pattern-match', 'type', 'ascription'],
  },

  {
    id: 'scala-pattern-110',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Nested Case Class Match',
    text: 'Match nested case class structure.',
    setup:
      'case class Address(city: String)\ncase class Person(name: String, address: Address)\nval person = Person("Alice", Address("NYC"))',
    setupCode:
      'case class Address(city: String)\ncase class Person(name: String, address: Address)\nval person = Person("Alice", Address("NYC"))',
    expected: 'NYC',
    sample: 'person match { case Person(_, Address(city)) => city }',
    hints: ['Nest patterns for deep extraction', 'Destructure at any level'],
    tags: ['pattern-match', 'nested', 'case-class'],
  },

  {
    id: 'scala-pattern-111',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Match with Back-tick',
    text: 'Match against existing variable.',
    setup: 'val expected = 42\nval actual = 42',
    setupCode: 'val expected = 42\nval actual = 42',
    expected: 'match',
    sample: 'actual match { case `expected` => "match"; case _ => "no match" }',
    hints: ['Back-ticks reference variable', 'Without back-ticks creates new binding'],
    tags: ['pattern-match', 'backtick', 'variable'],
  },

  {
    id: 'scala-pattern-112',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Extractor Sequence',
    text: 'Use unapplySeq for variable args.',
    setup:
      'object Words { def unapplySeq(s: String): Option[Seq[String]] = Some(s.split(" ").toSeq) }\nval sentence = "hello world scala"',
    setupCode:
      'object Words { def unapplySeq(s: String): Option[Seq[String]] = Some(s.split(" ").toSeq) }\nval sentence = "hello world scala"',
    expected: 'hello',
    sample: 'sentence match { case Words(first, _*) => first; case _ => "" }',
    hints: ['unapplySeq for variable args', '_* captures rest'],
    tags: ['pattern-match', 'unapplySeq', 'varargs'],
  },

  {
    id: 'scala-pattern-113',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Product Match',
    text: 'Match on Product elements.',
    setup: 'val tuple: Product = (1, "hello", true)',
    setupCode: 'val tuple: Product = (1, "hello", true)',
    expected: 3,
    sample: 'tuple.productArity',
    hints: ['Product provides generic access', 'productArity gives element count'],
    tags: ['pattern-match', 'product', 'generic'],
  },

  {
    id: 'scala-pattern-114',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'XML Pattern Match',
    text: 'Match XML structure.',
    setup: 'val xml = <person><name>Alice</name></person>',
    setupCode: 'val xml = <person><name>Alice</name></person>',
    expected: 'Alice',
    sample: 'xml match { case <person><name>{name}</name></person> => name.text; case _ => "" }',
    hints: ['XML literals in patterns', 'Braces for variable binding'],
    tags: ['pattern-match', 'xml', 'extraction'],
  },

  {
    id: 'scala-pattern-115',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Deep Guard Pattern',
    text: 'Use guards with nested extraction.',
    setup:
      'case class Order(item: String, qty: Int)\ncase class Customer(name: String, order: Order)\nval customer = Customer("Alice", Order("Book", 5))',
    setupCode:
      'case class Order(item: String, qty: Int)\ncase class Customer(name: String, order: Order)\nval customer = Customer("Alice", Order("Book", 5))',
    expected: 'bulk order',
    sample:
      'customer match { case Customer(_, Order(_, qty)) if qty > 3 => "bulk order"; case _ => "regular" }',
    hints: ['Guard applies after extraction', 'Can reference extracted values'],
    tags: ['pattern-match', 'guard', 'nested'],
  },

  {
    id: 'scala-pattern-116',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Match with PartialFunction',
    text: 'Create PartialFunction from match.',
    setup: 'val numbers = List(1, 2, 3, 4, 5)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5)',
    expected: [2, 4],
    sample: 'numbers.collect { case n if n % 2 == 0 => n }',
    hints: ['Pattern match creates PartialFunction', 'collect uses PartialFunction'],
    tags: ['pattern-match', 'partial-function', 'collect'],
  },

  {
    id: 'scala-pattern-117',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Recursive Match',
    text: 'Recursively match nested structure.',
    setup:
      'sealed trait Tree\ncase class Node(left: Tree, right: Tree) extends Tree\ncase class Leaf(value: Int) extends Tree\nval tree: Tree = Node(Leaf(1), Node(Leaf(2), Leaf(3)))',
    setupCode:
      'sealed trait Tree\ncase class Node(left: Tree, right: Tree) extends Tree\ncase class Leaf(value: Int) extends Tree\nval tree: Tree = Node(Leaf(1), Node(Leaf(2), Leaf(3)))',
    expected: 6,
    sample:
      'def sum(t: Tree): Int = t match { case Leaf(v) => v; case Node(l, r) => sum(l) + sum(r) }; sum(tree)',
    hints: ['Recursive function with match', 'Handle all cases'],
    tags: ['pattern-match', 'recursive', 'tree'],
  },

  {
    id: 'scala-pattern-118',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Match Map Entry',
    text: 'Pattern match on map entries.',
    setup: 'val map = Map("a" -> 1, "b" -> 2, "c" -> 3)',
    setupCode: 'val map = Map("a" -> 1, "b" -> 2, "c" -> 3)',
    expected: [1, 2, 3],
    sample: 'map.toList.map { case (_, v) => v }',
    hints: ['Destructure tuple in function', 'Maps iterate as tuples'],
    tags: ['pattern-match', 'map', 'tuple'],
  },

  {
    id: 'scala-pattern-119',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Name-based Extractor',
    text: 'Use name-based extraction.',
    setup:
      'class User(val name: String, val age: Int)\nobject User { def unapply(u: User): Some[(String, Int)] = Some((u.name, u.age)) }\nval user = new User("Alice", 30)',
    setupCode:
      'class User(val name: String, val age: Int)\nobject User { def unapply(u: User): Some[(String, Int)] = Some((u.name, u.age)) }\nval user = new User("Alice", 30)',
    expected: 'Alice',
    sample: 'user match { case User(name, _) => name }',
    hints: ['Regular class with extractor', 'unapply enables pattern matching'],
    tags: ['pattern-match', 'extractor', 'class'],
  },

  // ============================================================
  // NEW PROBLEMS - Case Classes (30 problems)
  // ============================================================

  {
    id: 'scala-case-100',
    category: 'Case Classes',
    difficulty: 'easy',
    title: 'Create Case Class Instance',
    text: 'Create a Person case class instance.',
    setup: 'case class Person(name: String, age: Int)',
    setupCode: 'case class Person(name: String, age: Int)',
    expected: 'Alice',
    sample: 'Person("Alice", 30).name',
    hints: ['No new keyword needed', 'Apply method auto-generated'],
    tags: ['case-class', 'create', 'basics'],
  },

  {
    id: 'scala-case-101',
    category: 'Case Classes',
    difficulty: 'easy',
    title: 'Copy with Modified Field',
    text: 'Create a copy with modified age.',
    setup: 'case class Person(name: String, age: Int)\nval alice = Person("Alice", 30)',
    setupCode: 'case class Person(name: String, age: Int)\nval alice = Person("Alice", 30)',
    expected: 31,
    sample: 'alice.copy(age = 31).age',
    hints: ['copy creates modified copy', 'Named parameters for changes'],
    tags: ['case-class', 'copy', 'immutable'],
  },

  {
    id: 'scala-case-102',
    category: 'Case Classes',
    difficulty: 'easy',
    title: 'Case Class Equality',
    text: 'Compare two case class instances.',
    setup: 'case class Point(x: Int, y: Int)\nval p1 = Point(1, 2)\nval p2 = Point(1, 2)',
    setupCode: 'case class Point(x: Int, y: Int)\nval p1 = Point(1, 2)\nval p2 = Point(1, 2)',
    expected: true,
    sample: 'p1 == p2',
    hints: ['Case classes have structural equality', 'Auto-generated equals'],
    tags: ['case-class', 'equality', 'compare'],
  },

  {
    id: 'scala-case-103',
    category: 'Case Classes',
    difficulty: 'easy',
    title: 'Case Class toString',
    text: 'Get string representation of case class.',
    setup: 'case class Person(name: String, age: Int)\nval person = Person("Alice", 30)',
    setupCode: 'case class Person(name: String, age: Int)\nval person = Person("Alice", 30)',
    expected: 'Person(Alice,30)',
    sample: 'person.toString',
    hints: ['Auto-generated toString', 'Shows class name and fields'],
    tags: ['case-class', 'toString', 'string'],
  },

  {
    id: 'scala-case-104',
    category: 'Case Classes',
    difficulty: 'easy',
    title: 'Case Class hashCode',
    text: 'Get consistent hashCode for case class.',
    setup: 'case class Point(x: Int, y: Int)\nval p1 = Point(1, 2)\nval p2 = Point(1, 2)',
    setupCode: 'case class Point(x: Int, y: Int)\nval p1 = Point(1, 2)\nval p2 = Point(1, 2)',
    expected: true,
    sample: 'p1.hashCode == p2.hashCode',
    hints: ['Equal objects have equal hashCode', 'Auto-generated hashCode'],
    tags: ['case-class', 'hashCode', 'equality'],
  },

  {
    id: 'scala-case-105',
    category: 'Case Classes',
    difficulty: 'easy',
    title: 'ProductArity',
    text: 'Get number of fields in case class.',
    setup:
      'case class Person(name: String, age: Int, city: String)\nval person = Person("Alice", 30, "NYC")',
    setupCode:
      'case class Person(name: String, age: Int, city: String)\nval person = Person("Alice", 30, "NYC")',
    expected: 3,
    sample: 'person.productArity',
    hints: ['productArity returns field count', 'Case class extends Product'],
    tags: ['case-class', 'productArity', 'product'],
  },

  {
    id: 'scala-case-106',
    category: 'Case Classes',
    difficulty: 'easy',
    title: 'ProductIterator',
    text: 'Iterate over case class fields.',
    setup: 'case class Person(name: String, age: Int)\nval person = Person("Alice", 30)',
    setupCode: 'case class Person(name: String, age: Int)\nval person = Person("Alice", 30)',
    expected: ['Alice', 30],
    sample: 'person.productIterator.toList',
    hints: ['productIterator gives field values', 'Returns Iterator[Any]'],
    tags: ['case-class', 'productIterator', 'iterate'],
  },

  {
    id: 'scala-case-107',
    category: 'Case Classes',
    difficulty: 'medium',
    title: 'Unapply Extraction',
    text: 'Use unapply in pattern matching.',
    setup: 'case class Person(name: String, age: Int)\nval person = Person("Alice", 30)',
    setupCode: 'case class Person(name: String, age: Int)\nval person = Person("Alice", 30)',
    expected: 'Alice is 30',
    sample: 'val Person(n, a) = person; s"$n is $a"',
    hints: ['unapply enables destructuring', 'Auto-generated for case class'],
    tags: ['case-class', 'unapply', 'destructure'],
  },

  {
    id: 'scala-case-108',
    category: 'Case Classes',
    difficulty: 'medium',
    title: 'Case Class with Default Values',
    text: 'Use case class with default parameters.',
    setup: 'case class Config(host: String = "localhost", port: Int = 8080)',
    setupCode: 'case class Config(host: String = "localhost", port: Int = 8080)',
    expected: 8080,
    sample: 'Config().port',
    hints: ['Default values in constructor', 'Override only what needed'],
    tags: ['case-class', 'default', 'parameters'],
  },

  {
    id: 'scala-case-109',
    category: 'Case Classes',
    difficulty: 'medium',
    title: 'Copy Multiple Fields',
    text: 'Copy with multiple field modifications.',
    setup:
      'case class Person(name: String, age: Int, city: String)\nval person = Person("Alice", 30, "NYC")',
    setupCode:
      'case class Person(name: String, age: Int, city: String)\nval person = Person("Alice", 30, "NYC")',
    expected: 'Bob in LA',
    sample:
      'val updated = person.copy(name = "Bob", city = "LA"); s"${updated.name} in ${updated.city}"',
    hints: ['Multiple named parameters in copy', 'Unchanged fields preserved'],
    tags: ['case-class', 'copy', 'multiple'],
  },

  {
    id: 'scala-case-110',
    category: 'Case Classes',
    difficulty: 'medium',
    title: 'Nested Case Classes',
    text: 'Work with nested case classes.',
    setup:
      'case class Address(city: String, zip: String)\ncase class Person(name: String, address: Address)\nval person = Person("Alice", Address("NYC", "10001"))',
    setupCode:
      'case class Address(city: String, zip: String)\ncase class Person(name: String, address: Address)\nval person = Person("Alice", Address("NYC", "10001"))',
    expected: 'NYC',
    sample: 'person.address.city',
    hints: ['Access through nested structure', 'Dot notation for navigation'],
    tags: ['case-class', 'nested', 'access'],
  },

  {
    id: 'scala-case-111',
    category: 'Case Classes',
    difficulty: 'medium',
    title: 'Case Class in Collection',
    text: 'Filter collection of case classes.',
    setup:
      'case class Person(name: String, age: Int)\nval people = List(Person("Alice", 30), Person("Bob", 25), Person("Charlie", 35))',
    setupCode:
      'case class Person(name: String, age: Int)\nval people = List(Person("Alice", 30), Person("Bob", 25), Person("Charlie", 35))',
    expected: ['Alice', 'Charlie'],
    sample: 'people.filter(_.age >= 30).map(_.name)',
    hints: ['Filter by field value', 'Map to extract field'],
    tags: ['case-class', 'collection', 'filter'],
  },

  {
    id: 'scala-case-112',
    category: 'Case Classes',
    difficulty: 'medium',
    title: 'Case Class Ordering',
    text: 'Sort case classes by field.',
    setup:
      'case class Person(name: String, age: Int)\nval people = List(Person("Charlie", 35), Person("Alice", 30), Person("Bob", 25))',
    setupCode:
      'case class Person(name: String, age: Int)\nval people = List(Person("Charlie", 35), Person("Alice", 30), Person("Bob", 25))',
    expected: ['Bob', 'Alice', 'Charlie'],
    sample: 'people.sortBy(_.age).map(_.name)',
    hints: ['sortBy extracts key', 'Natural ordering on field'],
    tags: ['case-class', 'sort', 'ordering'],
  },

  {
    id: 'scala-case-113',
    category: 'Case Classes',
    difficulty: 'medium',
    title: 'ProductElement Access',
    text: 'Access field by index.',
    setup: 'case class Person(name: String, age: Int)\nval person = Person("Alice", 30)',
    setupCode: 'case class Person(name: String, age: Int)\nval person = Person("Alice", 30)',
    expected: 'Alice',
    sample: 'person.productElement(0).asInstanceOf[String]',
    hints: ['productElement gives field by index', '0-based indexing'],
    tags: ['case-class', 'productElement', 'index'],
  },

  {
    id: 'scala-case-114',
    category: 'Case Classes',
    difficulty: 'hard',
    title: 'Case Class with Type Parameter',
    text: 'Use generic case class.',
    setup: 'case class Box[A](value: A)\nval intBox = Box(42)\nval strBox = Box("hello")',
    setupCode: 'case class Box[A](value: A)\nval intBox = Box(42)\nval strBox = Box("hello")',
    expected: 47,
    sample: 'intBox.value + strBox.value.length',
    hints: ['Type parameter for generic data', 'Type inference works'],
    tags: ['case-class', 'generic', 'type-parameter'],
  },

  {
    id: 'scala-case-115',
    category: 'Case Classes',
    difficulty: 'hard',
    title: 'Case Class with Variance',
    text: 'Use covariant case class.',
    setup:
      'case class Box[+A](value: A)\nval strBox: Box[String] = Box("hello")\nval anyBox: Box[Any] = strBox',
    setupCode:
      'case class Box[+A](value: A)\nval strBox: Box[String] = Box("hello")\nval anyBox: Box[Any] = strBox',
    expected: 'hello',
    sample: 'anyBox.value.toString',
    hints: ['+ makes type covariant', 'Subtype relationship preserved'],
    tags: ['case-class', 'variance', 'covariant'],
  },

  {
    id: 'scala-case-116',
    category: 'Case Classes',
    difficulty: 'hard',
    title: 'Lens-like Update',
    text: 'Update nested field immutably.',
    setup:
      'case class Address(city: String)\ncase class Person(name: String, address: Address)\nval person = Person("Alice", Address("NYC"))',
    setupCode:
      'case class Address(city: String)\ncase class Person(name: String, address: Address)\nval person = Person("Alice", Address("NYC"))',
    expected: 'LA',
    sample: 'person.copy(address = person.address.copy(city = "LA")).address.city',
    hints: ['Nested copy for deep update', 'Lens pattern manual'],
    tags: ['case-class', 'nested', 'update'],
  },

  {
    id: 'scala-case-117',
    category: 'Case Classes',
    difficulty: 'hard',
    title: 'Case Object Singleton',
    text: 'Use case object as singleton.',
    setup:
      'sealed trait Status\ncase object Active extends Status\ncase object Inactive extends Status\nval status: Status = Active',
    setupCode:
      'sealed trait Status\ncase object Active extends Status\ncase object Inactive extends Status\nval status: Status = Active',
    expected: 'active',
    sample: 'status match { case Active => "active"; case Inactive => "inactive" }',
    hints: ['case object for singleton values', 'Common for enumerations'],
    tags: ['case-class', 'case-object', 'singleton'],
  },

  {
    id: 'scala-case-118',
    category: 'Case Classes',
    difficulty: 'hard',
    title: 'Case Class with Private Constructor',
    text: 'Case class with smart constructor.',
    setup:
      'case class Email private (value: String)\nobject Email { def apply(s: String): Option[Email] = if (s.contains("@")) Some(new Email(s)) else None }',
    setupCode:
      'case class Email private (value: String)\nobject Email { def apply(s: String): Option[Email] = if (s.contains("@")) Some(new Email(s)) else None }',
    expected: 'test@example.com',
    sample: 'Email("test@example.com").map(_.value).getOrElse("")',
    hints: ['Private constructor with smart apply', 'Validation in companion'],
    tags: ['case-class', 'smart-constructor', 'validation'],
  },

  {
    id: 'scala-case-119',
    category: 'Case Classes',
    difficulty: 'hard',
    title: 'Case Class Serialization',
    text: 'Case class to Map conversion.',
    setup: 'case class Person(name: String, age: Int)\nval person = Person("Alice", 30)',
    setupCode: 'case class Person(name: String, age: Int)\nval person = Person("Alice", 30)',
    expected: { name: 'Alice', age: 30 },
    sample: 'Map("name" -> person.name, "age" -> person.age)',
    hints: ['Manual serialization to Map', 'productElementNames in Scala 2.13+'],
    tags: ['case-class', 'serialization', 'map'],
  },

  // ============================================================
  // NEW PROBLEMS - Traits (30 problems)
  // ============================================================

  {
    id: 'scala-trait-100',
    category: 'Traits',
    difficulty: 'easy',
    title: 'Basic Trait Implementation',
    text: 'Implement a simple trait.',
    setup:
      'trait Greeting { def greet: String }\nclass Person(name: String) extends Greeting { def greet = s"Hello, $name" }',
    setupCode:
      'trait Greeting { def greet: String }\nclass Person(name: String) extends Greeting { def greet = s"Hello, $name" }',
    expected: 'Hello, Alice',
    sample: 'new Person("Alice").greet',
    hints: ['extends for first trait', 'Implement abstract methods'],
    tags: ['trait', 'implement', 'basics'],
  },

  {
    id: 'scala-trait-101',
    category: 'Traits',
    difficulty: 'easy',
    title: 'Trait with Concrete Method',
    text: 'Use trait with default implementation.',
    setup: 'trait Logger { def log(msg: String): String = s"[LOG] $msg" }',
    setupCode: 'trait Logger { def log(msg: String): String = s"[LOG] $msg" }',
    expected: '[LOG] test',
    sample: 'new Logger {}.log("test")',
    hints: ['Traits can have concrete methods', 'Anonymous instance'],
    tags: ['trait', 'concrete', 'default'],
  },

  {
    id: 'scala-trait-102',
    category: 'Traits',
    difficulty: 'easy',
    title: 'Multiple Trait Mixin',
    text: 'Mix in multiple traits.',
    setup: 'trait A { def a = "A" }\ntrait B { def b = "B" }\nclass C extends A with B',
    setupCode: 'trait A { def a = "A" }\ntrait B { def b = "B" }\nclass C extends A with B',
    expected: 'AB',
    sample: 'val c = new C; c.a + c.b',
    hints: ['with for additional traits', 'All trait methods available'],
    tags: ['trait', 'mixin', 'multiple'],
  },

  {
    id: 'scala-trait-103',
    category: 'Traits',
    difficulty: 'easy',
    title: 'Trait with Field',
    text: 'Trait with abstract field.',
    setup: 'trait Named { val name: String }\nclass Person(val name: String) extends Named',
    setupCode: 'trait Named { val name: String }\nclass Person(val name: String) extends Named',
    expected: 'Alice',
    sample: 'new Person("Alice").name',
    hints: ['Abstract val in trait', 'Implemented by constructor param'],
    tags: ['trait', 'field', 'abstract'],
  },

  {
    id: 'scala-trait-104',
    category: 'Traits',
    difficulty: 'easy',
    title: 'Trait Override',
    text: 'Override trait method in class.',
    setup:
      'trait Greeting { def greet: String = "Hello" }\nclass FriendlyPerson extends Greeting { override def greet = "Hi there!" }',
    setupCode:
      'trait Greeting { def greet: String = "Hello" }\nclass FriendlyPerson extends Greeting { override def greet = "Hi there!" }',
    expected: 'Hi there!',
    sample: 'new FriendlyPerson().greet',
    hints: ['override keyword required', 'Replaces default implementation'],
    tags: ['trait', 'override', 'method'],
  },

  {
    id: 'scala-trait-105',
    category: 'Traits',
    difficulty: 'medium',
    title: 'Stackable Trait Modification',
    text: 'Use stackable trait pattern.',
    setup:
      'trait IntQueue { def put(x: Int): Unit; def get(): Int }\ntrait Doubling extends IntQueue { abstract override def put(x: Int) = super.put(x * 2) }',
    setupCode:
      'trait IntQueue { def put(x: Int): Unit; def get(): Int }\ntrait Doubling extends IntQueue { abstract override def put(x: Int) = super.put(x * 2) }',
    expected: 42,
    sample:
      'class BasicQueue extends IntQueue { var buf = List[Int](); def put(x: Int) = buf = buf :+ x; def get() = { val h = buf.head; buf = buf.tail; h } }; val q = new BasicQueue with Doubling; q.put(21); q.get()',
    hints: ['abstract override for stackable', 'super calls next in chain'],
    tags: ['trait', 'stackable', 'modification'],
  },

  {
    id: 'scala-trait-106',
    category: 'Traits',
    difficulty: 'medium',
    title: 'Self Type Annotation',
    text: 'Use self type for dependency.',
    setup:
      'trait Logger { def log(msg: String): String }\ntrait Service { this: Logger => def serve() = log("serving") }',
    setupCode:
      'trait Logger { def log(msg: String): String }\ntrait Service { this: Logger => def serve() = log("serving") }',
    expected: '[LOG] serving',
    sample:
      'class MyService extends Service with Logger { def log(msg: String) = s"[LOG] $msg" }; new MyService().serve()',
    hints: ['this: Type => declares dependency', 'Must mix in required trait'],
    tags: ['trait', 'self-type', 'dependency'],
  },

  {
    id: 'scala-trait-107',
    category: 'Traits',
    difficulty: 'medium',
    title: 'Trait Linearization',
    text: 'Understand trait linearization order.',
    setup:
      'trait A { def value: String = "A" }\ntrait B extends A { override def value = "B" + super.value }\ntrait C extends A { override def value = "C" + super.value }',
    setupCode:
      'trait A { def value: String = "A" }\ntrait B extends A { override def value = "B" + super.value }\ntrait C extends A { override def value = "C" + super.value }',
    expected: 'CBA',
    sample: 'class D extends B with C; new D().value',
    hints: ['Right-to-left linearization', 'super goes to next in chain'],
    tags: ['trait', 'linearization', 'super'],
  },

  {
    id: 'scala-trait-108',
    category: 'Traits',
    difficulty: 'medium',
    title: 'Trait with Type Member',
    text: 'Use abstract type member in trait.',
    setup:
      'trait Container { type Element; def get: Element }\nclass IntContainer(val get: Int) extends Container { type Element = Int }',
    setupCode:
      'trait Container { type Element; def get: Element }\nclass IntContainer(val get: Int) extends Container { type Element = Int }',
    expected: 42,
    sample: 'new IntContainer(42).get',
    hints: ['type member for abstraction', 'Defined in implementation'],
    tags: ['trait', 'type-member', 'abstract'],
  },

  {
    id: 'scala-trait-109',
    category: 'Traits',
    difficulty: 'medium',
    title: 'Sealed Trait Hierarchy',
    text: 'Use sealed trait for ADT.',
    setup:
      'sealed trait Option[+A]\ncase class Some[A](value: A) extends Option[A]\ncase object None extends Option[Nothing]',
    setupCode:
      'sealed trait Option[+A]\ncase class Some[A](value: A) extends Option[A]\ncase object None extends Option[Nothing]',
    expected: 42,
    sample: 'val opt: Option[Int] = Some(42); opt match { case Some(v) => v; case None => 0 }',
    hints: ['sealed restricts subtypes', 'Enables exhaustive matching'],
    tags: ['trait', 'sealed', 'adt'],
  },

  {
    id: 'scala-trait-110',
    category: 'Traits',
    difficulty: 'medium',
    title: 'Trait Constructor Order',
    text: 'Understand initialization order.',
    setup:
      'trait A { val a: String; val len = a.length }\nclass B extends { val a = "hello" } with A',
    setupCode:
      'trait A { val a: String; val len = a.length }\nclass B extends { val a = "hello" } with A',
    expected: 5,
    sample: 'new B().len',
    hints: ['Early definition for initialization', 'Prevents null pointer'],
    tags: ['trait', 'early-definition', 'initialization'],
  },

  {
    id: 'scala-trait-111',
    category: 'Traits',
    difficulty: 'hard',
    title: 'Cake Pattern',
    text: 'Implement cake pattern for DI.',
    setup:
      'trait RepositoryComponent { def repository: Repository; trait Repository { def get(id: Int): String } }\ntrait ServiceComponent { this: RepositoryComponent => def service: Service; class Service { def fetch(id: Int) = repository.get(id) } }',
    setupCode:
      'trait RepositoryComponent { def repository: Repository; trait Repository { def get(id: Int): String } }\ntrait ServiceComponent { this: RepositoryComponent => def service: Service; class Service { def fetch(id: Int) = repository.get(id) } }',
    expected: 'item-1',
    sample:
      'object App extends ServiceComponent with RepositoryComponent { val repository = new Repository { def get(id: Int) = s"item-$id" }; val service = new Service }; App.service.fetch(1)',
    hints: ['Cake pattern for dependency injection', 'Self types for requirements'],
    tags: ['trait', 'cake-pattern', 'di'],
  },

  {
    id: 'scala-trait-112',
    category: 'Traits',
    difficulty: 'hard',
    title: 'Type Class Pattern',
    text: 'Implement type class with trait.',
    setup:
      'trait Show[A] { def show(a: A): String }\nobject Show { implicit val intShow: Show[Int] = (a: Int) => s"Int: $a" }',
    setupCode:
      'trait Show[A] { def show(a: A): String }\nobject Show { implicit val intShow: Show[Int] = (a: Int) => s"Int: $a" }',
    expected: 'Int: 42',
    sample: 'def show[A](a: A)(implicit s: Show[A]) = s.show(a); show(42)',
    hints: ['Type class pattern with implicit', 'Ad-hoc polymorphism'],
    tags: ['trait', 'type-class', 'implicit'],
  },

  {
    id: 'scala-trait-113',
    category: 'Traits',
    difficulty: 'hard',
    title: 'Structural Refinement',
    text: 'Use structural type with trait.',
    setup: 'def close(resource: { def close(): Unit }): String = { resource.close(); "closed" }',
    setupCode:
      'def close(resource: { def close(): Unit }): String = { resource.close(); "closed" }',
    expected: 'closed',
    sample: 'close(new { def close() = () })',
    hints: ['Structural types for duck typing', 'Uses reflection'],
    tags: ['trait', 'structural', 'duck-typing'],
  },

  {
    id: 'scala-trait-114',
    category: 'Traits',
    difficulty: 'hard',
    title: 'Trait with Context Bound',
    text: 'Use context bound in trait method.',
    setup:
      'trait Summable[A] { def sum(a: A, b: A)(implicit num: Numeric[A]): A = num.plus(a, b) }',
    setupCode:
      'trait Summable[A] { def sum(a: A, b: A)(implicit num: Numeric[A]): A = num.plus(a, b) }',
    expected: 30,
    sample: 'new Summable[Int] {}.sum(10, 20)',
    hints: ['Context bound for type class', 'Numeric provides operations'],
    tags: ['trait', 'context-bound', 'numeric'],
  },

  {
    id: 'scala-trait-115',
    category: 'Traits',
    difficulty: 'hard',
    title: 'Diamond Problem Resolution',
    text: 'Handle diamond inheritance.',
    setup:
      'trait A { def value = 1 }\ntrait B extends A { override def value = super.value + 1 }\ntrait C extends A { override def value = super.value + 2 }\nclass D extends B with C',
    setupCode:
      'trait A { def value = 1 }\ntrait B extends A { override def value = super.value + 1 }\ntrait C extends A { override def value = super.value + 2 }\nclass D extends B with C',
    expected: 4,
    sample: 'new D().value',
    hints: ['Linearization resolves diamond', 'Each trait called once'],
    tags: ['trait', 'diamond', 'linearization'],
  },

  // ============================================================
  // NEW PROBLEMS - Implicits/Givens (30 problems)
  // ============================================================

  {
    id: 'scala-implicit-100',
    category: 'Implicits/Givens',
    difficulty: 'easy',
    title: 'Implicit Parameter',
    text: 'Use implicit parameter.',
    setup: 'implicit val greeting: String = "Hello"',
    setupCode: 'implicit val greeting: String = "Hello"',
    expected: 'Hello, World',
    sample: 'def greet(name: String)(implicit g: String) = s"$g, $name"; greet("World")',
    hints: ['implicit val provides value', 'Compiler finds it automatically'],
    tags: ['implicit', 'parameter', 'basics'],
  },

  {
    id: 'scala-implicit-101',
    category: 'Implicits/Givens',
    difficulty: 'easy',
    title: 'Implicitly Lookup',
    text: 'Use implicitly to get implicit value.',
    setup: 'implicit val multiplier: Int = 10',
    setupCode: 'implicit val multiplier: Int = 10',
    expected: 10,
    sample: 'implicitly[Int]',
    hints: ['implicitly finds implicit of type', 'Useful for debugging'],
    tags: ['implicit', 'implicitly', 'lookup'],
  },

  {
    id: 'scala-implicit-102',
    category: 'Implicits/Givens',
    difficulty: 'easy',
    title: 'Context Bound Sugar',
    text: 'Use context bound syntax.',
    setup: 'def sum[A: Numeric](a: A, b: A) = implicitly[Numeric[A]].plus(a, b)',
    setupCode: 'def sum[A: Numeric](a: A, b: A) = implicitly[Numeric[A]].plus(a, b)',
    expected: 30,
    sample: 'sum(10, 20)',
    hints: ['A: TC is context bound', 'Shorthand for implicit parameter'],
    tags: ['implicit', 'context-bound', 'sugar'],
  },

  {
    id: 'scala-implicit-103',
    category: 'Implicits/Givens',
    difficulty: 'easy',
    title: 'Implicit Def Conversion',
    text: 'Define implicit conversion.',
    setup: 'implicit def intToString(i: Int): String = i.toString',
    setupCode: 'implicit def intToString(i: Int): String = i.toString',
    expected: '42',
    sample: 'val s: String = 42; s',
    hints: ['implicit def for conversion', 'Automatic type conversion'],
    tags: ['implicit', 'conversion', 'def'],
  },

  {
    id: 'scala-implicit-104',
    category: 'Implicits/Givens',
    difficulty: 'easy',
    title: 'Implicit Class Extension',
    text: 'Add method using implicit class.',
    setup: 'implicit class StringOps(s: String) { def exclaim = s + "!" }',
    setupCode: 'implicit class StringOps(s: String) { def exclaim = s + "!" }',
    expected: 'Hello!',
    sample: '"Hello".exclaim',
    hints: ['implicit class adds methods', 'Extension method pattern'],
    tags: ['implicit', 'class', 'extension'],
  },

  {
    id: 'scala-implicit-105',
    category: 'Implicits/Givens',
    difficulty: 'medium',
    title: 'Type Class Instance',
    text: 'Provide type class instance with implicit.',
    setup:
      'trait Show[A] { def show(a: A): String }\nimplicit val intShow: Show[Int] = (a: Int) => s"Int($a)"',
    setupCode:
      'trait Show[A] { def show(a: A): String }\nimplicit val intShow: Show[Int] = (a: Int) => s"Int($a)"',
    expected: 'Int(42)',
    sample: 'def show[A](a: A)(implicit s: Show[A]) = s.show(a); show(42)',
    hints: ['Implicit provides type class', 'Ad-hoc polymorphism'],
    tags: ['implicit', 'type-class', 'instance'],
  },

  {
    id: 'scala-implicit-106',
    category: 'Implicits/Givens',
    difficulty: 'medium',
    title: 'Implicit Object',
    text: 'Use implicit object for type class.',
    setup:
      'trait Monoid[A] { def empty: A; def combine(a: A, b: A): A }\nimplicit object IntMonoid extends Monoid[Int] { def empty = 0; def combine(a: Int, b: Int) = a + b }',
    setupCode:
      'trait Monoid[A] { def empty: A; def combine(a: A, b: A): A }\nimplicit object IntMonoid extends Monoid[Int] { def empty = 0; def combine(a: Int, b: Int) = a + b }',
    expected: 6,
    sample:
      'def combineAll[A](list: List[A])(implicit m: Monoid[A]): A = list.foldLeft(m.empty)(m.combine); combineAll(List(1, 2, 3))',
    hints: ['implicit object for singleton', 'Monoid pattern'],
    tags: ['implicit', 'object', 'monoid'],
  },

  {
    id: 'scala-implicit-107',
    category: 'Implicits/Givens',
    difficulty: 'medium',
    title: 'View Bound Legacy',
    text: 'Understand view bound pattern.',
    setup: 'def max[A](a: A, b: A)(implicit ord: Ordering[A]): A = if (ord.gt(a, b)) a else b',
    setupCode: 'def max[A](a: A, b: A)(implicit ord: Ordering[A]): A = if (ord.gt(a, b)) a else b',
    expected: 20,
    sample: 'max(10, 20)',
    hints: ['Ordering is type class', 'Provides comparison operations'],
    tags: ['implicit', 'ordering', 'comparison'],
  },

  {
    id: 'scala-implicit-108',
    category: 'Implicits/Givens',
    difficulty: 'medium',
    title: 'Chained Implicits',
    text: 'Chain implicit derivation.',
    setup:
      'trait Show[A] { def show(a: A): String }\nimplicit val intShow: Show[Int] = _.toString\nimplicit def listShow[A](implicit s: Show[A]): Show[List[A]] = list => list.map(s.show).mkString("[", ", ", "]")',
    setupCode:
      'trait Show[A] { def show(a: A): String }\nimplicit val intShow: Show[Int] = _.toString\nimplicit def listShow[A](implicit s: Show[A]): Show[List[A]] = list => list.map(s.show).mkString("[", ", ", "]")',
    expected: '[1, 2, 3]',
    sample: 'implicitly[Show[List[Int]]].show(List(1, 2, 3))',
    hints: ['implicit def derives instances', 'Compiler chains resolution'],
    tags: ['implicit', 'derivation', 'chain'],
  },

  {
    id: 'scala-implicit-109',
    category: 'Implicits/Givens',
    difficulty: 'medium',
    title: 'Implicit Scope',
    text: 'Use companion object implicit scope.',
    setup:
      'case class Email(value: String)\nobject Email { implicit val ordering: Ordering[Email] = Ordering.by(_.value) }',
    setupCode:
      'case class Email(value: String)\nobject Email { implicit val ordering: Ordering[Email] = Ordering.by(_.value) }',
    expected: ['a@test.com', 'b@test.com'],
    sample: 'List(Email("b@test.com"), Email("a@test.com")).sorted.map(_.value)',
    hints: ['Companion object in implicit scope', 'No import needed'],
    tags: ['implicit', 'scope', 'companion'],
  },

  {
    id: 'scala-implicit-110',
    category: 'Implicits/Givens',
    difficulty: 'medium',
    title: 'Implicit Evidence',
    text: 'Use implicit evidence type.',
    setup: 'def toList[A](a: A)(implicit ev: A =:= String): List[Char] = a.toList',
    setupCode: 'def toList[A](a: A)(implicit ev: A =:= String): List[Char] = a.toList',
    expected: ['h', 'i'],
    sample: 'toList("hi")',
    hints: ['=:= proves type equality', 'Compile-time type constraint'],
    tags: ['implicit', 'evidence', 'type-equality'],
  },

  {
    id: 'scala-implicit-111',
    category: 'Implicits/Givens',
    difficulty: 'hard',
    title: 'Scala 3 Given Instance',
    text: 'Define given instance (Scala 3 style).',
    setup:
      'trait Ord[A] { def compare(a: A, b: A): Int }\ngiven Ord[Int] with { def compare(a: Int, b: Int) = a - b }',
    setupCode:
      'trait Ord[A] { def compare(a: A, b: A): Int }\ngiven Ord[Int] with { def compare(a: Int, b: Int) = a - b }',
    expected: -10,
    sample: 'summon[Ord[Int]].compare(10, 20)',
    hints: ['given replaces implicit val', 'summon replaces implicitly'],
    tags: ['given', 'scala3', 'type-class'],
  },

  {
    id: 'scala-implicit-112',
    category: 'Implicits/Givens',
    difficulty: 'hard',
    title: 'Using Clause',
    text: 'Use using clause for parameters.',
    setup: 'def max[A](a: A, b: A)(using ord: Ordering[A]): A = if (ord.gt(a, b)) a else b',
    setupCode: 'def max[A](a: A, b: A)(using ord: Ordering[A]): A = if (ord.gt(a, b)) a else b',
    expected: 20,
    sample: 'max(10, 20)',
    hints: ['using replaces implicit', 'Scala 3 syntax'],
    tags: ['using', 'scala3', 'parameter'],
  },

  {
    id: 'scala-implicit-113',
    category: 'Implicits/Givens',
    difficulty: 'hard',
    title: 'Extension Method Scala 3',
    text: 'Define extension method.',
    setup: 'extension (s: String) def exclaim: String = s + "!"',
    setupCode: 'extension (s: String) def exclaim: String = s + "!"',
    expected: 'Hello!',
    sample: '"Hello".exclaim',
    hints: ['extension syntax in Scala 3', 'Cleaner than implicit class'],
    tags: ['extension', 'scala3', 'method'],
  },

  {
    id: 'scala-implicit-114',
    category: 'Implicits/Givens',
    difficulty: 'hard',
    title: 'Given With Derivation',
    text: 'Derive given from other givens.',
    setup:
      'trait Show[A] { def show(a: A): String }\ngiven Show[Int] = _.toString\ngiven [A](using s: Show[A]): Show[List[A]] = list => list.map(s.show).mkString("[", ",", "]")',
    setupCode:
      'trait Show[A] { def show(a: A): String }\ngiven Show[Int] = _.toString\ngiven [A](using s: Show[A]): Show[List[A]] = list => list.map(s.show).mkString("[", ",", "]")',
    expected: '[1,2,3]',
    sample: 'summon[Show[List[Int]]].show(List(1, 2, 3))',
    hints: ['Parameterized given for derivation', 'Depends on other givens'],
    tags: ['given', 'derivation', 'scala3'],
  },

  {
    id: 'scala-implicit-115',
    category: 'Implicits/Givens',
    difficulty: 'hard',
    title: 'Context Function',
    text: 'Use context function type.',
    setup: 'type Executable[A] = ExecutionContext ?=> A\nimport scala.concurrent.ExecutionContext',
    setupCode:
      'type Executable[A] = ExecutionContext ?=> A\nimport scala.concurrent.ExecutionContext',
    expected: true,
    sample:
      'def run[A](f: ExecutionContext ?=> A)(using ec: ExecutionContext): A = f; import scala.concurrent.ExecutionContext.Implicits.global; run(true)',
    hints: ['?=> is context function', 'Implicit parameter in type'],
    tags: ['context-function', 'scala3', 'type'],
  },

  // ============================================================
  // NEW PROBLEMS - For Comprehensions (30 problems)
  // ============================================================

  {
    id: 'scala-for-100',
    category: 'For Comprehensions',
    difficulty: 'easy',
    title: 'Basic For Yield',
    text: 'Transform list with for-yield.',
    setup: 'val numbers = List(1, 2, 3)',
    setupCode: 'val numbers = List(1, 2, 3)',
    expected: [2, 4, 6],
    sample: 'for (n <- numbers) yield n * 2',
    hints: ['for-yield produces new collection', 'Equivalent to map'],
    tags: ['for', 'yield', 'transform'],
  },

  {
    id: 'scala-for-101',
    category: 'For Comprehensions',
    difficulty: 'easy',
    title: 'For with Guard',
    text: 'Filter with guard in for.',
    setup: 'val numbers = List(1, 2, 3, 4, 5)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5)',
    expected: [2, 4],
    sample: 'for (n <- numbers if n % 2 == 0) yield n',
    hints: ['if adds filter condition', 'Called guard'],
    tags: ['for', 'guard', 'filter'],
  },

  {
    id: 'scala-for-102',
    category: 'For Comprehensions',
    difficulty: 'easy',
    title: 'Multiple Generators',
    text: 'Use multiple generators for cross product.',
    setup: 'val xs = List(1, 2)\nval ys = List("a", "b")',
    setupCode: 'val xs = List(1, 2)\nval ys = List("a", "b")',
    expected: ['1a', '1b', '2a', '2b'],
    sample: 'for { x <- xs; y <- ys } yield s"$x$y"',
    hints: ['Multiple generators nest loops', 'Cross product of collections'],
    tags: ['for', 'generator', 'cross-product'],
  },

  {
    id: 'scala-for-103',
    category: 'For Comprehensions',
    difficulty: 'easy',
    title: 'For with Definition',
    text: 'Use intermediate definition in for.',
    setup: 'val numbers = List(1, 2, 3)',
    setupCode: 'val numbers = List(1, 2, 3)',
    expected: [2, 4, 6],
    sample: 'for { n <- numbers; doubled = n * 2 } yield doubled',
    hints: ['= creates local definition', 'Can use in yield'],
    tags: ['for', 'definition', 'local'],
  },

  {
    id: 'scala-for-104',
    category: 'For Comprehensions',
    difficulty: 'easy',
    title: 'For with Option',
    text: 'Combine Options with for.',
    setup: 'val a: Option[Int] = Some(10)\nval b: Option[Int] = Some(20)',
    setupCode: 'val a: Option[Int] = Some(10)\nval b: Option[Int] = Some(20)',
    expected: 30,
    sample: '(for { x <- a; y <- b } yield x + y).getOrElse(0)',
    hints: ['for works with any monad', 'Option flatMap chain'],
    tags: ['for', 'option', 'combine'],
  },

  {
    id: 'scala-for-105',
    category: 'For Comprehensions',
    difficulty: 'easy',
    title: 'For Loop Side Effect',
    text: 'Use for without yield for side effects.',
    setup: 'val numbers = List(1, 2, 3)\nvar sum = 0',
    setupCode: 'val numbers = List(1, 2, 3)\nvar sum = 0',
    expected: 6,
    sample: 'for (n <- numbers) sum += n; sum',
    hints: ['No yield means foreach', 'Returns Unit'],
    tags: ['for', 'foreach', 'side-effect'],
  },

  {
    id: 'scala-for-106',
    category: 'For Comprehensions',
    difficulty: 'medium',
    title: 'Nested For Guards',
    text: 'Multiple guards in for comprehension.',
    setup: 'val numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)',
    setupCode: 'val numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)',
    expected: [6],
    sample: 'for { n <- numbers if n > 5 if n < 7 } yield n',
    hints: ['Multiple guards allowed', 'All must be true'],
    tags: ['for', 'guard', 'multiple'],
  },

  {
    id: 'scala-for-107',
    category: 'For Comprehensions',
    difficulty: 'medium',
    title: 'Pattern in Generator',
    text: 'Use pattern matching in generator.',
    setup: 'val pairs = List((1, "a"), (2, "b"), (3, "c"))',
    setupCode: 'val pairs = List((1, "a"), (2, "b"), (3, "c"))',
    expected: ['1-a', '2-b', '3-c'],
    sample: 'for { (n, s) <- pairs } yield s"$n-$s"',
    hints: ['Destructure in generator', 'Pattern on left side'],
    tags: ['for', 'pattern', 'destructure'],
  },

  {
    id: 'scala-for-108',
    category: 'For Comprehensions',
    difficulty: 'medium',
    title: 'For with Either',
    text: 'Combine Either values with for.',
    setup: 'val a: Either[String, Int] = Right(10)\nval b: Either[String, Int] = Right(20)',
    setupCode: 'val a: Either[String, Int] = Right(10)\nval b: Either[String, Int] = Right(20)',
    expected: 30,
    sample: '(for { x <- a; y <- b } yield x + y).getOrElse(0)',
    hints: ['Either is right-biased', 'Left short-circuits'],
    tags: ['for', 'either', 'combine'],
  },

  {
    id: 'scala-for-109',
    category: 'For Comprehensions',
    difficulty: 'medium',
    title: 'For with Range',
    text: 'Generate range values.',
    setup: 'val range = 1 to 5',
    setupCode: 'val range = 1 to 5',
    expected: [1, 4, 9, 16, 25],
    sample: 'for (n <- range) yield n * n',
    hints: ['Range works in for', 'to is inclusive'],
    tags: ['for', 'range', 'sequence'],
  },

  {
    id: 'scala-for-110',
    category: 'For Comprehensions',
    difficulty: 'medium',
    title: 'Pythagorean Triples',
    text: 'Generate Pythagorean triples.',
    setup: 'val limit = 10',
    setupCode: 'val limit = 10',
    expected: [
      [3, 4, 5],
      [6, 8, 10],
    ],
    sample:
      'for { a <- 1 to limit; b <- a to limit; c <- b to limit if a*a + b*b == c*c } yield List(a, b, c)',
    hints: ['Multiple generators with guard', 'Mathematical constraint'],
    tags: ['for', 'math', 'constraint'],
  },

  {
    id: 'scala-for-111',
    category: 'For Comprehensions',
    difficulty: 'medium',
    title: 'For with Try',
    text: 'Combine Try values with for.',
    setup: 'import scala.util.Try\nval a = Try(10)\nval b = Try(2)',
    setupCode: 'import scala.util.Try\nval a = Try(10)\nval b = Try(2)',
    expected: 5,
    sample: '(for { x <- a; y <- b } yield x / y).getOrElse(0)',
    hints: ['Try works in for', 'Failure propagates'],
    tags: ['for', 'try', 'combine'],
  },

  {
    id: 'scala-for-112',
    category: 'For Comprehensions',
    difficulty: 'medium',
    title: 'Filter vs Guard',
    text: 'Pattern match filter in generator.',
    setup: 'val options = List(Some(1), None, Some(2), None, Some(3))',
    setupCode: 'val options = List(Some(1), None, Some(2), None, Some(3))',
    expected: [1, 2, 3],
    sample: 'for { Some(n) <- options } yield n',
    hints: ['Pattern filters non-matching', 'None filtered out'],
    tags: ['for', 'pattern', 'filter'],
  },

  {
    id: 'scala-for-113',
    category: 'For Comprehensions',
    difficulty: 'hard',
    title: 'Nested Collections Flatten',
    text: 'Flatten nested collections with for.',
    setup: 'val nested = List(List(1, 2), List(3, 4), List(5, 6))',
    setupCode: 'val nested = List(List(1, 2), List(3, 4), List(5, 6))',
    expected: [1, 2, 3, 4, 5, 6],
    sample: 'for { inner <- nested; n <- inner } yield n',
    hints: ['Nested generators flatten', 'Equivalent to flatMap'],
    tags: ['for', 'flatten', 'nested'],
  },

  {
    id: 'scala-for-114',
    category: 'For Comprehensions',
    difficulty: 'hard',
    title: 'For with Future',
    text: 'Combine Futures with for.',
    setup:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval a = Future.successful(10)\nval b = Future.successful(20)',
    setupCode:
      'import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nval a = Future.successful(10)\nval b = Future.successful(20)',
    expected: 30,
    sample:
      'import scala.concurrent.Await\nimport scala.concurrent.duration._\nAwait.result(for { x <- a; y <- b } yield x + y, 1.second)',
    hints: ['Future in for is sequential', 'Start Futures before for for parallel'],
    tags: ['for', 'future', 'async'],
  },

  {
    id: 'scala-for-115',
    category: 'For Comprehensions',
    difficulty: 'hard',
    title: 'For Desugaring',
    text: 'Understand for desugaring.',
    setup: 'val numbers = List(1, 2, 3)',
    setupCode: 'val numbers = List(1, 2, 3)',
    expected: [2, 4, 6],
    sample: 'numbers.map(_ * 2)',
    hints: ['for-yield becomes map/flatMap', 'Guards become withFilter'],
    tags: ['for', 'desugar', 'map'],
  },

  {
    id: 'scala-for-116',
    category: 'For Comprehensions',
    difficulty: 'hard',
    title: 'Complex For Chain',
    text: 'Chain multiple monadic operations.',
    setup:
      'def parse(s: String): Option[Int] = s.toIntOption\ndef validate(n: Int): Option[Int] = if (n > 0) Some(n) else None\ndef double(n: Int): Option[Int] = Some(n * 2)',
    setupCode:
      'def parse(s: String): Option[Int] = s.toIntOption\ndef validate(n: Int): Option[Int] = if (n > 0) Some(n) else None\ndef double(n: Int): Option[Int] = Some(n * 2)',
    expected: 42,
    sample: '(for { p <- parse("21"); v <- validate(p); d <- double(v) } yield d).getOrElse(0)',
    hints: ['Chain dependent operations', 'Each step can fail'],
    tags: ['for', 'chain', 'monad'],
  },

  // ============================================================
  // NEW PROBLEMS - Partial Functions (25 problems)
  // ============================================================

  {
    id: 'scala-partial-100',
    category: 'Partial Functions',
    difficulty: 'easy',
    title: 'Basic Partial Function',
    text: 'Create partial function with case.',
    setup: 'val double: PartialFunction[Int, Int] = { case n if n > 0 => n * 2 }',
    setupCode: 'val double: PartialFunction[Int, Int] = { case n if n > 0 => n * 2 }',
    expected: 10,
    sample: 'double(5)',
    hints: ['case syntax creates PartialFunction', 'Only defined for some inputs'],
    tags: ['partial-function', 'case', 'basics'],
  },

  {
    id: 'scala-partial-101',
    category: 'Partial Functions',
    difficulty: 'easy',
    title: 'IsDefinedAt Check',
    text: 'Check if partial function is defined.',
    setup: 'val positive: PartialFunction[Int, Int] = { case n if n > 0 => n }',
    setupCode: 'val positive: PartialFunction[Int, Int] = { case n if n > 0 => n }',
    expected: false,
    sample: 'positive.isDefinedAt(-5)',
    hints: ['isDefinedAt tests domain', 'Safe check before apply'],
    tags: ['partial-function', 'isDefinedAt', 'check'],
  },

  {
    id: 'scala-partial-102',
    category: 'Partial Functions',
    difficulty: 'easy',
    title: 'Lift to Option',
    text: 'Lift partial function to return Option.',
    setup: 'val positive: PartialFunction[Int, Int] = { case n if n > 0 => n * 2 }',
    setupCode: 'val positive: PartialFunction[Int, Int] = { case n if n > 0 => n * 2 }',
    expected: 10,
    sample: 'positive.lift(5).getOrElse(0)',
    hints: ['lift returns Option', 'None for undefined inputs'],
    tags: ['partial-function', 'lift', 'option'],
  },

  {
    id: 'scala-partial-103',
    category: 'Partial Functions',
    difficulty: 'easy',
    title: 'Collect with Partial',
    text: 'Use collect with partial function.',
    setup: 'val numbers = List(-2, -1, 0, 1, 2)',
    setupCode: 'val numbers = List(-2, -1, 0, 1, 2)',
    expected: [2, 4],
    sample: 'numbers.collect { case n if n > 0 => n * 2 }',
    hints: ['collect filters and transforms', 'Only applies where defined'],
    tags: ['partial-function', 'collect', 'filter'],
  },

  {
    id: 'scala-partial-104',
    category: 'Partial Functions',
    difficulty: 'easy',
    title: 'OrElse Fallback',
    text: 'Chain partial functions with orElse.',
    setup:
      'val positive: PartialFunction[Int, String] = { case n if n > 0 => "positive" }\nval negative: PartialFunction[Int, String] = { case n if n < 0 => "negative" }',
    setupCode:
      'val positive: PartialFunction[Int, String] = { case n if n > 0 => "positive" }\nval negative: PartialFunction[Int, String] = { case n if n < 0 => "negative" }',
    expected: 'negative',
    sample: '(positive orElse negative)(-5)',
    hints: ['orElse tries second if first undefined', 'Chain multiple handlers'],
    tags: ['partial-function', 'orElse', 'chain'],
  },

  {
    id: 'scala-partial-105',
    category: 'Partial Functions',
    difficulty: 'medium',
    title: 'AndThen Compose',
    text: 'Compose partial function with andThen.',
    setup: 'val double: PartialFunction[Int, Int] = { case n if n > 0 => n * 2 }',
    setupCode: 'val double: PartialFunction[Int, Int] = { case n if n > 0 => n * 2 }',
    expected: '10',
    sample: '(double andThen (_.toString))(5)',
    hints: ['andThen chains after result', 'Transform output'],
    tags: ['partial-function', 'andThen', 'compose'],
  },

  {
    id: 'scala-partial-106',
    category: 'Partial Functions',
    difficulty: 'medium',
    title: 'Type Matching Partial',
    text: 'Match on type in partial function.',
    setup:
      'val stringify: PartialFunction[Any, String] = { case i: Int => s"Int: $i"; case s: String => s"String: $s" }',
    setupCode:
      'val stringify: PartialFunction[Any, String] = { case i: Int => s"Int: $i"; case s: String => s"String: $s" }',
    expected: 'Int: 42',
    sample: 'stringify(42)',
    hints: ['Type patterns in partial function', 'Match on runtime type'],
    tags: ['partial-function', 'type', 'matching'],
  },

  {
    id: 'scala-partial-107',
    category: 'Partial Functions',
    difficulty: 'medium',
    title: 'Unlift to Partial',
    text: 'Convert function returning Option to partial.',
    setup: 'val parsePositive: Int => Option[Int] = n => if (n > 0) Some(n) else None',
    setupCode: 'val parsePositive: Int => Option[Int] = n => if (n > 0) Some(n) else None',
    expected: 5,
    sample: 'Function.unlift(parsePositive)(5)',
    hints: ['unlift converts Option function', 'Inverse of lift'],
    tags: ['partial-function', 'unlift', 'option'],
  },

  {
    id: 'scala-partial-108',
    category: 'Partial Functions',
    difficulty: 'medium',
    title: 'Apply Or Else',
    text: 'Use applyOrElse for efficient fallback.',
    setup: 'val positive: PartialFunction[Int, Int] = { case n if n > 0 => n * 2 }',
    setupCode: 'val positive: PartialFunction[Int, Int] = { case n if n > 0 => n * 2 }',
    expected: 0,
    sample: 'positive.applyOrElse(-5, (_: Int) => 0)',
    hints: ['applyOrElse avoids double check', 'More efficient than isDefinedAt + apply'],
    tags: ['partial-function', 'applyOrElse', 'efficient'],
  },

  {
    id: 'scala-partial-109',
    category: 'Partial Functions',
    difficulty: 'medium',
    title: 'RunWith Handler',
    text: 'Use runWith for conditional execution.',
    setup: 'val positive: PartialFunction[Int, Int] = { case n if n > 0 => n * 2 }',
    setupCode: 'val positive: PartialFunction[Int, Int] = { case n if n > 0 => n * 2 }',
    expected: true,
    sample: 'var result = 0; positive.runWith(r => result = r)(5); result == 10',
    hints: ['runWith executes handler if defined', 'Returns Boolean for success'],
    tags: ['partial-function', 'runWith', 'handler'],
  },

  {
    id: 'scala-partial-110',
    category: 'Partial Functions',
    difficulty: 'hard',
    title: 'Extractor Partial Function',
    text: 'Use custom extractor in partial function.',
    setup:
      'object Even { def unapply(n: Int): Option[Int] = if (n % 2 == 0) Some(n / 2) else None }\nval halfEven: PartialFunction[Int, Int] = { case Even(half) => half }',
    setupCode:
      'object Even { def unapply(n: Int): Option[Int] = if (n % 2 == 0) Some(n / 2) else None }\nval halfEven: PartialFunction[Int, Int] = { case Even(half) => half }',
    expected: 5,
    sample: 'halfEven(10)',
    hints: ['Extractors in partial functions', 'Defined where extractor succeeds'],
    tags: ['partial-function', 'extractor', 'unapply'],
  },

  {
    id: 'scala-partial-111',
    category: 'Partial Functions',
    difficulty: 'hard',
    title: 'Multiple Case Clauses',
    text: 'Combine multiple cases in partial function.',
    setup:
      'val classify: PartialFunction[Int, String] = { case 0 => "zero"; case n if n > 0 => "positive"; case n if n < 0 => "negative" }',
    setupCode:
      'val classify: PartialFunction[Int, String] = { case 0 => "zero"; case n if n > 0 => "positive"; case n if n < 0 => "negative" }',
    expected: ['zero', 'positive', 'negative'],
    sample: 'List(0, 5, -3).map(classify)',
    hints: ['Multiple cases in one partial', 'First matching case wins'],
    tags: ['partial-function', 'cases', 'multiple'],
  },

  {
    id: 'scala-partial-112',
    category: 'Partial Functions',
    difficulty: 'hard',
    title: 'Composed Domain',
    text: 'Check composed partial function domain.',
    setup:
      'val a: PartialFunction[Int, Int] = { case n if n > 0 => n * 2 }\nval b: PartialFunction[Int, Int] = { case n if n < 0 => n * -1 }\nval combined = a orElse b',
    setupCode:
      'val a: PartialFunction[Int, Int] = { case n if n > 0 => n * 2 }\nval b: PartialFunction[Int, Int] = { case n if n < 0 => n * -1 }\nval combined = a orElse b',
    expected: [true, true, false],
    sample: 'List(5, -5, 0).map(combined.isDefinedAt)',
    hints: ['orElse combines domains', 'Union of defined inputs'],
    tags: ['partial-function', 'domain', 'compose'],
  },

  // ========================================
  // BEGINNER FUNDAMENTALS
  // ========================================
  {
    id: 'scala-beginner-loop-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Sum Numbers with For Loop',
    text: 'Use a for comprehension to sum all numbers from 1 to 10.',
    setup: '',
    setupCode: '',
    expected: 55,
    sample: '(1 to 10).sum',
    hints: [
      'Use (1 to 10) for inclusive range',
      'Use .sum method on collection',
      'Alternatively use foldLeft',
    ],
    tags: ['beginner', 'for-loop', 'sum'],
  },
  {
    id: 'scala-beginner-loop-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Count Even Numbers',
    text: 'Count how many even numbers are between 1 and 20.',
    setup: '',
    setupCode: '',
    expected: 10,
    sample: '(1 to 20).count(_ % 2 == 0)',
    hints: ['Use (1 to 20) for range', 'Use count with predicate', 'Even numbers have remainder 0'],
    tags: ['beginner', 'for-loop', 'conditionals'],
  },
  {
    id: 'scala-beginner-loop-003',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Build a String with Loop',
    text: 'Build a string "123456789" by concatenating numbers 1 through 9.',
    setup: '',
    setupCode: '',
    expected: '123456789',
    sample: '(1 to 9).mkString',
    hints: ['Use (1 to 9) for range', 'mkString joins elements', 'No separator needed'],
    tags: ['beginner', 'for-loop', 'strings'],
  },
  {
    id: 'scala-beginner-cond-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Check Positive or Negative',
    text: 'Use if/else to return "positive" if number is greater than 0, "negative" if less than 0, or "zero".',
    setup: 'val number = 5',
    setupCode: 'val number = 5',
    expected: 'positive',
    sample: 'if (number > 0) "positive" else if (number < 0) "negative" else "zero"',
    hints: [
      'Use if/else if/else chain',
      'if/else is an expression in Scala',
      'Returns String directly',
    ],
    tags: ['beginner', 'if-else', 'conditionals'],
  },
  {
    id: 'scala-beginner-cond-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Find Maximum of Two',
    text: 'Use if/else to return the larger of two numbers.',
    setup: 'val a = 15; val b = 8',
    setupCode: 'val a = 15; val b = 8',
    expected: 15,
    sample: 'if (a > b) a else b',
    hints: ['Compare a and b', 'Return larger value', 'Or use math.max(a, b)'],
    tags: ['beginner', 'if-else', 'comparison'],
  },
  {
    id: 'scala-beginner-cond-003',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Grade Calculator',
    text: 'Return letter grade: A for score >= 90, B for >= 80, C for >= 70, D for >= 60, F otherwise.',
    setup: 'val score = 85',
    setupCode: 'val score = 85',
    expected: 'B',
    sample:
      'if (score >= 90) "A" else if (score >= 80) "B" else if (score >= 70) "C" else if (score >= 60) "D" else "F"',
    hints: [
      'Check from highest to lowest',
      'Use if/else if chain',
      'Can also use match expression',
    ],
    tags: ['beginner', 'if-else', 'grades'],
  },
  {
    id: 'scala-beginner-list-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Create and Sum List',
    text: 'Create a List with values 1, 2, 3, 4, 5 and sum all elements.',
    setup: '',
    setupCode: '',
    expected: 15,
    sample: 'List(1, 2, 3, 4, 5).sum',
    hints: ['Use List() to create', 'Use .sum method', 'Works on numeric collections'],
    tags: ['beginner', 'list', 'sum'],
  },
  {
    id: 'scala-beginner-list-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Prepend and Get Length',
    text: 'Create a List(20, 30), prepend 10, and return its length.',
    setup: '',
    setupCode: '',
    expected: 3,
    sample: '(10 :: List(20, 30)).length',
    hints: ['Use :: to prepend', 'Use .length for size', 'Lists are immutable'],
    tags: ['beginner', 'list', 'prepend', 'length'],
  },
  {
    id: 'scala-beginner-map-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Create and Access Map',
    text: 'Create a Map with key "apple" -> 3 and return the value for "apple".',
    setup: '',
    setupCode: '',
    expected: 3,
    sample: 'Map("apple" -> 3)("apple")',
    hints: ['Use Map() with arrows', 'Access with key in parentheses', 'Or use .get for Option'],
    tags: ['beginner', 'map', 'access'],
  },
  {
    id: 'scala-beginner-map-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Count Map Entries',
    text: 'Create a Map with 3 fruit entries and return its size.',
    setup: '',
    setupCode: '',
    expected: 3,
    sample: 'Map("apple" -> 1, "banana" -> 2, "cherry" -> 3).size',
    hints: ['Create Map with multiple pairs', 'Use .size for count', 'Each pair is one entry'],
    tags: ['beginner', 'map', 'size'],
  },
  {
    id: 'scala-beginner-string-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'String Concatenation',
    text: 'Concatenate the strings "Hello, " and "World!" to form "Hello, World!".',
    setup: '',
    setupCode: '',
    expected: 'Hello, World!',
    sample: '"Hello, " + "World!"',
    hints: [
      'Use + operator for strings',
      'Or use string interpolation s"..."',
      'Concat is straightforward',
    ],
    tags: ['beginner', 'string', 'concatenation'],
  },
  {
    id: 'scala-beginner-string-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'String Length',
    text: 'Return the length of the string "Scala".',
    setup: '',
    setupCode: '',
    expected: 5,
    sample: '"Scala".length',
    hints: ['Use .length method', 'Returns number of characters', 'Works on any string'],
    tags: ['beginner', 'string', 'length'],
  },
  {
    id: 'scala-beginner-while-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Basic While Loop',
    text: 'Use a while loop to sum numbers from 1 to 5 and return the total.',
    setup: '',
    setupCode: '',
    expected: 15,
    sample: 'var sum = 0; var i = 1; while (i <= 5) { sum += i; i += 1 }; sum',
    hints: [
      'Use var for mutable variables',
      'while (condition) { body }',
      'Increment counter inside loop',
    ],
    tags: ['beginner', 'while', 'loop', 'sum'],
  },
  {
    id: 'scala-beginner-list-adv-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'List Max',
    text: 'Find the maximum value in List(3, 7, 2, 9, 4).',
    setup: '',
    setupCode: '',
    expected: 9,
    sample: 'List(3, 7, 2, 9, 4).max',
    hints: ['Use .max method', 'Works on any comparable collection', 'Throws exception if empty'],
    tags: ['beginner', 'list', 'max'],
  },
  {
    id: 'scala-beginner-list-adv-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'List Contains',
    text: 'Check if List(10, 20, 30, 40) contains the value 30.',
    setup: '',
    setupCode: '',
    expected: true,
    sample: 'List(10, 20, 30, 40).contains(30)',
    hints: ['Use .contains() method', 'Pass the value directly', 'Returns Boolean'],
    tags: ['beginner', 'list', 'contains'],
  },
  {
    id: 'scala-beginner-list-adv-003',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'List Filter',
    text: 'Filter List(1, 2, 3, 4, 5, 6) to keep only even numbers and return the resulting list.',
    setup: '',
    setupCode: '',
    expected: [2, 4, 6],
    sample: 'List(1, 2, 3, 4, 5, 6).filter(_ % 2 == 0)',
    hints: ['Use .filter() method', 'Pass a predicate function', '_ % 2 == 0 checks for even'],
    tags: ['beginner', 'list', 'filter'],
  },
];

export default scalaProblems;
