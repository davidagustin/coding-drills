/**
 * Clojure coding drill problems
 * Covers Sequence Functions, Collection Functions, String Functions,
 * Higher Order Functions, and Threading Macros
 */

import type { Problem } from '../types';

export const clojureProblems: Problem[] = [
  // ============================================================
  // Sequence Functions (12 problems: 5 easy, 5 medium, 2 hard)
  // ============================================================

  // map
  {
    id: 'clojure-seq-001',
    category: 'Sequence Functions',
    difficulty: 'easy',
    title: 'Double Numbers with map',
    text: 'Use the `map` function to double each number in the vector.',
    setup: '(def numbers [1 2 3 4 5])',
    setupCode: '(def numbers [1 2 3 4 5])',
    expected: [2, 4, 6, 8, 10],
    sample: '(map #(* 2 %) numbers)',
    hints: ['map applies a function to each element', 'Use #(* 2 %) or (fn [x] (* 2 x))'],
    validPatterns: [/map/, /\*\s*2/],
    tags: ['map', 'sequences', 'transform'],
  },
  {
    id: 'clojure-seq-002',
    category: 'Sequence Functions',
    difficulty: 'easy',
    title: 'Convert to Strings with map',
    text: 'Use `map` with `str` to convert each number to a string.',
    setup: '(def numbers [1 2 3])',
    setupCode: '(def numbers [1 2 3])',
    expected: ['1', '2', '3'],
    sample: '(map str numbers)',
    hints: ['str converts values to strings', 'map can use named functions directly'],
    validPatterns: [/map\s+str/],
    tags: ['map', 'str', 'conversion'],
  },

  // filter
  {
    id: 'clojure-seq-003',
    category: 'Sequence Functions',
    difficulty: 'easy',
    title: 'Filter Even Numbers',
    text: 'Use the `filter` function to keep only even numbers.',
    setup: '(def numbers [1 2 3 4 5 6])',
    setupCode: '(def numbers [1 2 3 4 5 6])',
    expected: [2, 4, 6],
    sample: '(filter even? numbers)',
    hints: ['filter keeps elements where predicate returns true', 'even? checks for even numbers'],
    validPatterns: [/filter\s+even\?/],
    tags: ['filter', 'even?', 'sequences'],
  },
  {
    id: 'clojure-seq-004',
    category: 'Sequence Functions',
    difficulty: 'medium',
    title: 'Filter with Custom Predicate',
    text: 'Use `filter` to keep only numbers greater than 5.',
    setup: '(def numbers [3 7 2 9 4 8])',
    setupCode: '(def numbers [3 7 2 9 4 8])',
    expected: [7, 9, 8],
    sample: '(filter #(> % 5) numbers)',
    hints: ['Use anonymous function #(> % 5)', 'Or use partial: (partial < 5)'],
    validPatterns: [/filter/, />\s*%\s*5|>\s*5/],
    tags: ['filter', 'predicate', 'sequences'],
  },

  // reduce
  {
    id: 'clojure-seq-005',
    category: 'Sequence Functions',
    difficulty: 'easy',
    title: 'Sum with reduce',
    text: 'Use `reduce` with `+` to calculate the sum of all numbers.',
    setup: '(def numbers [1 2 3 4 5])',
    setupCode: '(def numbers [1 2 3 4 5])',
    expected: 15,
    sample: '(reduce + numbers)',
    hints: ['reduce accumulates a value', '+ can take multiple arguments'],
    validPatterns: [/reduce\s+\+/],
    tags: ['reduce', 'sum', 'sequences'],
  },
  {
    id: 'clojure-seq-006',
    category: 'Sequence Functions',
    difficulty: 'medium',
    title: 'Product with reduce',
    text: 'Use `reduce` with `*` to calculate the product of all numbers.',
    setup: '(def numbers [1 2 3 4])',
    setupCode: '(def numbers [1 2 3 4])',
    expected: 24,
    sample: '(reduce * numbers)',
    hints: ['Use * for multiplication', 'reduce applies function cumulatively'],
    validPatterns: [/reduce\s+\*/],
    tags: ['reduce', 'product', 'sequences'],
  },
  {
    id: 'clojure-seq-007',
    category: 'Sequence Functions',
    difficulty: 'hard',
    title: 'Build Map with reduce',
    text: 'Use `reduce` to count occurrences of each element.',
    setup: '(def letters ["a" "b" "a" "c" "b" "a"])',
    setupCode: '(def letters ["a" "b" "a" "c" "b" "a"])',
    expected: { a: 3, b: 2, c: 1 },
    sample: '(reduce #(update %1 %2 (fnil inc 0)) {} letters)',
    hints: ['Use update with fnil to handle missing keys', 'Start with empty map {}'],
    validPatterns: [/reduce/, /update/, /fnil|inc/],
    tags: ['reduce', 'frequencies', 'map-building'],
  },

  // take / drop
  {
    id: 'clojure-seq-008',
    category: 'Sequence Functions',
    difficulty: 'easy',
    title: 'Take First N Elements',
    text: 'Use `take` to get the first 3 elements from the sequence.',
    setup: '(def numbers [1 2 3 4 5])',
    setupCode: '(def numbers [1 2 3 4 5])',
    expected: [1, 2, 3],
    sample: '(take 3 numbers)',
    hints: ['take returns first n elements', 'Returns lazy sequence'],
    validPatterns: [/take\s+3/],
    tags: ['take', 'sequences', 'slice'],
  },
  {
    id: 'clojure-seq-009',
    category: 'Sequence Functions',
    difficulty: 'medium',
    title: 'Drop First N Elements',
    text: 'Use `drop` to skip the first 2 elements.',
    setup: '(def numbers [1 2 3 4 5])',
    setupCode: '(def numbers [1 2 3 4 5])',
    expected: [3, 4, 5],
    sample: '(drop 2 numbers)',
    hints: ['drop skips first n elements', 'Returns remaining elements'],
    validPatterns: [/drop\s+2/],
    tags: ['drop', 'sequences', 'slice'],
  },

  // first / rest / cons
  {
    id: 'clojure-seq-010',
    category: 'Sequence Functions',
    difficulty: 'medium',
    title: 'Get Rest of Sequence',
    text: 'Use `rest` to get all elements except the first.',
    setup: '(def numbers [1 2 3 4])',
    setupCode: '(def numbers [1 2 3 4])',
    expected: [2, 3, 4],
    sample: '(rest numbers)',
    hints: ['rest returns sequence without first element', 'Returns empty list for single element'],
    validPatterns: [/rest\s+numbers/],
    tags: ['rest', 'sequences', 'slice'],
  },
  {
    id: 'clojure-seq-011',
    category: 'Sequence Functions',
    difficulty: 'medium',
    title: 'Prepend with cons',
    text: 'Use `cons` to add 0 to the front of the sequence.',
    setup: '(def numbers [1 2 3])',
    setupCode: '(def numbers [1 2 3])',
    expected: [0, 1, 2, 3],
    sample: '(cons 0 numbers)',
    hints: ['cons constructs a new sequence', 'First arg is new head element'],
    validPatterns: [/cons\s+0/],
    tags: ['cons', 'sequences', 'prepend'],
  },
  {
    id: 'clojure-seq-012',
    category: 'Sequence Functions',
    difficulty: 'hard',
    title: 'Partition Sequence',
    text: 'Use `partition` to split sequence into pairs.',
    setup: '(def numbers [1 2 3 4 5 6])',
    setupCode: '(def numbers [1 2 3 4 5 6])',
    expected: [
      [1, 2],
      [3, 4],
      [5, 6],
    ],
    sample: '(partition 2 numbers)',
    hints: ['partition splits into groups of n', 'Returns lazy sequence of lists'],
    validPatterns: [/partition\s+2/],
    tags: ['partition', 'sequences', 'grouping'],
  },

  // ============================================================
  // Collection Functions (10 problems: 4 easy, 4 medium, 2 hard)
  // ============================================================

  // conj
  {
    id: 'clojure-coll-001',
    category: 'Collection Functions',
    difficulty: 'easy',
    title: 'Add to Vector with conj',
    text: 'Use `conj` to add 4 to the end of the vector.',
    setup: '(def numbers [1 2 3])',
    setupCode: '(def numbers [1 2 3])',
    expected: [1, 2, 3, 4],
    sample: '(conj numbers 4)',
    hints: ['conj adds to efficient end', 'For vectors, adds to the back'],
    validPatterns: [/conj\s+numbers\s+4/],
    tags: ['conj', 'vector', 'append'],
  },
  {
    id: 'clojure-coll-002',
    category: 'Collection Functions',
    difficulty: 'medium',
    title: 'Add Multiple with conj',
    text: 'Use `conj` to add 4, 5, and 6 to the vector.',
    setup: '(def numbers [1 2 3])',
    setupCode: '(def numbers [1 2 3])',
    expected: [1, 2, 3, 4, 5, 6],
    sample: '(conj numbers 4 5 6)',
    hints: ['conj can take multiple values', 'Values are added in order'],
    validPatterns: [/conj\s+numbers\s+4\s+5\s+6/],
    tags: ['conj', 'vector', 'multiple'],
  },

  // assoc
  {
    id: 'clojure-coll-003',
    category: 'Collection Functions',
    difficulty: 'easy',
    title: 'Add Key to Map with assoc',
    text: 'Use `assoc` to add :age 30 to the person map.',
    setup: '(def person {:name "Alice"})',
    setupCode: '(def person {:name "Alice"})',
    expected: { name: 'Alice', age: 30 },
    sample: '(assoc person :age 30)',
    hints: ['assoc associates a key with a value', 'Returns new map'],
    validPatterns: [/assoc\s+person\s+:age\s+30/],
    tags: ['assoc', 'map', 'add-key'],
  },
  {
    id: 'clojure-coll-004',
    category: 'Collection Functions',
    difficulty: 'medium',
    title: 'Update Vector at Index',
    text: 'Use `assoc` to set index 1 to 20.',
    setup: '(def numbers [1 2 3])',
    setupCode: '(def numbers [1 2 3])',
    expected: [1, 20, 3],
    sample: '(assoc numbers 1 20)',
    hints: ['assoc works on vectors too', 'Index must exist'],
    validPatterns: [/assoc\s+numbers\s+1\s+20/],
    tags: ['assoc', 'vector', 'index'],
  },

  // dissoc
  {
    id: 'clojure-coll-005',
    category: 'Collection Functions',
    difficulty: 'easy',
    title: 'Remove Key with dissoc',
    text: 'Use `dissoc` to remove :age from the map.',
    setup: '(def person {:name "Alice" :age 30})',
    setupCode: '(def person {:name "Alice" :age 30})',
    expected: { name: 'Alice' },
    sample: '(dissoc person :age)',
    hints: ['dissoc removes a key', 'Returns new map without key'],
    validPatterns: [/dissoc\s+person\s+:age/],
    tags: ['dissoc', 'map', 'remove'],
  },
  {
    id: 'clojure-coll-006',
    category: 'Collection Functions',
    difficulty: 'medium',
    title: 'Remove Multiple Keys',
    text: 'Use `dissoc` to remove both :age and :city from the map.',
    setup: '(def person {:name "Alice" :age 30 :city "NYC"})',
    setupCode: '(def person {:name "Alice" :age 30 :city "NYC"})',
    expected: { name: 'Alice' },
    sample: '(dissoc person :age :city)',
    hints: ['dissoc can take multiple keys', 'All specified keys removed'],
    validPatterns: [/dissoc\s+person\s+:age\s+:city/],
    tags: ['dissoc', 'map', 'multiple'],
  },

  // get
  {
    id: 'clojure-coll-007',
    category: 'Collection Functions',
    difficulty: 'easy',
    title: 'Get Value from Map',
    text: 'Use `get` to retrieve the :name value from the map.',
    setup: '(def person {:name "Alice" :age 30})',
    setupCode: '(def person {:name "Alice" :age 30})',
    expected: 'Alice',
    sample: '(get person :name)',
    hints: ['get retrieves value for key', 'Returns nil if key not found'],
    validPatterns: [/get\s+person\s+:name|:name\s+person|\(person\s+:name\)/],
    tags: ['get', 'map', 'access'],
  },
  {
    id: 'clojure-coll-008',
    category: 'Collection Functions',
    difficulty: 'hard',
    title: 'Get Nested Value with get-in',
    text: 'Use `get-in` to retrieve the nested :name value.',
    setup: '(def data {:user {:profile {:name "Alice"}}})',
    setupCode: '(def data {:user {:profile {:name "Alice"}}})',
    expected: 'Alice',
    sample: '(get-in data [:user :profile :name])',
    hints: ['get-in takes path as vector', 'Safely navigates nested structures'],
    validPatterns: [/get-in\s+data\s+\[:user\s+:profile\s+:name\]/],
    tags: ['get-in', 'map', 'nested'],
  },

  // count / empty?
  {
    id: 'clojure-coll-009',
    category: 'Collection Functions',
    difficulty: 'medium',
    title: 'Count Elements',
    text: 'Use `count` to get the number of elements in the vector.',
    setup: '(def numbers [1 2 3 4 5])',
    setupCode: '(def numbers [1 2 3 4 5])',
    expected: 5,
    sample: '(count numbers)',
    hints: ['count returns number of elements', 'Works on any collection'],
    validPatterns: [/count\s+numbers/],
    tags: ['count', 'collection', 'size'],
  },
  {
    id: 'clojure-coll-010',
    category: 'Collection Functions',
    difficulty: 'hard',
    title: 'Update Nested Value',
    text: 'Use `update-in` to increment the nested :count value.',
    setup: '(def data {:stats {:count 5}})',
    setupCode: '(def data {:stats {:count 5}})',
    expected: { stats: { count: 6 } },
    sample: '(update-in data [:stats :count] inc)',
    hints: ['update-in takes path and function', 'inc increments by 1'],
    validPatterns: [/update-in\s+data\s+\[:stats\s+:count\]\s+inc/],
    tags: ['update-in', 'nested', 'map'],
  },

  // ============================================================
  // String Functions (10 problems: 4 easy, 4 medium, 2 hard)
  // ============================================================

  // str
  {
    id: 'clojure-str-001',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Concatenate Strings with str',
    text: 'Use `str` to concatenate "Hello" and "World" with a space.',
    setup: '(def greeting "Hello")\n(def name "World")',
    setupCode: '(def greeting "Hello")\n(def name "World")',
    expected: 'Hello World',
    sample: '(str greeting " " name)',
    hints: ['str concatenates any values as strings', 'Works with multiple arguments'],
    validPatterns: [/str\s+greeting\s+" "\s+name/],
    tags: ['str', 'concatenate', 'strings'],
  },
  {
    id: 'clojure-str-002',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Convert to String',
    text: 'Use `str` to convert the number to a string.',
    setup: '(def num 42)',
    setupCode: '(def num 42)',
    expected: '42',
    sample: '(str num)',
    hints: ['str converts any value to string', 'Works with numbers, keywords, etc'],
    validPatterns: [/str\s+num/],
    tags: ['str', 'conversion', 'strings'],
  },

  // subs
  {
    id: 'clojure-str-003',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Substring from Start',
    text: 'Use `subs` to get characters from index 0 to 5.',
    setup: '(def text "Hello World")',
    setupCode: '(def text "Hello World")',
    expected: 'Hello',
    sample: '(subs text 0 5)',
    hints: ['subs takes start and end indices', 'End index is exclusive'],
    validPatterns: [/subs\s+text\s+0\s+5/],
    tags: ['subs', 'substring', 'strings'],
  },
  {
    id: 'clojure-str-004',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Substring to End',
    text: 'Use `subs` to get everything from index 6 onwards.',
    setup: '(def text "Hello World")',
    setupCode: '(def text "Hello World")',
    expected: 'World',
    sample: '(subs text 6)',
    hints: ['subs with one index goes to end', 'Omit end parameter'],
    validPatterns: [/subs\s+text\s+6/],
    tags: ['subs', 'substring', 'strings'],
  },

  // clojure.string/split
  {
    id: 'clojure-str-005',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Split String by Space',
    text: 'Use `clojure.string/split` to split the string into words.',
    setup: '(require \'[clojure.string :as str])\n(def text "hello world clojure")',
    setupCode: '(require \'[clojure.string :as str])\n(def text "hello world clojure")',
    expected: ['hello', 'world', 'clojure'],
    sample: '(str/split text #" ")',
    hints: ['split takes a regex pattern', 'Use #" " for space'],
    validPatterns: [/split\s+text\s+#" "/],
    tags: ['split', 'strings', 'regex'],
  },
  {
    id: 'clojure-str-006',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Split by Comma',
    text: 'Use `clojure.string/split` to parse CSV values.',
    setup: '(require \'[clojure.string :as str])\n(def csv "a,b,c,d")',
    setupCode: '(require \'[clojure.string :as str])\n(def csv "a,b,c,d")',
    expected: ['a', 'b', 'c', 'd'],
    sample: '(str/split csv #",")',
    hints: ['Use regex #"," for comma', 'Returns vector of strings'],
    validPatterns: [/split\s+csv\s+#","/],
    tags: ['split', 'csv', 'strings'],
  },

  // clojure.string/join
  {
    id: 'clojure-str-007',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Join with Separator',
    text: 'Use `clojure.string/join` to combine words with a dash.',
    setup: '(require \'[clojure.string :as str])\n(def words ["hello" "world"])',
    setupCode: '(require \'[clojure.string :as str])\n(def words ["hello" "world"])',
    expected: 'hello-world',
    sample: '(str/join "-" words)',
    hints: ['join takes separator and collection', 'Separator goes first'],
    validPatterns: [/join\s+"-"\s+words/],
    tags: ['join', 'strings', 'concatenate'],
  },
  {
    id: 'clojure-str-008',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Join without Separator',
    text: 'Use `clojure.string/join` to combine characters without separator.',
    setup: '(require \'[clojure.string :as str])\n(def chars ["a" "b" "c"])',
    setupCode: '(require \'[clojure.string :as str])\n(def chars ["a" "b" "c"])',
    expected: 'abc',
    sample: '(str/join chars)',
    hints: ['join without separator concatenates directly', 'Or use empty string ""'],
    validPatterns: [/join\s+chars|join\s+""\s+chars/],
    tags: ['join', 'strings', 'concatenate'],
  },

  // clojure.string/replace
  {
    id: 'clojure-str-009',
    category: 'String Functions',
    difficulty: 'hard',
    title: 'Replace All Occurrences',
    text: 'Use `clojure.string/replace` to replace all spaces with underscores.',
    setup: '(require \'[clojure.string :as str])\n(def text "hello world clojure")',
    setupCode: '(require \'[clojure.string :as str])\n(def text "hello world clojure")',
    expected: 'hello_world_clojure',
    sample: '(str/replace text " " "_")',
    hints: ['replace replaces all occurrences', 'Can use string or regex pattern'],
    validPatterns: [/replace\s+text\s+" "\s+"_"/],
    tags: ['replace', 'strings', 'substitute'],
  },
  {
    id: 'clojure-str-010',
    category: 'String Functions',
    difficulty: 'hard',
    title: 'Replace with Regex',
    text: 'Use `clojure.string/replace` with regex to remove all digits.',
    setup: '(require \'[clojure.string :as str])\n(def text "a1b2c3")',
    setupCode: '(require \'[clojure.string :as str])\n(def text "a1b2c3")',
    expected: 'abc',
    sample: '(str/replace text #"\\d" "")',
    hints: ['Use regex #"\\d" for digits', 'Replace with empty string'],
    validPatterns: [/replace\s+text\s+#"\\d"\s+""/],
    tags: ['replace', 'regex', 'strings'],
  },

  // ============================================================
  // Higher Order Functions (9 problems: 3 easy, 4 medium, 2 hard)
  // ============================================================

  // partial
  {
    id: 'clojure-hof-001',
    category: 'Higher Order Functions',
    difficulty: 'medium',
    title: 'Create Adder with partial',
    text: 'Use `partial` to create a function that adds 10 to any number.',
    setup: '(def x 5)',
    setupCode: '(def x 5)',
    expected: 15,
    sample: '((partial + 10) x)',
    hints: ['partial fixes some arguments', 'Returns a new function'],
    validPatterns: [/partial\s+\+\s+10/],
    tags: ['partial', 'currying', 'higher-order'],
  },
  {
    id: 'clojure-hof-002',
    category: 'Higher Order Functions',
    difficulty: 'medium',
    title: 'Partial with str',
    text: 'Use `partial` to create a greeter that prepends "Hello, ".',
    setup: '(def name "World")',
    setupCode: '(def name "World")',
    expected: 'Hello, World',
    sample: '((partial str "Hello, ") name)',
    hints: ['partial works with any function', 'str concatenates strings'],
    validPatterns: [/partial\s+str\s+"Hello, "/],
    tags: ['partial', 'str', 'higher-order'],
  },

  // comp
  {
    id: 'clojure-hof-003',
    category: 'Higher Order Functions',
    difficulty: 'medium',
    title: 'Compose Two Functions',
    text: 'Use `comp` to create a function that increments then doubles.',
    setup: '(def x 5)',
    setupCode: '(def x 5)',
    expected: 12,
    sample: '((comp #(* 2 %) inc) x)',
    hints: ['comp applies functions right to left', 'inc then double: (5+1)*2=12'],
    validPatterns: [/comp/, /\*\s*2/, /inc/],
    tags: ['comp', 'composition', 'higher-order'],
  },
  {
    id: 'clojure-hof-004',
    category: 'Higher Order Functions',
    difficulty: 'hard',
    title: 'Compose Multiple Functions',
    text: 'Use `comp` to reverse, uppercase, then get first character.',
    setup: '(require \'[clojure.string :as str])\n(def text "hello")',
    setupCode: '(require \'[clojure.string :as str])\n(def text "hello")',
    expected: 'O',
    sample: '((comp first str/upper-case str/reverse) text)',
    hints: ['comp applies right to left', 'reverse -> uppercase -> first'],
    validPatterns: [/comp/, /first/, /upper-case/, /reverse/],
    tags: ['comp', 'string', 'composition'],
  },

  // juxt
  {
    id: 'clojure-hof-005',
    category: 'Higher Order Functions',
    difficulty: 'medium',
    title: 'Apply Multiple Functions with juxt',
    text: 'Use `juxt` to get both first and last elements at once.',
    setup: '(def numbers [1 2 3 4 5])',
    setupCode: '(def numbers [1 2 3 4 5])',
    expected: [1, 5],
    sample: '((juxt first last) numbers)',
    hints: ['juxt returns vector of results', 'Each function applied to same input'],
    validPatterns: [/juxt\s+first\s+last/],
    tags: ['juxt', 'multiple', 'higher-order'],
  },
  {
    id: 'clojure-hof-006',
    category: 'Higher Order Functions',
    difficulty: 'hard',
    title: 'Extract Multiple Values with juxt',
    text: 'Use `juxt` to extract :name and :age from the map.',
    setup: '(def person {:name "Alice" :age 30 :city "NYC"})',
    setupCode: '(def person {:name "Alice" :age 30 :city "NYC"})',
    expected: ['Alice', 30],
    sample: '((juxt :name :age) person)',
    hints: ['Keywords are functions', 'juxt applies each keyword as getter'],
    validPatterns: [/juxt\s+:name\s+:age/],
    tags: ['juxt', 'keywords', 'map-access'],
  },

  // apply
  {
    id: 'clojure-hof-007',
    category: 'Higher Order Functions',
    difficulty: 'easy',
    title: 'Apply Function to Collection',
    text: 'Use `apply` to find the maximum value in the vector.',
    setup: '(def numbers [3 1 4 1 5 9 2 6])',
    setupCode: '(def numbers [3 1 4 1 5 9 2 6])',
    expected: 9,
    sample: '(apply max numbers)',
    hints: ['apply spreads collection as args', 'max takes multiple args'],
    validPatterns: [/apply\s+max/],
    tags: ['apply', 'max', 'higher-order'],
  },
  {
    id: 'clojure-hof-008',
    category: 'Higher Order Functions',
    difficulty: 'easy',
    title: 'Apply str for Concatenation',
    text: 'Use `apply` with `str` to join all strings.',
    setup: '(def words ["Hello" " " "World"])',
    setupCode: '(def words ["Hello" " " "World"])',
    expected: 'Hello World',
    sample: '(apply str words)',
    hints: ['apply spreads args to str', 'str concatenates all args'],
    validPatterns: [/apply\s+str/],
    tags: ['apply', 'str', 'concatenate'],
  },
  {
    id: 'clojure-hof-009',
    category: 'Higher Order Functions',
    difficulty: 'easy',
    title: 'Apply min to Find Minimum',
    text: 'Use `apply` with `min` to find the smallest number.',
    setup: '(def numbers [5 2 8 1 9])',
    setupCode: '(def numbers [5 2 8 1 9])',
    expected: 1,
    sample: '(apply min numbers)',
    hints: ['apply spreads collection as args', 'min finds smallest value'],
    validPatterns: [/apply\s+min/],
    tags: ['apply', 'min', 'higher-order'],
  },

  // ============================================================
  // Threading Macros (9 problems: 4 easy, 3 medium, 2 hard)
  // ============================================================

  // -> (thread-first)
  {
    id: 'clojure-thread-001',
    category: 'Threading Macros',
    difficulty: 'easy',
    title: 'Thread-First Basic',
    text: 'Use `->` to increment a number and then double it.',
    setup: '(def x 5)',
    setupCode: '(def x 5)',
    expected: 12,
    sample: '(-> x inc (* 2))',
    hints: ['-> threads as first argument', 'inc then (* 2) = (5+1)*2'],
    validPatterns: [/->\s+x\s+inc/, /\*\s*2/],
    tags: ['->', 'thread-first', 'pipeline'],
  },
  {
    id: 'clojure-thread-002',
    category: 'Threading Macros',
    difficulty: 'easy',
    title: 'Thread-First with Maps',
    text: 'Use `->` to add :age 30 to the person map.',
    setup: '(def person {:name "Alice"})',
    setupCode: '(def person {:name "Alice"})',
    expected: { name: 'Alice', age: 30 },
    sample: '(-> person (assoc :age 30))',
    hints: ['-> inserts as first arg', 'assoc adds key-value pair'],
    validPatterns: [/->\s+person/, /assoc\s+:age\s+30/],
    tags: ['->', 'maps', 'pipeline'],
  },
  {
    id: 'clojure-thread-003',
    category: 'Threading Macros',
    difficulty: 'medium',
    title: 'Thread-First Chain',
    text: 'Use `->` to update a map: add :age, then dissoc :temp.',
    setup: '(def person {:name "Alice" :temp true})',
    setupCode: '(def person {:name "Alice" :temp true})',
    expected: { name: 'Alice', age: 30 },
    sample: '(-> person (assoc :age 30) (dissoc :temp))',
    hints: ['-> chains map operations', 'Each form gets result of previous'],
    validPatterns: [/->\s+person/, /assoc\s+:age\s+30/, /dissoc\s+:temp/],
    tags: ['->', 'maps', 'pipeline'],
  },

  // ->> (thread-last)
  {
    id: 'clojure-thread-004',
    category: 'Threading Macros',
    difficulty: 'easy',
    title: 'Thread-Last with Filter',
    text: 'Use `->>` to filter even numbers from the sequence.',
    setup: '(def numbers [1 2 3 4 5 6])',
    setupCode: '(def numbers [1 2 3 4 5 6])',
    expected: [2, 4, 6],
    sample: '(->> numbers (filter even?))',
    hints: ['->> threads as last argument', 'Sequence functions take coll last'],
    validPatterns: [/->>\s+numbers/, /filter\s+even\?/],
    tags: ['->>', 'thread-last', 'sequences'],
  },
  {
    id: 'clojure-thread-005',
    category: 'Threading Macros',
    difficulty: 'easy',
    title: 'Thread-Last with Map',
    text: 'Use `->>` to double all numbers in the sequence.',
    setup: '(def numbers [1 2 3 4 5])',
    setupCode: '(def numbers [1 2 3 4 5])',
    expected: [2, 4, 6, 8, 10],
    sample: '(->> numbers (map #(* 2 %)))',
    hints: ['->> inserts as last arg', 'map takes function then collection'],
    validPatterns: [/->>\s+numbers/, /map/],
    tags: ['->>', 'thread-last', 'sequences'],
  },
  {
    id: 'clojure-thread-006',
    category: 'Threading Macros',
    difficulty: 'medium',
    title: 'Thread-Last Pipeline',
    text: 'Use `->>` to filter even, then double, then sum.',
    setup: '(def numbers [1 2 3 4 5 6])',
    setupCode: '(def numbers [1 2 3 4 5 6])',
    expected: 24,
    sample: '(->> numbers (filter even?) (map #(* 2 %)) (reduce +))',
    hints: ['->> chains sequence operations', '(2+4+6)*2 = 24'],
    validPatterns: [/->>\s+numbers/, /filter\s+even\?/, /map/, /reduce\s+\+/],
    tags: ['->>', 'pipeline', 'sequences'],
  },
  {
    id: 'clojure-thread-007',
    category: 'Threading Macros',
    difficulty: 'medium',
    title: 'Thread-Last with Take',
    text: 'Use `->>` to take first 3 elements, then sum them.',
    setup: '(def numbers [1 2 3 4 5])',
    setupCode: '(def numbers [1 2 3 4 5])',
    expected: 6,
    sample: '(->> numbers (take 3) (reduce +))',
    hints: ['take returns first n elements', '1 + 2 + 3 = 6'],
    validPatterns: [/->>\s+numbers/, /take\s+3/, /reduce\s+\+/],
    tags: ['->>', 'take', 'reduce'],
  },
  {
    id: 'clojure-thread-008',
    category: 'Threading Macros',
    difficulty: 'hard',
    title: 'Complex Thread-Last',
    text: 'Use `->>` to process: filter > 2, take 3, map to strings, join with comma.',
    setup: "(require '[clojure.string :as str])\n(def numbers [1 2 3 4 5 6 7])",
    setupCode: "(require '[clojure.string :as str])\n(def numbers [1 2 3 4 5 6 7])",
    expected: '3,4,5',
    sample: '(->> numbers (filter #(> % 2)) (take 3) (map str) (str/join ","))',
    hints: ['Chain multiple operations', 'join takes separator first'],
    validPatterns: [/->>\s+numbers/, /filter/, /take\s+3/, /map\s+str/, /join/],
    tags: ['->>', 'complex', 'strings'],
  },
  {
    id: 'clojure-thread-009',
    category: 'Threading Macros',
    difficulty: 'hard',
    title: 'Thread with some-> for nil safety',
    text: 'Use `some->` to safely navigate nested map that might have nil.',
    setup: '(require \'[clojure.string :as str])\n(def data {:user {:profile {:name "alice"}}})',
    setupCode:
      '(require \'[clojure.string :as str])\n(def data {:user {:profile {:name "alice"}}})',
    expected: 'ALICE',
    sample: '(some-> data :user :profile :name str/upper-case)',
    hints: ['some-> short-circuits on nil', 'Safe navigation pattern'],
    validPatterns: [/some->\s+data/, /:user/, /:profile/, /:name/, /upper-case/],
    tags: ['some->', 'nil-safe', 'nested'],
  },
];

export default clojureProblems;
