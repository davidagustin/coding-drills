/**
 * Clojure coding drill problems
 * Covers Sequence Functions, Collection Functions, String Functions,
 * Higher Order Functions, and Threading Macros
 */

import type { Problem } from '../types';

export const clojureProblems: Problem[] = [
  // ============================================================
  // Sequence Functions (12 problems: 5 easy, 5 medium, 2 hard)
  // ============================================================

  // map
  {
    id: 'clojure-seq-001',
    category: 'Sequence Functions',
    difficulty: 'easy',
    title: 'Double Numbers with map',
    text: 'Use the `map` function to double each number in the vector.',
    setup: '(def numbers [1 2 3 4 5])',
    setupCode: '(def numbers [1 2 3 4 5])',
    expected: [2, 4, 6, 8, 10],
    sample: '(map #(* 2 %) numbers)',
    hints: ['map applies a function to each element', 'Use #(* 2 %) or (fn [x] (* 2 x))'],
    validPatterns: [/map/, /\*\s*2/],
    tags: ['map', 'sequences', 'transform'],
  },
  {
    id: 'clojure-seq-002',
    category: 'Sequence Functions',
    difficulty: 'easy',
    title: 'Convert to Strings with map',
    text: 'Use `map` with `str` to convert each number to a string.',
    setup: '(def numbers [1 2 3])',
    setupCode: '(def numbers [1 2 3])',
    expected: ['1', '2', '3'],
    sample: '(map str numbers)',
    hints: ['str converts values to strings', 'map can use named functions directly'],
    validPatterns: [/map\s+str/],
    tags: ['map', 'str', 'conversion'],
  },

  // filter
  {
    id: 'clojure-seq-003',
    category: 'Sequence Functions',
    difficulty: 'easy',
    title: 'Filter Even Numbers',
    text: 'Use the `filter` function to keep only even numbers.',
    setup: '(def numbers [1 2 3 4 5 6])',
    setupCode: '(def numbers [1 2 3 4 5 6])',
    expected: [2, 4, 6],
    sample: '(filter even? numbers)',
    hints: ['filter keeps elements where predicate returns true', 'even? checks for even numbers'],
    validPatterns: [/filter\s+even\?/],
    tags: ['filter', 'even?', 'sequences'],
  },
  {
    id: 'clojure-seq-004',
    category: 'Sequence Functions',
    difficulty: 'medium',
    title: 'Filter with Custom Predicate',
    text: 'Use `filter` to keep only numbers greater than 5.',
    setup: '(def numbers [3 7 2 9 4 8])',
    setupCode: '(def numbers [3 7 2 9 4 8])',
    expected: [7, 9, 8],
    sample: '(filter #(> % 5) numbers)',
    hints: ['Use anonymous function #(> % 5)', 'Or use partial: (partial < 5)'],
    validPatterns: [/filter/, />\s*%\s*5|>\s*5/],
    tags: ['filter', 'predicate', 'sequences'],
  },

  // reduce
  {
    id: 'clojure-seq-005',
    category: 'Sequence Functions',
    difficulty: 'easy',
    title: 'Sum with reduce',
    text: 'Use `reduce` with `+` to calculate the sum of all numbers.',
    setup: '(def numbers [1 2 3 4 5])',
    setupCode: '(def numbers [1 2 3 4 5])',
    expected: 15,
    sample: '(reduce + numbers)',
    hints: ['reduce accumulates a value', '+ can take multiple arguments'],
    validPatterns: [/reduce\s+\+/],
    tags: ['reduce', 'sum', 'sequences'],
  },
  {
    id: 'clojure-seq-006',
    category: 'Sequence Functions',
    difficulty: 'medium',
    title: 'Product with reduce',
    text: 'Use `reduce` with `*` to calculate the product of all numbers.',
    setup: '(def numbers [1 2 3 4])',
    setupCode: '(def numbers [1 2 3 4])',
    expected: 24,
    sample: '(reduce * numbers)',
    hints: ['Use * for multiplication', 'reduce applies function cumulatively'],
    validPatterns: [/reduce\s+\*/],
    tags: ['reduce', 'product', 'sequences'],
  },
  {
    id: 'clojure-seq-007',
    category: 'Sequence Functions',
    difficulty: 'hard',
    title: 'Build Map with reduce',
    text: 'Use `reduce` to count occurrences of each element.',
    setup: '(def letters ["a" "b" "a" "c" "b" "a"])',
    setupCode: '(def letters ["a" "b" "a" "c" "b" "a"])',
    expected: { a: 3, b: 2, c: 1 },
    sample: '(reduce #(update %1 %2 (fnil inc 0)) {} letters)',
    hints: ['Use update with fnil to handle missing keys', 'Start with empty map {}'],
    validPatterns: [/reduce/, /update/, /fnil|inc/],
    tags: ['reduce', 'frequencies', 'map-building'],
  },

  // take / drop
  {
    id: 'clojure-seq-008',
    category: 'Sequence Functions',
    difficulty: 'easy',
    title: 'Take First N Elements',
    text: 'Use `take` to get the first 3 elements from the sequence.',
    setup: '(def numbers [1 2 3 4 5])',
    setupCode: '(def numbers [1 2 3 4 5])',
    expected: [1, 2, 3],
    sample: '(take 3 numbers)',
    hints: ['take returns first n elements', 'Returns lazy sequence'],
    validPatterns: [/take\s+3/],
    tags: ['take', 'sequences', 'slice'],
  },
  {
    id: 'clojure-seq-009',
    category: 'Sequence Functions',
    difficulty: 'medium',
    title: 'Drop First N Elements',
    text: 'Use `drop` to skip the first 2 elements.',
    setup: '(def numbers [1 2 3 4 5])',
    setupCode: '(def numbers [1 2 3 4 5])',
    expected: [3, 4, 5],
    sample: '(drop 2 numbers)',
    hints: ['drop skips first n elements', 'Returns remaining elements'],
    validPatterns: [/drop\s+2/],
    tags: ['drop', 'sequences', 'slice'],
  },

  // first / rest / cons
  {
    id: 'clojure-seq-010',
    category: 'Sequence Functions',
    difficulty: 'medium',
    title: 'Get Rest of Sequence',
    text: 'Use `rest` to get all elements except the first.',
    setup: '(def numbers [1 2 3 4])',
    setupCode: '(def numbers [1 2 3 4])',
    expected: [2, 3, 4],
    sample: '(rest numbers)',
    hints: ['rest returns sequence without first element', 'Returns empty list for single element'],
    validPatterns: [/rest\s+numbers/],
    tags: ['rest', 'sequences', 'slice'],
  },
  {
    id: 'clojure-seq-011',
    category: 'Sequence Functions',
    difficulty: 'medium',
    title: 'Prepend with cons',
    text: 'Use `cons` to add 0 to the front of the sequence.',
    setup: '(def numbers [1 2 3])',
    setupCode: '(def numbers [1 2 3])',
    expected: [0, 1, 2, 3],
    sample: '(cons 0 numbers)',
    hints: ['cons constructs a new sequence', 'First arg is new head element'],
    validPatterns: [/cons\s+0/],
    tags: ['cons', 'sequences', 'prepend'],
  },
  {
    id: 'clojure-seq-012',
    category: 'Sequence Functions',
    difficulty: 'hard',
    title: 'Partition Sequence',
    text: 'Use `partition` to split sequence into pairs.',
    setup: '(def numbers [1 2 3 4 5 6])',
    setupCode: '(def numbers [1 2 3 4 5 6])',
    expected: [
      [1, 2],
      [3, 4],
      [5, 6],
    ],
    sample: '(partition 2 numbers)',
    hints: ['partition splits into groups of n', 'Returns lazy sequence of lists'],
    validPatterns: [/partition\s+2/],
    tags: ['partition', 'sequences', 'grouping'],
  },

  // ============================================================
  // Collection Functions (10 problems: 4 easy, 4 medium, 2 hard)
  // ============================================================

  // conj
  {
    id: 'clojure-coll-001',
    category: 'Collection Functions',
    difficulty: 'easy',
    title: 'Add to Vector with conj',
    text: 'Use `conj` to add 4 to the end of the vector.',
    setup: '(def numbers [1 2 3])',
    setupCode: '(def numbers [1 2 3])',
    expected: [1, 2, 3, 4],
    sample: '(conj numbers 4)',
    hints: ['conj adds to efficient end', 'For vectors, adds to the back'],
    validPatterns: [/conj\s+numbers\s+4/],
    tags: ['conj', 'vector', 'append'],
  },
  {
    id: 'clojure-coll-002',
    category: 'Collection Functions',
    difficulty: 'medium',
    title: 'Add Multiple with conj',
    text: 'Use `conj` to add 4, 5, and 6 to the vector.',
    setup: '(def numbers [1 2 3])',
    setupCode: '(def numbers [1 2 3])',
    expected: [1, 2, 3, 4, 5, 6],
    sample: '(conj numbers 4 5 6)',
    hints: ['conj can take multiple values', 'Values are added in order'],
    validPatterns: [/conj\s+numbers\s+4\s+5\s+6/],
    tags: ['conj', 'vector', 'multiple'],
  },

  // assoc
  {
    id: 'clojure-coll-003',
    category: 'Collection Functions',
    difficulty: 'easy',
    title: 'Add Key to Map with assoc',
    text: 'Use `assoc` to add :age 30 to the person map.',
    setup: '(def person {:name "Alice"})',
    setupCode: '(def person {:name "Alice"})',
    expected: { name: 'Alice', age: 30 },
    sample: '(assoc person :age 30)',
    hints: ['assoc associates a key with a value', 'Returns new map'],
    validPatterns: [/assoc\s+person\s+:age\s+30/],
    tags: ['assoc', 'map', 'add-key'],
  },
  {
    id: 'clojure-coll-004',
    category: 'Collection Functions',
    difficulty: 'medium',
    title: 'Update Vector at Index',
    text: 'Use `assoc` to set index 1 to 20.',
    setup: '(def numbers [1 2 3])',
    setupCode: '(def numbers [1 2 3])',
    expected: [1, 20, 3],
    sample: '(assoc numbers 1 20)',
    hints: ['assoc works on vectors too', 'Index must exist'],
    validPatterns: [/assoc\s+numbers\s+1\s+20/],
    tags: ['assoc', 'vector', 'index'],
  },

  // dissoc
  {
    id: 'clojure-coll-005',
    category: 'Collection Functions',
    difficulty: 'easy',
    title: 'Remove Key with dissoc',
    text: 'Use `dissoc` to remove :age from the map.',
    setup: '(def person {:name "Alice" :age 30})',
    setupCode: '(def person {:name "Alice" :age 30})',
    expected: { name: 'Alice' },
    sample: '(dissoc person :age)',
    hints: ['dissoc removes a key', 'Returns new map without key'],
    validPatterns: [/dissoc\s+person\s+:age/],
    tags: ['dissoc', 'map', 'remove'],
  },
  {
    id: 'clojure-coll-006',
    category: 'Collection Functions',
    difficulty: 'medium',
    title: 'Remove Multiple Keys',
    text: 'Use `dissoc` to remove both :age and :city from the map.',
    setup: '(def person {:name "Alice" :age 30 :city "NYC"})',
    setupCode: '(def person {:name "Alice" :age 30 :city "NYC"})',
    expected: { name: 'Alice' },
    sample: '(dissoc person :age :city)',
    hints: ['dissoc can take multiple keys', 'All specified keys removed'],
    validPatterns: [/dissoc\s+person\s+:age\s+:city/],
    tags: ['dissoc', 'map', 'multiple'],
  },

  // get
  {
    id: 'clojure-coll-007',
    category: 'Collection Functions',
    difficulty: 'easy',
    title: 'Get Value from Map',
    text: 'Use `get` to retrieve the :name value from the map.',
    setup: '(def person {:name "Alice" :age 30})',
    setupCode: '(def person {:name "Alice" :age 30})',
    expected: 'Alice',
    sample: '(get person :name)',
    hints: ['get retrieves value for key', 'Returns nil if key not found'],
    validPatterns: [/get\s+person\s+:name|:name\s+person|\(person\s+:name\)/],
    tags: ['get', 'map', 'access'],
  },
  {
    id: 'clojure-coll-008',
    category: 'Collection Functions',
    difficulty: 'hard',
    title: 'Get Nested Value with get-in',
    text: 'Use `get-in` to retrieve the nested :name value.',
    setup: '(def data {:user {:profile {:name "Alice"}}})',
    setupCode: '(def data {:user {:profile {:name "Alice"}}})',
    expected: 'Alice',
    sample: '(get-in data [:user :profile :name])',
    hints: ['get-in takes path as vector', 'Safely navigates nested structures'],
    validPatterns: [/get-in\s+data\s+\[:user\s+:profile\s+:name\]/],
    tags: ['get-in', 'map', 'nested'],
  },

  // count / empty?
  {
    id: 'clojure-coll-009',
    category: 'Collection Functions',
    difficulty: 'medium',
    title: 'Count Elements',
    text: 'Use `count` to get the number of elements in the vector.',
    setup: '(def numbers [1 2 3 4 5])',
    setupCode: '(def numbers [1 2 3 4 5])',
    expected: 5,
    sample: '(count numbers)',
    hints: ['count returns number of elements', 'Works on any collection'],
    validPatterns: [/count\s+numbers/],
    tags: ['count', 'collection', 'size'],
  },
  {
    id: 'clojure-coll-010',
    category: 'Collection Functions',
    difficulty: 'hard',
    title: 'Update Nested Value',
    text: 'Use `update-in` to increment the nested :count value.',
    setup: '(def data {:stats {:count 5}})',
    setupCode: '(def data {:stats {:count 5}})',
    expected: { stats: { count: 6 } },
    sample: '(update-in data [:stats :count] inc)',
    hints: ['update-in takes path and function', 'inc increments by 1'],
    validPatterns: [/update-in\s+data\s+\[:stats\s+:count\]\s+inc/],
    tags: ['update-in', 'nested', 'map'],
  },

  // ============================================================
  // String Functions (10 problems: 4 easy, 4 medium, 2 hard)
  // ============================================================

  // str
  {
    id: 'clojure-str-001',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Concatenate Strings with str',
    text: 'Use `str` to concatenate "Hello" and "World" with a space.',
    setup: '(def greeting "Hello")\n(def name "World")',
    setupCode: '(def greeting "Hello")\n(def name "World")',
    expected: 'Hello World',
    sample: '(str greeting " " name)',
    hints: ['str concatenates any values as strings', 'Works with multiple arguments'],
    validPatterns: [/str\s+greeting\s+" "\s+name/],
    tags: ['str', 'concatenate', 'strings'],
  },
  {
    id: 'clojure-str-002',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Convert to String',
    text: 'Use `str` to convert the number to a string.',
    setup: '(def num 42)',
    setupCode: '(def num 42)',
    expected: '42',
    sample: '(str num)',
    hints: ['str converts any value to string', 'Works with numbers, keywords, etc'],
    validPatterns: [/str\s+num/],
    tags: ['str', 'conversion', 'strings'],
  },

  // subs
  {
    id: 'clojure-str-003',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Substring from Start',
    text: 'Use `subs` to get characters from index 0 to 5.',
    setup: '(def text "Hello World")',
    setupCode: '(def text "Hello World")',
    expected: 'Hello',
    sample: '(subs text 0 5)',
    hints: ['subs takes start and end indices', 'End index is exclusive'],
    validPatterns: [/subs\s+text\s+0\s+5/],
    tags: ['subs', 'substring', 'strings'],
  },
  {
    id: 'clojure-str-004',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Substring to End',
    text: 'Use `subs` to get everything from index 6 onwards.',
    setup: '(def text "Hello World")',
    setupCode: '(def text "Hello World")',
    expected: 'World',
    sample: '(subs text 6)',
    hints: ['subs with one index goes to end', 'Omit end parameter'],
    validPatterns: [/subs\s+text\s+6/],
    tags: ['subs', 'substring', 'strings'],
  },

  // clojure.string/split
  {
    id: 'clojure-str-005',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Split String by Space',
    text: 'Use `clojure.string/split` to split the string into words.',
    setup: '(require \'[clojure.string :as str])\n(def text "hello world clojure")',
    setupCode: '(require \'[clojure.string :as str])\n(def text "hello world clojure")',
    expected: ['hello', 'world', 'clojure'],
    sample: '(str/split text #" ")',
    hints: ['split takes a regex pattern', 'Use #" " for space'],
    validPatterns: [/split\s+text\s+#" "/],
    tags: ['split', 'strings', 'regex'],
  },
  {
    id: 'clojure-str-006',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Split by Comma',
    text: 'Use `clojure.string/split` to parse CSV values.',
    setup: '(require \'[clojure.string :as str])\n(def csv "a,b,c,d")',
    setupCode: '(require \'[clojure.string :as str])\n(def csv "a,b,c,d")',
    expected: ['a', 'b', 'c', 'd'],
    sample: '(str/split csv #",")',
    hints: ['Use regex #"," for comma', 'Returns vector of strings'],
    validPatterns: [/split\s+csv\s+#","/],
    tags: ['split', 'csv', 'strings'],
  },

  // clojure.string/join
  {
    id: 'clojure-str-007',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Join with Separator',
    text: 'Use `clojure.string/join` to combine words with a dash.',
    setup: '(require \'[clojure.string :as str])\n(def words ["hello" "world"])',
    setupCode: '(require \'[clojure.string :as str])\n(def words ["hello" "world"])',
    expected: 'hello-world',
    sample: '(str/join "-" words)',
    hints: ['join takes separator and collection', 'Separator goes first'],
    validPatterns: [/join\s+"-"\s+words/],
    tags: ['join', 'strings', 'concatenate'],
  },
  {
    id: 'clojure-str-008',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Join without Separator',
    text: 'Use `clojure.string/join` to combine characters without separator.',
    setup: '(require \'[clojure.string :as str])\n(def chars ["a" "b" "c"])',
    setupCode: '(require \'[clojure.string :as str])\n(def chars ["a" "b" "c"])',
    expected: 'abc',
    sample: '(str/join chars)',
    hints: ['join without separator concatenates directly', 'Or use empty string ""'],
    validPatterns: [/join\s+chars|join\s+""\s+chars/],
    tags: ['join', 'strings', 'concatenate'],
  },

  // clojure.string/replace
  {
    id: 'clojure-str-009',
    category: 'String Functions',
    difficulty: 'hard',
    title: 'Replace All Occurrences',
    text: 'Use `clojure.string/replace` to replace all spaces with underscores.',
    setup: '(require \'[clojure.string :as str])\n(def text "hello world clojure")',
    setupCode: '(require \'[clojure.string :as str])\n(def text "hello world clojure")',
    expected: 'hello_world_clojure',
    sample: '(str/replace text " " "_")',
    hints: ['replace replaces all occurrences', 'Can use string or regex pattern'],
    validPatterns: [/replace\s+text\s+" "\s+"_"/],
    tags: ['replace', 'strings', 'substitute'],
  },
  {
    id: 'clojure-str-010',
    category: 'String Functions',
    difficulty: 'hard',
    title: 'Replace with Regex',
    text: 'Use `clojure.string/replace` with regex to remove all digits.',
    setup: '(require \'[clojure.string :as str])\n(def text "a1b2c3")',
    setupCode: '(require \'[clojure.string :as str])\n(def text "a1b2c3")',
    expected: 'abc',
    sample: '(str/replace text #"\\d" "")',
    hints: ['Use regex #"\\d" for digits', 'Replace with empty string'],
    validPatterns: [/replace\s+text\s+#"\\d"\s+""/],
    tags: ['replace', 'regex', 'strings'],
  },

  // ============================================================
  // Higher Order Functions (9 problems: 3 easy, 4 medium, 2 hard)
  // ============================================================

  // partial
  {
    id: 'clojure-hof-001',
    category: 'Higher Order Functions',
    difficulty: 'medium',
    title: 'Create Adder with partial',
    text: 'Use `partial` to create a function that adds 10 to any number.',
    setup: '(def x 5)',
    setupCode: '(def x 5)',
    expected: 15,
    sample: '((partial + 10) x)',
    hints: ['partial fixes some arguments', 'Returns a new function'],
    validPatterns: [/partial\s+\+\s+10/],
    tags: ['partial', 'currying', 'higher-order'],
  },
  {
    id: 'clojure-hof-002',
    category: 'Higher Order Functions',
    difficulty: 'medium',
    title: 'Partial with str',
    text: 'Use `partial` to create a greeter that prepends "Hello, ".',
    setup: '(def name "World")',
    setupCode: '(def name "World")',
    expected: 'Hello, World',
    sample: '((partial str "Hello, ") name)',
    hints: ['partial works with any function', 'str concatenates strings'],
    validPatterns: [/partial\s+str\s+"Hello, "/],
    tags: ['partial', 'str', 'higher-order'],
  },

  // comp
  {
    id: 'clojure-hof-003',
    category: 'Higher Order Functions',
    difficulty: 'medium',
    title: 'Compose Two Functions',
    text: 'Use `comp` to create a function that increments then doubles.',
    setup: '(def x 5)',
    setupCode: '(def x 5)',
    expected: 12,
    sample: '((comp #(* 2 %) inc) x)',
    hints: ['comp applies functions right to left', 'inc then double: (5+1)*2=12'],
    validPatterns: [/comp/, /\*\s*2/, /inc/],
    tags: ['comp', 'composition', 'higher-order'],
  },
  {
    id: 'clojure-hof-004',
    category: 'Higher Order Functions',
    difficulty: 'hard',
    title: 'Compose Multiple Functions',
    text: 'Use `comp` to reverse, uppercase, then get first character.',
    setup: '(require \'[clojure.string :as str])\n(def text "hello")',
    setupCode: '(require \'[clojure.string :as str])\n(def text "hello")',
    expected: 'O',
    sample: '((comp first str/upper-case str/reverse) text)',
    hints: ['comp applies right to left', 'reverse -> uppercase -> first'],
    validPatterns: [/comp/, /first/, /upper-case/, /reverse/],
    tags: ['comp', 'string', 'composition'],
  },

  // juxt
  {
    id: 'clojure-hof-005',
    category: 'Higher Order Functions',
    difficulty: 'medium',
    title: 'Apply Multiple Functions with juxt',
    text: 'Use `juxt` to get both first and last elements at once.',
    setup: '(def numbers [1 2 3 4 5])',
    setupCode: '(def numbers [1 2 3 4 5])',
    expected: [1, 5],
    sample: '((juxt first last) numbers)',
    hints: ['juxt returns vector of results', 'Each function applied to same input'],
    validPatterns: [/juxt\s+first\s+last/],
    tags: ['juxt', 'multiple', 'higher-order'],
  },
  {
    id: 'clojure-hof-006',
    category: 'Higher Order Functions',
    difficulty: 'hard',
    title: 'Extract Multiple Values with juxt',
    text: 'Use `juxt` to extract :name and :age from the map.',
    setup: '(def person {:name "Alice" :age 30 :city "NYC"})',
    setupCode: '(def person {:name "Alice" :age 30 :city "NYC"})',
    expected: ['Alice', 30],
    sample: '((juxt :name :age) person)',
    hints: ['Keywords are functions', 'juxt applies each keyword as getter'],
    validPatterns: [/juxt\s+:name\s+:age/],
    tags: ['juxt', 'keywords', 'map-access'],
  },

  // apply
  {
    id: 'clojure-hof-007',
    category: 'Higher Order Functions',
    difficulty: 'easy',
    title: 'Apply Function to Collection',
    text: 'Use `apply` to find the maximum value in the vector.',
    setup: '(def numbers [3 1 4 1 5 9 2 6])',
    setupCode: '(def numbers [3 1 4 1 5 9 2 6])',
    expected: 9,
    sample: '(apply max numbers)',
    hints: ['apply spreads collection as args', 'max takes multiple args'],
    validPatterns: [/apply\s+max/],
    tags: ['apply', 'max', 'higher-order'],
  },
  {
    id: 'clojure-hof-008',
    category: 'Higher Order Functions',
    difficulty: 'easy',
    title: 'Apply str for Concatenation',
    text: 'Use `apply` with `str` to join all strings.',
    setup: '(def words ["Hello" " " "World"])',
    setupCode: '(def words ["Hello" " " "World"])',
    expected: 'Hello World',
    sample: '(apply str words)',
    hints: ['apply spreads args to str', 'str concatenates all args'],
    validPatterns: [/apply\s+str/],
    tags: ['apply', 'str', 'concatenate'],
  },
  {
    id: 'clojure-hof-009',
    category: 'Higher Order Functions',
    difficulty: 'easy',
    title: 'Apply min to Find Minimum',
    text: 'Use `apply` with `min` to find the smallest number.',
    setup: '(def numbers [5 2 8 1 9])',
    setupCode: '(def numbers [5 2 8 1 9])',
    expected: 1,
    sample: '(apply min numbers)',
    hints: ['apply spreads collection as args', 'min finds smallest value'],
    validPatterns: [/apply\s+min/],
    tags: ['apply', 'min', 'higher-order'],
  },

  // ============================================================
  // Threading Macros (9 problems: 4 easy, 3 medium, 2 hard)
  // ============================================================

  // -> (thread-first)
  {
    id: 'clojure-thread-001',
    category: 'Threading Macros',
    difficulty: 'easy',
    title: 'Thread-First Basic',
    text: 'Use `->` to increment a number and then double it.',
    setup: '(def x 5)',
    setupCode: '(def x 5)',
    expected: 12,
    sample: '(-> x inc (* 2))',
    hints: ['-> threads as first argument', 'inc then (* 2) = (5+1)*2'],
    validPatterns: [/->\s+x\s+inc/, /\*\s*2/],
    tags: ['->', 'thread-first', 'pipeline'],
  },
  {
    id: 'clojure-thread-002',
    category: 'Threading Macros',
    difficulty: 'easy',
    title: 'Thread-First with Maps',
    text: 'Use `->` to add :age 30 to the person map.',
    setup: '(def person {:name "Alice"})',
    setupCode: '(def person {:name "Alice"})',
    expected: { name: 'Alice', age: 30 },
    sample: '(-> person (assoc :age 30))',
    hints: ['-> inserts as first arg', 'assoc adds key-value pair'],
    validPatterns: [/->\s+person/, /assoc\s+:age\s+30/],
    tags: ['->', 'maps', 'pipeline'],
  },
  {
    id: 'clojure-thread-003',
    category: 'Threading Macros',
    difficulty: 'medium',
    title: 'Thread-First Chain',
    text: 'Use `->` to update a map: add :age, then dissoc :temp.',
    setup: '(def person {:name "Alice" :temp true})',
    setupCode: '(def person {:name "Alice" :temp true})',
    expected: { name: 'Alice', age: 30 },
    sample: '(-> person (assoc :age 30) (dissoc :temp))',
    hints: ['-> chains map operations', 'Each form gets result of previous'],
    validPatterns: [/->\s+person/, /assoc\s+:age\s+30/, /dissoc\s+:temp/],
    tags: ['->', 'maps', 'pipeline'],
  },

  // ->> (thread-last)
  {
    id: 'clojure-thread-004',
    category: 'Threading Macros',
    difficulty: 'easy',
    title: 'Thread-Last with Filter',
    text: 'Use `->>` to filter even numbers from the sequence.',
    setup: '(def numbers [1 2 3 4 5 6])',
    setupCode: '(def numbers [1 2 3 4 5 6])',
    expected: [2, 4, 6],
    sample: '(->> numbers (filter even?))',
    hints: ['->> threads as last argument', 'Sequence functions take coll last'],
    validPatterns: [/->>\s+numbers/, /filter\s+even\?/],
    tags: ['->>', 'thread-last', 'sequences'],
  },
  {
    id: 'clojure-thread-005',
    category: 'Threading Macros',
    difficulty: 'easy',
    title: 'Thread-Last with Map',
    text: 'Use `->>` to double all numbers in the sequence.',
    setup: '(def numbers [1 2 3 4 5])',
    setupCode: '(def numbers [1 2 3 4 5])',
    expected: [2, 4, 6, 8, 10],
    sample: '(->> numbers (map #(* 2 %)))',
    hints: ['->> inserts as last arg', 'map takes function then collection'],
    validPatterns: [/->>\s+numbers/, /map/],
    tags: ['->>', 'thread-last', 'sequences'],
  },
  {
    id: 'clojure-thread-006',
    category: 'Threading Macros',
    difficulty: 'medium',
    title: 'Thread-Last Pipeline',
    text: 'Use `->>` to filter even, then double, then sum.',
    setup: '(def numbers [1 2 3 4 5 6])',
    setupCode: '(def numbers [1 2 3 4 5 6])',
    expected: 24,
    sample: '(->> numbers (filter even?) (map #(* 2 %)) (reduce +))',
    hints: ['->> chains sequence operations', '(2+4+6)*2 = 24'],
    validPatterns: [/->>\s+numbers/, /filter\s+even\?/, /map/, /reduce\s+\+/],
    tags: ['->>', 'pipeline', 'sequences'],
  },
  {
    id: 'clojure-thread-007',
    category: 'Threading Macros',
    difficulty: 'medium',
    title: 'Thread-Last with Take',
    text: 'Use `->>` to take first 3 elements, then sum them.',
    setup: '(def numbers [1 2 3 4 5])',
    setupCode: '(def numbers [1 2 3 4 5])',
    expected: 6,
    sample: '(->> numbers (take 3) (reduce +))',
    hints: ['take returns first n elements', '1 + 2 + 3 = 6'],
    validPatterns: [/->>\s+numbers/, /take\s+3/, /reduce\s+\+/],
    tags: ['->>', 'take', 'reduce'],
  },
  {
    id: 'clojure-thread-008',
    category: 'Threading Macros',
    difficulty: 'hard',
    title: 'Complex Thread-Last',
    text: 'Use `->>` to process: filter > 2, take 3, map to strings, join with comma.',
    setup: "(require '[clojure.string :as str])\n(def numbers [1 2 3 4 5 6 7])",
    setupCode: "(require '[clojure.string :as str])\n(def numbers [1 2 3 4 5 6 7])",
    expected: '3,4,5',
    sample: '(->> numbers (filter #(> % 2)) (take 3) (map str) (str/join ","))',
    hints: ['Chain multiple operations', 'join takes separator first'],
    validPatterns: [/->>\s+numbers/, /filter/, /take\s+3/, /map\s+str/, /join/],
    tags: ['->>', 'complex', 'strings'],
  },
  {
    id: 'clojure-thread-009',
    category: 'Threading Macros',
    difficulty: 'hard',
    title: 'Thread with some-> for nil safety',
    text: 'Use `some->` to safely navigate nested map that might have nil.',
    setup: '(require \'[clojure.string :as str])\n(def data {:user {:profile {:name "alice"}}})',
    setupCode:
      '(require \'[clojure.string :as str])\n(def data {:user {:profile {:name "alice"}}})',
    expected: 'ALICE',
    sample: '(some-> data :user :profile :name str/upper-case)',
    hints: ['some-> short-circuits on nil', 'Safe navigation pattern'],
    validPatterns: [/some->\s+data/, /:user/, /:profile/, /:name/, /upper-case/],
    tags: ['some->', 'nil-safe', 'nested'],
  },

  // ============================================================
  // Sequence Operations (40 problems)
  // ============================================================

  // map variations
  {
    id: 'clj-seq-100',
    category: 'Sequence Operations',
    difficulty: 'easy',
    title: 'Map with Keyword',
    text: 'Use `map` with a keyword to extract all :name values from the list of maps.',
    setup: '(def people [{:name "Alice"} {:name "Bob"} {:name "Carol"}])',
    setupCode: '(def people [{:name "Alice"} {:name "Bob"} {:name "Carol"}])',
    expected: ['Alice', 'Bob', 'Carol'],
    sample: '(map :name people)',
    hints: ['Keywords can be used as functions', 'map applies :name to each map'],
    tags: ['map', 'keywords', 'extraction'],
  },
  {
    id: 'clj-seq-101',
    category: 'Sequence Operations',
    difficulty: 'easy',
    title: 'Map Square Numbers',
    text: 'Use `map` to square each number in the vector.',
    setup: '(def nums [1 2 3 4 5])',
    setupCode: '(def nums [1 2 3 4 5])',
    expected: [1, 4, 9, 16, 25],
    sample: '(map #(* % %) nums)',
    hints: ['Use anonymous function #(* % %)', 'Multiply each number by itself'],
    tags: ['map', 'math', 'transform'],
  },
  {
    id: 'clj-seq-102',
    category: 'Sequence Operations',
    difficulty: 'medium',
    title: 'Map with Two Collections',
    text: 'Use `map` with two collections to add corresponding elements.',
    setup: '(def a [1 2 3])\n(def b [10 20 30])',
    setupCode: '(def a [1 2 3])\n(def b [10 20 30])',
    expected: [11, 22, 33],
    sample: '(map + a b)',
    hints: ['map can take multiple collections', 'Elements are paired by position'],
    tags: ['map', 'multiple-collections', 'zip'],
  },
  {
    id: 'clj-seq-103',
    category: 'Sequence Operations',
    difficulty: 'medium',
    title: 'Map with Index using map-indexed',
    text: 'Use `map-indexed` to pair each element with its index.',
    setup: '(def letters ["a" "b" "c"])',
    setupCode: '(def letters ["a" "b" "c"])',
    expected: [[0, 'a'], [1, 'b'], [2, 'c']],
    sample: '(map-indexed vector letters)',
    hints: ['map-indexed passes index as first arg', 'vector creates pairs'],
    tags: ['map-indexed', 'index', 'pairs'],
  },
  {
    id: 'clj-seq-104',
    category: 'Sequence Operations',
    difficulty: 'hard',
    title: 'Nested Map Transformation',
    text: 'Use `map` to increment all :age values in the list of people.',
    setup: '(def people [{:name "A" :age 20} {:name "B" :age 30}])',
    setupCode: '(def people [{:name "A" :age 20} {:name "B" :age 30}])',
    expected: [{ name: 'A', age: 21 }, { name: 'B', age: 31 }],
    sample: '(map #(update % :age inc) people)',
    hints: ['Use update to modify a key', 'inc increments by 1'],
    tags: ['map', 'update', 'nested'],
  },

  // filter variations
  {
    id: 'clj-seq-105',
    category: 'Sequence Operations',
    difficulty: 'easy',
    title: 'Filter Odd Numbers',
    text: 'Use `filter` to keep only odd numbers.',
    setup: '(def nums [1 2 3 4 5 6 7 8 9 10])',
    setupCode: '(def nums [1 2 3 4 5 6 7 8 9 10])',
    expected: [1, 3, 5, 7, 9],
    sample: '(filter odd? nums)',
    hints: ['odd? checks for odd numbers', 'filter keeps truthy results'],
    tags: ['filter', 'odd?', 'predicate'],
  },
  {
    id: 'clj-seq-106',
    category: 'Sequence Operations',
    difficulty: 'easy',
    title: 'Filter Positive Numbers',
    text: 'Use `filter` with `pos?` to keep only positive numbers.',
    setup: '(def nums [-2 -1 0 1 2 3])',
    setupCode: '(def nums [-2 -1 0 1 2 3])',
    expected: [1, 2, 3],
    sample: '(filter pos? nums)',
    hints: ['pos? returns true for positive numbers', 'Zero is not positive'],
    tags: ['filter', 'pos?', 'predicate'],
  },
  {
    id: 'clj-seq-107',
    category: 'Sequence Operations',
    difficulty: 'medium',
    title: 'Filter Non-nil Values',
    text: 'Use `filter` with `some?` to remove nil values.',
    setup: '(def items [1 nil 2 nil 3])',
    setupCode: '(def items [1 nil 2 nil 3])',
    expected: [1, 2, 3],
    sample: '(filter some? items)',
    hints: ['some? returns true for non-nil values', 'Opposite of nil?'],
    tags: ['filter', 'some?', 'nil'],
  },
  {
    id: 'clj-seq-108',
    category: 'Sequence Operations',
    difficulty: 'medium',
    title: 'Filter by String Length',
    text: 'Use `filter` to keep only strings longer than 3 characters.',
    setup: '(def words ["a" "ab" "abc" "abcd" "abcde"])',
    setupCode: '(def words ["a" "ab" "abc" "abcd" "abcde"])',
    expected: ['abcd', 'abcde'],
    sample: '(filter #(> (count %) 3) words)',
    hints: ['count returns string length', 'Use anonymous function for condition'],
    tags: ['filter', 'count', 'strings'],
  },
  {
    id: 'clj-seq-109',
    category: 'Sequence Operations',
    difficulty: 'hard',
    title: 'Filter Maps by Key Value',
    text: 'Use `filter` to keep only people with :age >= 21.',
    setup: '(def people [{:name "A" :age 18} {:name "B" :age 25} {:name "C" :age 21}])',
    setupCode: '(def people [{:name "A" :age 18} {:name "B" :age 25} {:name "C" :age 21}])',
    expected: [{ name: 'B', age: 25 }, { name: 'C', age: 21 }],
    sample: '(filter #(>= (:age %) 21) people)',
    hints: ['Access :age from each map', 'Use >= for comparison'],
    tags: ['filter', 'maps', 'comparison'],
  },

  // reduce variations
  {
    id: 'clj-seq-110',
    category: 'Sequence Operations',
    difficulty: 'easy',
    title: 'Reduce with Initial Value',
    text: 'Use `reduce` with initial value 100 to sum numbers.',
    setup: '(def nums [1 2 3 4 5])',
    setupCode: '(def nums [1 2 3 4 5])',
    expected: 115,
    sample: '(reduce + 100 nums)',
    hints: ['Initial value is second argument', '100 + 1 + 2 + 3 + 4 + 5 = 115'],
    tags: ['reduce', 'initial-value', 'sum'],
  },
  {
    id: 'clj-seq-111',
    category: 'Sequence Operations',
    difficulty: 'medium',
    title: 'Reduce to Find Maximum',
    text: 'Use `reduce` with `max` to find the largest number.',
    setup: '(def nums [3 7 2 9 1 5])',
    setupCode: '(def nums [3 7 2 9 1 5])',
    expected: 9,
    sample: '(reduce max nums)',
    hints: ['max returns larger of two values', 'reduce applies cumulatively'],
    tags: ['reduce', 'max', 'aggregate'],
  },
  {
    id: 'clj-seq-112',
    category: 'Sequence Operations',
    difficulty: 'medium',
    title: 'Reduce to Concatenate Strings',
    text: 'Use `reduce` with `str` to join all strings.',
    setup: '(def words ["Hello" " " "World"])',
    setupCode: '(def words ["Hello" " " "World"])',
    expected: 'Hello World',
    sample: '(reduce str words)',
    hints: ['str concatenates strings', 'reduce applies left to right'],
    tags: ['reduce', 'str', 'concatenate'],
  },
  {
    id: 'clj-seq-113',
    category: 'Sequence Operations',
    difficulty: 'hard',
    title: 'Reduce to Group by Key',
    text: 'Use `reduce` to group numbers by even/odd.',
    setup: '(def nums [1 2 3 4 5 6])',
    setupCode: '(def nums [1 2 3 4 5 6])',
    expected: { even: [2, 4, 6], odd: [1, 3, 5] },
    sample: '(reduce #(update %1 (if (even? %2) :even :odd) conj %2) {:even [] :odd []} nums)',
    hints: ['Use update to add to vectors', 'Check even? for categorization'],
    tags: ['reduce', 'grouping', 'categorize'],
  },
  {
    id: 'clj-seq-114',
    category: 'Sequence Operations',
    difficulty: 'hard',
    title: 'Reduce to Build Running Total',
    text: 'Use `reduce` to create a running sum vector.',
    setup: '(def nums [1 2 3 4])',
    setupCode: '(def nums [1 2 3 4])',
    expected: [1, 3, 6, 10],
    sample: '(rest (reduce #(conj %1 (+ (last %1) %2)) [0] nums))',
    hints: ['Track accumulated sum', 'Add each new sum to result vector'],
    tags: ['reduce', 'running-total', 'accumulate'],
  },

  // take variations
  {
    id: 'clj-seq-115',
    category: 'Sequence Operations',
    difficulty: 'easy',
    title: 'Take First Five',
    text: 'Use `take` to get the first 5 elements.',
    setup: '(def nums [1 2 3 4 5 6 7 8 9 10])',
    setupCode: '(def nums [1 2 3 4 5 6 7 8 9 10])',
    expected: [1, 2, 3, 4, 5],
    sample: '(take 5 nums)',
    hints: ['take returns first n elements', 'Works on any sequence'],
    tags: ['take', 'slice', 'sequence'],
  },
  {
    id: 'clj-seq-116',
    category: 'Sequence Operations',
    difficulty: 'medium',
    title: 'Take While Positive',
    text: 'Use `take-while` to take elements while they are positive.',
    setup: '(def nums [3 2 1 0 -1 -2])',
    setupCode: '(def nums [3 2 1 0 -1 -2])',
    expected: [3, 2, 1],
    sample: '(take-while pos? nums)',
    hints: ['take-while stops at first false', 'pos? checks for positive'],
    tags: ['take-while', 'predicate', 'sequence'],
  },
  {
    id: 'clj-seq-117',
    category: 'Sequence Operations',
    difficulty: 'medium',
    title: 'Take Last Three',
    text: 'Use `take-last` to get the last 3 elements.',
    setup: '(def nums [1 2 3 4 5 6 7])',
    setupCode: '(def nums [1 2 3 4 5 6 7])',
    expected: [5, 6, 7],
    sample: '(take-last 3 nums)',
    hints: ['take-last returns last n elements', 'Different from take'],
    tags: ['take-last', 'slice', 'sequence'],
  },
  {
    id: 'clj-seq-118',
    category: 'Sequence Operations',
    difficulty: 'hard',
    title: 'Take Nth Elements',
    text: 'Use `take-nth` to take every 2nd element.',
    setup: '(def nums [1 2 3 4 5 6 7 8])',
    setupCode: '(def nums [1 2 3 4 5 6 7 8])',
    expected: [1, 3, 5, 7],
    sample: '(take-nth 2 nums)',
    hints: ['take-nth takes every nth element', 'Starts from first element'],
    tags: ['take-nth', 'stride', 'sequence'],
  },

  // drop variations
  {
    id: 'clj-seq-119',
    category: 'Sequence Operations',
    difficulty: 'easy',
    title: 'Drop First Three',
    text: 'Use `drop` to skip the first 3 elements.',
    setup: '(def nums [1 2 3 4 5 6 7])',
    setupCode: '(def nums [1 2 3 4 5 6 7])',
    expected: [4, 5, 6, 7],
    sample: '(drop 3 nums)',
    hints: ['drop skips first n elements', 'Returns remaining sequence'],
    tags: ['drop', 'skip', 'sequence'],
  },
  {
    id: 'clj-seq-120',
    category: 'Sequence Operations',
    difficulty: 'medium',
    title: 'Drop While Less Than Five',
    text: 'Use `drop-while` to skip elements while less than 5.',
    setup: '(def nums [1 2 3 4 5 6 7])',
    setupCode: '(def nums [1 2 3 4 5 6 7])',
    expected: [5, 6, 7],
    sample: '(drop-while #(< % 5) nums)',
    hints: ['drop-while skips until predicate false', 'Use #(< % 5) predicate'],
    tags: ['drop-while', 'predicate', 'sequence'],
  },
  {
    id: 'clj-seq-121',
    category: 'Sequence Operations',
    difficulty: 'medium',
    title: 'Drop Last Two',
    text: 'Use `drop-last` to remove the last 2 elements.',
    setup: '(def nums [1 2 3 4 5])',
    setupCode: '(def nums [1 2 3 4 5])',
    expected: [1, 2, 3],
    sample: '(drop-last 2 nums)',
    hints: ['drop-last removes from end', 'Opposite of take-last'],
    tags: ['drop-last', 'slice', 'sequence'],
  },

  // partition variations
  {
    id: 'clj-seq-122',
    category: 'Sequence Operations',
    difficulty: 'easy',
    title: 'Partition into Triples',
    text: 'Use `partition` to split into groups of 3.',
    setup: '(def nums [1 2 3 4 5 6 7 8 9])',
    setupCode: '(def nums [1 2 3 4 5 6 7 8 9])',
    expected: [[1, 2, 3], [4, 5, 6], [7, 8, 9]],
    sample: '(partition 3 nums)',
    hints: ['partition creates fixed-size groups', 'Drops incomplete last group'],
    tags: ['partition', 'grouping', 'chunk'],
  },
  {
    id: 'clj-seq-123',
    category: 'Sequence Operations',
    difficulty: 'medium',
    title: 'Partition with Step',
    text: 'Use `partition` with step of 1 to get sliding pairs.',
    setup: '(def nums [1 2 3 4 5])',
    setupCode: '(def nums [1 2 3 4 5])',
    expected: [[1, 2], [2, 3], [3, 4], [4, 5]],
    sample: '(partition 2 1 nums)',
    hints: ['Second arg is step size', 'Creates overlapping windows'],
    tags: ['partition', 'sliding-window', 'overlap'],
  },
  {
    id: 'clj-seq-124',
    category: 'Sequence Operations',
    difficulty: 'medium',
    title: 'Partition All Including Remainder',
    text: 'Use `partition-all` to include the incomplete final group.',
    setup: '(def nums [1 2 3 4 5 6 7])',
    setupCode: '(def nums [1 2 3 4 5 6 7])',
    expected: [[1, 2, 3], [4, 5, 6], [7]],
    sample: '(partition-all 3 nums)',
    hints: ['partition-all includes incomplete groups', 'Different from partition'],
    tags: ['partition-all', 'grouping', 'remainder'],
  },
  {
    id: 'clj-seq-125',
    category: 'Sequence Operations',
    difficulty: 'hard',
    title: 'Partition By Predicate',
    text: 'Use `partition-by` to split when predicate result changes.',
    setup: '(def nums [1 1 2 2 2 3 3])',
    setupCode: '(def nums [1 1 2 2 2 3 3])',
    expected: [[1, 1], [2, 2, 2], [3, 3]],
    sample: '(partition-by identity nums)',
    hints: ['partition-by splits on value change', 'identity returns the value itself'],
    tags: ['partition-by', 'grouping', 'consecutive'],
  },

  // More sequence operations
  {
    id: 'clj-seq-126',
    category: 'Sequence Operations',
    difficulty: 'easy',
    title: 'Reverse Sequence',
    text: 'Use `reverse` to reverse the order of elements.',
    setup: '(def nums [1 2 3 4 5])',
    setupCode: '(def nums [1 2 3 4 5])',
    expected: [5, 4, 3, 2, 1],
    sample: '(reverse nums)',
    hints: ['reverse returns elements in opposite order', 'Returns a sequence'],
    tags: ['reverse', 'order', 'sequence'],
  },
  {
    id: 'clj-seq-127',
    category: 'Sequence Operations',
    difficulty: 'easy',
    title: 'Sort Numbers',
    text: 'Use `sort` to arrange numbers in ascending order.',
    setup: '(def nums [5 2 8 1 9 3])',
    setupCode: '(def nums [5 2 8 1 9 3])',
    expected: [1, 2, 3, 5, 8, 9],
    sample: '(sort nums)',
    hints: ['sort uses natural ordering', 'Returns sorted sequence'],
    tags: ['sort', 'order', 'sequence'],
  },
  {
    id: 'clj-seq-128',
    category: 'Sequence Operations',
    difficulty: 'medium',
    title: 'Sort Descending',
    text: 'Use `sort` with comparator to sort in descending order.',
    setup: '(def nums [5 2 8 1 9 3])',
    setupCode: '(def nums [5 2 8 1 9 3])',
    expected: [9, 8, 5, 3, 2, 1],
    sample: '(sort > nums)',
    hints: ['Pass > as comparator', 'Reverses natural order'],
    tags: ['sort', 'comparator', 'descending'],
  },
  {
    id: 'clj-seq-129',
    category: 'Sequence Operations',
    difficulty: 'medium',
    title: 'Sort By Key',
    text: 'Use `sort-by` to sort people by :age.',
    setup: '(def people [{:name "B" :age 30} {:name "A" :age 20} {:name "C" :age 25}])',
    setupCode: '(def people [{:name "B" :age 30} {:name "A" :age 20} {:name "C" :age 25}])',
    expected: [{ name: 'A', age: 20 }, { name: 'C', age: 25 }, { name: 'B', age: 30 }],
    sample: '(sort-by :age people)',
    hints: ['sort-by extracts key for comparison', ':age is the key function'],
    tags: ['sort-by', 'maps', 'ordering'],
  },
  {
    id: 'clj-seq-130',
    category: 'Sequence Operations',
    difficulty: 'hard',
    title: 'Sort By Multiple Keys',
    text: 'Use `sort-by` with juxt to sort by :category then :name.',
    setup: '(def items [{:category "B" :name "x"} {:category "A" :name "y"} {:category "A" :name "x"}])',
    setupCode: '(def items [{:category "B" :name "x"} {:category "A" :name "y"} {:category "A" :name "x"}])',
    expected: [{ category: 'A', name: 'x' }, { category: 'A', name: 'y' }, { category: 'B', name: 'x' }],
    sample: '(sort-by (juxt :category :name) items)',
    hints: ['juxt creates composite key', 'Sorts by category first, then name'],
    tags: ['sort-by', 'juxt', 'multi-key'],
  },
  {
    id: 'clj-seq-131',
    category: 'Sequence Operations',
    difficulty: 'easy',
    title: 'Distinct Elements',
    text: 'Use `distinct` to remove duplicate values.',
    setup: '(def nums [1 2 2 3 3 3 4 4 4 4])',
    setupCode: '(def nums [1 2 2 3 3 3 4 4 4 4])',
    expected: [1, 2, 3, 4],
    sample: '(distinct nums)',
    hints: ['distinct removes duplicates', 'Preserves first occurrence'],
    tags: ['distinct', 'unique', 'duplicates'],
  },
  {
    id: 'clj-seq-132',
    category: 'Sequence Operations',
    difficulty: 'medium',
    title: 'Dedupe Consecutive',
    text: 'Use `dedupe` to remove consecutive duplicates only.',
    setup: '(def nums [1 1 2 2 1 1 3])',
    setupCode: '(def nums [1 1 2 2 1 1 3])',
    expected: [1, 2, 1, 3],
    sample: '(dedupe nums)',
    hints: ['dedupe removes consecutive duplicates', 'Non-consecutive duplicates remain'],
    tags: ['dedupe', 'consecutive', 'duplicates'],
  },
  {
    id: 'clj-seq-133',
    category: 'Sequence Operations',
    difficulty: 'medium',
    title: 'Interleave Two Sequences',
    text: 'Use `interleave` to alternate elements from two sequences.',
    setup: '(def a [1 2 3])\n(def b [:a :b :c])',
    setupCode: '(def a [1 2 3])\n(def b [:a :b :c])',
    expected: [1, 'a', 2, 'b', 3, 'c'],
    sample: '(interleave a b)',
    hints: ['interleave alternates between sequences', 'Stops at shortest sequence'],
    tags: ['interleave', 'combine', 'alternate'],
  },
  {
    id: 'clj-seq-134',
    category: 'Sequence Operations',
    difficulty: 'medium',
    title: 'Interpose Separator',
    text: 'Use `interpose` to insert separator between elements.',
    setup: '(def nums [1 2 3 4])',
    setupCode: '(def nums [1 2 3 4])',
    expected: [1, 0, 2, 0, 3, 0, 4],
    sample: '(interpose 0 nums)',
    hints: ['interpose inserts value between elements', 'Like join but keeps as sequence'],
    tags: ['interpose', 'separator', 'sequence'],
  },
  {
    id: 'clj-seq-135',
    category: 'Sequence Operations',
    difficulty: 'easy',
    title: 'Flatten Nested Sequence',
    text: 'Use `flatten` to convert nested structure to flat sequence.',
    setup: '(def nested [[1 2] [3 [4 5]] 6])',
    setupCode: '(def nested [[1 2] [3 [4 5]] 6])',
    expected: [1, 2, 3, 4, 5, 6],
    sample: '(flatten nested)',
    hints: ['flatten removes all nesting', 'Creates single flat sequence'],
    tags: ['flatten', 'nested', 'sequence'],
  },
  {
    id: 'clj-seq-136',
    category: 'Sequence Operations',
    difficulty: 'hard',
    title: 'Group By Function',
    text: 'Use `group-by` to group numbers by their remainder mod 3.',
    setup: '(def nums [1 2 3 4 5 6 7 8 9])',
    setupCode: '(def nums [1 2 3 4 5 6 7 8 9])',
    expected: { 0: [3, 6, 9], 1: [1, 4, 7], 2: [2, 5, 8] },
    sample: '(group-by #(mod % 3) nums)',
    hints: ['group-by returns map of key to values', 'Key is result of function'],
    tags: ['group-by', 'categorize', 'partition'],
  },
  {
    id: 'clj-seq-137',
    category: 'Sequence Operations',
    difficulty: 'medium',
    title: 'Frequencies Count',
    text: 'Use `frequencies` to count occurrences of each element.',
    setup: '(def letters ["a" "b" "a" "c" "b" "a"])',
    setupCode: '(def letters ["a" "b" "a" "c" "b" "a"])',
    expected: { a: 3, b: 2, c: 1 },
    sample: '(frequencies letters)',
    hints: ['frequencies returns map of counts', 'Built-in function for counting'],
    tags: ['frequencies', 'count', 'histogram'],
  },
  {
    id: 'clj-seq-138',
    category: 'Sequence Operations',
    difficulty: 'hard',
    title: 'Concat Multiple Sequences',
    text: 'Use `concat` to join three sequences into one.',
    setup: '(def a [1 2])\n(def b [3 4])\n(def c [5 6])',
    setupCode: '(def a [1 2])\n(def b [3 4])\n(def c [5 6])',
    expected: [1, 2, 3, 4, 5, 6],
    sample: '(concat a b c)',
    hints: ['concat joins multiple sequences', 'Returns lazy sequence'],
    tags: ['concat', 'join', 'sequence'],
  },
  {
    id: 'clj-seq-139',
    category: 'Sequence Operations',
    difficulty: 'hard',
    title: 'Mapcat Flatten Map',
    text: 'Use `mapcat` to map and flatten in one step.',
    setup: '(def nums [1 2 3])',
    setupCode: '(def nums [1 2 3])',
    expected: [1, 1, 2, 2, 3, 3],
    sample: '(mapcat #(repeat 2 %) nums)',
    hints: ['mapcat = map + concat', 'Flattens one level of nesting'],
    tags: ['mapcat', 'flatmap', 'sequence'],
  },

  // ============================================================
  // Vector Operations (40 problems)
  // ============================================================

  {
    id: 'clj-vec-100',
    category: 'Vector Operations',
    difficulty: 'easy',
    title: 'Create Vector with vec',
    text: 'Use `vec` to convert a list to a vector.',
    setup: "(def lst '(1 2 3 4 5))",
    setupCode: "(def lst '(1 2 3 4 5))",
    expected: [1, 2, 3, 4, 5],
    sample: '(vec lst)',
    hints: ['vec converts any collection to vector', 'Useful for list to vector conversion'],
    tags: ['vec', 'conversion', 'vector'],
  },
  {
    id: 'clj-vec-101',
    category: 'Vector Operations',
    difficulty: 'easy',
    title: 'Vector Literal',
    text: 'Create a vector containing 1, 2, 3 using literal syntax.',
    setup: '',
    setupCode: '',
    expected: [1, 2, 3],
    sample: '[1 2 3]',
    hints: ['Square brackets create vectors', 'Most common vector creation'],
    tags: ['vector', 'literal', 'creation'],
  },
  {
    id: 'clj-vec-102',
    category: 'Vector Operations',
    difficulty: 'easy',
    title: 'Conj to Vector End',
    text: 'Use `conj` to add 4 and 5 to the end of the vector.',
    setup: '(def v [1 2 3])',
    setupCode: '(def v [1 2 3])',
    expected: [1, 2, 3, 4, 5],
    sample: '(conj v 4 5)',
    hints: ['conj adds to end for vectors', 'Can add multiple elements'],
    tags: ['conj', 'append', 'vector'],
  },
  {
    id: 'clj-vec-103',
    category: 'Vector Operations',
    difficulty: 'easy',
    title: 'Get Element by Index',
    text: 'Use `nth` to get the element at index 2.',
    setup: '(def v [10 20 30 40 50])',
    setupCode: '(def v [10 20 30 40 50])',
    expected: 30,
    sample: '(nth v 2)',
    hints: ['nth gets element at index', 'Indices start at 0'],
    tags: ['nth', 'index', 'access'],
  },
  {
    id: 'clj-vec-104',
    category: 'Vector Operations',
    difficulty: 'easy',
    title: 'Vector as Function',
    text: 'Use the vector itself as a function to get index 1.',
    setup: '(def v [:a :b :c :d])',
    setupCode: '(def v [:a :b :c :d])',
    expected: 'b',
    sample: '(v 1)',
    hints: ['Vectors can be called as functions', 'Takes index as argument'],
    tags: ['vector', 'function', 'access'],
  },
  {
    id: 'clj-vec-105',
    category: 'Vector Operations',
    difficulty: 'medium',
    title: 'Assoc at Index',
    text: 'Use `assoc` to replace the element at index 2 with 99.',
    setup: '(def v [1 2 3 4 5])',
    setupCode: '(def v [1 2 3 4 5])',
    expected: [1, 2, 99, 4, 5],
    sample: '(assoc v 2 99)',
    hints: ['assoc works on vectors by index', 'Returns new vector'],
    tags: ['assoc', 'replace', 'vector'],
  },
  {
    id: 'clj-vec-106',
    category: 'Vector Operations',
    difficulty: 'medium',
    title: 'Assoc Multiple Indices',
    text: 'Use `assoc` to replace indices 0 and 2 with :a and :b.',
    setup: '(def v [1 2 3 4 5])',
    setupCode: '(def v [1 2 3 4 5])',
    expected: ['a', 2, 'b', 4, 5],
    sample: '(assoc v 0 :a 2 :b)',
    hints: ['assoc can take multiple index-value pairs', 'Replaces in single operation'],
    tags: ['assoc', 'multiple', 'vector'],
  },
  {
    id: 'clj-vec-107',
    category: 'Vector Operations',
    difficulty: 'easy',
    title: 'Subvec Extract Range',
    text: 'Use `subvec` to extract elements from index 1 to 4.',
    setup: '(def v [0 1 2 3 4 5])',
    setupCode: '(def v [0 1 2 3 4 5])',
    expected: [1, 2, 3],
    sample: '(subvec v 1 4)',
    hints: ['subvec takes start and end indices', 'End index is exclusive'],
    tags: ['subvec', 'slice', 'range'],
  },
  {
    id: 'clj-vec-108',
    category: 'Vector Operations',
    difficulty: 'medium',
    title: 'Subvec to End',
    text: 'Use `subvec` to extract from index 3 to the end.',
    setup: '(def v [0 1 2 3 4 5])',
    setupCode: '(def v [0 1 2 3 4 5])',
    expected: [3, 4, 5],
    sample: '(subvec v 3)',
    hints: ['subvec with one arg goes to end', 'Omit end index'],
    tags: ['subvec', 'slice', 'end'],
  },
  {
    id: 'clj-vec-109',
    category: 'Vector Operations',
    difficulty: 'easy',
    title: 'Peek Last Element',
    text: 'Use `peek` to get the last element of the vector.',
    setup: '(def v [1 2 3 4 5])',
    setupCode: '(def v [1 2 3 4 5])',
    expected: 5,
    sample: '(peek v)',
    hints: ['peek returns last for vectors', 'More efficient than last'],
    tags: ['peek', 'last', 'vector'],
  },
  {
    id: 'clj-vec-110',
    category: 'Vector Operations',
    difficulty: 'easy',
    title: 'Pop Last Element',
    text: 'Use `pop` to remove the last element.',
    setup: '(def v [1 2 3 4 5])',
    setupCode: '(def v [1 2 3 4 5])',
    expected: [1, 2, 3, 4],
    sample: '(pop v)',
    hints: ['pop removes last for vectors', 'Returns new vector'],
    tags: ['pop', 'remove', 'vector'],
  },
  {
    id: 'clj-vec-111',
    category: 'Vector Operations',
    difficulty: 'medium',
    title: 'Update at Index',
    text: 'Use `update` to increment the element at index 2.',
    setup: '(def v [10 20 30 40])',
    setupCode: '(def v [10 20 30 40])',
    expected: [10, 20, 31, 40],
    sample: '(update v 2 inc)',
    hints: ['update applies function at index', 'inc increments by 1'],
    tags: ['update', 'transform', 'vector'],
  },
  {
    id: 'clj-vec-112',
    category: 'Vector Operations',
    difficulty: 'medium',
    title: 'Update with Arguments',
    text: 'Use `update` to add 100 to the element at index 1.',
    setup: '(def v [10 20 30])',
    setupCode: '(def v [10 20 30])',
    expected: [10, 120, 30],
    sample: '(update v 1 + 100)',
    hints: ['update can pass extra args to function', '+ receives old value and 100'],
    tags: ['update', 'arguments', 'vector'],
  },
  {
    id: 'clj-vec-113',
    category: 'Vector Operations',
    difficulty: 'hard',
    title: 'Vector of Vectors',
    text: 'Use `get-in` to access the element at row 1, column 2.',
    setup: '(def matrix [[1 2 3] [4 5 6] [7 8 9]])',
    setupCode: '(def matrix [[1 2 3] [4 5 6] [7 8 9]])',
    expected: 6,
    sample: '(get-in matrix [1 2])',
    hints: ['get-in navigates nested structures', 'Path is [row col]'],
    tags: ['get-in', 'nested', 'matrix'],
  },
  {
    id: 'clj-vec-114',
    category: 'Vector Operations',
    difficulty: 'hard',
    title: 'Update Nested Vector',
    text: 'Use `update-in` to double the element at row 0, column 1.',
    setup: '(def matrix [[1 2 3] [4 5 6]])',
    setupCode: '(def matrix [[1 2 3] [4 5 6]])',
    expected: [[1, 4, 3], [4, 5, 6]],
    sample: '(update-in matrix [0 1] * 2)',
    hints: ['update-in works on nested path', 'Function is * with arg 2'],
    tags: ['update-in', 'nested', 'matrix'],
  },
  {
    id: 'clj-vec-115',
    category: 'Vector Operations',
    difficulty: 'medium',
    title: 'Assoc-in Nested',
    text: 'Use `assoc-in` to set the element at row 1, column 0 to 99.',
    setup: '(def matrix [[1 2] [3 4]])',
    setupCode: '(def matrix [[1 2] [3 4]])',
    expected: [[1, 2], [99, 4]],
    sample: '(assoc-in matrix [1 0] 99)',
    hints: ['assoc-in sets value at path', 'Path navigates nesting'],
    tags: ['assoc-in', 'nested', 'set'],
  },
  {
    id: 'clj-vec-116',
    category: 'Vector Operations',
    difficulty: 'easy',
    title: 'Check if Vector',
    text: 'Use `vector?` to check if the value is a vector.',
    setup: '(def v [1 2 3])',
    setupCode: '(def v [1 2 3])',
    expected: true,
    sample: '(vector? v)',
    hints: ['vector? returns boolean', 'Type checking predicate'],
    tags: ['vector?', 'predicate', 'type'],
  },
  {
    id: 'clj-vec-117',
    category: 'Vector Operations',
    difficulty: 'medium',
    title: 'Into Vector',
    text: 'Use `into` to add elements from a list into a vector.',
    setup: "(def v [1 2])\n(def lst '(3 4 5))",
    setupCode: "(def v [1 2])\n(def lst '(3 4 5))",
    expected: [1, 2, 3, 4, 5],
    sample: '(into v lst)',
    hints: ['into adds all elements to target', 'Preserves vector type'],
    tags: ['into', 'combine', 'vector'],
  },
  {
    id: 'clj-vec-118',
    category: 'Vector Operations',
    difficulty: 'medium',
    title: 'Replace Elements',
    text: 'Use `replace` to substitute values based on a map.',
    setup: '(def v [:a :b :c :a :b])\n(def subs {:a 1 :b 2})',
    setupCode: '(def v [:a :b :c :a :b])\n(def subs {:a 1 :b 2})',
    expected: [1, 2, 'c', 1, 2],
    sample: '(replace subs v)',
    hints: ['replace substitutes matching values', 'Uses map for lookup'],
    tags: ['replace', 'substitute', 'vector'],
  },
  {
    id: 'clj-vec-119',
    category: 'Vector Operations',
    difficulty: 'hard',
    title: 'Vector Reduce-kv',
    text: 'Use `reduce-kv` to sum indices times values.',
    setup: '(def v [10 20 30])',
    setupCode: '(def v [10 20 30])',
    expected: 80,
    sample: '(reduce-kv #(+ %1 (* %2 %3)) 0 v)',
    hints: ['reduce-kv provides key (index) and value', '0*10 + 1*20 + 2*30 = 80'],
    tags: ['reduce-kv', 'index', 'accumulate'],
  },
  {
    id: 'clj-vec-120',
    category: 'Vector Operations',
    difficulty: 'easy',
    title: 'Empty Vector Check',
    text: 'Use `empty?` to check if the vector is empty.',
    setup: '(def v [])',
    setupCode: '(def v [])',
    expected: true,
    sample: '(empty? v)',
    hints: ['empty? returns true for empty collections', 'Works on any collection'],
    tags: ['empty?', 'predicate', 'vector'],
  },
  {
    id: 'clj-vec-121',
    category: 'Vector Operations',
    difficulty: 'medium',
    title: 'Not Empty Check',
    text: 'Use `seq` to check if vector has elements (returns nil if empty).',
    setup: '(def v [1 2 3])',
    setupCode: '(def v [1 2 3])',
    expected: [1, 2, 3],
    sample: '(seq v)',
    hints: ['seq returns nil for empty, sequence otherwise', 'Idiomatic emptiness check'],
    tags: ['seq', 'check', 'vector'],
  },
  {
    id: 'clj-vec-122',
    category: 'Vector Operations',
    difficulty: 'hard',
    title: 'Mapv for Vector Result',
    text: 'Use `mapv` to double all numbers, returning a vector.',
    setup: '(def v [1 2 3 4 5])',
    setupCode: '(def v [1 2 3 4 5])',
    expected: [2, 4, 6, 8, 10],
    sample: '(mapv #(* 2 %) v)',
    hints: ['mapv returns vector not lazy seq', 'Eager evaluation'],
    tags: ['mapv', 'transform', 'eager'],
  },
  {
    id: 'clj-vec-123',
    category: 'Vector Operations',
    difficulty: 'hard',
    title: 'Filterv for Vector Result',
    text: 'Use `filterv` to keep even numbers as a vector.',
    setup: '(def v [1 2 3 4 5 6])',
    setupCode: '(def v [1 2 3 4 5 6])',
    expected: [2, 4, 6],
    sample: '(filterv even? v)',
    hints: ['filterv returns vector not lazy seq', 'Eager filtering'],
    tags: ['filterv', 'filter', 'eager'],
  },
  {
    id: 'clj-vec-124',
    category: 'Vector Operations',
    difficulty: 'medium',
    title: 'Rseq Reverse Sequence',
    text: 'Use `rseq` to get a reverse sequence of the vector.',
    setup: '(def v [1 2 3 4 5])',
    setupCode: '(def v [1 2 3 4 5])',
    expected: [5, 4, 3, 2, 1],
    sample: '(rseq v)',
    hints: ['rseq returns reverse seq in O(1)', 'Only works on reversible collections'],
    tags: ['rseq', 'reverse', 'efficient'],
  },
  {
    id: 'clj-vec-125',
    category: 'Vector Operations',
    difficulty: 'easy',
    title: 'First Element',
    text: 'Use `first` to get the first element of the vector.',
    setup: '(def v [10 20 30])',
    setupCode: '(def v [10 20 30])',
    expected: 10,
    sample: '(first v)',
    hints: ['first returns first element', 'nil for empty collection'],
    tags: ['first', 'access', 'vector'],
  },
  {
    id: 'clj-vec-126',
    category: 'Vector Operations',
    difficulty: 'easy',
    title: 'Last Element',
    text: 'Use `last` to get the last element of the vector.',
    setup: '(def v [10 20 30])',
    setupCode: '(def v [10 20 30])',
    expected: 30,
    sample: '(last v)',
    hints: ['last returns last element', 'O(n) for sequences, use peek for vectors'],
    tags: ['last', 'access', 'vector'],
  },
  {
    id: 'clj-vec-127',
    category: 'Vector Operations',
    difficulty: 'medium',
    title: 'Second Element',
    text: 'Use `second` to get the second element.',
    setup: '(def v [:a :b :c :d])',
    setupCode: '(def v [:a :b :c :d])',
    expected: 'b',
    sample: '(second v)',
    hints: ['second is shorthand for (first (rest ...))', 'Returns second element'],
    tags: ['second', 'access', 'vector'],
  },
  {
    id: 'clj-vec-128',
    category: 'Vector Operations',
    difficulty: 'medium',
    title: 'Nth with Default',
    text: 'Use `nth` with default value for out of bounds index.',
    setup: '(def v [1 2 3])',
    setupCode: '(def v [1 2 3])',
    expected: 'not-found',
    sample: '(nth v 10 :not-found)',
    hints: ['nth third arg is default', 'Returned when index out of bounds'],
    tags: ['nth', 'default', 'safe'],
  },
  {
    id: 'clj-vec-129',
    category: 'Vector Operations',
    difficulty: 'hard',
    title: 'Get with Default',
    text: 'Use `get` with default for missing index.',
    setup: '(def v [1 2 3])',
    setupCode: '(def v [1 2 3])',
    expected: 0,
    sample: '(get v 99 0)',
    hints: ['get returns nil or default for missing', 'Safer than nth'],
    tags: ['get', 'default', 'vector'],
  },
  {
    id: 'clj-vec-130',
    category: 'Vector Operations',
    difficulty: 'medium',
    title: 'Contains Index',
    text: 'Use `contains?` to check if index 2 exists in vector.',
    setup: '(def v [10 20 30])',
    setupCode: '(def v [10 20 30])',
    expected: true,
    sample: '(contains? v 2)',
    hints: ['contains? checks for key/index', 'For vectors, checks index exists'],
    tags: ['contains?', 'index', 'check'],
  },
  {
    id: 'clj-vec-131',
    category: 'Vector Operations',
    difficulty: 'hard',
    title: 'Keep Indexed',
    text: 'Use `keep-indexed` to get elements at even indices.',
    setup: '(def v [:a :b :c :d :e])',
    setupCode: '(def v [:a :b :c :d :e])',
    expected: ['a', 'c', 'e'],
    sample: '(keep-indexed #(when (even? %1) %2) v)',
    hints: ['keep-indexed provides index and value', 'Return nil to exclude'],
    tags: ['keep-indexed', 'filter', 'index'],
  },
  {
    id: 'clj-vec-132',
    category: 'Vector Operations',
    difficulty: 'medium',
    title: 'Butlast All But Last',
    text: 'Use `butlast` to get all elements except the last.',
    setup: '(def v [1 2 3 4 5])',
    setupCode: '(def v [1 2 3 4 5])',
    expected: [1, 2, 3, 4],
    sample: '(butlast v)',
    hints: ['butlast removes last element', 'Returns sequence not vector'],
    tags: ['butlast', 'slice', 'vector'],
  },
  {
    id: 'clj-vec-133',
    category: 'Vector Operations',
    difficulty: 'hard',
    title: 'Split At Index',
    text: 'Use `split-at` to split vector at index 3.',
    setup: '(def v [1 2 3 4 5 6])',
    setupCode: '(def v [1 2 3 4 5 6])',
    expected: [[1, 2, 3], [4, 5, 6]],
    sample: '(split-at 3 v)',
    hints: ['split-at returns pair of sequences', 'First has n elements'],
    tags: ['split-at', 'divide', 'vector'],
  },
  {
    id: 'clj-vec-134',
    category: 'Vector Operations',
    difficulty: 'hard',
    title: 'Split With Predicate',
    text: 'Use `split-with` to split at first number >= 5.',
    setup: '(def v [1 2 3 4 5 6 7])',
    setupCode: '(def v [1 2 3 4 5 6 7])',
    expected: [[1, 2, 3, 4], [5, 6, 7]],
    sample: '(split-with #(< % 5) v)',
    hints: ['split-with uses predicate', 'Like take-while and drop-while combined'],
    tags: ['split-with', 'predicate', 'divide'],
  },
  {
    id: 'clj-vec-135',
    category: 'Vector Operations',
    difficulty: 'easy',
    title: 'Count Vector Length',
    text: 'Use `count` to get the number of elements.',
    setup: '(def v [1 2 3 4 5 6 7])',
    setupCode: '(def v [1 2 3 4 5 6 7])',
    expected: 7,
    sample: '(count v)',
    hints: ['count returns collection size', 'O(1) for vectors'],
    tags: ['count', 'length', 'size'],
  },
  {
    id: 'clj-vec-136',
    category: 'Vector Operations',
    difficulty: 'medium',
    title: 'Reduce Into Vector',
    text: 'Use `reduce` with `conj` to build a vector from range.',
    setup: '(def r (range 5))',
    setupCode: '(def r (range 5))',
    expected: [0, 1, 2, 3, 4],
    sample: '(reduce conj [] r)',
    hints: ['Start with empty vector', 'conj adds each element'],
    tags: ['reduce', 'conj', 'build'],
  },
  {
    id: 'clj-vec-137',
    category: 'Vector Operations',
    difficulty: 'hard',
    title: 'Shuffle Vector',
    text: 'Check that `shuffle` returns a vector with same elements.',
    setup: '(def v [1 2 3 4 5])',
    setupCode: '(def v [1 2 3 4 5])',
    expected: 5,
    sample: '(count (shuffle v))',
    hints: ['shuffle randomizes order', 'Returns vector with same elements'],
    tags: ['shuffle', 'random', 'vector'],
  },
  {
    id: 'clj-vec-138',
    category: 'Vector Operations',
    difficulty: 'medium',
    title: 'Rand-nth Random Element',
    text: 'Check that `rand-nth` returns an element from the vector.',
    setup: '(def v [1 2 3 4 5])',
    setupCode: '(def v [1 2 3 4 5])',
    expected: true,
    sample: '(contains? (set v) (rand-nth v))',
    hints: ['rand-nth picks random element', 'Result must be in original'],
    tags: ['rand-nth', 'random', 'element'],
  },
  {
    id: 'clj-vec-139',
    category: 'Vector Operations',
    difficulty: 'hard',
    title: 'Zipmap Vectors to Map',
    text: 'Use `zipmap` to create a map from two vectors.',
    setup: '(def keys [:a :b :c])\n(def vals [1 2 3])',
    setupCode: '(def keys [:a :b :c])\n(def vals [1 2 3])',
    expected: { a: 1, b: 2, c: 3 },
    sample: '(zipmap keys vals)',
    hints: ['zipmap pairs corresponding elements', 'First vector is keys, second is values'],
    tags: ['zipmap', 'map', 'combine'],
  },

  // ============================================================
  // Map Operations (40 problems)
  // ============================================================

  {
    id: 'clj-map-100',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Create Map Literal',
    text: 'Create a map with :name "Alice" and :age 30.',
    setup: '',
    setupCode: '',
    expected: { name: 'Alice', age: 30 },
    sample: '{:name "Alice" :age 30}',
    hints: ['Curly braces create maps', 'Key-value pairs alternate'],
    tags: ['map', 'literal', 'creation'],
  },
  {
    id: 'clj-map-101',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Hash-map Function',
    text: 'Use `hash-map` to create a map with :x 1 and :y 2.',
    setup: '',
    setupCode: '',
    expected: { x: 1, y: 2 },
    sample: '(hash-map :x 1 :y 2)',
    hints: ['hash-map takes alternating key-value args', 'Creates hash map'],
    tags: ['hash-map', 'function', 'creation'],
  },
  {
    id: 'clj-map-102',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Assoc Add Key',
    text: 'Use `assoc` to add :email "a@b.com" to the map.',
    setup: '(def m {:name "Alice"})',
    setupCode: '(def m {:name "Alice"})',
    expected: { name: 'Alice', email: 'a@b.com' },
    sample: '(assoc m :email "a@b.com")',
    hints: ['assoc adds or updates key', 'Returns new map'],
    tags: ['assoc', 'add', 'map'],
  },
  {
    id: 'clj-map-103',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Assoc Multiple Keys',
    text: 'Use `assoc` to add :age 30 and :city "NYC" to the map.',
    setup: '(def m {:name "Alice"})',
    setupCode: '(def m {:name "Alice"})',
    expected: { name: 'Alice', age: 30, city: 'NYC' },
    sample: '(assoc m :age 30 :city "NYC")',
    hints: ['assoc can take multiple key-value pairs', 'Single operation'],
    tags: ['assoc', 'multiple', 'map'],
  },
  {
    id: 'clj-map-104',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Dissoc Remove Key',
    text: 'Use `dissoc` to remove :temp from the map.',
    setup: '(def m {:name "Alice" :temp true})',
    setupCode: '(def m {:name "Alice" :temp true})',
    expected: { name: 'Alice' },
    sample: '(dissoc m :temp)',
    hints: ['dissoc removes key', 'Returns map without key'],
    tags: ['dissoc', 'remove', 'map'],
  },
  {
    id: 'clj-map-105',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Dissoc Multiple Keys',
    text: 'Use `dissoc` to remove :a and :b from the map.',
    setup: '(def m {:name "X" :a 1 :b 2 :c 3})',
    setupCode: '(def m {:name "X" :a 1 :b 2 :c 3})',
    expected: { name: 'X', c: 3 },
    sample: '(dissoc m :a :b)',
    hints: ['dissoc can remove multiple keys', 'List all keys to remove'],
    tags: ['dissoc', 'multiple', 'remove'],
  },
  {
    id: 'clj-map-106',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Get Value',
    text: 'Use `get` to retrieve the :name value.',
    setup: '(def m {:name "Alice" :age 30})',
    setupCode: '(def m {:name "Alice" :age 30})',
    expected: 'Alice',
    sample: '(get m :name)',
    hints: ['get retrieves value for key', 'Returns nil if not found'],
    tags: ['get', 'access', 'map'],
  },
  {
    id: 'clj-map-107',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Get with Default',
    text: 'Use `get` with default "unknown" for missing :email key.',
    setup: '(def m {:name "Alice"})',
    setupCode: '(def m {:name "Alice"})',
    expected: 'unknown',
    sample: '(get m :email "unknown")',
    hints: ['Third arg is default value', 'Returned when key missing'],
    tags: ['get', 'default', 'missing'],
  },
  {
    id: 'clj-map-108',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Keyword as Function',
    text: 'Use :name as a function to get the value.',
    setup: '(def m {:name "Alice" :age 30})',
    setupCode: '(def m {:name "Alice" :age 30})',
    expected: 'Alice',
    sample: '(:name m)',
    hints: ['Keywords are functions', 'Look themselves up in maps'],
    tags: ['keyword', 'function', 'access'],
  },
  {
    id: 'clj-map-109',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Keyword with Default',
    text: 'Use keyword as function with default for missing key.',
    setup: '(def m {:name "Alice"})',
    setupCode: '(def m {:name "Alice"})',
    expected: 0,
    sample: '(:age m 0)',
    hints: ['Keyword function takes optional default', 'Second arg is default'],
    tags: ['keyword', 'default', 'access'],
  },
  {
    id: 'clj-map-110',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Get-in Nested Access',
    text: 'Use `get-in` to get the nested :city value.',
    setup: '(def m {:user {:address {:city "NYC"}}})',
    setupCode: '(def m {:user {:address {:city "NYC"}}})',
    expected: 'NYC',
    sample: '(get-in m [:user :address :city])',
    hints: ['get-in takes path as vector', 'Navigates nested maps'],
    tags: ['get-in', 'nested', 'path'],
  },
  {
    id: 'clj-map-111',
    category: 'Map Operations',
    difficulty: 'hard',
    title: 'Get-in with Default',
    text: 'Use `get-in` with default for missing nested path.',
    setup: '(def m {:user {:name "Alice"}})',
    setupCode: '(def m {:user {:name "Alice"}})',
    expected: 'N/A',
    sample: '(get-in m [:user :address :city] "N/A")',
    hints: ['Third arg is default', 'Returned when path missing'],
    tags: ['get-in', 'default', 'nested'],
  },
  {
    id: 'clj-map-112',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Update Value',
    text: 'Use `update` to increment the :count value.',
    setup: '(def m {:count 5})',
    setupCode: '(def m {:count 5})',
    expected: { count: 6 },
    sample: '(update m :count inc)',
    hints: ['update applies function to value', 'inc increments by 1'],
    tags: ['update', 'transform', 'map'],
  },
  {
    id: 'clj-map-113',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Update with Extra Args',
    text: 'Use `update` to add 10 to the :score value.',
    setup: '(def m {:score 50})',
    setupCode: '(def m {:score 50})',
    expected: { score: 60 },
    sample: '(update m :score + 10)',
    hints: ['update can pass extra args', '+ receives current value and 10'],
    tags: ['update', 'arguments', 'map'],
  },
  {
    id: 'clj-map-114',
    category: 'Map Operations',
    difficulty: 'hard',
    title: 'Update-in Nested',
    text: 'Use `update-in` to increment nested :stats :count.',
    setup: '(def m {:stats {:count 10}})',
    setupCode: '(def m {:stats {:count 10}})',
    expected: { stats: { count: 11 } },
    sample: '(update-in m [:stats :count] inc)',
    hints: ['update-in takes path vector', 'Applies function at path'],
    tags: ['update-in', 'nested', 'transform'],
  },
  {
    id: 'clj-map-115',
    category: 'Map Operations',
    difficulty: 'hard',
    title: 'Assoc-in Nested',
    text: 'Use `assoc-in` to set nested :user :settings :theme to "dark".',
    setup: '(def m {:user {:settings {}}})',
    setupCode: '(def m {:user {:settings {}}})',
    expected: { user: { settings: { theme: 'dark' } } },
    sample: '(assoc-in m [:user :settings :theme] "dark")',
    hints: ['assoc-in sets value at path', 'Creates intermediate maps if needed'],
    tags: ['assoc-in', 'nested', 'set'],
  },
  {
    id: 'clj-map-116',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Merge Two Maps',
    text: 'Use `merge` to combine two maps.',
    setup: '(def a {:x 1})\n(def b {:y 2})',
    setupCode: '(def a {:x 1})\n(def b {:y 2})',
    expected: { x: 1, y: 2 },
    sample: '(merge a b)',
    hints: ['merge combines maps', 'Later maps override earlier'],
    tags: ['merge', 'combine', 'map'],
  },
  {
    id: 'clj-map-117',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Merge Override',
    text: 'Use `merge` where second map overrides :a.',
    setup: '(def m1 {:a 1 :b 2})\n(def m2 {:a 99})',
    setupCode: '(def m1 {:a 1 :b 2})\n(def m2 {:a 99})',
    expected: { a: 99, b: 2 },
    sample: '(merge m1 m2)',
    hints: ['Later maps override earlier keys', 'Non-conflicting keys preserved'],
    tags: ['merge', 'override', 'conflict'],
  },
  {
    id: 'clj-map-118',
    category: 'Map Operations',
    difficulty: 'hard',
    title: 'Merge-with Custom Function',
    text: 'Use `merge-with` to sum conflicting values.',
    setup: '(def m1 {:a 1 :b 2})\n(def m2 {:a 3 :c 4})',
    setupCode: '(def m1 {:a 1 :b 2})\n(def m2 {:a 3 :c 4})',
    expected: { a: 4, b: 2, c: 4 },
    sample: '(merge-with + m1 m2)',
    hints: ['merge-with applies function to conflicts', '+ adds conflicting values'],
    tags: ['merge-with', 'combine', 'function'],
  },
  {
    id: 'clj-map-119',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Select-keys Subset',
    text: 'Use `select-keys` to keep only :name and :age.',
    setup: '(def m {:name "Alice" :age 30 :city "NYC" :email "a@b.com"})',
    setupCode: '(def m {:name "Alice" :age 30 :city "NYC" :email "a@b.com"})',
    expected: { name: 'Alice', age: 30 },
    sample: '(select-keys m [:name :age])',
    hints: ['select-keys filters to specified keys', 'Returns map with subset'],
    tags: ['select-keys', 'filter', 'subset'],
  },
  {
    id: 'clj-map-120',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Keys Get All Keys',
    text: 'Use `keys` to get all keys from the map.',
    setup: '(def m {:a 1 :b 2 :c 3})',
    setupCode: '(def m {:a 1 :b 2 :c 3})',
    expected: ['a', 'b', 'c'],
    sample: '(keys m)',
    hints: ['keys returns sequence of keys', 'Order may vary'],
    tags: ['keys', 'extract', 'map'],
  },
  {
    id: 'clj-map-121',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Vals Get All Values',
    text: 'Use `vals` to get all values from the map.',
    setup: '(def m {:a 1 :b 2 :c 3})',
    setupCode: '(def m {:a 1 :b 2 :c 3})',
    expected: [1, 2, 3],
    sample: '(vals m)',
    hints: ['vals returns sequence of values', 'Order corresponds to keys'],
    tags: ['vals', 'extract', 'map'],
  },
  {
    id: 'clj-map-122',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Contains? Check Key',
    text: 'Use `contains?` to check if :email key exists.',
    setup: '(def m {:name "Alice" :email "a@b.com"})',
    setupCode: '(def m {:name "Alice" :email "a@b.com"})',
    expected: true,
    sample: '(contains? m :email)',
    hints: ['contains? checks for key presence', 'Returns boolean'],
    tags: ['contains?', 'check', 'key'],
  },
  {
    id: 'clj-map-123',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Empty Map Check',
    text: 'Use `empty?` to check if map is empty.',
    setup: '(def m {})',
    setupCode: '(def m {})',
    expected: true,
    sample: '(empty? m)',
    hints: ['empty? returns true for empty map', 'Works on any collection'],
    tags: ['empty?', 'check', 'map'],
  },
  {
    id: 'clj-map-124',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Count Map Entries',
    text: 'Use `count` to get number of key-value pairs.',
    setup: '(def m {:a 1 :b 2 :c 3 :d 4})',
    setupCode: '(def m {:a 1 :b 2 :c 3 :d 4})',
    expected: 4,
    sample: '(count m)',
    hints: ['count returns number of entries', 'Each key-value is one entry'],
    tags: ['count', 'size', 'map'],
  },
  {
    id: 'clj-map-125',
    category: 'Map Operations',
    difficulty: 'hard',
    title: 'Find Key Entry',
    text: 'Use `find` to get the map entry for :name.',
    setup: '(def m {:name "Alice" :age 30})',
    setupCode: '(def m {:name "Alice" :age 30})',
    expected: ['name', 'Alice'],
    sample: '(find m :name)',
    hints: ['find returns map entry [k v]', 'nil if key not found'],
    tags: ['find', 'entry', 'map'],
  },
  {
    id: 'clj-map-126',
    category: 'Map Operations',
    difficulty: 'hard',
    title: 'Reduce-kv Sum Values',
    text: 'Use `reduce-kv` to sum all values in the map.',
    setup: '(def m {:a 10 :b 20 :c 30})',
    setupCode: '(def m {:a 10 :b 20 :c 30})',
    expected: 60,
    sample: '(reduce-kv (fn [acc k v] (+ acc v)) 0 m)',
    hints: ['reduce-kv provides key and value', 'Accumulate values only'],
    tags: ['reduce-kv', 'sum', 'accumulate'],
  },
  {
    id: 'clj-map-127',
    category: 'Map Operations',
    difficulty: 'hard',
    title: 'Reduce-kv Transform Map',
    text: 'Use `reduce-kv` to double all values.',
    setup: '(def m {:a 1 :b 2 :c 3})',
    setupCode: '(def m {:a 1 :b 2 :c 3})',
    expected: { a: 2, b: 4, c: 6 },
    sample: '(reduce-kv (fn [acc k v] (assoc acc k (* 2 v))) {} m)',
    hints: ['Build new map with assoc', 'Double each value'],
    tags: ['reduce-kv', 'transform', 'map'],
  },
  {
    id: 'clj-map-128',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Into Empty Map',
    text: 'Use `into` to convert sequence of pairs into map.',
    setup: '(def pairs [[:a 1] [:b 2] [:c 3]])',
    setupCode: '(def pairs [[:a 1] [:b 2] [:c 3]])',
    expected: { a: 1, b: 2, c: 3 },
    sample: '(into {} pairs)',
    hints: ['into {} converts pairs to map', 'Each pair is [key value]'],
    tags: ['into', 'convert', 'map'],
  },
  {
    id: 'clj-map-129',
    category: 'Map Operations',
    difficulty: 'hard',
    title: 'Update-vals Transform All',
    text: 'Use `update-vals` to increment all values.',
    setup: '(def m {:a 1 :b 2 :c 3})',
    setupCode: '(def m {:a 1 :b 2 :c 3})',
    expected: { a: 2, b: 3, c: 4 },
    sample: '(update-vals m inc)',
    hints: ['update-vals applies fn to all values', 'Clojure 1.11+ function'],
    tags: ['update-vals', 'transform', 'all'],
  },
  {
    id: 'clj-map-130',
    category: 'Map Operations',
    difficulty: 'hard',
    title: 'Update-keys Transform Keys',
    text: 'Use `update-keys` to convert all keys to strings.',
    setup: '(def m {:a 1 :b 2})',
    setupCode: '(def m {:a 1 :b 2})',
    expected: { a: 1, b: 2 },
    sample: '(update-keys m name)',
    hints: ['update-keys applies fn to all keys', 'name converts keyword to string'],
    tags: ['update-keys', 'transform', 'keys'],
  },
  {
    id: 'clj-map-131',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Map-indexed to Map',
    text: 'Create a map from index to element.',
    setup: '(def items [:a :b :c])',
    setupCode: '(def items [:a :b :c])',
    expected: { 0: 'a', 1: 'b', 2: 'c' },
    sample: '(into {} (map-indexed vector items))',
    hints: ['map-indexed creates [index value] pairs', 'into {} converts to map'],
    tags: ['map-indexed', 'index', 'map'],
  },
  {
    id: 'clj-map-132',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Map? Type Check',
    text: 'Use `map?` to check if value is a map.',
    setup: '(def m {:a 1})',
    setupCode: '(def m {:a 1})',
    expected: true,
    sample: '(map? m)',
    hints: ['map? returns boolean', 'Type checking predicate'],
    tags: ['map?', 'type', 'check'],
  },
  {
    id: 'clj-map-133',
    category: 'Map Operations',
    difficulty: 'hard',
    title: 'Seq on Map',
    text: 'Use `seq` to get sequence of map entries.',
    setup: '(def m {:a 1 :b 2})',
    setupCode: '(def m {:a 1 :b 2})',
    expected: [['a', 1], ['b', 2]],
    sample: '(seq m)',
    hints: ['seq on map returns entry pairs', 'Each entry is [key value]'],
    tags: ['seq', 'entries', 'map'],
  },
  {
    id: 'clj-map-134',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Filter Map by Value',
    text: 'Filter map to keep entries where value > 5.',
    setup: '(def m {:a 3 :b 7 :c 5 :d 9})',
    setupCode: '(def m {:a 3 :b 7 :c 5 :d 9})',
    expected: { b: 7, d: 9 },
    sample: '(into {} (filter #(> (val %) 5) m))',
    hints: ['filter on map entries', 'val extracts value from entry'],
    tags: ['filter', 'value', 'map'],
  },
  {
    id: 'clj-map-135',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Filter Map by Key',
    text: 'Filter map to keep entries where key starts with :x.',
    setup: '(def m {:x1 1 :x2 2 :y1 3})',
    setupCode: '(def m {:x1 1 :x2 2 :y1 3})',
    expected: { x1: 1, x2: 2 },
    sample: '(into {} (filter #(clojure.string/starts-with? (name (key %)) "x") m))',
    hints: ['filter on map entries', 'key extracts key from entry'],
    tags: ['filter', 'key', 'map'],
  },
  {
    id: 'clj-map-136',
    category: 'Map Operations',
    difficulty: 'hard',
    title: 'Map over Map Values',
    text: 'Double all values in the map using map.',
    setup: '(def m {:a 1 :b 2 :c 3})',
    setupCode: '(def m {:a 1 :b 2 :c 3})',
    expected: { a: 2, b: 4, c: 6 },
    sample: '(into {} (map (fn [[k v]] [k (* 2 v)]) m))',
    hints: ['Destructure map entry as [k v]', 'Return new [k v] pair'],
    tags: ['map', 'transform', 'values'],
  },
  {
    id: 'clj-map-137',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Rename Keys',
    text: 'Use `clojure.set/rename-keys` to rename :name to :title.',
    setup: '(require \'[clojure.set :as set])\n(def m {:name "X" :value 1})',
    setupCode: '(require \'[clojure.set :as set])\n(def m {:name "X" :value 1})',
    expected: { title: 'X', value: 1 },
    sample: '(set/rename-keys m {:name :title})',
    hints: ['rename-keys takes map of old->new', 'Only renames specified keys'],
    tags: ['rename-keys', 'transform', 'keys'],
  },
  {
    id: 'clj-map-138',
    category: 'Map Operations',
    difficulty: 'hard',
    title: 'Deep Merge Maps',
    text: 'Merge nested maps recursively.',
    setup: '(def m1 {:a {:b 1}})\n(def m2 {:a {:c 2}})',
    setupCode: '(def m1 {:a {:b 1}})\n(def m2 {:a {:c 2}})',
    expected: { a: { b: 1, c: 2 } },
    sample: '(merge-with merge m1 m2)',
    hints: ['merge-with merge for nested maps', 'Recursively merges conflicts'],
    tags: ['merge-with', 'nested', 'deep'],
  },
  {
    id: 'clj-map-139',
    category: 'Map Operations',
    difficulty: 'hard',
    title: 'Invert Map',
    text: 'Use `clojure.set/map-invert` to swap keys and values.',
    setup: '(require \'[clojure.set :as set])\n(def m {:a 1 :b 2 :c 3})',
    setupCode: '(require \'[clojure.set :as set])\n(def m {:a 1 :b 2 :c 3})',
    expected: { 1: 'a', 2: 'b', 3: 'c' },
    sample: '(set/map-invert m)',
    hints: ['map-invert swaps keys and values', 'Values become keys'],
    tags: ['map-invert', 'swap', 'transform'],
  },

  // ============================================================
  // Set Operations (35 problems)
  // ============================================================

  {
    id: 'clj-set-100',
    category: 'Set Operations',
    difficulty: 'easy',
    title: 'Create Set Literal',
    text: 'Create a set containing 1, 2, and 3.',
    setup: '',
    setupCode: '',
    expected: [1, 2, 3],
    sample: '#{1 2 3}',
    hints: ['#{} creates sets', 'Duplicates automatically removed'],
    tags: ['set', 'literal', 'creation'],
  },
  {
    id: 'clj-set-101',
    category: 'Set Operations',
    difficulty: 'easy',
    title: 'Set from Vector',
    text: 'Use `set` to convert vector to set, removing duplicates.',
    setup: '(def v [1 2 2 3 3 3])',
    setupCode: '(def v [1 2 2 3 3 3])',
    expected: [1, 2, 3],
    sample: '(set v)',
    hints: ['set function converts to set', 'Removes duplicates'],
    tags: ['set', 'conversion', 'dedupe'],
  },
  {
    id: 'clj-set-102',
    category: 'Set Operations',
    difficulty: 'easy',
    title: 'Conj Add Element',
    text: 'Use `conj` to add 4 to the set.',
    setup: '(def s #{1 2 3})',
    setupCode: '(def s #{1 2 3})',
    expected: [1, 2, 3, 4],
    sample: '(conj s 4)',
    hints: ['conj adds to set', 'Returns new set'],
    tags: ['conj', 'add', 'set'],
  },
  {
    id: 'clj-set-103',
    category: 'Set Operations',
    difficulty: 'medium',
    title: 'Conj Multiple Elements',
    text: 'Use `conj` to add 4, 5, and 6 to the set.',
    setup: '(def s #{1 2 3})',
    setupCode: '(def s #{1 2 3})',
    expected: [1, 2, 3, 4, 5, 6],
    sample: '(conj s 4 5 6)',
    hints: ['conj can add multiple elements', 'Single operation'],
    tags: ['conj', 'multiple', 'set'],
  },
  {
    id: 'clj-set-104',
    category: 'Set Operations',
    difficulty: 'easy',
    title: 'Disj Remove Element',
    text: 'Use `disj` to remove 2 from the set.',
    setup: '(def s #{1 2 3})',
    setupCode: '(def s #{1 2 3})',
    expected: [1, 3],
    sample: '(disj s 2)',
    hints: ['disj removes from set', 'Returns new set'],
    tags: ['disj', 'remove', 'set'],
  },
  {
    id: 'clj-set-105',
    category: 'Set Operations',
    difficulty: 'medium',
    title: 'Disj Multiple Elements',
    text: 'Use `disj` to remove 1 and 3 from the set.',
    setup: '(def s #{1 2 3 4})',
    setupCode: '(def s #{1 2 3 4})',
    expected: [2, 4],
    sample: '(disj s 1 3)',
    hints: ['disj can remove multiple', 'List all elements to remove'],
    tags: ['disj', 'multiple', 'remove'],
  },
  {
    id: 'clj-set-106',
    category: 'Set Operations',
    difficulty: 'easy',
    title: 'Contains? Check Membership',
    text: 'Use `contains?` to check if 3 is in the set.',
    setup: '(def s #{1 2 3 4 5})',
    setupCode: '(def s #{1 2 3 4 5})',
    expected: true,
    sample: '(contains? s 3)',
    hints: ['contains? checks membership', 'Returns boolean'],
    tags: ['contains?', 'membership', 'check'],
  },
  {
    id: 'clj-set-107',
    category: 'Set Operations',
    difficulty: 'easy',
    title: 'Set as Function',
    text: 'Use the set as a function to check for element 3.',
    setup: '(def s #{1 2 3 4 5})',
    setupCode: '(def s #{1 2 3 4 5})',
    expected: 3,
    sample: '(s 3)',
    hints: ['Sets can be called as functions', 'Returns element if present, nil if not'],
    tags: ['set', 'function', 'lookup'],
  },
  {
    id: 'clj-set-108',
    category: 'Set Operations',
    difficulty: 'medium',
    title: 'Union Two Sets',
    text: 'Use `clojure.set/union` to combine two sets.',
    setup: '(require \'[clojure.set :as set])\n(def a #{1 2 3})\n(def b #{3 4 5})',
    setupCode: '(require \'[clojure.set :as set])\n(def a #{1 2 3})\n(def b #{3 4 5})',
    expected: [1, 2, 3, 4, 5],
    sample: '(set/union a b)',
    hints: ['union combines all elements', 'Duplicates removed'],
    tags: ['union', 'combine', 'set'],
  },
  {
    id: 'clj-set-109',
    category: 'Set Operations',
    difficulty: 'medium',
    title: 'Union Multiple Sets',
    text: 'Use `clojure.set/union` to combine three sets.',
    setup: '(require \'[clojure.set :as set])\n(def a #{1 2})\n(def b #{2 3})\n(def c #{3 4})',
    setupCode: '(require \'[clojure.set :as set])\n(def a #{1 2})\n(def b #{2 3})\n(def c #{3 4})',
    expected: [1, 2, 3, 4],
    sample: '(set/union a b c)',
    hints: ['union can take multiple sets', 'All combined'],
    tags: ['union', 'multiple', 'set'],
  },
  {
    id: 'clj-set-110',
    category: 'Set Operations',
    difficulty: 'medium',
    title: 'Intersection Two Sets',
    text: 'Use `clojure.set/intersection` to find common elements.',
    setup: '(require \'[clojure.set :as set])\n(def a #{1 2 3 4})\n(def b #{3 4 5 6})',
    setupCode: '(require \'[clojure.set :as set])\n(def a #{1 2 3 4})\n(def b #{3 4 5 6})',
    expected: [3, 4],
    sample: '(set/intersection a b)',
    hints: ['intersection finds common elements', 'Only in both sets'],
    tags: ['intersection', 'common', 'set'],
  },
  {
    id: 'clj-set-111',
    category: 'Set Operations',
    difficulty: 'hard',
    title: 'Intersection Multiple Sets',
    text: 'Find elements common to all three sets.',
    setup: '(require \'[clojure.set :as set])\n(def a #{1 2 3})\n(def b #{2 3 4})\n(def c #{3 4 5})',
    setupCode: '(require \'[clojure.set :as set])\n(def a #{1 2 3})\n(def b #{2 3 4})\n(def c #{3 4 5})',
    expected: [3],
    sample: '(set/intersection a b c)',
    hints: ['intersection of all three', 'Only element in all sets'],
    tags: ['intersection', 'multiple', 'set'],
  },
  {
    id: 'clj-set-112',
    category: 'Set Operations',
    difficulty: 'medium',
    title: 'Difference Two Sets',
    text: 'Use `clojure.set/difference` to find elements in a but not b.',
    setup: '(require \'[clojure.set :as set])\n(def a #{1 2 3 4})\n(def b #{3 4 5 6})',
    setupCode: '(require \'[clojure.set :as set])\n(def a #{1 2 3 4})\n(def b #{3 4 5 6})',
    expected: [1, 2],
    sample: '(set/difference a b)',
    hints: ['difference removes elements', 'First set minus second'],
    tags: ['difference', 'subtract', 'set'],
  },
  {
    id: 'clj-set-113',
    category: 'Set Operations',
    difficulty: 'hard',
    title: 'Symmetric Difference',
    text: 'Find elements in either set but not both.',
    setup: '(require \'[clojure.set :as set])\n(def a #{1 2 3})\n(def b #{2 3 4})',
    setupCode: '(require \'[clojure.set :as set])\n(def a #{1 2 3})\n(def b #{2 3 4})',
    expected: [1, 4],
    sample: '(set/union (set/difference a b) (set/difference b a))',
    hints: ['Union of both differences', 'Elements unique to each set'],
    tags: ['difference', 'symmetric', 'set'],
  },
  {
    id: 'clj-set-114',
    category: 'Set Operations',
    difficulty: 'medium',
    title: 'Subset Check',
    text: 'Use `clojure.set/subset?` to check if a is subset of b.',
    setup: '(require \'[clojure.set :as set])\n(def a #{1 2})\n(def b #{1 2 3 4})',
    setupCode: '(require \'[clojure.set :as set])\n(def a #{1 2})\n(def b #{1 2 3 4})',
    expected: true,
    sample: '(set/subset? a b)',
    hints: ['subset? checks containment', 'All elements of a in b'],
    tags: ['subset?', 'check', 'containment'],
  },
  {
    id: 'clj-set-115',
    category: 'Set Operations',
    difficulty: 'medium',
    title: 'Superset Check',
    text: 'Use `clojure.set/superset?` to check if b contains all of a.',
    setup: '(require \'[clojure.set :as set])\n(def a #{1 2})\n(def b #{1 2 3 4})',
    setupCode: '(require \'[clojure.set :as set])\n(def a #{1 2})\n(def b #{1 2 3 4})',
    expected: true,
    sample: '(set/superset? b a)',
    hints: ['superset? is reverse of subset?', 'b contains all of a'],
    tags: ['superset?', 'check', 'containment'],
  },
  {
    id: 'clj-set-116',
    category: 'Set Operations',
    difficulty: 'easy',
    title: 'Count Set Size',
    text: 'Use `count` to get the number of elements in the set.',
    setup: '(def s #{:a :b :c :d :e})',
    setupCode: '(def s #{:a :b :c :d :e})',
    expected: 5,
    sample: '(count s)',
    hints: ['count returns set size', 'Works on any collection'],
    tags: ['count', 'size', 'set'],
  },
  {
    id: 'clj-set-117',
    category: 'Set Operations',
    difficulty: 'easy',
    title: 'Empty Set Check',
    text: 'Use `empty?` to check if set is empty.',
    setup: '(def s #{})',
    setupCode: '(def s #{})',
    expected: true,
    sample: '(empty? s)',
    hints: ['empty? returns boolean', 'True for empty set'],
    tags: ['empty?', 'check', 'set'],
  },
  {
    id: 'clj-set-118',
    category: 'Set Operations',
    difficulty: 'hard',
    title: 'Select from Set',
    text: 'Use `clojure.set/select` to keep elements greater than 3.',
    setup: '(require \'[clojure.set :as set])\n(def s #{1 2 3 4 5 6})',
    setupCode: '(require \'[clojure.set :as set])\n(def s #{1 2 3 4 5 6})',
    expected: [4, 5, 6],
    sample: '(set/select #(> % 3) s)',
    hints: ['select filters set by predicate', 'Like filter for sets'],
    tags: ['select', 'filter', 'set'],
  },
  {
    id: 'clj-set-119',
    category: 'Set Operations',
    difficulty: 'hard',
    title: 'Project from Set of Maps',
    text: 'Use `clojure.set/project` to select only :name key from set of maps.',
    setup: '(require \'[clojure.set :as set])\n(def s #{{:name "A" :age 1} {:name "B" :age 2}})',
    setupCode: '(require \'[clojure.set :as set])\n(def s #{{:name "A" :age 1} {:name "B" :age 2}})',
    expected: [{ name: 'A' }, { name: 'B' }],
    sample: '(set/project s [:name])',
    hints: ['project selects keys from maps', 'Like select-keys for each map'],
    tags: ['project', 'select', 'set-of-maps'],
  },
  {
    id: 'clj-set-120',
    category: 'Set Operations',
    difficulty: 'medium',
    title: 'Into Sorted Set',
    text: 'Use `into` to add elements to a sorted-set.',
    setup: '(def nums [5 2 8 1 9])',
    setupCode: '(def nums [5 2 8 1 9])',
    expected: [1, 2, 5, 8, 9],
    sample: '(into (sorted-set) nums)',
    hints: ['sorted-set maintains order', 'into adds all elements'],
    tags: ['sorted-set', 'into', 'ordered'],
  },
  {
    id: 'clj-set-121',
    category: 'Set Operations',
    difficulty: 'easy',
    title: 'Set? Type Check',
    text: 'Use `set?` to check if value is a set.',
    setup: '(def s #{1 2 3})',
    setupCode: '(def s #{1 2 3})',
    expected: true,
    sample: '(set? s)',
    hints: ['set? returns boolean', 'Type checking predicate'],
    tags: ['set?', 'type', 'check'],
  },
  {
    id: 'clj-set-122',
    category: 'Set Operations',
    difficulty: 'medium',
    title: 'Filter Set Elements',
    text: 'Use `filter` to keep only even numbers from set.',
    setup: '(def s #{1 2 3 4 5 6})',
    setupCode: '(def s #{1 2 3 4 5 6})',
    expected: [2, 4, 6],
    sample: '(filter even? s)',
    hints: ['filter works on sets', 'Returns sequence, not set'],
    tags: ['filter', 'set', 'predicate'],
  },
  {
    id: 'clj-set-123',
    category: 'Set Operations',
    difficulty: 'medium',
    title: 'Map over Set',
    text: 'Use `map` to double each element in the set.',
    setup: '(def s #{1 2 3})',
    setupCode: '(def s #{1 2 3})',
    expected: [2, 4, 6],
    sample: '(map #(* 2 %) s)',
    hints: ['map works on sets', 'Returns sequence'],
    tags: ['map', 'set', 'transform'],
  },
  {
    id: 'clj-set-124',
    category: 'Set Operations',
    difficulty: 'hard',
    title: 'Reduce Set to Sum',
    text: 'Use `reduce` to sum all elements in the set.',
    setup: '(def s #{1 2 3 4 5})',
    setupCode: '(def s #{1 2 3 4 5})',
    expected: 15,
    sample: '(reduce + s)',
    hints: ['reduce works on sets', '+ adds all elements'],
    tags: ['reduce', 'set', 'sum'],
  },
  {
    id: 'clj-set-125',
    category: 'Set Operations',
    difficulty: 'medium',
    title: 'Some Element Check',
    text: 'Use `some` to check if any element is greater than 5.',
    setup: '(def s #{1 2 3 4 5 6 7})',
    setupCode: '(def s #{1 2 3 4 5 6 7})',
    expected: true,
    sample: '(some #(> % 5) s)',
    hints: ['some returns first truthy value', 'Checks if any match'],
    tags: ['some', 'check', 'predicate'],
  },
  {
    id: 'clj-set-126',
    category: 'Set Operations',
    difficulty: 'medium',
    title: 'Every? Check All',
    text: 'Use `every?` to check if all elements are positive.',
    setup: '(def s #{1 2 3 4 5})',
    setupCode: '(def s #{1 2 3 4 5})',
    expected: true,
    sample: '(every? pos? s)',
    hints: ['every? checks all elements', 'Returns boolean'],
    tags: ['every?', 'check', 'all'],
  },
  {
    id: 'clj-set-127',
    category: 'Set Operations',
    difficulty: 'hard',
    title: 'Index Set by Function',
    text: 'Use `clojure.set/index` to group maps by :category.',
    setup: '(require \'[clojure.set :as set])\n(def s #{{:name "A" :category 1} {:name "B" :category 1} {:name "C" :category 2}})',
    setupCode: '(require \'[clojure.set :as set])\n(def s #{{:name "A" :category 1} {:name "B" :category 1} {:name "C" :category 2}})',
    expected: { '{:category 1}': [{ name: 'A', category: 1 }, { name: 'B', category: 1 }], '{:category 2}': [{ name: 'C', category: 2 }] },
    sample: '(set/index s [:category])',
    hints: ['index groups by key values', 'Returns map of sets'],
    tags: ['index', 'group', 'set-of-maps'],
  },
  {
    id: 'clj-set-128',
    category: 'Set Operations',
    difficulty: 'easy',
    title: 'First from Set',
    text: 'Use `first` to get any element from the set.',
    setup: '(def s #{:only-element})',
    setupCode: '(def s #{:only-element})',
    expected: 'only-element',
    sample: '(first s)',
    hints: ['first returns one element', 'Order not guaranteed'],
    tags: ['first', 'access', 'set'],
  },
  {
    id: 'clj-set-129',
    category: 'Set Operations',
    difficulty: 'medium',
    title: 'Seq on Set',
    text: 'Use `seq` to convert set to sequence.',
    setup: '(def s #{1 2 3})',
    setupCode: '(def s #{1 2 3})',
    expected: [1, 2, 3],
    sample: '(seq s)',
    hints: ['seq converts to sequence', 'Order may vary'],
    tags: ['seq', 'convert', 'set'],
  },
  {
    id: 'clj-set-130',
    category: 'Set Operations',
    difficulty: 'hard',
    title: 'Join Sets of Maps',
    text: 'Use `clojure.set/join` to join two relation sets.',
    setup: '(require \'[clojure.set :as set])\n(def a #{{:id 1 :name "A"} {:id 2 :name "B"}})\n(def b #{{:id 1 :val 10} {:id 2 :val 20}})',
    setupCode: '(require \'[clojure.set :as set])\n(def a #{{:id 1 :name "A"} {:id 2 :name "B"}})\n(def b #{{:id 1 :val 10} {:id 2 :val 20}})',
    expected: [{ id: 1, name: 'A', val: 10 }, { id: 2, name: 'B', val: 20 }],
    sample: '(set/join a b)',
    hints: ['join like SQL inner join', 'Matches on common keys'],
    tags: ['join', 'relational', 'set-of-maps'],
  },
  {
    id: 'clj-set-131',
    category: 'Set Operations',
    difficulty: 'medium',
    title: 'Clojure into Set',
    text: 'Use `into` to merge two sets.',
    setup: '(def a #{1 2 3})\n(def b #{3 4 5})',
    setupCode: '(def a #{1 2 3})\n(def b #{3 4 5})',
    expected: [1, 2, 3, 4, 5],
    sample: '(into a b)',
    hints: ['into adds all elements to target', 'Alternative to union'],
    tags: ['into', 'merge', 'set'],
  },
  {
    id: 'clj-set-132',
    category: 'Set Operations',
    difficulty: 'hard',
    title: 'Sorted Set with Comparator',
    text: 'Create a sorted set with descending order.',
    setup: '(def nums [3 1 4 1 5 9 2 6])',
    setupCode: '(def nums [3 1 4 1 5 9 2 6])',
    expected: [9, 6, 5, 4, 3, 2, 1],
    sample: '(into (sorted-set-by >) nums)',
    hints: ['sorted-set-by takes comparator', '> for descending'],
    tags: ['sorted-set-by', 'comparator', 'order'],
  },
  {
    id: 'clj-set-133',
    category: 'Set Operations',
    difficulty: 'medium',
    title: 'Remove from Set if Present',
    text: 'Use `disj` to safely remove element (no error if missing).',
    setup: '(def s #{1 2 3})',
    setupCode: '(def s #{1 2 3})',
    expected: [1, 2, 3],
    sample: '(disj s 99)',
    hints: ['disj is safe if element missing', 'Returns unchanged set'],
    tags: ['disj', 'safe', 'remove'],
  },
  {
    id: 'clj-set-134',
    category: 'Set Operations',
    difficulty: 'hard',
    title: 'Set Comprehension',
    text: 'Use `into` with `for` to create set of squares.',
    setup: '(def nums [1 2 3 4 5])',
    setupCode: '(def nums [1 2 3 4 5])',
    expected: [1, 4, 9, 16, 25],
    sample: '(into #{} (for [n nums] (* n n)))',
    hints: ['for creates lazy seq', 'into #{} converts to set'],
    tags: ['for', 'into', 'comprehension'],
  },

  // ============================================================
  // String Functions (35 problems)
  // ============================================================

  {
    id: 'clj-str-100',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'String Concatenation',
    text: 'Use `str` to concatenate three strings.',
    setup: '(def a "Hello")\n(def b " ")\n(def c "World")',
    setupCode: '(def a "Hello")\n(def b " ")\n(def c "World")',
    expected: 'Hello World',
    sample: '(str a b c)',
    hints: ['str joins multiple args', 'Works with any values'],
    tags: ['str', 'concatenate', 'join'],
  },
  {
    id: 'clj-str-101',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Convert to String',
    text: 'Use `str` to convert number to string.',
    setup: '(def n 42)',
    setupCode: '(def n 42)',
    expected: '42',
    sample: '(str n)',
    hints: ['str converts any value', 'Common conversion method'],
    tags: ['str', 'convert', 'number'],
  },
  {
    id: 'clj-str-102',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Substring from Start',
    text: 'Use `subs` to extract first 5 characters.',
    setup: '(def s "Hello World")',
    setupCode: '(def s "Hello World")',
    expected: 'Hello',
    sample: '(subs s 0 5)',
    hints: ['subs takes start and end', 'End is exclusive'],
    tags: ['subs', 'substring', 'extract'],
  },
  {
    id: 'clj-str-103',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Substring to End',
    text: 'Use `subs` to extract from position 6 to end.',
    setup: '(def s "Hello World")',
    setupCode: '(def s "Hello World")',
    expected: 'World',
    sample: '(subs s 6)',
    hints: ['subs with one index to end', 'Omit end parameter'],
    tags: ['subs', 'substring', 'end'],
  },
  {
    id: 'clj-str-104',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Split by Space',
    text: 'Use `clojure.string/split` to split into words.',
    setup: '(require \'[clojure.string :as str])\n(def s "one two three")',
    setupCode: '(require \'[clojure.string :as str])\n(def s "one two three")',
    expected: ['one', 'two', 'three'],
    sample: '(str/split s #" ")',
    hints: ['split takes regex', '#" " matches space'],
    tags: ['split', 'words', 'regex'],
  },
  {
    id: 'clj-str-105',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Split by Multiple Delimiters',
    text: 'Use `split` with regex to split by comma or semicolon.',
    setup: '(require \'[clojure.string :as str])\n(def s "a,b;c,d")',
    setupCode: '(require \'[clojure.string :as str])\n(def s "a,b;c,d")',
    expected: ['a', 'b', 'c', 'd'],
    sample: '(str/split s #"[,;]")',
    hints: ['Regex character class [,;]', 'Matches either delimiter'],
    tags: ['split', 'regex', 'multiple'],
  },
  {
    id: 'clj-str-106',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Join with Separator',
    text: 'Use `clojure.string/join` to join with comma.',
    setup: '(require \'[clojure.string :as str])\n(def words ["a" "b" "c"])',
    setupCode: '(require \'[clojure.string :as str])\n(def words ["a" "b" "c"])',
    expected: 'a,b,c',
    sample: '(str/join "," words)',
    hints: ['join takes separator first', 'Combines all elements'],
    tags: ['join', 'separator', 'combine'],
  },
  {
    id: 'clj-str-107',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Join without Separator',
    text: 'Use `clojure.string/join` to concatenate directly.',
    setup: '(require \'[clojure.string :as str])\n(def chars ["a" "b" "c"])',
    setupCode: '(require \'[clojure.string :as str])\n(def chars ["a" "b" "c"])',
    expected: 'abc',
    sample: '(str/join chars)',
    hints: ['join without separator', 'Concatenates directly'],
    tags: ['join', 'concatenate', 'no-separator'],
  },
  {
    id: 'clj-str-108',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Replace All Occurrences',
    text: 'Use `clojure.string/replace` to replace all spaces with dashes.',
    setup: '(require \'[clojure.string :as str])\n(def s "hello world clojure")',
    setupCode: '(require \'[clojure.string :as str])\n(def s "hello world clojure")',
    expected: 'hello-world-clojure',
    sample: '(str/replace s " " "-")',
    hints: ['replace replaces all occurrences', 'String or regex pattern'],
    tags: ['replace', 'substitute', 'all'],
  },
  {
    id: 'clj-str-109',
    category: 'String Functions',
    difficulty: 'hard',
    title: 'Replace with Regex',
    text: 'Use `replace` with regex to remove all digits.',
    setup: '(require \'[clojure.string :as str])\n(def s "a1b2c3d4")',
    setupCode: '(require \'[clojure.string :as str])\n(def s "a1b2c3d4")',
    expected: 'abcd',
    sample: '(str/replace s #"\\d" "")',
    hints: ['#"\\d" matches digits', 'Replace with empty string'],
    tags: ['replace', 'regex', 'remove'],
  },
  {
    id: 'clj-str-110',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Upper Case',
    text: 'Use `clojure.string/upper-case` to convert to uppercase.',
    setup: '(require \'[clojure.string :as str])\n(def s "hello")',
    setupCode: '(require \'[clojure.string :as str])\n(def s "hello")',
    expected: 'HELLO',
    sample: '(str/upper-case s)',
    hints: ['upper-case converts entire string', 'Returns new string'],
    tags: ['upper-case', 'case', 'transform'],
  },
  {
    id: 'clj-str-111',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Lower Case',
    text: 'Use `clojure.string/lower-case` to convert to lowercase.',
    setup: '(require \'[clojure.string :as str])\n(def s "HELLO")',
    setupCode: '(require \'[clojure.string :as str])\n(def s "HELLO")',
    expected: 'hello',
    sample: '(str/lower-case s)',
    hints: ['lower-case converts entire string', 'Returns new string'],
    tags: ['lower-case', 'case', 'transform'],
  },
  {
    id: 'clj-str-112',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Capitalize First',
    text: 'Use `clojure.string/capitalize` to capitalize first letter.',
    setup: '(require \'[clojure.string :as str])\n(def s "hello world")',
    setupCode: '(require \'[clojure.string :as str])\n(def s "hello world")',
    expected: 'Hello world',
    sample: '(str/capitalize s)',
    hints: ['capitalize first letter only', 'Rest lowercase'],
    tags: ['capitalize', 'case', 'first'],
  },
  {
    id: 'clj-str-113',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Trim Whitespace',
    text: 'Use `clojure.string/trim` to remove leading/trailing whitespace.',
    setup: '(require \'[clojure.string :as str])\n(def s "  hello  ")',
    setupCode: '(require \'[clojure.string :as str])\n(def s "  hello  ")',
    expected: 'hello',
    sample: '(str/trim s)',
    hints: ['trim removes both ends', 'Whitespace only'],
    tags: ['trim', 'whitespace', 'clean'],
  },
  {
    id: 'clj-str-114',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Trim Left',
    text: 'Use `clojure.string/triml` to remove leading whitespace only.',
    setup: '(require \'[clojure.string :as str])\n(def s "  hello  ")',
    setupCode: '(require \'[clojure.string :as str])\n(def s "  hello  ")',
    expected: 'hello  ',
    sample: '(str/triml s)',
    hints: ['triml trims left side only', 'Trailing whitespace kept'],
    tags: ['triml', 'trim', 'left'],
  },
  {
    id: 'clj-str-115',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Trim Right',
    text: 'Use `clojure.string/trimr` to remove trailing whitespace only.',
    setup: '(require \'[clojure.string :as str])\n(def s "  hello  ")',
    setupCode: '(require \'[clojure.string :as str])\n(def s "  hello  ")',
    expected: '  hello',
    sample: '(str/trimr s)',
    hints: ['trimr trims right side only', 'Leading whitespace kept'],
    tags: ['trimr', 'trim', 'right'],
  },
  {
    id: 'clj-str-116',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Blank Check',
    text: 'Use `clojure.string/blank?` to check if string is blank.',
    setup: '(require \'[clojure.string :as str])\n(def s "   ")',
    setupCode: '(require \'[clojure.string :as str])\n(def s "   ")',
    expected: true,
    sample: '(str/blank? s)',
    hints: ['blank? checks for whitespace only', 'Also true for empty'],
    tags: ['blank?', 'check', 'empty'],
  },
  {
    id: 'clj-str-117',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Starts With Check',
    text: 'Use `clojure.string/starts-with?` to check prefix.',
    setup: '(require \'[clojure.string :as str])\n(def s "hello world")',
    setupCode: '(require \'[clojure.string :as str])\n(def s "hello world")',
    expected: true,
    sample: '(str/starts-with? s "hello")',
    hints: ['starts-with? checks beginning', 'Returns boolean'],
    tags: ['starts-with?', 'prefix', 'check'],
  },
  {
    id: 'clj-str-118',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Ends With Check',
    text: 'Use `clojure.string/ends-with?` to check suffix.',
    setup: '(require \'[clojure.string :as str])\n(def s "hello world")',
    setupCode: '(require \'[clojure.string :as str])\n(def s "hello world")',
    expected: true,
    sample: '(str/ends-with? s "world")',
    hints: ['ends-with? checks ending', 'Returns boolean'],
    tags: ['ends-with?', 'suffix', 'check'],
  },
  {
    id: 'clj-str-119',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Includes Check',
    text: 'Use `clojure.string/includes?` to check if contains substring.',
    setup: '(require \'[clojure.string :as str])\n(def s "hello world")',
    setupCode: '(require \'[clojure.string :as str])\n(def s "hello world")',
    expected: true,
    sample: '(str/includes? s "lo wo")',
    hints: ['includes? checks for substring', 'Anywhere in string'],
    tags: ['includes?', 'contains', 'substring'],
  },
  {
    id: 'clj-str-120',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Reverse String',
    text: 'Use `clojure.string/reverse` to reverse the string.',
    setup: '(require \'[clojure.string :as str])\n(def s "hello")',
    setupCode: '(require \'[clojure.string :as str])\n(def s "hello")',
    expected: 'olleh',
    sample: '(str/reverse s)',
    hints: ['reverse reverses characters', 'Returns new string'],
    tags: ['reverse', 'string', 'transform'],
  },
  {
    id: 'clj-str-121',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'String Length',
    text: 'Use `count` to get the length of the string.',
    setup: '(def s "hello")',
    setupCode: '(def s "hello")',
    expected: 5,
    sample: '(count s)',
    hints: ['count works on strings', 'Returns character count'],
    tags: ['count', 'length', 'string'],
  },
  {
    id: 'clj-str-122',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Get Character at Index',
    text: 'Use `nth` to get character at index 1.',
    setup: '(def s "hello")',
    setupCode: '(def s "hello")',
    expected: 'e',
    sample: '(nth s 1)',
    hints: ['nth works on strings', 'Returns character'],
    tags: ['nth', 'index', 'character'],
  },
  {
    id: 'clj-str-123',
    category: 'String Functions',
    difficulty: 'hard',
    title: 'Split Lines',
    text: 'Use `clojure.string/split-lines` to split by newlines.',
    setup: '(require \'[clojure.string :as str])\n(def s "line1\\nline2\\nline3")',
    setupCode: '(require \'[clojure.string :as str])\n(def s "line1\\nline2\\nline3")',
    expected: ['line1', 'line2', 'line3'],
    sample: '(str/split-lines s)',
    hints: ['split-lines splits on newlines', 'Handles different line endings'],
    tags: ['split-lines', 'newline', 'split'],
  },
  {
    id: 'clj-str-124',
    category: 'String Functions',
    difficulty: 'hard',
    title: 'Replace First Only',
    text: 'Use `clojure.string/replace-first` to replace only first occurrence.',
    setup: '(require \'[clojure.string :as str])\n(def s "abcabc")',
    setupCode: '(require \'[clojure.string :as str])\n(def s "abcabc")',
    expected: 'Xbcabc',
    sample: '(str/replace-first s "a" "X")',
    hints: ['replace-first only replaces first', 'Unlike replace'],
    tags: ['replace-first', 'substitute', 'first'],
  },
  {
    id: 'clj-str-125',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Index Of Substring',
    text: 'Use `.indexOf` to find position of substring.',
    setup: '(def s "hello world")',
    setupCode: '(def s "hello world")',
    expected: 6,
    sample: '(.indexOf s "world")',
    hints: ['Java interop with .indexOf', 'Returns index or -1'],
    tags: ['indexOf', 'find', 'position'],
  },
  {
    id: 'clj-str-126',
    category: 'String Functions',
    difficulty: 'hard',
    title: 'Regex Match',
    text: 'Use `re-find` to find first digit in string.',
    setup: '(def s "abc123def")',
    setupCode: '(def s "abc123def")',
    expected: '1',
    sample: '(re-find #"\\d" s)',
    hints: ['re-find returns first match', '#"\\d" matches digit'],
    tags: ['re-find', 'regex', 'match'],
  },
  {
    id: 'clj-str-127',
    category: 'String Functions',
    difficulty: 'hard',
    title: 'Regex Match All',
    text: 'Use `re-seq` to find all digits in string.',
    setup: '(def s "a1b2c3")',
    setupCode: '(def s "a1b2c3")',
    expected: ['1', '2', '3'],
    sample: '(re-seq #"\\d" s)',
    hints: ['re-seq returns all matches', 'Lazy sequence'],
    tags: ['re-seq', 'regex', 'all'],
  },
  {
    id: 'clj-str-128',
    category: 'String Functions',
    difficulty: 'hard',
    title: 'Regex Groups',
    text: 'Use `re-matches` to extract groups from pattern.',
    setup: '(def s "hello world")',
    setupCode: '(def s "hello world")',
    expected: ['hello world', 'hello', 'world'],
    sample: '(re-matches #"(\\w+) (\\w+)" s)',
    hints: ['re-matches returns vector of groups', 'First is full match'],
    tags: ['re-matches', 'groups', 'capture'],
  },
  {
    id: 'clj-str-129',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Format String',
    text: 'Use `format` to create formatted string with number.',
    setup: '(def n 42)',
    setupCode: '(def n 42)',
    expected: 'The answer is 42',
    sample: '(format "The answer is %d" n)',
    hints: ['format uses printf syntax', '%d for integers'],
    tags: ['format', 'printf', 'template'],
  },
  {
    id: 'clj-str-130',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Format Float',
    text: 'Use `format` to format float with 2 decimal places.',
    setup: '(def pi 3.14159)',
    setupCode: '(def pi 3.14159)',
    expected: '3.14',
    sample: '(format "%.2f" pi)',
    hints: ['%.2f for 2 decimal places', 'Printf formatting'],
    tags: ['format', 'float', 'decimal'],
  },
  {
    id: 'clj-str-131',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Keyword to String',
    text: 'Use `name` to convert keyword to string.',
    setup: '(def k :hello)',
    setupCode: '(def k :hello)',
    expected: 'hello',
    sample: '(name k)',
    hints: ['name extracts string part', 'Works on keywords and symbols'],
    tags: ['name', 'keyword', 'convert'],
  },
  {
    id: 'clj-str-132',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'String to Keyword',
    text: 'Use `keyword` to convert string to keyword.',
    setup: '(def s "hello")',
    setupCode: '(def s "hello")',
    expected: 'hello',
    sample: '(keyword s)',
    hints: ['keyword creates keyword from string', 'Returns keyword'],
    tags: ['keyword', 'convert', 'string'],
  },
  {
    id: 'clj-str-133',
    category: 'String Functions',
    difficulty: 'hard',
    title: 'Escape HTML',
    text: 'Use `clojure.string/escape` to escape HTML characters.',
    setup: '(require \'[clojure.string :as str])\n(def s "<div>")',
    setupCode: '(require \'[clojure.string :as str])\n(def s "<div>")',
    expected: '&lt;div&gt;',
    sample: '(str/escape s {\\< "&lt;" \\> "&gt;"})',
    hints: ['escape takes character map', 'Replaces characters'],
    tags: ['escape', 'html', 'sanitize'],
  },
  {
    id: 'clj-str-134',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Parse Integer',
    text: 'Use `Integer/parseInt` to convert string to integer.',
    setup: '(def s "42")',
    setupCode: '(def s "42")',
    expected: 42,
    sample: '(Integer/parseInt s)',
    hints: ['Java interop for parsing', 'Returns int'],
    tags: ['parseInt', 'convert', 'number'],
  },

  // ============================================================
  // Higher-Order Functions (40 problems)
  // ============================================================

  {
    id: 'clj-hof-100',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Compose Two Functions',
    text: 'Use `comp` to create a function that increments then squares.',
    setup: '(def x 4)',
    setupCode: '(def x 4)',
    expected: 25,
    sample: '((comp #(* % %) inc) x)',
    hints: ['comp applies right to left', 'inc then square: (4+1)^2 = 25'],
    tags: ['comp', 'compose', 'functions'],
  },
  {
    id: 'clj-hof-101',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Compose Three Functions',
    text: 'Use `comp` to reverse, uppercase, then get first char.',
    setup: '(require \'[clojure.string :as str])\n(def s "hello")',
    setupCode: '(require \'[clojure.string :as str])\n(def s "hello")',
    expected: 'O',
    sample: '((comp first str/upper-case str/reverse) s)',
    hints: ['comp applies right to left', 'reverse -> upper -> first'],
    tags: ['comp', 'multiple', 'chain'],
  },
  {
    id: 'clj-hof-102',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'Partial Add 10',
    text: 'Use `partial` to create a function that adds 10.',
    setup: '(def x 5)',
    setupCode: '(def x 5)',
    expected: 15,
    sample: '((partial + 10) x)',
    hints: ['partial fixes arguments', 'Returns new function'],
    tags: ['partial', 'curry', 'add'],
  },
  {
    id: 'clj-hof-103',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Partial with Multiple Args',
    text: 'Use `partial` to create multiplier by 3.',
    setup: '(def x 7)',
    setupCode: '(def x 7)',
    expected: 21,
    sample: '((partial * 3) x)',
    hints: ['partial works with any function', 'Fixes first argument'],
    tags: ['partial', 'multiply', 'curry'],
  },
  {
    id: 'clj-hof-104',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Partial String Formatter',
    text: 'Use `partial` to create a greeter function.',
    setup: '(def name "World")',
    setupCode: '(def name "World")',
    expected: 'Hello, World!',
    sample: '((partial str "Hello, ") name "!")',
    hints: ['partial with str', 'Remaining args appended'],
    tags: ['partial', 'str', 'format'],
  },
  {
    id: 'clj-hof-105',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Juxt First and Last',
    text: 'Use `juxt` to get both first and last elements.',
    setup: '(def v [1 2 3 4 5])',
    setupCode: '(def v [1 2 3 4 5])',
    expected: [1, 5],
    sample: '((juxt first last) v)',
    hints: ['juxt applies all functions', 'Returns vector of results'],
    tags: ['juxt', 'first', 'last'],
  },
  {
    id: 'clj-hof-106',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Juxt Multiple Keys',
    text: 'Use `juxt` to extract :x, :y, :z from a map.',
    setup: '(def m {:x 1 :y 2 :z 3 :w 4})',
    setupCode: '(def m {:x 1 :y 2 :z 3 :w 4})',
    expected: [1, 2, 3],
    sample: '((juxt :x :y :z) m)',
    hints: ['Keywords are functions', 'juxt combines their results'],
    tags: ['juxt', 'keywords', 'extract'],
  },
  {
    id: 'clj-hof-107',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Juxt with Transformations',
    text: 'Use `juxt` to get count, first, and last of a vector.',
    setup: '(def v [:a :b :c :d])',
    setupCode: '(def v [:a :b :c :d])',
    expected: [4, 'a', 'd'],
    sample: '((juxt count first last) v)',
    hints: ['juxt combines any functions', 'Applied to same input'],
    tags: ['juxt', 'count', 'analysis'],
  },
  {
    id: 'clj-hof-108',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'Apply Max',
    text: 'Use `apply` to find maximum of a vector.',
    setup: '(def nums [3 1 4 1 5 9 2 6])',
    setupCode: '(def nums [3 1 4 1 5 9 2 6])',
    expected: 9,
    sample: '(apply max nums)',
    hints: ['apply spreads args', 'max takes varargs'],
    tags: ['apply', 'max', 'spread'],
  },
  {
    id: 'clj-hof-109',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'Apply Min',
    text: 'Use `apply` to find minimum of a vector.',
    setup: '(def nums [3 1 4 1 5 9 2 6])',
    setupCode: '(def nums [3 1 4 1 5 9 2 6])',
    expected: 1,
    sample: '(apply min nums)',
    hints: ['apply spreads collection', 'min finds smallest'],
    tags: ['apply', 'min', 'spread'],
  },
  {
    id: 'clj-hof-110',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Apply String Join',
    text: 'Use `apply` with `str` to concatenate vector elements.',
    setup: '(def parts ["Hello" " " "World"])',
    setupCode: '(def parts ["Hello" " " "World"])',
    expected: 'Hello World',
    sample: '(apply str parts)',
    hints: ['str takes multiple args', 'apply spreads vector'],
    tags: ['apply', 'str', 'concat'],
  },
  {
    id: 'clj-hof-111',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Apply with Leading Args',
    text: 'Use `apply` with leading args to divide 100 by elements.',
    setup: '(def divisors [2 5])',
    setupCode: '(def divisors [2 5])',
    expected: 10,
    sample: '(apply / 100 divisors)',
    hints: ['apply can have leading args', '100 / 2 / 5 = 10'],
    tags: ['apply', 'leading', 'divide'],
  },
  {
    id: 'clj-hof-112',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'Thread First Basic',
    text: 'Use `->` to increment then double a number.',
    setup: '(def x 5)',
    setupCode: '(def x 5)',
    expected: 12,
    sample: '(-> x inc (* 2))',
    hints: ['-> threads as first arg', 'Left to right'],
    tags: ['->', 'thread', 'chain'],
  },
  {
    id: 'clj-hof-113',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Thread First with Maps',
    text: 'Use `->` to update a map multiple times.',
    setup: '(def m {:a 1})',
    setupCode: '(def m {:a 1})',
    expected: { a: 1, b: 2, c: 3 },
    sample: '(-> m (assoc :b 2) (assoc :c 3))',
    hints: ['-> works great with assoc', 'Each step builds on previous'],
    tags: ['->', 'assoc', 'map'],
  },
  {
    id: 'clj-hof-114',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Thread First Complex',
    text: 'Use `->` to transform a map: add key, update value, dissoc.',
    setup: '(def m {:name "Alice" :temp true})',
    setupCode: '(def m {:name "Alice" :temp true})',
    expected: { name: 'Alice', age: 30 },
    sample: '(-> m (assoc :age 30) (dissoc :temp))',
    hints: ['Chain multiple operations', 'Clean transformation pipeline'],
    tags: ['->', 'transform', 'pipeline'],
  },
  {
    id: 'clj-hof-115',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'Thread Last Basic',
    text: 'Use `->>` to filter then take from sequence.',
    setup: '(def nums [1 2 3 4 5 6 7 8 9 10])',
    setupCode: '(def nums [1 2 3 4 5 6 7 8 9 10])',
    expected: [2, 4, 6],
    sample: '(->> nums (filter even?) (take 3))',
    hints: ['->> threads as last arg', 'Sequence functions'],
    tags: ['->>', 'filter', 'take'],
  },
  {
    id: 'clj-hof-116',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Thread Last Map Filter',
    text: 'Use `->>` to double numbers then keep those > 10.',
    setup: '(def nums [1 2 3 4 5 6 7 8])',
    setupCode: '(def nums [1 2 3 4 5 6 7 8])',
    expected: [12, 14, 16],
    sample: '(->> nums (map #(* 2 %)) (filter #(> % 10)))',
    hints: ['->> for sequence operations', 'map then filter'],
    tags: ['->>', 'map', 'filter'],
  },
  {
    id: 'clj-hof-117',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Thread Last Pipeline',
    text: 'Use `->>` to filter, map, and reduce a sequence.',
    setup: '(def nums [1 2 3 4 5 6])',
    setupCode: '(def nums [1 2 3 4 5 6])',
    expected: 24,
    sample: '(->> nums (filter even?) (map #(* 2 %)) (reduce +))',
    hints: ['Full pipeline: filter -> map -> reduce', 'Even nums doubled then summed'],
    tags: ['->>', 'pipeline', 'reduce'],
  },
  {
    id: 'clj-hof-118',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'As-> Threading',
    text: 'Use `as->` to thread with variable position.',
    setup: '(def x 5)',
    setupCode: '(def x 5)',
    expected: 20,
    sample: '(as-> x $ (+ $ 5) (* 2 $))',
    hints: ['as-> names the threaded value', '$ can appear anywhere'],
    tags: ['as->', 'flexible', 'thread'],
  },
  {
    id: 'clj-hof-119',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Some-> Nil Safe',
    text: 'Use `some->` to safely navigate nested structure.',
    setup: '(def data {:user {:name "Alice"}})',
    setupCode: '(def data {:user {:name "Alice"}})',
    expected: 'ALICE',
    sample: '(some-> data :user :name clojure.string/upper-case)',
    hints: ['some-> short-circuits on nil', 'Safe navigation'],
    tags: ['some->', 'nil', 'safe'],
  },
  {
    id: 'clj-hof-120',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Some->> Nil Safe Last',
    text: 'Use `some->>` with sequence operations safely.',
    setup: '(def items [1 2 3])',
    setupCode: '(def items [1 2 3])',
    expected: [2, 4, 6],
    sample: '(some->> items (map #(* 2 %)))',
    hints: ['some->> threads as last arg', 'Nil-safe version of ->>'],
    tags: ['some->>', 'nil', 'sequence'],
  },
  {
    id: 'clj-hof-121',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Cond-> Conditional Threading',
    text: 'Use `cond->` to conditionally add key to map.',
    setup: '(def m {:name "Alice"})\n(def add-age? true)',
    setupCode: '(def m {:name "Alice"})\n(def add-age? true)',
    expected: { name: 'Alice', age: 30 },
    sample: '(cond-> m add-age? (assoc :age 30))',
    hints: ['cond-> threads when condition true', 'Selective transformation'],
    tags: ['cond->', 'conditional', 'thread'],
  },
  {
    id: 'clj-hof-122',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Cond->> Conditional Last',
    text: 'Use `cond->>` for conditional sequence operations.',
    setup: '(def nums [1 2 3 4 5])\n(def should-filter? true)',
    setupCode: '(def nums [1 2 3 4 5])\n(def should-filter? true)',
    expected: [2, 4],
    sample: '(cond->> nums should-filter? (filter even?))',
    hints: ['cond->> threads as last when true', 'Conditional pipeline'],
    tags: ['cond->>', 'conditional', 'filter'],
  },
  {
    id: 'clj-hof-123',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Complement Function',
    text: 'Use `complement` to create inverse predicate.',
    setup: '(def nums [1 2 3 4 5 6])',
    setupCode: '(def nums [1 2 3 4 5 6])',
    expected: [1, 3, 5],
    sample: '(filter (complement even?) nums)',
    hints: ['complement inverts predicate', 'Like not but returns function'],
    tags: ['complement', 'predicate', 'inverse'],
  },
  {
    id: 'clj-hof-124',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Every-pred Combined Predicate',
    text: 'Use `every-pred` to check both even? and pos?.',
    setup: '(def nums [-2 -1 0 1 2 3 4])',
    setupCode: '(def nums [-2 -1 0 1 2 3 4])',
    expected: [2, 4],
    sample: '(filter (every-pred even? pos?) nums)',
    hints: ['every-pred combines predicates', 'All must be true'],
    tags: ['every-pred', 'combine', 'and'],
  },
  {
    id: 'clj-hof-125',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Some-fn Any Predicate',
    text: 'Use `some-fn` to check if zero? or neg?.',
    setup: '(def nums [1 2 0 3 -1 4])',
    setupCode: '(def nums [1 2 0 3 -1 4])',
    expected: [0, -1],
    sample: '(filter (some-fn zero? neg?) nums)',
    hints: ['some-fn combines with or', 'Any predicate true'],
    tags: ['some-fn', 'combine', 'or'],
  },
  {
    id: 'clj-hof-126',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'Constantly Return Value',
    text: 'Use `constantly` to create function that always returns 42.',
    setup: '(def always-42 (constantly 42))',
    setupCode: '(def always-42 (constantly 42))',
    expected: 42,
    sample: '(always-42 :any :args)',
    hints: ['constantly ignores arguments', 'Always returns same value'],
    tags: ['constantly', 'constant', 'function'],
  },
  {
    id: 'clj-hof-127',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'Identity Function',
    text: 'Use `identity` to return the input unchanged.',
    setup: '(def x {:a 1})',
    setupCode: '(def x {:a 1})',
    expected: { a: 1 },
    sample: '(identity x)',
    hints: ['identity returns its argument', 'Useful as default function'],
    tags: ['identity', 'passthrough', 'function'],
  },
  {
    id: 'clj-hof-128',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Fnil with Default',
    text: 'Use `fnil` to provide default value for nil argument.',
    setup: '(def m {})',
    setupCode: '(def m {})',
    expected: { count: 1 },
    sample: '(update m :count (fnil inc 0))',
    hints: ['fnil replaces nil with default', 'Then applies function'],
    tags: ['fnil', 'nil', 'default'],
  },
  {
    id: 'clj-hof-129',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Memoize Function',
    text: 'Check that `memoize` caches results.',
    setup: '(def slow-fn (fn [x] (Thread/sleep 1) x))\n(def fast-fn (memoize slow-fn))',
    setupCode: '(def slow-fn (fn [x] (Thread/sleep 1) x))\n(def fast-fn (memoize slow-fn))',
    expected: 42,
    sample: '(fast-fn 42)',
    hints: ['memoize caches function results', 'Same input returns cached'],
    tags: ['memoize', 'cache', 'performance'],
  },
  {
    id: 'clj-hof-130',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Trampoline for Recursion',
    text: 'Use `trampoline` for tail-call optimization.',
    setup: '(defn count-down [n]\n  (if (zero? n)\n    n\n    #(count-down (dec n))))',
    setupCode: '(defn count-down [n]\n  (if (zero? n)\n    n\n    #(count-down (dec n))))',
    expected: 0,
    sample: '(trampoline count-down 10)',
    hints: ['trampoline continues calling', 'Enables deep recursion'],
    tags: ['trampoline', 'recursion', 'tail-call'],
  },
  {
    id: 'clj-hof-131',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Iterate Generate Sequence',
    text: 'Use `iterate` and `take` to generate powers of 2.',
    setup: '',
    setupCode: '',
    expected: [1, 2, 4, 8, 16],
    sample: '(take 5 (iterate #(* 2 %) 1))',
    hints: ['iterate applies fn repeatedly', 'Creates infinite sequence'],
    tags: ['iterate', 'generate', 'sequence'],
  },
  {
    id: 'clj-hof-132',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Reduce with Init Value',
    text: 'Use `reduce` with init value to concatenate with prefix.',
    setup: '(def words ["a" "b" "c"])',
    setupCode: '(def words ["a" "b" "c"])',
    expected: 'prefix:a:b:c',
    sample: '(reduce #(str %1 ":" %2) "prefix" words)',
    hints: ['Init value is starting accumulator', 'Build string incrementally'],
    tags: ['reduce', 'init', 'accumulate'],
  },
  {
    id: 'clj-hof-133',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Reductions Running Results',
    text: 'Use `reductions` to show running sum.',
    setup: '(def nums [1 2 3 4 5])',
    setupCode: '(def nums [1 2 3 4 5])',
    expected: [1, 3, 6, 10, 15],
    sample: '(reductions + nums)',
    hints: ['reductions shows intermediate results', 'Like reduce but keeps all'],
    tags: ['reductions', 'running', 'accumulate'],
  },
  {
    id: 'clj-hof-134',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Reduced Early Termination',
    text: 'Use `reduced` to stop reduce early when sum > 10.',
    setup: '(def nums [1 2 3 4 5 6 7 8 9])',
    setupCode: '(def nums [1 2 3 4 5 6 7 8 9])',
    expected: 15,
    sample: '(reduce #(if (> (+ %1 %2) 15) (reduced %1) (+ %1 %2)) nums)',
    hints: ['reduced wraps value to stop', 'Early termination'],
    tags: ['reduced', 'early', 'terminate'],
  },
  {
    id: 'clj-hof-135',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Keep Non-nil Results',
    text: 'Use `keep` to get only non-nil transformation results.',
    setup: '(def nums [1 2 3 4 5])',
    setupCode: '(def nums [1 2 3 4 5])',
    expected: [2, 4],
    sample: '(keep #(when (even? %) %) nums)',
    hints: ['keep removes nil results', 'Like filter + map combined'],
    tags: ['keep', 'filter', 'transform'],
  },
  {
    id: 'clj-hof-136',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Juxt for Statistics',
    text: 'Use `juxt` to compute min, max, and count at once.',
    setup: '(def nums [3 1 4 1 5 9 2 6])',
    setupCode: '(def nums [3 1 4 1 5 9 2 6])',
    expected: [1, 9, 8],
    sample: '((juxt #(apply min %) #(apply max %) count) nums)',
    hints: ['juxt applies all functions', 'Compute multiple statistics'],
    tags: ['juxt', 'statistics', 'aggregate'],
  },
  {
    id: 'clj-hof-137',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Partial Map Transform',
    text: 'Use `partial` and `map` to add 5 to each number.',
    setup: '(def nums [1 2 3 4 5])',
    setupCode: '(def nums [1 2 3 4 5])',
    expected: [6, 7, 8, 9, 10],
    sample: '(map (partial + 5) nums)',
    hints: ['partial creates adder', 'map applies to each'],
    tags: ['partial', 'map', 'transform'],
  },
  {
    id: 'clj-hof-138',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Comp with Partial',
    text: 'Use `comp` and `partial` together for transformation.',
    setup: '(def x 3)',
    setupCode: '(def x 3)',
    expected: 8,
    sample: '((comp (partial * 2) (partial + 1)) x)',
    hints: ['Compose partial functions', 'Add 1 then multiply 2'],
    tags: ['comp', 'partial', 'combine'],
  },
  {
    id: 'clj-hof-139',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Fn Literal with Multiple Args',
    text: 'Use fn literal to create subtraction function.',
    setup: '(def result (#(- %1 %2 %3) 10 3 2))',
    setupCode: '(def result (#(- %1 %2 %3) 10 3 2))',
    expected: 5,
    sample: 'result',
    hints: ['%1 %2 %3 for multiple args', '10 - 3 - 2 = 5'],
    tags: ['fn', 'literal', 'multiple-args'],
  },

  // ============================================================
  // Lazy Sequences (35 problems)
  // ============================================================

  {
    id: 'clj-lazy-100',
    category: 'Lazy Sequences',
    difficulty: 'easy',
    title: 'Range Generate Numbers',
    text: 'Use `range` to generate numbers 0 to 9.',
    setup: '',
    setupCode: '',
    expected: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
    sample: '(range 10)',
    hints: ['range generates lazy sequence', 'Excludes end value'],
    tags: ['range', 'generate', 'sequence'],
  },
  {
    id: 'clj-lazy-101',
    category: 'Lazy Sequences',
    difficulty: 'easy',
    title: 'Range with Start and End',
    text: 'Use `range` to generate numbers 5 to 9.',
    setup: '',
    setupCode: '',
    expected: [5, 6, 7, 8, 9],
    sample: '(range 5 10)',
    hints: ['range with two args: start end', 'Start inclusive, end exclusive'],
    tags: ['range', 'start', 'end'],
  },
  {
    id: 'clj-lazy-102',
    category: 'Lazy Sequences',
    difficulty: 'medium',
    title: 'Range with Step',
    text: 'Use `range` to generate even numbers 0 to 10.',
    setup: '',
    setupCode: '',
    expected: [0, 2, 4, 6, 8, 10],
    sample: '(range 0 11 2)',
    hints: ['Third arg is step', 'Step by 2 for evens'],
    tags: ['range', 'step', 'increment'],
  },
  {
    id: 'clj-lazy-103',
    category: 'Lazy Sequences',
    difficulty: 'easy',
    title: 'Repeat Value',
    text: 'Use `repeat` to create 5 copies of :x.',
    setup: '',
    setupCode: '',
    expected: ['x', 'x', 'x', 'x', 'x'],
    sample: '(repeat 5 :x)',
    hints: ['repeat with count and value', 'Creates finite sequence'],
    tags: ['repeat', 'duplicate', 'value'],
  },
  {
    id: 'clj-lazy-104',
    category: 'Lazy Sequences',
    difficulty: 'medium',
    title: 'Repeatedly Generate',
    text: 'Use `repeatedly` and `take` to generate 3 random-ish values.',
    setup: '',
    setupCode: '',
    expected: 3,
    sample: '(count (take 3 (repeatedly #(rand-int 100))))',
    hints: ['repeatedly calls function each time', 'Creates infinite sequence'],
    tags: ['repeatedly', 'generate', 'function'],
  },
  {
    id: 'clj-lazy-105',
    category: 'Lazy Sequences',
    difficulty: 'medium',
    title: 'Cycle Repeat Pattern',
    text: 'Use `cycle` and `take` to repeat pattern.',
    setup: '',
    setupCode: '',
    expected: [1, 2, 3, 1, 2, 3, 1],
    sample: '(take 7 (cycle [1 2 3]))',
    hints: ['cycle repeats infinitely', 'take limits result'],
    tags: ['cycle', 'repeat', 'pattern'],
  },
  {
    id: 'clj-lazy-106',
    category: 'Lazy Sequences',
    difficulty: 'medium',
    title: 'Iterate Generate',
    text: 'Use `iterate` to generate fibonacci-like pattern.',
    setup: '',
    setupCode: '',
    expected: [1, 2, 4, 8, 16],
    sample: '(take 5 (iterate #(* 2 %) 1))',
    hints: ['iterate applies function repeatedly', 'Each output becomes next input'],
    tags: ['iterate', 'generate', 'powers'],
  },
  {
    id: 'clj-lazy-107',
    category: 'Lazy Sequences',
    difficulty: 'hard',
    title: 'Iterate with State',
    text: 'Use `iterate` to generate countdown.',
    setup: '',
    setupCode: '',
    expected: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
    sample: '(take 10 (iterate dec 10))',
    hints: ['dec decrements by 1', 'iterate creates sequence'],
    tags: ['iterate', 'countdown', 'dec'],
  },
  {
    id: 'clj-lazy-108',
    category: 'Lazy Sequences',
    difficulty: 'easy',
    title: 'Lazy Seq Map',
    text: 'Verify `map` returns lazy sequence.',
    setup: '(def nums [1 2 3])',
    setupCode: '(def nums [1 2 3])',
    expected: true,
    sample: '(seq? (map inc nums))',
    hints: ['map returns lazy sequence', 'seq? checks if sequence'],
    tags: ['map', 'lazy', 'check'],
  },
  {
    id: 'clj-lazy-109',
    category: 'Lazy Sequences',
    difficulty: 'easy',
    title: 'Lazy Seq Filter',
    text: 'Verify `filter` returns lazy sequence.',
    setup: '(def nums [1 2 3 4 5])',
    setupCode: '(def nums [1 2 3 4 5])',
    expected: true,
    sample: '(seq? (filter even? nums))',
    hints: ['filter returns lazy sequence', 'Not realized until needed'],
    tags: ['filter', 'lazy', 'check'],
  },
  {
    id: 'clj-lazy-110',
    category: 'Lazy Sequences',
    difficulty: 'medium',
    title: 'Realize Lazy Seq',
    text: 'Use `doall` to force realization of lazy sequence.',
    setup: '(def nums (range 5))',
    setupCode: '(def nums (range 5))',
    expected: [0, 1, 2, 3, 4],
    sample: '(doall nums)',
    hints: ['doall forces realization', 'Returns the sequence'],
    tags: ['doall', 'realize', 'force'],
  },
  {
    id: 'clj-lazy-111',
    category: 'Lazy Sequences',
    difficulty: 'medium',
    title: 'Realize with dorun',
    text: 'Use `dorun` to realize sequence for side effects.',
    setup: '(def nums (range 5))',
    setupCode: '(def nums (range 5))',
    expected: null,
    sample: '(dorun nums)',
    hints: ['dorun returns nil', 'Only for side effects'],
    tags: ['dorun', 'realize', 'side-effects'],
  },
  {
    id: 'clj-lazy-112',
    category: 'Lazy Sequences',
    difficulty: 'hard',
    title: 'Lazy-seq Macro',
    text: 'Use `lazy-seq` to create custom lazy sequence.',
    setup: '(defn ones [] (lazy-seq (cons 1 (ones))))',
    setupCode: '(defn ones [] (lazy-seq (cons 1 (ones))))',
    expected: [1, 1, 1, 1, 1],
    sample: '(take 5 (ones))',
    hints: ['lazy-seq defers evaluation', 'cons builds sequence'],
    tags: ['lazy-seq', 'custom', 'recursive'],
  },
  {
    id: 'clj-lazy-113',
    category: 'Lazy Sequences',
    difficulty: 'hard',
    title: 'Custom Lazy Range',
    text: 'Create lazy sequence of naturals starting at n.',
    setup: '(defn naturals [n] (lazy-seq (cons n (naturals (inc n)))))',
    setupCode: '(defn naturals [n] (lazy-seq (cons n (naturals (inc n)))))',
    expected: [1, 2, 3, 4, 5],
    sample: '(take 5 (naturals 1))',
    hints: ['cons prepends element', 'Recursive lazy definition'],
    tags: ['lazy-seq', 'naturals', 'infinite'],
  },
  {
    id: 'clj-lazy-114',
    category: 'Lazy Sequences',
    difficulty: 'hard',
    title: 'Lazy Fibonacci',
    text: 'Generate Fibonacci numbers lazily.',
    setup: '(def fibs (lazy-cat [0 1] (map + fibs (rest fibs))))',
    setupCode: '(def fibs (lazy-cat [0 1] (map + fibs (rest fibs))))',
    expected: [0, 1, 1, 2, 3, 5, 8],
    sample: '(take 7 fibs)',
    hints: ['lazy-cat concatenates lazily', 'Self-referential definition'],
    tags: ['lazy-cat', 'fibonacci', 'infinite'],
  },
  {
    id: 'clj-lazy-115',
    category: 'Lazy Sequences',
    difficulty: 'medium',
    title: 'Concat Lazy',
    text: 'Use `concat` to join lazy sequences.',
    setup: '(def a (range 3))\n(def b (range 3 6))',
    setupCode: '(def a (range 3))\n(def b (range 3 6))',
    expected: [0, 1, 2, 3, 4, 5],
    sample: '(concat a b)',
    hints: ['concat returns lazy sequence', 'Joins sequences'],
    tags: ['concat', 'lazy', 'join'],
  },
  {
    id: 'clj-lazy-116',
    category: 'Lazy Sequences',
    difficulty: 'medium',
    title: 'Mapcat Flatten Lazy',
    text: 'Use `mapcat` for lazy flatmap.',
    setup: '(def nums [1 2 3])',
    setupCode: '(def nums [1 2 3])',
    expected: [1, 1, 2, 2, 3, 3],
    sample: '(mapcat #(repeat 2 %) nums)',
    hints: ['mapcat = map + concat', 'Flattens one level'],
    tags: ['mapcat', 'lazy', 'flatmap'],
  },
  {
    id: 'clj-lazy-117',
    category: 'Lazy Sequences',
    difficulty: 'easy',
    title: 'For List Comprehension',
    text: 'Use `for` to generate lazy sequence.',
    setup: '',
    setupCode: '',
    expected: [2, 4, 6, 8, 10],
    sample: '(for [x (range 1 6)] (* 2 x))',
    hints: ['for creates lazy sequence', 'Like list comprehension'],
    tags: ['for', 'comprehension', 'lazy'],
  },
  {
    id: 'clj-lazy-118',
    category: 'Lazy Sequences',
    difficulty: 'medium',
    title: 'For with Filter',
    text: 'Use `for` with `:when` to filter.',
    setup: '',
    setupCode: '',
    expected: [2, 4, 6, 8, 10],
    sample: '(for [x (range 1 11) :when (even? x)] x)',
    hints: [':when filters elements', 'Like guard clause'],
    tags: ['for', 'when', 'filter'],
  },
  {
    id: 'clj-lazy-119',
    category: 'Lazy Sequences',
    difficulty: 'hard',
    title: 'For Cartesian Product',
    text: 'Use `for` to generate all pairs.',
    setup: '(def a [1 2])\n(def b [:x :y])',
    setupCode: '(def a [1 2])\n(def b [:x :y])',
    expected: [[1, 'x'], [1, 'y'], [2, 'x'], [2, 'y']],
    sample: '(for [x a y b] [x y])',
    hints: ['Multiple bindings = cartesian product', 'All combinations'],
    tags: ['for', 'cartesian', 'pairs'],
  },
  {
    id: 'clj-lazy-120',
    category: 'Lazy Sequences',
    difficulty: 'hard',
    title: 'For with Let',
    text: 'Use `for` with `:let` for intermediate binding.',
    setup: '',
    setupCode: '',
    expected: [[1, 1], [2, 4], [3, 9]],
    sample: '(for [x (range 1 4) :let [sq (* x x)]] [x sq])',
    hints: [':let creates local binding', 'Use within for'],
    tags: ['for', 'let', 'binding'],
  },
  {
    id: 'clj-lazy-121',
    category: 'Lazy Sequences',
    difficulty: 'medium',
    title: 'Take from Infinite',
    text: 'Use `take` to get finite from infinite.',
    setup: '',
    setupCode: '',
    expected: [0, 0, 0, 0, 0],
    sample: '(take 5 (repeat 0))',
    hints: ['repeat without count is infinite', 'take makes it finite'],
    tags: ['take', 'infinite', 'finite'],
  },
  {
    id: 'clj-lazy-122',
    category: 'Lazy Sequences',
    difficulty: 'medium',
    title: 'Take While from Infinite',
    text: 'Use `take-while` to stop at condition.',
    setup: '',
    setupCode: '',
    expected: [0, 1, 2, 3, 4],
    sample: '(take-while #(< % 5) (range))',
    hints: ['range without args is infinite', 'take-while stops at predicate'],
    tags: ['take-while', 'infinite', 'predicate'],
  },
  {
    id: 'clj-lazy-123',
    category: 'Lazy Sequences',
    difficulty: 'hard',
    title: 'Interleave Infinite',
    text: 'Use `interleave` with infinite sequences.',
    setup: '',
    setupCode: '',
    expected: [0, 'a', 1, 'b', 2, 'c'],
    sample: '(take 6 (interleave (range) (cycle [:a :b :c])))',
    hints: ['interleave alternates', 'take limits infinite'],
    tags: ['interleave', 'infinite', 'alternate'],
  },
  {
    id: 'clj-lazy-124',
    category: 'Lazy Sequences',
    difficulty: 'easy',
    title: 'Realized? Check',
    text: 'Use `realized?` to check if lazy seq is realized.',
    setup: '(def nums (range 5))',
    setupCode: '(def nums (range 5))',
    expected: false,
    sample: '(realized? nums)',
    hints: ['realized? checks realization state', 'false until accessed'],
    tags: ['realized?', 'lazy', 'check'],
  },
  {
    id: 'clj-lazy-125',
    category: 'Lazy Sequences',
    difficulty: 'medium',
    title: 'Chunk Lazy Seq',
    text: 'Understand that lazy seqs often chunk by 32.',
    setup: '(def nums (range 100))',
    setupCode: '(def nums (range 100))',
    expected: 32,
    sample: '(count (chunk-first (chunk-rest (seq nums))))',
    hints: ['Lazy seqs chunk for efficiency', 'Chunks are typically 32'],
    tags: ['chunk', 'lazy', 'performance'],
  },
  {
    id: 'clj-lazy-126',
    category: 'Lazy Sequences',
    difficulty: 'hard',
    title: 'Sequence Over Iteration',
    text: 'Use `sequence` with transducer for lazy transformation.',
    setup: '(def nums (range 10))',
    setupCode: '(def nums (range 10))',
    expected: [0, 2, 4, 6, 8],
    sample: '(sequence (filter even?) nums)',
    hints: ['sequence applies transducer lazily', 'Returns lazy sequence'],
    tags: ['sequence', 'transducer', 'lazy'],
  },
  {
    id: 'clj-lazy-127',
    category: 'Lazy Sequences',
    difficulty: 'medium',
    title: 'Distinct Lazy',
    text: 'Use `distinct` for lazy deduplication.',
    setup: '(def nums [1 2 1 3 2 4 3 5])',
    setupCode: '(def nums [1 2 1 3 2 4 3 5])',
    expected: [1, 2, 3, 4, 5],
    sample: '(distinct nums)',
    hints: ['distinct is lazy', 'Removes duplicates on demand'],
    tags: ['distinct', 'lazy', 'dedupe'],
  },
  {
    id: 'clj-lazy-128',
    category: 'Lazy Sequences',
    difficulty: 'medium',
    title: 'Remove vs Filter',
    text: 'Use `remove` to exclude matching elements.',
    setup: '(def nums [1 2 3 4 5 6])',
    setupCode: '(def nums [1 2 3 4 5 6])',
    expected: [1, 3, 5],
    sample: '(remove even? nums)',
    hints: ['remove is complement of filter', 'Keeps non-matching'],
    tags: ['remove', 'lazy', 'exclude'],
  },
  {
    id: 'clj-lazy-129',
    category: 'Lazy Sequences',
    difficulty: 'hard',
    title: 'Line Seq File Reading',
    text: 'Understand `line-seq` for lazy file reading.',
    setup: '',
    setupCode: '',
    expected: true,
    sample: '(fn? line-seq)',
    hints: ['line-seq reads files lazily', 'Returns lazy seq of lines'],
    tags: ['line-seq', 'lazy', 'file'],
  },
  {
    id: 'clj-lazy-130',
    category: 'Lazy Sequences',
    difficulty: 'hard',
    title: 'Tree Seq Lazy Traversal',
    text: 'Use `tree-seq` for lazy tree traversal.',
    setup: '(def tree {:a {:b 1 :c 2} :d {:e 3}})',
    setupCode: '(def tree {:a {:b 1 :c 2} :d {:e 3}})',
    expected: true,
    sample: '(> (count (tree-seq map? vals tree)) 1)',
    hints: ['tree-seq traverses lazily', 'branch? and children fns'],
    tags: ['tree-seq', 'lazy', 'tree'],
  },
  {
    id: 'clj-lazy-131',
    category: 'Lazy Sequences',
    difficulty: 'medium',
    title: 'Partition Lazy',
    text: 'Use `partition` for lazy chunking.',
    setup: '(def nums (range 9))',
    setupCode: '(def nums (range 9))',
    expected: [[0, 1, 2], [3, 4, 5], [6, 7, 8]],
    sample: '(partition 3 nums)',
    hints: ['partition is lazy', 'Groups into fixed size'],
    tags: ['partition', 'lazy', 'chunk'],
  },
  {
    id: 'clj-lazy-132',
    category: 'Lazy Sequences',
    difficulty: 'hard',
    title: 'Eduction Composable Lazy',
    text: 'Use `eduction` for reusable lazy transformation.',
    setup: '(def xform (eduction (map inc) (filter even?) (range 10)))',
    setupCode: '(def xform (eduction (map inc) (filter even?) (range 10)))',
    expected: [2, 4, 6, 8, 10],
    sample: '(into [] xform)',
    hints: ['eduction is reusable', 'Lazy transducer application'],
    tags: ['eduction', 'transducer', 'lazy'],
  },
  {
    id: 'clj-lazy-133',
    category: 'Lazy Sequences',
    difficulty: 'medium',
    title: 'Lazy Cat Sequences',
    text: 'Use `lazy-cat` to lazily concatenate.',
    setup: '',
    setupCode: '',
    expected: [1, 2, 3, 4, 5, 6],
    sample: '(lazy-cat [1 2 3] [4 5 6])',
    hints: ['lazy-cat defers concatenation', 'More lazy than concat'],
    tags: ['lazy-cat', 'concat', 'defer'],
  },
  {
    id: 'clj-lazy-134',
    category: 'Lazy Sequences',
    difficulty: 'hard',
    title: 'Halt When Short Circuit',
    text: 'Use `halt-when` transducer to stop early.',
    setup: '(def nums (range 100))',
    setupCode: '(def nums (range 100))',
    expected: [0, 1, 2, 3, 4],
    sample: '(into [] (halt-when #(= % 5)) nums)',
    hints: ['halt-when stops transformation', 'Like take-while for transducers'],
    tags: ['halt-when', 'transducer', 'short-circuit'],
  },

  // ============================================================
  // Destructuring (35 problems)
  // ============================================================

  {
    id: 'clj-dest-100',
    category: 'Destructuring',
    difficulty: 'easy',
    title: 'Vector First Two',
    text: 'Use destructuring to get first two elements.',
    setup: '(def v [1 2 3 4 5])',
    setupCode: '(def v [1 2 3 4 5])',
    expected: 3,
    sample: '(let [[a b] v] (+ a b))',
    hints: ['[a b] binds first two', 'Rest ignored'],
    tags: ['destructure', 'vector', 'let'],
  },
  {
    id: 'clj-dest-101',
    category: 'Destructuring',
    difficulty: 'easy',
    title: 'Vector with Rest',
    text: 'Use destructuring with & to capture rest.',
    setup: '(def v [1 2 3 4 5])',
    setupCode: '(def v [1 2 3 4 5])',
    expected: [3, 4, 5],
    sample: '(let [[a b & rest] v] rest)',
    hints: ['& captures remaining', 'rest is a sequence'],
    tags: ['destructure', 'rest', 'vector'],
  },
  {
    id: 'clj-dest-102',
    category: 'Destructuring',
    difficulty: 'medium',
    title: 'Vector with :as',
    text: 'Use :as to keep original while destructuring.',
    setup: '(def v [1 2 3])',
    setupCode: '(def v [1 2 3])',
    expected: 6,
    sample: '(let [[a b c :as all] v] (apply + all))',
    hints: [':as binds entire collection', 'Both parts accessible'],
    tags: ['destructure', 'as', 'original'],
  },
  {
    id: 'clj-dest-103',
    category: 'Destructuring',
    difficulty: 'easy',
    title: 'Map Keys',
    text: 'Use :keys to destructure map.',
    setup: '(def m {:name "Alice" :age 30})',
    setupCode: '(def m {:name "Alice" :age 30})',
    expected: 'Alice is 30',
    sample: '(let [{:keys [name age]} m] (str name " is " age))',
    hints: [':keys extracts by keyword', 'Creates local bindings'],
    tags: ['destructure', 'keys', 'map'],
  },
  {
    id: 'clj-dest-104',
    category: 'Destructuring',
    difficulty: 'medium',
    title: 'Map with Default',
    text: 'Use :or to provide default values.',
    setup: '(def m {:name "Alice"})',
    setupCode: '(def m {:name "Alice"})',
    expected: 'Alice is 25',
    sample: '(let [{:keys [name age] :or {age 25}} m] (str name " is " age))',
    hints: [':or provides defaults', 'Used when key missing'],
    tags: ['destructure', 'or', 'default'],
  },
  {
    id: 'clj-dest-105',
    category: 'Destructuring',
    difficulty: 'medium',
    title: 'Map with :as',
    text: 'Use :as to keep original map.',
    setup: '(def m {:x 1 :y 2})',
    setupCode: '(def m {:x 1 :y 2})',
    expected: 3,
    sample: '(let [{:keys [x y] :as all} m] (+ x y (count all)))',
    hints: [':as binds original', 'count returns 2 for map'],
    tags: ['destructure', 'as', 'map'],
  },
  {
    id: 'clj-dest-106',
    category: 'Destructuring',
    difficulty: 'hard',
    title: 'Nested Vector Destructuring',
    text: 'Destructure nested vectors.',
    setup: '(def v [[1 2] [3 4]])',
    setupCode: '(def v [[1 2] [3 4]])',
    expected: 10,
    sample: '(let [[[a b] [c d]] v] (+ a b c d))',
    hints: ['Nest destructuring patterns', 'Matches structure'],
    tags: ['destructure', 'nested', 'vector'],
  },
  {
    id: 'clj-dest-107',
    category: 'Destructuring',
    difficulty: 'hard',
    title: 'Nested Map Destructuring',
    text: 'Destructure nested maps.',
    setup: '(def m {:user {:name "Alice" :age 30}})',
    setupCode: '(def m {:user {:name "Alice" :age 30}})',
    expected: 'Alice',
    sample: '(let [{:keys [user]} m {:keys [name]} user] name)',
    hints: ['Multiple let bindings', 'Or nest destructuring'],
    tags: ['destructure', 'nested', 'map'],
  },
  {
    id: 'clj-dest-108',
    category: 'Destructuring',
    difficulty: 'hard',
    title: 'Deep Nested Destructuring',
    text: 'Destructure deeply nested structure in one pattern.',
    setup: '(def m {:a {:b {:c 42}}})',
    setupCode: '(def m {:a {:b {:c 42}}})',
    expected: 42,
    sample: '(let [{{{{:keys [c]} :b} :a}} m] c)',
    hints: ['Nest map patterns deeply', 'Matches nested structure'],
    tags: ['destructure', 'deep', 'nested'],
  },
  {
    id: 'clj-dest-109',
    category: 'Destructuring',
    difficulty: 'medium',
    title: 'Function Parameter Destructuring',
    text: 'Use destructuring in function parameters.',
    setup: '(defn greet [{:keys [name]}] (str "Hello, " name))',
    setupCode: '(defn greet [{:keys [name]}] (str "Hello, " name))',
    expected: 'Hello, Alice',
    sample: '(greet {:name "Alice"})',
    hints: ['Destructure in fn params', 'Direct access to keys'],
    tags: ['destructure', 'function', 'parameter'],
  },
  {
    id: 'clj-dest-110',
    category: 'Destructuring',
    difficulty: 'medium',
    title: 'Vector in Function',
    text: 'Destructure vector in function parameters.',
    setup: '(defn sum-pair [[a b]] (+ a b))',
    setupCode: '(defn sum-pair [[a b]] (+ a b))',
    expected: 7,
    sample: '(sum-pair [3 4])',
    hints: ['Vector destructure in fn', 'Extracts elements'],
    tags: ['destructure', 'vector', 'function'],
  },
  {
    id: 'clj-dest-111',
    category: 'Destructuring',
    difficulty: 'easy',
    title: 'String Keys with :strs',
    text: 'Use :strs to destructure string keys.',
    setup: '(def m {"name" "Alice" "age" 30})',
    setupCode: '(def m {"name" "Alice" "age" 30})',
    expected: 'Alice',
    sample: '(let [{:strs [name]} m] name)',
    hints: [':strs for string keys', 'Like :keys for strings'],
    tags: ['destructure', 'strs', 'string-keys'],
  },
  {
    id: 'clj-dest-112',
    category: 'Destructuring',
    difficulty: 'easy',
    title: 'Symbol Keys with :syms',
    text: 'Use :syms to destructure symbol keys.',
    setup: "(def m {'name \"Alice\" 'age 30})",
    setupCode: "(def m {'name \"Alice\" 'age 30})",
    expected: 'Alice',
    sample: '(let [{:syms [name]} m] name)',
    hints: [':syms for symbol keys', 'Like :keys for symbols'],
    tags: ['destructure', 'syms', 'symbol-keys'],
  },
  {
    id: 'clj-dest-113',
    category: 'Destructuring',
    difficulty: 'medium',
    title: 'Rename Keys on Destructure',
    text: 'Use key renaming in destructuring.',
    setup: '(def m {:name "Alice"})',
    setupCode: '(def m {:name "Alice"})',
    expected: 'Alice',
    sample: '(let [{n :name} m] n)',
    hints: ['{local-name :key} renames', 'n bound to :name value'],
    tags: ['destructure', 'rename', 'map'],
  },
  {
    id: 'clj-dest-114',
    category: 'Destructuring',
    difficulty: 'hard',
    title: 'Combine Rename and :keys',
    text: 'Mix rename and :keys destructuring.',
    setup: '(def m {:name "Alice" :age 30 :city "NYC"})',
    setupCode: '(def m {:name "Alice" :age 30 :city "NYC"})',
    expected: 'Alice, 30, NYC',
    sample: '(let [{n :name :keys [age city]} m] (str n ", " age ", " city))',
    hints: ['Can mix rename and :keys', 'Both patterns in one map'],
    tags: ['destructure', 'mixed', 'map'],
  },
  {
    id: 'clj-dest-115',
    category: 'Destructuring',
    difficulty: 'easy',
    title: 'Ignore with Underscore',
    text: 'Use _ to ignore values in destructuring.',
    setup: '(def v [1 2 3])',
    setupCode: '(def v [1 2 3])',
    expected: 3,
    sample: '(let [[_ _ third] v] third)',
    hints: ['_ ignores position', 'Common convention'],
    tags: ['destructure', 'ignore', 'underscore'],
  },
  {
    id: 'clj-dest-116',
    category: 'Destructuring',
    difficulty: 'medium',
    title: 'Destructure in Loop',
    text: 'Use destructuring in loop binding.',
    setup: '(def pairs [[1 2] [3 4] [5 6]])',
    setupCode: '(def pairs [[1 2] [3 4] [5 6]])',
    expected: 21,
    sample: '(loop [[[a b] & rest] pairs sum 0] (if a (recur rest (+ sum a b)) sum))',
    hints: ['Destructure in loop', 'Process pairs recursively'],
    tags: ['destructure', 'loop', 'recur'],
  },
  {
    id: 'clj-dest-117',
    category: 'Destructuring',
    difficulty: 'medium',
    title: 'Destructure in For',
    text: 'Use destructuring in for binding.',
    setup: '(def points [{:x 1 :y 2} {:x 3 :y 4}])',
    setupCode: '(def points [{:x 1 :y 2} {:x 3 :y 4}])',
    expected: [3, 7],
    sample: '(for [{:keys [x y]} points] (+ x y))',
    hints: ['Destructure in for', 'Each iteration destructures'],
    tags: ['destructure', 'for', 'comprehension'],
  },
  {
    id: 'clj-dest-118',
    category: 'Destructuring',
    difficulty: 'hard',
    title: 'Destructure in Doseq',
    text: 'Use destructuring in doseq for side effects.',
    setup: '(def people [{:name "A"} {:name "B"}])',
    setupCode: '(def people [{:name "A"} {:name "B"}])',
    expected: null,
    sample: '(doseq [{:keys [name]} people] (println name))',
    hints: ['doseq for side effects', 'Destructure each element'],
    tags: ['destructure', 'doseq', 'side-effects'],
  },
  {
    id: 'clj-dest-119',
    category: 'Destructuring',
    difficulty: 'medium',
    title: 'Varargs with Destructuring',
    text: 'Use & in function for varargs.',
    setup: '(defn sum-all [& nums] (apply + nums))',
    setupCode: '(defn sum-all [& nums] (apply + nums))',
    expected: 15,
    sample: '(sum-all 1 2 3 4 5)',
    hints: ['& collects rest args', 'nums is a sequence'],
    tags: ['destructure', 'varargs', 'rest'],
  },
  {
    id: 'clj-dest-120',
    category: 'Destructuring',
    difficulty: 'hard',
    title: 'Named Args with Destructuring',
    text: 'Use map destructuring for named arguments.',
    setup: '(defn greet [& {:keys [name greeting] :or {greeting "Hello"}}]\n  (str greeting ", " name))',
    setupCode: '(defn greet [& {:keys [name greeting] :or {greeting "Hello"}}]\n  (str greeting ", " name))',
    expected: 'Hello, Alice',
    sample: '(greet :name "Alice")',
    hints: ['& with map destructure', 'Named keyword arguments'],
    tags: ['destructure', 'named-args', 'kwargs'],
  },
  {
    id: 'clj-dest-121',
    category: 'Destructuring',
    difficulty: 'easy',
    title: 'First and Rest Pattern',
    text: 'Extract first element and rest of vector.',
    setup: '(def v [1 2 3 4 5])',
    setupCode: '(def v [1 2 3 4 5])',
    expected: [1, [2, 3, 4, 5]],
    sample: '(let [[first & rest] v] [first rest])',
    hints: ['Common pattern', 'first and rest bound'],
    tags: ['destructure', 'first', 'rest'],
  },
  {
    id: 'clj-dest-122',
    category: 'Destructuring',
    difficulty: 'hard',
    title: 'Vector of Maps Destructure',
    text: 'Destructure in map over vector of maps.',
    setup: '(def users [{:id 1 :name "A"} {:id 2 :name "B"}])',
    setupCode: '(def users [{:id 1 :name "A"} {:id 2 :name "B"}])',
    expected: [[1, 'A'], [2, 'B']],
    sample: '(map (fn [{:keys [id name]}] [id name]) users)',
    hints: ['Destructure in fn param', 'Extract from each map'],
    tags: ['destructure', 'map', 'collection'],
  },
  {
    id: 'clj-dest-123',
    category: 'Destructuring',
    difficulty: 'medium',
    title: 'Sequential Destructure on Map',
    text: 'Use sequential destructure on map entry.',
    setup: '(def m {:a 1 :b 2})',
    setupCode: '(def m {:a 1 :b 2})',
    expected: [['a', 1], ['b', 2]],
    sample: '(for [[k v] m] [k v])',
    hints: ['Map entries are [k v] pairs', 'Sequential destructure'],
    tags: ['destructure', 'map-entry', 'sequential'],
  },
  {
    id: 'clj-dest-124',
    category: 'Destructuring',
    difficulty: 'hard',
    title: 'Associative Destructure on Vector',
    text: 'Use associative destructure with vector indices.',
    setup: '(def v [:a :b :c :d :e])',
    setupCode: '(def v [:a :b :c :d :e])',
    expected: ['a', 'c', 'e'],
    sample: '(let [{x 0 y 2 z 4} v] [x y z])',
    hints: ['Can destructure by index', 'Index as key'],
    tags: ['destructure', 'associative', 'index'],
  },
  {
    id: 'clj-dest-125',
    category: 'Destructuring',
    difficulty: 'medium',
    title: 'Namespaced Keys',
    text: 'Destructure namespaced keywords.',
    setup: '(def m {:user/name "Alice" :user/age 30})',
    setupCode: '(def m {:user/name "Alice" :user/age 30})',
    expected: 'Alice',
    sample: '(let [{:user/keys [name]} m] name)',
    hints: [':ns/keys for namespaced', 'Extracts with namespace'],
    tags: ['destructure', 'namespaced', 'keys'],
  },
  {
    id: 'clj-dest-126',
    category: 'Destructuring',
    difficulty: 'hard',
    title: 'Mixed Namespaced Keys',
    text: 'Destructure mixed namespaced and regular keys.',
    setup: '(def m {:user/name "Alice" :age 30})',
    setupCode: '(def m {:user/name "Alice" :age 30})',
    expected: 'Alice is 30',
    sample: '(let [{:user/keys [name] :keys [age]} m] (str name " is " age))',
    hints: ['Mix namespace patterns', 'Both in same let'],
    tags: ['destructure', 'mixed', 'namespaced'],
  },
  {
    id: 'clj-dest-127',
    category: 'Destructuring',
    difficulty: 'medium',
    title: 'Destructure Return Value',
    text: 'Destructure function return value directly.',
    setup: '(defn get-point [] [10 20])',
    setupCode: '(defn get-point [] [10 20])',
    expected: 30,
    sample: '(let [[x y] (get-point)] (+ x y))',
    hints: ['Destructure any expression', 'Including function calls'],
    tags: ['destructure', 'return', 'function'],
  },
  {
    id: 'clj-dest-128',
    category: 'Destructuring',
    difficulty: 'easy',
    title: 'Binding First Three',
    text: 'Destructure first three elements of vector.',
    setup: '(def v [1 2 3 4 5 6 7])',
    setupCode: '(def v [1 2 3 4 5 6 7])',
    expected: 6,
    sample: '(let [[a b c] v] (+ a b c))',
    hints: ['Only first three bound', 'Rest ignored'],
    tags: ['destructure', 'first', 'vector'],
  },
  {
    id: 'clj-dest-129',
    category: 'Destructuring',
    difficulty: 'hard',
    title: 'Complex Nested Destructure',
    text: 'Destructure complex nested structure.',
    setup: '(def data {:users [{:name "A" :scores [1 2 3]}]})',
    setupCode: '(def data {:users [{:name "A" :scores [1 2 3]}]})',
    expected: 3,
    sample: '(let [{[{[_ _ third] :scores}] :users} data] third)',
    hints: ['Combine map and vector', 'Navigate deeply'],
    tags: ['destructure', 'complex', 'nested'],
  },
  {
    id: 'clj-dest-130',
    category: 'Destructuring',
    difficulty: 'medium',
    title: 'Destructure with Defaults in Vector',
    text: 'Use :or with sequential destructure.',
    setup: '(def v [1])',
    setupCode: '(def v [1])',
    expected: 11,
    sample: '(let [[a b :or {b 10}] v] (+ a b))',
    hints: [':or works with seq destructure too', 'Names must be bound'],
    tags: ['destructure', 'default', 'vector'],
  },
  {
    id: 'clj-dest-131',
    category: 'Destructuring',
    difficulty: 'hard',
    title: 'Multi-arity with Destructure',
    text: 'Use destructuring in multi-arity function.',
    setup: '(defn process\n  ([{:keys [x]}] x)\n  ([{:keys [x]} {:keys [y]}] (+ x y)))',
    setupCode: '(defn process\n  ([{:keys [x]}] x)\n  ([{:keys [x]} {:keys [y]}] (+ x y)))',
    expected: 15,
    sample: '(process {:x 10} {:y 5})',
    hints: ['Each arity can destructure', 'Different patterns per arity'],
    tags: ['destructure', 'multi-arity', 'function'],
  },
  {
    id: 'clj-dest-132',
    category: 'Destructuring',
    difficulty: 'medium',
    title: 'Destructure Keyword Args',
    text: 'Process options map with destructuring.',
    setup: '(defn configure [{:keys [host port] :or {host "localhost" port 8080}}]\n  (str host ":" port))',
    setupCode: '(defn configure [{:keys [host port] :or {host "localhost" port 8080}}]\n  (str host ":" port))',
    expected: 'localhost:3000',
    sample: '(configure {:port 3000})',
    hints: ['Common options pattern', 'Defaults fill in missing'],
    tags: ['destructure', 'options', 'defaults'],
  },
  {
    id: 'clj-dest-133',
    category: 'Destructuring',
    difficulty: 'hard',
    title: 'Destructure Record Fields',
    text: 'Use destructuring with defrecord.',
    setup: '(defrecord Point [x y])\n(def p (->Point 10 20))',
    setupCode: '(defrecord Point [x y])\n(def p (->Point 10 20))',
    expected: 30,
    sample: '(let [{:keys [x y]} p] (+ x y))',
    hints: ['Records support map destructure', 'Access fields as keywords'],
    tags: ['destructure', 'record', 'fields'],
  },
  {
    id: 'clj-dest-134',
    category: 'Destructuring',
    difficulty: 'medium',
    title: 'Destructure in Reduce',
    text: 'Use destructuring in reduce function.',
    setup: '(def pairs [[1 2] [3 4] [5 6]])',
    setupCode: '(def pairs [[1 2] [3 4] [5 6]])',
    expected: 21,
    sample: '(reduce (fn [acc [a b]] (+ acc a b)) 0 pairs)',
    hints: ['Destructure in reducing fn', 'Access pair elements'],
    tags: ['destructure', 'reduce', 'accumulate'],
  },

  // ============================================================
  // Multimethods (30 problems)
  // ============================================================

  {
    id: 'clj-multi-100',
    category: 'Multimethods',
    difficulty: 'medium',
    title: 'Define Multimethod',
    text: 'Define a multimethod that dispatches on :type key.',
    setup: '(defmulti area :type)\n(defmethod area :circle [{:keys [r]}] (* 3.14159 r r))\n(defmethod area :square [{:keys [side]}] (* side side))',
    setupCode: '(defmulti area :type)\n(defmethod area :circle [{:keys [r]}] (* 3.14159 r r))\n(defmethod area :square [{:keys [side]}] (* side side))',
    expected: 9,
    sample: '(area {:type :square :side 3})',
    hints: ['defmulti defines dispatch', 'defmethod provides implementations'],
    tags: ['defmulti', 'defmethod', 'dispatch'],
  },
  {
    id: 'clj-multi-101',
    category: 'Multimethods',
    difficulty: 'medium',
    title: 'Dispatch on Class',
    text: 'Use `class` as dispatch function.',
    setup: '(defmulti stringify class)\n(defmethod stringify String [s] (str "String: " s))\n(defmethod stringify Long [n] (str "Number: " n))',
    setupCode: '(defmulti stringify class)\n(defmethod stringify String [s] (str "String: " s))\n(defmethod stringify Long [n] (str "Number: " n))',
    expected: 'Number: 42',
    sample: '(stringify 42)',
    hints: ['class returns type', 'Different method per type'],
    tags: ['defmulti', 'class', 'type-dispatch'],
  },
  {
    id: 'clj-multi-102',
    category: 'Multimethods',
    difficulty: 'hard',
    title: 'Default Method',
    text: 'Define a :default method for unmatched dispatches.',
    setup: '(defmulti greet :lang)\n(defmethod greet :en [_] "Hello")\n(defmethod greet :default [_] "Hi")',
    setupCode: '(defmulti greet :lang)\n(defmethod greet :en [_] "Hello")\n(defmethod greet :default [_] "Hi")',
    expected: 'Hi',
    sample: '(greet {:lang :unknown})',
    hints: [':default catches unmatched', 'Fallback implementation'],
    tags: ['defmethod', 'default', 'fallback'],
  },
  {
    id: 'clj-multi-103',
    category: 'Multimethods',
    difficulty: 'hard',
    title: 'Multiple Dispatch Values',
    text: 'Use vector dispatch for multiple criteria.',
    setup: '(defmulti combine (fn [a b] [(type a) (type b)]))\n(defmethod combine [String String] [a b] (str a b))\n(defmethod combine [Long Long] [a b] (+ a b))',
    setupCode: '(defmulti combine (fn [a b] [(type a) (type b)]))\n(defmethod combine [String String] [a b] (str a b))\n(defmethod combine [Long Long] [a b] (+ a b))',
    expected: 'ab',
    sample: '(combine "a" "b")',
    hints: ['Vector dispatch for multiple args', 'Match on both types'],
    tags: ['defmulti', 'vector', 'multiple-dispatch'],
  },
  {
    id: 'clj-multi-104',
    category: 'Multimethods',
    difficulty: 'medium',
    title: 'Prefer Method',
    text: 'Use `prefer-method` to resolve ambiguity.',
    setup: '(defmulti process identity)\n(defmethod process :a [_] "A")\n(defmethod process :b [_] "B")',
    setupCode: '(defmulti process identity)\n(defmethod process :a [_] "A")\n(defmethod process :b [_] "B")',
    expected: 'A',
    sample: '(process :a)',
    hints: ['prefer-method resolves conflicts', 'For hierarchy ambiguity'],
    tags: ['prefer-method', 'hierarchy', 'conflict'],
  },
  {
    id: 'clj-multi-105',
    category: 'Multimethods',
    difficulty: 'hard',
    title: 'Hierarchy-based Dispatch',
    text: 'Use derive for hierarchy-based dispatch.',
    setup: '(derive ::rectangle ::shape)\n(derive ::square ::rectangle)\n(defmulti draw :kind)\n(defmethod draw ::shape [_] "shape")\n(defmethod draw ::rectangle [_] "rectangle")',
    setupCode: '(derive ::rectangle ::shape)\n(derive ::square ::rectangle)\n(defmulti draw :kind)\n(defmethod draw ::shape [_] "shape")\n(defmethod draw ::rectangle [_] "rectangle")',
    expected: 'rectangle',
    sample: '(draw {:kind ::rectangle})',
    hints: ['derive creates hierarchy', 'Methods inherit'],
    tags: ['derive', 'hierarchy', 'inheritance'],
  },
  {
    id: 'clj-multi-106',
    category: 'Multimethods',
    difficulty: 'medium',
    title: 'Get Method',
    text: 'Use `get-method` to retrieve a method implementation.',
    setup: '(defmulti calc :op)\n(defmethod calc :add [{:keys [a b]}] (+ a b))',
    setupCode: '(defmulti calc :op)\n(defmethod calc :add [{:keys [a b]}] (+ a b))',
    expected: true,
    sample: '(fn? (get-method calc :add))',
    hints: ['get-method returns fn', 'Can inspect implementations'],
    tags: ['get-method', 'inspect', 'multimethod'],
  },
  {
    id: 'clj-multi-107',
    category: 'Multimethods',
    difficulty: 'medium',
    title: 'Methods Map',
    text: 'Use `methods` to get all method implementations.',
    setup: '(defmulti op :type)\n(defmethod op :a [_] 1)\n(defmethod op :b [_] 2)',
    setupCode: '(defmulti op :type)\n(defmethod op :a [_] 1)\n(defmethod op :b [_] 2)',
    expected: 2,
    sample: '(count (methods op))',
    hints: ['methods returns map', 'dispatch-val -> fn'],
    tags: ['methods', 'enumerate', 'multimethod'],
  },
  {
    id: 'clj-multi-108',
    category: 'Multimethods',
    difficulty: 'hard',
    title: 'Remove Method',
    text: 'Use `remove-method` to remove an implementation.',
    setup: '(defmulti process :type)\n(defmethod process :a [_] 1)',
    setupCode: '(defmulti process :type)\n(defmethod process :a [_] 1)',
    expected: 0,
    sample: '(do (remove-method process :a) (count (methods process)))',
    hints: ['remove-method removes by dispatch', 'Dynamic modification'],
    tags: ['remove-method', 'modify', 'multimethod'],
  },
  {
    id: 'clj-multi-109',
    category: 'Multimethods',
    difficulty: 'medium',
    title: 'Dispatch Function',
    text: 'Access dispatch function with `get-method`.',
    setup: '(defmulti area (fn [shape] (:type shape)))',
    setupCode: '(defmulti area (fn [shape] (:type shape)))',
    expected: 'circle',
    sample: '((:dispatch-fn (meta #\'area)) {:type :circle})',
    hints: ['Dispatch fn in metadata', 'Can call independently'],
    tags: ['dispatch', 'meta', 'multimethod'],
  },
  {
    id: 'clj-multi-110',
    category: 'Multimethods',
    difficulty: 'easy',
    title: 'Simple Keyword Dispatch',
    text: 'Use keyword as dispatch function.',
    setup: '(defmulti handle-event :event-type)\n(defmethod handle-event :click [e] "clicked")\n(defmethod handle-event :hover [e] "hovered")',
    setupCode: '(defmulti handle-event :event-type)\n(defmethod handle-event :click [e] "clicked")\n(defmethod handle-event :hover [e] "hovered")',
    expected: 'clicked',
    sample: '(handle-event {:event-type :click})',
    hints: ['Keyword extracts value', 'Common dispatch pattern'],
    tags: ['defmulti', 'keyword', 'event'],
  },
  {
    id: 'clj-multi-111',
    category: 'Multimethods',
    difficulty: 'hard',
    title: 'Isa? Check',
    text: 'Use `isa?` to check hierarchy relationship.',
    setup: '(derive ::child ::parent)',
    setupCode: '(derive ::child ::parent)',
    expected: true,
    sample: '(isa? ::child ::parent)',
    hints: ['isa? checks hierarchy', 'Works with derive'],
    tags: ['isa?', 'hierarchy', 'check'],
  },
  {
    id: 'clj-multi-112',
    category: 'Multimethods',
    difficulty: 'hard',
    title: 'Parents Function',
    text: 'Use `parents` to get parent types.',
    setup: '(derive ::child ::parent)',
    setupCode: '(derive ::child ::parent)',
    expected: true,
    sample: '(contains? (parents ::child) ::parent)',
    hints: ['parents returns set', 'Direct parents only'],
    tags: ['parents', 'hierarchy', 'inspect'],
  },
  {
    id: 'clj-multi-113',
    category: 'Multimethods',
    difficulty: 'hard',
    title: 'Ancestors Function',
    text: 'Use `ancestors` to get all ancestor types.',
    setup: '(derive ::c ::b)\n(derive ::b ::a)',
    setupCode: '(derive ::c ::b)\n(derive ::b ::a)',
    expected: true,
    sample: '(contains? (ancestors ::c) ::a)',
    hints: ['ancestors returns all', 'Transitive closure'],
    tags: ['ancestors', 'hierarchy', 'transitive'],
  },
  {
    id: 'clj-multi-114',
    category: 'Multimethods',
    difficulty: 'hard',
    title: 'Descendants Function',
    text: 'Use `descendants` to get all child types.',
    setup: '(derive ::child ::parent)\n(derive ::grandchild ::child)',
    setupCode: '(derive ::child ::parent)\n(derive ::grandchild ::child)',
    expected: true,
    sample: '(contains? (descendants ::parent) ::grandchild)',
    hints: ['descendants returns all below', 'Transitive'],
    tags: ['descendants', 'hierarchy', 'children'],
  },
  {
    id: 'clj-multi-115',
    category: 'Multimethods',
    difficulty: 'medium',
    title: 'Multimethod with nil',
    text: 'Handle nil dispatch value.',
    setup: '(defmulti process identity)\n(defmethod process nil [_] "nil value")\n(defmethod process :default [v] (str v))',
    setupCode: '(defmulti process identity)\n(defmethod process nil [_] "nil value")\n(defmethod process :default [v] (str v))',
    expected: 'nil value',
    sample: '(process nil)',
    hints: ['nil is valid dispatch', 'Explicit nil method'],
    tags: ['defmethod', 'nil', 'dispatch'],
  },
  {
    id: 'clj-multi-116',
    category: 'Multimethods',
    difficulty: 'medium',
    title: 'Computed Dispatch',
    text: 'Use computed dispatch value.',
    setup: '(defmulti categorize (fn [n] (cond (< n 0) :negative (> n 0) :positive :else :zero)))\n(defmethod categorize :positive [_] "pos")\n(defmethod categorize :negative [_] "neg")\n(defmethod categorize :zero [_] "zero")',
    setupCode: '(defmulti categorize (fn [n] (cond (< n 0) :negative (> n 0) :positive :else :zero)))\n(defmethod categorize :positive [_] "pos")\n(defmethod categorize :negative [_] "neg")\n(defmethod categorize :zero [_] "zero")',
    expected: 'neg',
    sample: '(categorize -5)',
    hints: ['Dispatch can compute value', 'Arbitrary logic'],
    tags: ['defmulti', 'computed', 'dispatch'],
  },
  {
    id: 'clj-multi-117',
    category: 'Multimethods',
    difficulty: 'hard',
    title: 'Custom Hierarchy',
    text: 'Create custom hierarchy with make-hierarchy.',
    setup: '(def h (-> (make-hierarchy) (derive :child :parent)))',
    setupCode: '(def h (-> (make-hierarchy) (derive :child :parent)))',
    expected: true,
    sample: '(isa? h :child :parent)',
    hints: ['make-hierarchy creates new', 'Pass to isa?'],
    tags: ['make-hierarchy', 'custom', 'hierarchy'],
  },
  {
    id: 'clj-multi-118',
    category: 'Multimethods',
    difficulty: 'medium',
    title: 'Multimethod Docstring',
    text: 'Access multimethod documentation.',
    setup: '(defmulti process "Processes data" :type)',
    setupCode: '(defmulti process "Processes data" :type)',
    expected: 'Processes data',
    sample: '(:doc (meta #\'process))',
    hints: ['Docstring in metadata', 'Document your multimethods'],
    tags: ['defmulti', 'docstring', 'meta'],
  },
  {
    id: 'clj-multi-119',
    category: 'Multimethods',
    difficulty: 'hard',
    title: 'Prefers Map',
    text: 'Use `prefers` to see preference relationships.',
    setup: '(defmulti proc identity)\n(derive ::a ::b)\n(defmethod proc ::a [_] "a")\n(defmethod proc ::b [_] "b")\n(prefer-method proc ::a ::b)',
    setupCode: '(defmulti proc identity)\n(derive ::a ::b)\n(defmethod proc ::a [_] "a")\n(defmethod proc ::b [_] "b")\n(prefer-method proc ::a ::b)',
    expected: true,
    sample: '(contains? (get (prefers proc) ::a) ::b)',
    hints: ['prefers returns map', 'Shows preferences set'],
    tags: ['prefers', 'preference', 'inspect'],
  },
  {
    id: 'clj-multi-120',
    category: 'Multimethods',
    difficulty: 'medium',
    title: 'Remove All Methods',
    text: 'Clear all methods from multimethod.',
    setup: '(defmulti op :type)\n(defmethod op :a [_] 1)\n(defmethod op :b [_] 2)',
    setupCode: '(defmulti op :type)\n(defmethod op :a [_] 1)\n(defmethod op :b [_] 2)',
    expected: 0,
    sample: '(do (remove-all-methods op) (count (methods op)))',
    hints: ['remove-all-methods clears', 'Reset multimethod'],
    tags: ['remove-all-methods', 'clear', 'multimethod'],
  },
  {
    id: 'clj-multi-121',
    category: 'Multimethods',
    difficulty: 'hard',
    title: 'Global Hierarchy',
    text: 'Understand global hierarchy usage.',
    setup: '(derive ::dog ::animal)\n(defmulti speak :species)\n(defmethod speak ::animal [_] "sound")\n(defmethod speak ::dog [_] "bark")',
    setupCode: '(derive ::dog ::animal)\n(defmethod speak :species)\n(defmethod speak ::animal [_] "sound")\n(defmethod speak ::dog [_] "bark")',
    expected: 'bark',
    sample: '(speak {:species ::dog})',
    hints: ['Global hierarchy used by default', 'More specific wins'],
    tags: ['hierarchy', 'global', 'dispatch'],
  },
  {
    id: 'clj-multi-122',
    category: 'Multimethods',
    difficulty: 'medium',
    title: 'Dispatch on Map Keys',
    text: 'Dispatch based on which keys are present.',
    setup: '(defmulti handle-msg (fn [m] (first (keys m))))\n(defmethod handle-msg :error [{:keys [error]}] (str "Error: " error))\n(defmethod handle-msg :data [{:keys [data]}] (str "Data: " data))',
    setupCode: '(defmulti handle-msg (fn [m] (first (keys m))))\n(defmethod handle-msg :error [{:keys [error]}] (str "Error: " error))\n(defmethod handle-msg :data [{:keys [data]}] (str "Data: " data))',
    expected: 'Error: oops',
    sample: '(handle-msg {:error "oops"})',
    hints: ['Dispatch on structure', 'Dynamic dispatch choice'],
    tags: ['defmulti', 'keys', 'structure'],
  },
  {
    id: 'clj-multi-123',
    category: 'Multimethods',
    difficulty: 'hard',
    title: 'Ad-hoc Hierarchy',
    text: 'Use ad-hoc hierarchy in multimethod.',
    setup: '(def h (-> (make-hierarchy) (derive :dog :animal)))\n(defmulti speak :type :hierarchy #\'h)\n(defmethod speak :animal [_] "noise")',
    setupCode: '(def h (-> (make-hierarchy) (derive :dog :animal)))\n(defmulti speak :type :hierarchy #\'h)\n(defmethod speak :animal [_] "noise")',
    expected: 'noise',
    sample: '(speak {:type :dog})',
    hints: [':hierarchy option', 'Use custom hierarchy'],
    tags: ['defmulti', 'hierarchy', 'custom'],
  },
  {
    id: 'clj-multi-124',
    category: 'Multimethods',
    difficulty: 'medium',
    title: 'Boolean Dispatch',
    text: 'Dispatch on boolean result.',
    setup: '(defmulti access (fn [user] (:admin user)))\n(defmethod access true [_] "Full access")\n(defmethod access false [_] "Limited")',
    setupCode: '(defmulti access (fn [user] (:admin user)))\n(defmethod access true [_] "Full access")\n(defmethod access false [_] "Limited")',
    expected: 'Full access',
    sample: '(access {:admin true})',
    hints: ['Boolean dispatch values', 'true/false as cases'],
    tags: ['defmulti', 'boolean', 'dispatch'],
  },
  {
    id: 'clj-multi-125',
    category: 'Multimethods',
    difficulty: 'hard',
    title: 'Variadic Multimethod',
    text: 'Define multimethod with variable arguments.',
    setup: '(defmulti combine-all (fn [& args] (mapv type args)))\n(defmethod combine-all [String String] [& args] (apply str args))\n(defmethod combine-all [Long Long] [& args] (apply + args))',
    setupCode: '(defmulti combine-all (fn [& args] (mapv type args)))\n(defmethod combine-all [String String] [& args] (apply str args))\n(defmethod combine-all [Long Long] [& args] (apply + args))',
    expected: 'ab',
    sample: '(combine-all "a" "b")',
    hints: ['Variadic dispatch fn', 'Match on all arg types'],
    tags: ['defmulti', 'variadic', 'args'],
  },
  {
    id: 'clj-multi-126',
    category: 'Multimethods',
    difficulty: 'medium',
    title: 'Underive Relationship',
    text: 'Use `underive` to remove hierarchy relationship.',
    setup: '(derive ::child ::parent)',
    setupCode: '(derive ::child ::parent)',
    expected: false,
    sample: '(do (underive ::child ::parent) (isa? ::child ::parent))',
    hints: ['underive removes relationship', 'Modifies hierarchy'],
    tags: ['underive', 'hierarchy', 'remove'],
  },
  {
    id: 'clj-multi-127',
    category: 'Multimethods',
    difficulty: 'hard',
    title: 'Dispatch on Predicate',
    text: 'Use predicate result as dispatch.',
    setup: '(defmulti handle-coll #(cond (vector? %) :vec (list? %) :list (set? %) :set :else :other))\n(defmethod handle-coll :vec [c] "vector")\n(defmethod handle-coll :list [c] "list")\n(defmethod handle-coll :set [c] "set")',
    setupCode: '(defmulti handle-coll #(cond (vector? %) :vec (list? %) :list (set? %) :set :else :other))\n(defmethod handle-coll :vec [c] "vector")\n(defmethod handle-coll :list [c] "list")\n(defmethod handle-coll :set [c] "set")',
    expected: 'vector',
    sample: '(handle-coll [1 2 3])',
    hints: ['Dispatch on type predicates', 'Map to keywords'],
    tags: ['defmulti', 'predicate', 'cond'],
  },
  {
    id: 'clj-multi-128',
    category: 'Multimethods',
    difficulty: 'hard',
    title: 'Multimethod as Protocol Alternative',
    text: 'Use multimethod for protocol-like behavior.',
    setup: '(defmulti to-string type)\n(defmethod to-string clojure.lang.PersistentVector [v] (str "Vec:" v))\n(defmethod to-string clojure.lang.PersistentArrayMap [m] (str "Map:" m))',
    setupCode: '(defmulti to-string type)\n(defmethod to-string clojure.lang.PersistentVector [v] (str "Vec:" v))\n(defmethod to-string clojure.lang.PersistentArrayMap [m] (str "Map:" m))',
    expected: 'Vec:[1 2 3]',
    sample: '(to-string [1 2 3])',
    hints: ['Dispatch on concrete type', 'Like protocol extension'],
    tags: ['defmulti', 'type', 'protocol-like'],
  },
  {
    id: 'clj-multi-129',
    category: 'Multimethods',
    difficulty: 'medium',
    title: 'Dispatch on Count',
    text: 'Dispatch based on collection size.',
    setup: '(defmulti describe-size count)\n(defmethod describe-size 0 [_] "empty")\n(defmethod describe-size 1 [_] "single")\n(defmethod describe-size :default [c] "many")',
    setupCode: '(defmulti describe-size count)\n(defmethod describe-size 0 [_] "empty")\n(defmethod describe-size 1 [_] "single")\n(defmethod describe-size :default [c] "many")',
    expected: 'many',
    sample: '(describe-size [1 2 3])',
    hints: ['Dispatch on derived value', 'count as dispatch fn'],
    tags: ['defmulti', 'count', 'size'],
  },

  // ============================================================
  // Protocols (30 problems)
  // ============================================================

  {
    id: 'clj-proto-100',
    category: 'Protocols',
    difficulty: 'medium',
    title: 'Define Protocol',
    text: 'Define a simple protocol with one method.',
    setup: '(defprotocol Greetable (greet [this]))',
    setupCode: '(defprotocol Greetable (greet [this]))',
    expected: true,
    sample: '(satisfies? Greetable (reify Greetable (greet [_] "Hi")))',
    hints: ['defprotocol defines interface', 'Methods declared'],
    tags: ['defprotocol', 'define', 'interface'],
  },
  {
    id: 'clj-proto-101',
    category: 'Protocols',
    difficulty: 'medium',
    title: 'Defrecord with Protocol',
    text: 'Create record implementing protocol.',
    setup: '(defprotocol Describable (describe [this]))\n(defrecord Person [name age]\n  Describable\n  (describe [_] (str name " is " age)))',
    setupCode: '(defprotocol Describable (describe [this]))\n(defrecord Person [name age]\n  Describable\n  (describe [_] (str name " is " age)))',
    expected: 'Alice is 30',
    sample: '(describe (->Person "Alice" 30))',
    hints: ['defrecord can implement protocols', 'Inline implementation'],
    tags: ['defrecord', 'protocol', 'implement'],
  },
  {
    id: 'clj-proto-102',
    category: 'Protocols',
    difficulty: 'hard',
    title: 'Extend Protocol to Type',
    text: 'Use `extend-protocol` to extend to existing type.',
    setup: '(defprotocol Countable (item-count [this]))\n(extend-protocol Countable\n  String (item-count [s] (count s))\n  clojure.lang.PersistentVector (item-count [v] (count v)))',
    setupCode: '(defprotocol Countable (item-count [this]))\n(extend-protocol Countable\n  String (item-count [s] (count s))\n  clojure.lang.PersistentVector (item-count [v] (count v)))',
    expected: 5,
    sample: '(item-count "hello")',
    hints: ['extend-protocol adds implementations', 'For existing types'],
    tags: ['extend-protocol', 'type', 'extend'],
  },
  {
    id: 'clj-proto-103',
    category: 'Protocols',
    difficulty: 'hard',
    title: 'Extend Type',
    text: 'Use `extend-type` to add multiple protocols.',
    setup: '(defprotocol Printable (to-str [this]))\n(extend-type String\n  Printable\n  (to-str [s] (str "String: " s)))',
    setupCode: '(defprotocol Printable (to-str [this]))\n(extend-type String\n  Printable\n  (to-str [s] (str "String: " s)))',
    expected: 'String: hello',
    sample: '(to-str "hello")',
    hints: ['extend-type focuses on one type', 'Multiple protocols possible'],
    tags: ['extend-type', 'protocol', 'string'],
  },
  {
    id: 'clj-proto-104',
    category: 'Protocols',
    difficulty: 'medium',
    title: 'Reify Protocol',
    text: 'Use `reify` to create anonymous implementation.',
    setup: '(defprotocol Runnable (run [this]))',
    setupCode: '(defprotocol Runnable (run [this]))',
    expected: 'running',
    sample: '(run (reify Runnable (run [_] "running")))',
    hints: ['reify creates anonymous instance', 'Implements protocols inline'],
    tags: ['reify', 'anonymous', 'protocol'],
  },
  {
    id: 'clj-proto-105',
    category: 'Protocols',
    difficulty: 'easy',
    title: 'Check Protocol Satisfaction',
    text: 'Use `satisfies?` to check if type implements protocol.',
    setup: '(defprotocol P (method [this]))\n(defrecord R [] P (method [_] nil))',
    setupCode: '(defprotocol P (method [this]))\n(defrecord R [] P (method [_] nil))',
    expected: true,
    sample: '(satisfies? P (->R))',
    hints: ['satisfies? returns boolean', 'Check implementation'],
    tags: ['satisfies?', 'check', 'protocol'],
  },
  {
    id: 'clj-proto-106',
    category: 'Protocols',
    difficulty: 'medium',
    title: 'Multiple Protocol Methods',
    text: 'Define protocol with multiple methods.',
    setup: '(defprotocol Shape\n  (area [this])\n  (perimeter [this]))\n(defrecord Square [side]\n  Shape\n  (area [_] (* side side))\n  (perimeter [_] (* 4 side)))',
    setupCode: '(defprotocol Shape\n  (area [this])\n  (perimeter [this]))\n(defrecord Square [side]\n  Shape\n  (area [_] (* side side))\n  (perimeter [_] (* 4 side)))',
    expected: [9, 12],
    sample: '(let [s (->Square 3)] [(area s) (perimeter s)])',
    hints: ['Multiple methods in protocol', 'All must be implemented'],
    tags: ['defprotocol', 'multiple', 'methods'],
  },
  {
    id: 'clj-proto-107',
    category: 'Protocols',
    difficulty: 'hard',
    title: 'Protocol with Arity',
    text: 'Define protocol method with multiple arities.',
    setup: '(defprotocol Addable\n  (add [this] [this other]))\n(defrecord Number [n]\n  Addable\n  (add [_] n)\n  (add [_ other] (+ n (:n other))))',
    setupCode: '(defprotocol Addable\n  (add [this] [this other]))\n(defrecord Number [n]\n  Addable\n  (add [_] n)\n  (add [_ other] (+ n (:n other))))',
    expected: 7,
    sample: '(add (->Number 3) (->Number 4))',
    hints: ['Methods can have arities', 'List each arity'],
    tags: ['defprotocol', 'arity', 'overload'],
  },
  {
    id: 'clj-proto-108',
    category: 'Protocols',
    difficulty: 'medium',
    title: 'Extend to nil',
    text: 'Handle nil with protocol extension.',
    setup: '(defprotocol Stringable (stringify [this]))\n(extend-protocol Stringable\n  nil (stringify [_] "nil")\n  String (stringify [s] s))',
    setupCode: '(defprotocol Stringable (stringify [this]))\n(extend-protocol Stringable\n  nil (stringify [_] "nil")\n  String (stringify [s] s))',
    expected: 'nil',
    sample: '(stringify nil)',
    hints: ['nil can have protocol impl', 'Handle null case'],
    tags: ['extend-protocol', 'nil', 'null'],
  },
  {
    id: 'clj-proto-109',
    category: 'Protocols',
    difficulty: 'hard',
    title: 'Extend to Object',
    text: 'Provide default implementation via Object.',
    setup: '(defprotocol Displayable (display [this]))\n(extend-protocol Displayable\n  Object (display [o] (str "Object: " o)))',
    setupCode: '(defprotocol Displayable (display [this]))\n(extend-protocol Displayable\n  Object (display [o] (str "Object: " o)))',
    expected: 'Object: 42',
    sample: '(display 42)',
    hints: ['Object is catch-all', 'Default implementation'],
    tags: ['extend-protocol', 'Object', 'default'],
  },
  {
    id: 'clj-proto-110',
    category: 'Protocols',
    difficulty: 'easy',
    title: 'Record Field Access',
    text: 'Access record fields as keywords.',
    setup: '(defrecord Point [x y])',
    setupCode: '(defrecord Point [x y])',
    expected: 10,
    sample: '(:x (->Point 10 20))',
    hints: ['Records are maps', 'Keyword access'],
    tags: ['defrecord', 'fields', 'access'],
  },
  {
    id: 'clj-proto-111',
    category: 'Protocols',
    difficulty: 'medium',
    title: 'Record as Map',
    text: 'Use record as a map with assoc.',
    setup: '(defrecord Config [host port])',
    setupCode: '(defrecord Config [host port])',
    expected: 'localhost',
    sample: '(:host (assoc (->Config "example.com" 80) :host "localhost"))',
    hints: ['Records support assoc', 'Immutable update'],
    tags: ['defrecord', 'assoc', 'map'],
  },
  {
    id: 'clj-proto-112',
    category: 'Protocols',
    difficulty: 'hard',
    title: 'Map to Record',
    text: 'Create record from map.',
    setup: '(defrecord User [name email])',
    setupCode: '(defrecord User [name email])',
    expected: 'Alice',
    sample: '(:name (map->User {:name "Alice" :email "a@b.com"}))',
    hints: ['map->Record factory', 'From map to record'],
    tags: ['defrecord', 'map->Record', 'factory'],
  },
  {
    id: 'clj-proto-113',
    category: 'Protocols',
    difficulty: 'medium',
    title: 'Record Equality',
    text: 'Records with same values are equal.',
    setup: '(defrecord Point [x y])',
    setupCode: '(defrecord Point [x y])',
    expected: true,
    sample: '(= (->Point 1 2) (->Point 1 2))',
    hints: ['Records have value equality', 'Same fields = equal'],
    tags: ['defrecord', 'equality', 'value'],
  },
  {
    id: 'clj-proto-114',
    category: 'Protocols',
    difficulty: 'hard',
    title: 'Deftype for Mutable',
    text: 'Use `deftype` for mutable fields.',
    setup: '(deftype Counter [^:volatile-mutable n]\n  clojure.lang.IDeref\n  (deref [_] n))',
    setupCode: '(deftype Counter [^:volatile-mutable n]\n  clojure.lang.IDeref\n  (deref [_] n))',
    expected: 0,
    sample: '@(Counter. 0)',
    hints: ['deftype for low-level', 'Mutable possible'],
    tags: ['deftype', 'mutable', 'volatile'],
  },
  {
    id: 'clj-proto-115',
    category: 'Protocols',
    difficulty: 'medium',
    title: 'Extend with Map',
    text: 'Use `extend` with implementation map.',
    setup: '(defprotocol P (method [this]))\n(extend String P {:method (fn [s] (str "String: " s))})',
    setupCode: '(defprotocol P (method [this]))\n(extend String P {:method (fn [s] (str "String: " s))})',
    expected: 'String: hello',
    sample: '(method "hello")',
    hints: ['extend takes map', 'Method name -> fn'],
    tags: ['extend', 'map', 'implementation'],
  },
  {
    id: 'clj-proto-116',
    category: 'Protocols',
    difficulty: 'hard',
    title: 'Protocol Docstring',
    text: 'Add documentation to protocol.',
    setup: '(defprotocol Documented\n  "A documented protocol"\n  (method [this] "Method docstring"))',
    setupCode: '(defprotocol Documented\n  "A documented protocol"\n  (method [this] "Method docstring"))',
    expected: true,
    sample: '(string? (:doc (meta #\'Documented)))',
    hints: ['Protocols can have docs', 'Methods too'],
    tags: ['defprotocol', 'docstring', 'documentation'],
  },
  {
    id: 'clj-proto-117',
    category: 'Protocols',
    difficulty: 'medium',
    title: 'Extends? Check',
    text: 'Use `extends?` to check if type extends protocol.',
    setup: '(defprotocol P (method [this]))\n(extend-type String P (method [s] s))',
    setupCode: '(defprotocol P (method [this]))\n(extend-type String P (method [s] s))',
    expected: true,
    sample: '(extends? P String)',
    hints: ['extends? checks type', 'Not instance'],
    tags: ['extends?', 'check', 'type'],
  },
  {
    id: 'clj-proto-118',
    category: 'Protocols',
    difficulty: 'hard',
    title: 'Extenders List',
    text: 'Get list of types extending protocol.',
    setup: '(defprotocol P (m [this]))\n(extend-type String P (m [_] nil))',
    setupCode: '(defprotocol P (m [this]))\n(extend-type String P (m [_] nil))',
    expected: true,
    sample: '(contains? (set (extenders P)) String)',
    hints: ['extenders returns types', 'All implementations'],
    tags: ['extenders', 'list', 'protocol'],
  },
  {
    id: 'clj-proto-119',
    category: 'Protocols',
    difficulty: 'easy',
    title: 'Record Constructor',
    text: 'Use positional constructor for record.',
    setup: '(defrecord Item [id name price])',
    setupCode: '(defrecord Item [id name price])',
    expected: 'Widget',
    sample: '(:name (->Item 1 "Widget" 9.99))',
    hints: ['->Record positional', 'Order matters'],
    tags: ['defrecord', 'constructor', 'positional'],
  },
  {
    id: 'clj-proto-120',
    category: 'Protocols',
    difficulty: 'hard',
    title: 'Record Implements Interfaces',
    text: 'Record implementing Java interface.',
    setup: '(defrecord Runner []\n  Runnable\n  (run [_] "ran"))',
    setupCode: '(defrecord Runner []\n  Runnable\n  (run [_] "ran"))',
    expected: true,
    sample: '(instance? Runnable (->Runner))',
    hints: ['Can implement Java interfaces', 'In defrecord body'],
    tags: ['defrecord', 'interface', 'java'],
  },
  {
    id: 'clj-proto-121',
    category: 'Protocols',
    difficulty: 'medium',
    title: 'Record with Extra Fields',
    text: 'Record can have extra fields via assoc.',
    setup: '(defrecord Base [a])',
    setupCode: '(defrecord Base [a])',
    expected: 2,
    sample: '(:b (assoc (->Base 1) :b 2))',
    hints: ['Records extensible', 'Extra fields allowed'],
    tags: ['defrecord', 'extra', 'fields'],
  },
  {
    id: 'clj-proto-122',
    category: 'Protocols',
    difficulty: 'hard',
    title: 'Inline Protocol Implementation',
    text: 'Multiple protocols in defrecord.',
    setup: '(defprotocol A (a [this]))\n(defprotocol B (b [this]))\n(defrecord Both []\n  A (a [_] "a")\n  B (b [_] "b"))',
    setupCode: '(defprotocol A (a [this]))\n(defprotocol B (b [this]))\n(defrecord Both []\n  A (a [_] "a")\n  B (b [_] "b"))',
    expected: ['a', 'b'],
    sample: '(let [x (->Both)] [(a x) (b x)])',
    hints: ['Multiple protocols inline', 'List each'],
    tags: ['defrecord', 'multiple', 'protocols'],
  },
  {
    id: 'clj-proto-123',
    category: 'Protocols',
    difficulty: 'medium',
    title: 'Record Dissoc',
    text: 'Dissoc on record returns map.',
    setup: '(defrecord Point [x y])',
    setupCode: '(defrecord Point [x y])',
    expected: false,
    sample: '(instance? Point (dissoc (->Point 1 2) :x))',
    hints: ['dissoc loses record type', 'Returns plain map'],
    tags: ['defrecord', 'dissoc', 'map'],
  },
  {
    id: 'clj-proto-124',
    category: 'Protocols',
    difficulty: 'hard',
    title: 'Protocol Function Access',
    text: 'Access protocol function directly.',
    setup: '(defprotocol P (method [this x]))',
    setupCode: '(defprotocol P (method [this x]))',
    expected: true,
    sample: '(fn? method)',
    hints: ['Protocol methods are functions', 'Can reference directly'],
    tags: ['defprotocol', 'function', 'access'],
  },
  {
    id: 'clj-proto-125',
    category: 'Protocols',
    difficulty: 'hard',
    title: 'Reify Multiple Protocols',
    text: 'Use reify to implement multiple protocols.',
    setup: '(defprotocol X (x [this]))\n(defprotocol Y (y [this]))',
    setupCode: '(defprotocol X (x [this]))\n(defprotocol Y (y [this]))',
    expected: ['a', 'b'],
    sample: '(let [o (reify X (x [_] "a") Y (y [_] "b"))] [(x o) (y o)])',
    hints: ['reify takes multiple', 'All inline'],
    tags: ['reify', 'multiple', 'protocols'],
  },
  {
    id: 'clj-proto-126',
    category: 'Protocols',
    difficulty: 'medium',
    title: 'Record Type Check',
    text: 'Check instance of record type.',
    setup: '(defrecord MyType [])',
    setupCode: '(defrecord MyType [])',
    expected: true,
    sample: '(instance? MyType (->MyType))',
    hints: ['Records have class', 'instance? for check'],
    tags: ['defrecord', 'instance?', 'type'],
  },
  {
    id: 'clj-proto-127',
    category: 'Protocols',
    difficulty: 'hard',
    title: 'Extend Protocol Later',
    text: 'Extend protocol after record definition.',
    setup: '(defprotocol Late (late-method [this]))\n(defrecord Eager [])\n(extend-type Eager Late (late-method [_] "extended"))',
    setupCode: '(defprotocol Late (late-method [this]))\n(defrecord Eager [])\n(extend-type Eager Late (late-method [_] "extended"))',
    expected: 'extended',
    sample: '(late-method (->Eager))',
    hints: ['Can extend after', 'Dynamic extension'],
    tags: ['extend-type', 'late', 'dynamic'],
  },
  {
    id: 'clj-proto-128',
    category: 'Protocols',
    difficulty: 'medium',
    title: 'Record Seq',
    text: 'Iterate over record fields.',
    setup: '(defrecord Pair [a b])',
    setupCode: '(defrecord Pair [a b])',
    expected: 2,
    sample: '(count (seq (->Pair 1 2)))',
    hints: ['Records are seqable', 'As map entries'],
    tags: ['defrecord', 'seq', 'iterate'],
  },
  {
    id: 'clj-proto-129',
    category: 'Protocols',
    difficulty: 'hard',
    title: 'Protocol Composition',
    text: 'Compose protocols for richer abstraction.',
    setup: '(defprotocol Readable (read-val [this]))\n(defprotocol Writable (write-val [this v]))\n(defn read-write [thing v]\n  (write-val thing v)\n  (read-val thing))',
    setupCode: '(defprotocol Readable (read-val [this]))\n(defprotocol Writable (write-val [this v]))\n(defn read-write [thing v]\n  (write-val thing v)\n  (read-val thing))',
    expected: true,
    sample: '(fn? read-write)',
    hints: ['Combine protocols in functions', 'Require multiple'],
    tags: ['protocol', 'composition', 'abstraction'],
  },

  // ============================================================
  // Atoms/Refs (35 problems)
  // ============================================================

  {
    id: 'clj-atom-100',
    category: 'Atoms/Refs',
    difficulty: 'easy',
    title: 'Create Atom',
    text: 'Create an atom with initial value 0.',
    setup: '',
    setupCode: '',
    expected: 0,
    sample: '@(atom 0)',
    hints: ['atom creates mutable ref', '@ dereferences'],
    tags: ['atom', 'create', 'deref'],
  },
  {
    id: 'clj-atom-101',
    category: 'Atoms/Refs',
    difficulty: 'easy',
    title: 'Deref Atom',
    text: 'Use `deref` to get atom value.',
    setup: '(def counter (atom 42))',
    setupCode: '(def counter (atom 42))',
    expected: 42,
    sample: '(deref counter)',
    hints: ['deref explicit form', 'Same as @'],
    tags: ['deref', 'atom', 'read'],
  },
  {
    id: 'clj-atom-102',
    category: 'Atoms/Refs',
    difficulty: 'easy',
    title: 'Swap! Atom',
    text: 'Use `swap!` to increment atom value.',
    setup: '(def counter (atom 0))',
    setupCode: '(def counter (atom 0))',
    expected: 1,
    sample: '(swap! counter inc)',
    hints: ['swap! applies function', 'Returns new value'],
    tags: ['swap!', 'update', 'atom'],
  },
  {
    id: 'clj-atom-103',
    category: 'Atoms/Refs',
    difficulty: 'medium',
    title: 'Swap! with Arguments',
    text: 'Use `swap!` with extra arguments.',
    setup: '(def counter (atom 0))',
    setupCode: '(def counter (atom 0))',
    expected: 10,
    sample: '(swap! counter + 10)',
    hints: ['swap! passes extra args', '+ receives current and 10'],
    tags: ['swap!', 'arguments', 'atom'],
  },
  {
    id: 'clj-atom-104',
    category: 'Atoms/Refs',
    difficulty: 'easy',
    title: 'Reset! Atom',
    text: 'Use `reset!` to set atom to new value.',
    setup: '(def state (atom {:x 1}))',
    setupCode: '(def state (atom {:x 1}))',
    expected: { x: 99 },
    sample: '(reset! state {:x 99})',
    hints: ['reset! replaces value', 'Returns new value'],
    tags: ['reset!', 'set', 'atom'],
  },
  {
    id: 'clj-atom-105',
    category: 'Atoms/Refs',
    difficulty: 'medium',
    title: 'Atom with Map',
    text: 'Update map in atom using swap! and assoc.',
    setup: '(def state (atom {:count 0}))',
    setupCode: '(def state (atom {:count 0}))',
    expected: { count: 0, name: 'test' },
    sample: '(swap! state assoc :name "test")',
    hints: ['swap! with assoc', 'Add key to map'],
    tags: ['swap!', 'assoc', 'map'],
  },
  {
    id: 'clj-atom-106',
    category: 'Atoms/Refs',
    difficulty: 'medium',
    title: 'Atom Update-in',
    text: 'Use swap! with update-in for nested update.',
    setup: '(def state (atom {:user {:score 10}}))',
    setupCode: '(def state (atom {:user {:score 10}}))',
    expected: { user: { score: 15 } },
    sample: '(swap! state update-in [:user :score] + 5)',
    hints: ['swap! with update-in', 'Nested path update'],
    tags: ['swap!', 'update-in', 'nested'],
  },
  {
    id: 'clj-atom-107',
    category: 'Atoms/Refs',
    difficulty: 'hard',
    title: 'Compare-and-set!',
    text: 'Use `compare-and-set!` for conditional update.',
    setup: '(def a (atom 1))',
    setupCode: '(def a (atom 1))',
    expected: true,
    sample: '(compare-and-set! a 1 2)',
    hints: ['CAS operation', 'Only if current matches'],
    tags: ['compare-and-set!', 'cas', 'conditional'],
  },
  {
    id: 'clj-atom-108',
    category: 'Atoms/Refs',
    difficulty: 'medium',
    title: 'Atom Watch',
    text: 'Add watcher to atom.',
    setup: '(def a (atom 0))\n(def changes (atom []))',
    setupCode: '(def a (atom 0))\n(def changes (atom []))',
    expected: true,
    sample: '(do (add-watch a :logger (fn [k r old new] (swap! changes conj [old new]))) true)',
    hints: ['add-watch for callbacks', 'Called on change'],
    tags: ['add-watch', 'observe', 'atom'],
  },
  {
    id: 'clj-atom-109',
    category: 'Atoms/Refs',
    difficulty: 'medium',
    title: 'Remove Watch',
    text: 'Remove watcher from atom.',
    setup: '(def a (atom 0))\n(add-watch a :key (fn [_ _ _ _]))',
    setupCode: '(def a (atom 0))\n(add-watch a :key (fn [_ _ _ _]))',
    expected: true,
    sample: '(do (remove-watch a :key) true)',
    hints: ['remove-watch by key', 'Stop observing'],
    tags: ['remove-watch', 'unwatch', 'atom'],
  },
  {
    id: 'clj-atom-110',
    category: 'Atoms/Refs',
    difficulty: 'hard',
    title: 'Atom Validator',
    text: 'Create atom with validator function.',
    setup: '',
    setupCode: '',
    expected: true,
    sample: '(atom 1 :validator pos?)',
    hints: [':validator ensures valid state', 'Rejects invalid'],
    tags: ['atom', 'validator', 'constraint'],
  },
  {
    id: 'clj-atom-111',
    category: 'Atoms/Refs',
    difficulty: 'hard',
    title: 'Set Validator',
    text: 'Set validator on existing atom.',
    setup: '(def a (atom 10))',
    setupCode: '(def a (atom 10))',
    expected: true,
    sample: '(do (set-validator! a pos?) true)',
    hints: ['set-validator! changes validator', 'Runtime validation'],
    tags: ['set-validator!', 'constraint', 'atom'],
  },
  {
    id: 'clj-atom-112',
    category: 'Atoms/Refs',
    difficulty: 'medium',
    title: 'Get Validator',
    text: 'Get validator from atom.',
    setup: '(def a (atom 1 :validator pos?))',
    setupCode: '(def a (atom 1 :validator pos?))',
    expected: true,
    sample: '(fn? (get-validator a))',
    hints: ['get-validator returns fn', 'nil if none'],
    tags: ['get-validator', 'inspect', 'atom'],
  },
  {
    id: 'clj-atom-113',
    category: 'Atoms/Refs',
    difficulty: 'easy',
    title: 'Create Ref',
    text: 'Create a ref for transactional state.',
    setup: '',
    setupCode: '',
    expected: 0,
    sample: '@(ref 0)',
    hints: ['ref for STM', 'Coordinated state'],
    tags: ['ref', 'create', 'stm'],
  },
  {
    id: 'clj-atom-114',
    category: 'Atoms/Refs',
    difficulty: 'medium',
    title: 'Ref-set in Dosync',
    text: 'Use `ref-set` in transaction.',
    setup: '(def r (ref 0))',
    setupCode: '(def r (ref 0))',
    expected: 42,
    sample: '(dosync (ref-set r 42))',
    hints: ['ref-set sets value', 'Must be in dosync'],
    tags: ['ref-set', 'dosync', 'transaction'],
  },
  {
    id: 'clj-atom-115',
    category: 'Atoms/Refs',
    difficulty: 'medium',
    title: 'Alter Ref',
    text: 'Use `alter` to update ref in transaction.',
    setup: '(def r (ref 0))',
    setupCode: '(def r (ref 0))',
    expected: 1,
    sample: '(dosync (alter r inc))',
    hints: ['alter like swap!', 'For refs in dosync'],
    tags: ['alter', 'dosync', 'update'],
  },
  {
    id: 'clj-atom-116',
    category: 'Atoms/Refs',
    difficulty: 'hard',
    title: 'Commute Ref',
    text: 'Use `commute` for commutative updates.',
    setup: '(def counter (ref 0))',
    setupCode: '(def counter (ref 0))',
    expected: 1,
    sample: '(dosync (commute counter inc))',
    hints: ['commute for commutative ops', 'May retry less'],
    tags: ['commute', 'dosync', 'commutative'],
  },
  {
    id: 'clj-atom-117',
    category: 'Atoms/Refs',
    difficulty: 'hard',
    title: 'Multiple Refs in Transaction',
    text: 'Update multiple refs atomically.',
    setup: '(def a (ref 100))\n(def b (ref 0))',
    setupCode: '(def a (ref 100))\n(def b (ref 0))',
    expected: [90, 10],
    sample: '(dosync (alter a - 10) (alter b + 10) [@a @b])',
    hints: ['dosync coordinates refs', 'All or nothing'],
    tags: ['dosync', 'multiple', 'atomic'],
  },
  {
    id: 'clj-atom-118',
    category: 'Atoms/Refs',
    difficulty: 'medium',
    title: 'Ensure Ref',
    text: 'Use `ensure` to protect ref read.',
    setup: '(def r (ref {:x 1}))',
    setupCode: '(def r (ref {:x 1}))',
    expected: { x: 1 },
    sample: '(dosync (ensure r))',
    hints: ['ensure protects from modification', 'Read consistency'],
    tags: ['ensure', 'dosync', 'protect'],
  },
  {
    id: 'clj-atom-119',
    category: 'Atoms/Refs',
    difficulty: 'hard',
    title: 'Ref History',
    text: 'Create ref with history for retries.',
    setup: '',
    setupCode: '',
    expected: true,
    sample: '(ref 0 :min-history 5 :max-history 10)',
    hints: [':min-history :max-history', 'For read-heavy workloads'],
    tags: ['ref', 'history', 'retry'],
  },
  {
    id: 'clj-atom-120',
    category: 'Atoms/Refs',
    difficulty: 'easy',
    title: 'Create Agent',
    text: 'Create an agent for async state.',
    setup: '',
    setupCode: '',
    expected: 0,
    sample: '@(agent 0)',
    hints: ['agent for async', 'Queued actions'],
    tags: ['agent', 'create', 'async'],
  },
  {
    id: 'clj-atom-121',
    category: 'Atoms/Refs',
    difficulty: 'medium',
    title: 'Send to Agent',
    text: 'Use `send` for CPU-bound agent action.',
    setup: '(def a (agent 0))',
    setupCode: '(def a (agent 0))',
    expected: 0,
    sample: '(do (send a inc) @a)',
    hints: ['send queues action', 'Returns immediately'],
    tags: ['send', 'agent', 'async'],
  },
  {
    id: 'clj-atom-122',
    category: 'Atoms/Refs',
    difficulty: 'medium',
    title: 'Send-off to Agent',
    text: 'Use `send-off` for IO-bound agent action.',
    setup: '(def a (agent 0))',
    setupCode: '(def a (agent 0))',
    expected: 0,
    sample: '(do (send-off a inc) @a)',
    hints: ['send-off for IO', 'Unbounded thread pool'],
    tags: ['send-off', 'agent', 'io'],
  },
  {
    id: 'clj-atom-123',
    category: 'Atoms/Refs',
    difficulty: 'hard',
    title: 'Await Agents',
    text: 'Use `await` to wait for agent actions.',
    setup: '(def a (agent 0))',
    setupCode: '(def a (agent 0))',
    expected: 1,
    sample: '(do (send a inc) (await a) @a)',
    hints: ['await blocks until done', 'For synchronization'],
    tags: ['await', 'agent', 'sync'],
  },
  {
    id: 'clj-atom-124',
    category: 'Atoms/Refs',
    difficulty: 'hard',
    title: 'Agent Error',
    text: 'Check agent for errors.',
    setup: '(def a (agent 0))\n(send a #(/ % 0))',
    setupCode: '(def a (agent 0))\n(send a #(/ % 0))',
    expected: true,
    sample: '(do (Thread/sleep 100) (some? (agent-error a)))',
    hints: ['agent-error returns exception', 'nil if no error'],
    tags: ['agent-error', 'error', 'agent'],
  },
  {
    id: 'clj-atom-125',
    category: 'Atoms/Refs',
    difficulty: 'hard',
    title: 'Restart Agent',
    text: 'Use `restart-agent` after error.',
    setup: '(def a (agent 0 :error-mode :fail))\n(send a #(/ % 0))',
    setupCode: '(def a (agent 0 :error-mode :fail))\n(send a #(/ % 0))',
    expected: true,
    sample: '(do (Thread/sleep 100) (restart-agent a 0) true)',
    hints: ['restart-agent clears error', 'Sets new value'],
    tags: ['restart-agent', 'error', 'recovery'],
  },
  {
    id: 'clj-atom-126',
    category: 'Atoms/Refs',
    difficulty: 'hard',
    title: 'Agent Error Handler',
    text: 'Set error handler for agent.',
    setup: '(def errors (atom []))',
    setupCode: '(def errors (atom []))',
    expected: true,
    sample: '(agent 0 :error-handler (fn [a e] (swap! errors conj e)))',
    hints: [':error-handler catches errors', 'Custom handling'],
    tags: ['agent', 'error-handler', 'callback'],
  },
  {
    id: 'clj-atom-127',
    category: 'Atoms/Refs',
    difficulty: 'medium',
    title: 'Atom Metadata',
    text: 'Add metadata to atom.',
    setup: '',
    setupCode: '',
    expected: 'counter',
    sample: '(:name (meta (atom 0 :meta {:name "counter"})))',
    hints: [':meta adds metadata', 'On atom itself'],
    tags: ['atom', 'meta', 'metadata'],
  },
  {
    id: 'clj-atom-128',
    category: 'Atoms/Refs',
    difficulty: 'medium',
    title: 'Swap Vals!',
    text: 'Use `swap-vals!` to get old and new.',
    setup: '(def a (atom 1))',
    setupCode: '(def a (atom 1))',
    expected: [1, 2],
    sample: '(swap-vals! a inc)',
    hints: ['swap-vals! returns [old new]', 'For comparison'],
    tags: ['swap-vals!', 'old-new', 'atom'],
  },
  {
    id: 'clj-atom-129',
    category: 'Atoms/Refs',
    difficulty: 'medium',
    title: 'Reset Vals!',
    text: 'Use `reset-vals!` to get old and new.',
    setup: '(def a (atom 1))',
    setupCode: '(def a (atom 1))',
    expected: [1, 99],
    sample: '(reset-vals! a 99)',
    hints: ['reset-vals! returns [old new]', 'See what changed'],
    tags: ['reset-vals!', 'old-new', 'atom'],
  },
  {
    id: 'clj-atom-130',
    category: 'Atoms/Refs',
    difficulty: 'easy',
    title: 'Create Volatile',
    text: 'Create volatile for thread-local mutable state.',
    setup: '',
    setupCode: '',
    expected: 0,
    sample: '@(volatile! 0)',
    hints: ['volatile! for fast mutable', 'Not thread-safe'],
    tags: ['volatile!', 'create', 'mutable'],
  },
  {
    id: 'clj-atom-131',
    category: 'Atoms/Refs',
    difficulty: 'easy',
    title: 'Vreset! Volatile',
    text: 'Use `vreset!` to set volatile value.',
    setup: '(def v (volatile! 0))',
    setupCode: '(def v (volatile! 0))',
    expected: 42,
    sample: '(vreset! v 42)',
    hints: ['vreset! sets value', 'Fast, no CAS'],
    tags: ['vreset!', 'set', 'volatile'],
  },
  {
    id: 'clj-atom-132',
    category: 'Atoms/Refs',
    difficulty: 'easy',
    title: 'Vswap! Volatile',
    text: 'Use `vswap!` to update volatile.',
    setup: '(def v (volatile! 0))',
    setupCode: '(def v (volatile! 0))',
    expected: 1,
    sample: '(vswap! v inc)',
    hints: ['vswap! like swap!', 'For volatile'],
    tags: ['vswap!', 'update', 'volatile'],
  },
  {
    id: 'clj-atom-133',
    category: 'Atoms/Refs',
    difficulty: 'hard',
    title: 'Ref Min/Max History',
    text: 'Configure ref retry history.',
    setup: '',
    setupCode: '',
    expected: true,
    sample: '(ref 0 :min-history 2 :max-history 5)',
    hints: ['History for read-heavy', 'Reduces retries'],
    tags: ['ref', 'history', 'config'],
  },
  {
    id: 'clj-atom-134',
    category: 'Atoms/Refs',
    difficulty: 'hard',
    title: 'Io! Block',
    text: 'Use `io!` to prevent IO in transactions.',
    setup: '',
    setupCode: '',
    expected: 'done',
    sample: '(io! "done")',
    hints: ['io! throws in dosync', 'Prevents accidental IO'],
    tags: ['io!', 'safety', 'transaction'],
  },

  // ============================================================
  // Transducers (35 problems)
  // ============================================================

  {
    id: 'clj-xf-100',
    category: 'Transducers',
    difficulty: 'medium',
    title: 'Map Transducer',
    text: 'Use map transducer with into.',
    setup: '(def nums [1 2 3 4 5])',
    setupCode: '(def nums [1 2 3 4 5])',
    expected: [2, 4, 6, 8, 10],
    sample: '(into [] (map #(* 2 %)) nums)',
    hints: ['map without coll is transducer', 'into applies it'],
    tags: ['map', 'transducer', 'into'],
  },
  {
    id: 'clj-xf-101',
    category: 'Transducers',
    difficulty: 'medium',
    title: 'Filter Transducer',
    text: 'Use filter transducer with into.',
    setup: '(def nums [1 2 3 4 5 6])',
    setupCode: '(def nums [1 2 3 4 5 6])',
    expected: [2, 4, 6],
    sample: '(into [] (filter even?) nums)',
    hints: ['filter without coll is transducer', 'Composable'],
    tags: ['filter', 'transducer', 'into'],
  },
  {
    id: 'clj-xf-102',
    category: 'Transducers',
    difficulty: 'medium',
    title: 'Compose Transducers',
    text: 'Use comp to compose transducers.',
    setup: '(def nums [1 2 3 4 5 6])',
    setupCode: '(def nums [1 2 3 4 5 6])',
    expected: [4, 8, 12],
    sample: '(into [] (comp (filter even?) (map #(* 2 %))) nums)',
    hints: ['comp combines transducers', 'Left to right order'],
    tags: ['comp', 'transducer', 'compose'],
  },
  {
    id: 'clj-xf-103',
    category: 'Transducers',
    difficulty: 'hard',
    title: 'Take Transducer',
    text: 'Use take transducer to limit results.',
    setup: '(def nums (range 100))',
    setupCode: '(def nums (range 100))',
    expected: [0, 1, 2, 3, 4],
    sample: '(into [] (take 5) nums)',
    hints: ['take as transducer', 'Limits output'],
    tags: ['take', 'transducer', 'limit'],
  },
  {
    id: 'clj-xf-104',
    category: 'Transducers',
    difficulty: 'hard',
    title: 'Drop Transducer',
    text: 'Use drop transducer to skip elements.',
    setup: '(def nums [1 2 3 4 5])',
    setupCode: '(def nums [1 2 3 4 5])',
    expected: [3, 4, 5],
    sample: '(into [] (drop 2) nums)',
    hints: ['drop as transducer', 'Skips first n'],
    tags: ['drop', 'transducer', 'skip'],
  },
  {
    id: 'clj-xf-105',
    category: 'Transducers',
    difficulty: 'hard',
    title: 'Take-while Transducer',
    text: 'Use take-while transducer.',
    setup: '(def nums [1 2 3 4 5 1 2])',
    setupCode: '(def nums [1 2 3 4 5 1 2])',
    expected: [1, 2, 3],
    sample: '(into [] (take-while #(< % 4)) nums)',
    hints: ['take-while as transducer', 'Stops at predicate'],
    tags: ['take-while', 'transducer', 'predicate'],
  },
  {
    id: 'clj-xf-106',
    category: 'Transducers',
    difficulty: 'hard',
    title: 'Drop-while Transducer',
    text: 'Use drop-while transducer.',
    setup: '(def nums [1 2 3 4 5 1 2])',
    setupCode: '(def nums [1 2 3 4 5 1 2])',
    expected: [4, 5, 1, 2],
    sample: '(into [] (drop-while #(< % 4)) nums)',
    hints: ['drop-while as transducer', 'Drops until predicate fails'],
    tags: ['drop-while', 'transducer', 'skip'],
  },
  {
    id: 'clj-xf-107',
    category: 'Transducers',
    difficulty: 'medium',
    title: 'Mapcat Transducer',
    text: 'Use mapcat transducer for flatmap.',
    setup: '(def nums [1 2 3])',
    setupCode: '(def nums [1 2 3])',
    expected: [1, 1, 2, 2, 3, 3],
    sample: '(into [] (mapcat #(repeat 2 %)) nums)',
    hints: ['mapcat = map + concat', 'Flattens one level'],
    tags: ['mapcat', 'transducer', 'flatmap'],
  },
  {
    id: 'clj-xf-108',
    category: 'Transducers',
    difficulty: 'medium',
    title: 'Partition-all Transducer',
    text: 'Use partition-all transducer.',
    setup: '(def nums [1 2 3 4 5 6 7])',
    setupCode: '(def nums [1 2 3 4 5 6 7])',
    expected: [[1, 2, 3], [4, 5, 6], [7]],
    sample: '(into [] (partition-all 3) nums)',
    hints: ['partition-all as transducer', 'Includes partial'],
    tags: ['partition-all', 'transducer', 'chunk'],
  },
  {
    id: 'clj-xf-109',
    category: 'Transducers',
    difficulty: 'hard',
    title: 'Partition-by Transducer',
    text: 'Use partition-by transducer.',
    setup: '(def nums [1 1 2 2 2 3 3])',
    setupCode: '(def nums [1 1 2 2 2 3 3])',
    expected: [[1, 1], [2, 2, 2], [3, 3]],
    sample: '(into [] (partition-by identity) nums)',
    hints: ['partition-by groups runs', 'By function result'],
    tags: ['partition-by', 'transducer', 'group'],
  },
  {
    id: 'clj-xf-110',
    category: 'Transducers',
    difficulty: 'medium',
    title: 'Distinct Transducer',
    text: 'Use distinct transducer.',
    setup: '(def nums [1 2 1 3 2 4 3])',
    setupCode: '(def nums [1 2 1 3 2 4 3])',
    expected: [1, 2, 3, 4],
    sample: '(into [] (distinct) nums)',
    hints: ['distinct removes duplicates', 'Keeps first occurrence'],
    tags: ['distinct', 'transducer', 'dedupe'],
  },
  {
    id: 'clj-xf-111',
    category: 'Transducers',
    difficulty: 'medium',
    title: 'Dedupe Transducer',
    text: 'Use dedupe transducer for consecutive duplicates.',
    setup: '(def nums [1 1 2 2 1 1 3])',
    setupCode: '(def nums [1 1 2 2 1 1 3])',
    expected: [1, 2, 1, 3],
    sample: '(into [] (dedupe) nums)',
    hints: ['dedupe removes consecutive only', 'Not all duplicates'],
    tags: ['dedupe', 'transducer', 'consecutive'],
  },
  {
    id: 'clj-xf-112',
    category: 'Transducers',
    difficulty: 'hard',
    title: 'Remove Transducer',
    text: 'Use remove transducer.',
    setup: '(def nums [1 2 3 4 5 6])',
    setupCode: '(def nums [1 2 3 4 5 6])',
    expected: [1, 3, 5],
    sample: '(into [] (remove even?) nums)',
    hints: ['remove is inverse of filter', 'Excludes matching'],
    tags: ['remove', 'transducer', 'exclude'],
  },
  {
    id: 'clj-xf-113',
    category: 'Transducers',
    difficulty: 'hard',
    title: 'Keep Transducer',
    text: 'Use keep transducer for non-nil results.',
    setup: '(def nums [1 2 3 4 5])',
    setupCode: '(def nums [1 2 3 4 5])',
    expected: [2, 4],
    sample: '(into [] (keep #(when (even? %) %)) nums)',
    hints: ['keep drops nil results', 'Like filter + map'],
    tags: ['keep', 'transducer', 'non-nil'],
  },
  {
    id: 'clj-xf-114',
    category: 'Transducers',
    difficulty: 'hard',
    title: 'Keep-indexed Transducer',
    text: 'Use keep-indexed transducer.',
    setup: '(def nums [:a :b :c :d :e])',
    setupCode: '(def nums [:a :b :c :d :e])',
    expected: ['a', 'c', 'e'],
    sample: '(into [] (keep-indexed #(when (even? %1) %2)) nums)',
    hints: ['keep-indexed with index', 'Filter by index'],
    tags: ['keep-indexed', 'transducer', 'index'],
  },
  {
    id: 'clj-xf-115',
    category: 'Transducers',
    difficulty: 'medium',
    title: 'Interpose Transducer',
    text: 'Use interpose transducer.',
    setup: '(def nums [1 2 3])',
    setupCode: '(def nums [1 2 3])',
    expected: [1, 0, 2, 0, 3],
    sample: '(into [] (interpose 0) nums)',
    hints: ['interpose inserts between', 'As transducer'],
    tags: ['interpose', 'transducer', 'separate'],
  },
  {
    id: 'clj-xf-116',
    category: 'Transducers',
    difficulty: 'hard',
    title: 'Cat Transducer',
    text: 'Use cat transducer to flatten.',
    setup: '(def nested [[1 2] [3 4] [5 6]])',
    setupCode: '(def nested [[1 2] [3 4] [5 6]])',
    expected: [1, 2, 3, 4, 5, 6],
    sample: '(into [] cat nested)',
    hints: ['cat flattens one level', 'Like mapcat identity'],
    tags: ['cat', 'transducer', 'flatten'],
  },
  {
    id: 'clj-xf-117',
    category: 'Transducers',
    difficulty: 'medium',
    title: 'Transduce with +',
    text: 'Use transduce to sum transformed values.',
    setup: '(def nums [1 2 3 4 5])',
    setupCode: '(def nums [1 2 3 4 5])',
    expected: 30,
    sample: '(transduce (map #(* 2 %)) + nums)',
    hints: ['transduce applies and reduces', 'No intermediate collection'],
    tags: ['transduce', 'reduce', 'sum'],
  },
  {
    id: 'clj-xf-118',
    category: 'Transducers',
    difficulty: 'hard',
    title: 'Transduce with Init',
    text: 'Use transduce with initial value.',
    setup: '(def nums [1 2 3])',
    setupCode: '(def nums [1 2 3])',
    expected: 112,
    sample: '(transduce (map #(* 2 %)) + 100 nums)',
    hints: ['Init value as third arg', '100 + 2 + 4 + 6'],
    tags: ['transduce', 'initial', 'accumulate'],
  },
  {
    id: 'clj-xf-119',
    category: 'Transducers',
    difficulty: 'medium',
    title: 'Sequence with Transducer',
    text: 'Use sequence for lazy transducer application.',
    setup: '(def nums (range 10))',
    setupCode: '(def nums (range 10))',
    expected: [0, 2, 4, 6, 8],
    sample: '(sequence (filter even?) nums)',
    hints: ['sequence returns lazy seq', 'With transducer'],
    tags: ['sequence', 'lazy', 'transducer'],
  },
  {
    id: 'clj-xf-120',
    category: 'Transducers',
    difficulty: 'hard',
    title: 'Eduction Reusable',
    text: 'Use eduction for reusable transformation.',
    setup: '(def nums [1 2 3 4 5])',
    setupCode: '(def nums [1 2 3 4 5])',
    expected: [2, 4, 6, 8, 10],
    sample: '(into [] (eduction (map #(* 2 %)) nums))',
    hints: ['eduction is reducible', 'Recomputes each time'],
    tags: ['eduction', 'reusable', 'transducer'],
  },
  {
    id: 'clj-xf-121',
    category: 'Transducers',
    difficulty: 'hard',
    title: 'Completing Function',
    text: 'Use completing for custom reduction.',
    setup: '',
    setupCode: '',
    expected: [1, 2, 3],
    sample: '(transduce identity (completing conj #(vec (reverse %))) [] [3 2 1])',
    hints: ['completing adds completion step', 'Final transformation'],
    tags: ['completing', 'finalize', 'transducer'],
  },
  {
    id: 'clj-xf-122',
    category: 'Transducers',
    difficulty: 'hard',
    title: 'Halt-when Transducer',
    text: 'Use halt-when to stop early.',
    setup: '(def nums (range 100))',
    setupCode: '(def nums (range 100))',
    expected: [0, 1, 2, 3, 4],
    sample: '(into [] (halt-when #(= % 5)) nums)',
    hints: ['halt-when stops processing', 'Early termination'],
    tags: ['halt-when', 'stop', 'early'],
  },
  {
    id: 'clj-xf-123',
    category: 'Transducers',
    difficulty: 'medium',
    title: 'Random-sample Transducer',
    text: 'Use random-sample transducer.',
    setup: '(def nums (range 100))',
    setupCode: '(def nums (range 100))',
    expected: true,
    sample: '(< (count (into [] (random-sample 0.1) nums)) 50)',
    hints: ['random-sample by probability', 'Approximate sampling'],
    tags: ['random-sample', 'sample', 'transducer'],
  },
  {
    id: 'clj-xf-124',
    category: 'Transducers',
    difficulty: 'hard',
    title: 'Complex Transducer Pipeline',
    text: 'Build complex transformation pipeline.',
    setup: '(def data [{:name "A" :score 90} {:name "B" :score 60} {:name "C" :score 85}])',
    setupCode: '(def data [{:name "A" :score 90} {:name "B" :score 60} {:name "C" :score 85}])',
    expected: ['A', 'C'],
    sample: '(into [] (comp (filter #(>= (:score %) 80)) (map :name)) data)',
    hints: ['Compose filter and map', 'Extract from filtered'],
    tags: ['comp', 'pipeline', 'complex'],
  },
  {
    id: 'clj-xf-125',
    category: 'Transducers',
    difficulty: 'medium',
    title: 'Into Set with Transducer',
    text: 'Use transducer with set as target.',
    setup: '(def nums [1 2 2 3 3 3])',
    setupCode: '(def nums [1 2 2 3 3 3])',
    expected: [2, 4, 6],
    sample: '(into #{} (map #(* 2 %)) nums)',
    hints: ['into works with any coll', 'Set dedupes'],
    tags: ['into', 'set', 'transducer'],
  },
  {
    id: 'clj-xf-126',
    category: 'Transducers',
    difficulty: 'hard',
    title: 'Transduce to Map',
    text: 'Build map using transducer.',
    setup: '(def items [{:id 1 :name "A"} {:id 2 :name "B"}])',
    setupCode: '(def items [{:id 1 :name "A"} {:id 2 :name "B"}])',
    expected: { 1: 'A', 2: 'B' },
    sample: '(into {} (map (juxt :id :name)) items)',
    hints: ['juxt creates pairs', 'into {} builds map'],
    tags: ['into', 'map', 'juxt'],
  },
  {
    id: 'clj-xf-127',
    category: 'Transducers',
    difficulty: 'hard',
    title: 'Replace Transducer',
    text: 'Use replace transducer.',
    setup: '(def nums [1 2 3 1 2 3])',
    setupCode: '(def nums [1 2 3 1 2 3])',
    expected: ['a', 'b', 3, 'a', 'b', 3],
    sample: '(into [] (replace {1 :a 2 :b}) nums)',
    hints: ['replace substitutes values', 'Map as lookup'],
    tags: ['replace', 'substitute', 'transducer'],
  },
  {
    id: 'clj-xf-128',
    category: 'Transducers',
    difficulty: 'medium',
    title: 'Map-indexed Transducer',
    text: 'Use map-indexed transducer.',
    setup: '(def items [:a :b :c])',
    setupCode: '(def items [:a :b :c])',
    expected: [[0, 'a'], [1, 'b'], [2, 'c']],
    sample: '(into [] (map-indexed vector) items)',
    hints: ['map-indexed provides index', 'As transducer'],
    tags: ['map-indexed', 'index', 'transducer'],
  },
  {
    id: 'clj-xf-129',
    category: 'Transducers',
    difficulty: 'hard',
    title: 'Volatile for Stateful Transducer',
    text: 'Create stateful transducer with volatile.',
    setup: '',
    setupCode: '',
    expected: [1, 3, 6, 10, 15],
    sample: '(into [] (fn [rf] (let [sum (volatile! 0)] (fn ([] (rf)) ([result] (rf result)) ([result input] (rf result (vswap! sum + input)))))) [1 2 3 4 5])',
    hints: ['volatile! for state', 'Custom transducer'],
    tags: ['volatile', 'stateful', 'custom'],
  },
  {
    id: 'clj-xf-130',
    category: 'Transducers',
    difficulty: 'hard',
    title: 'Transduce String',
    text: 'Apply transducer to string characters.',
    setup: '(def s "hello")',
    setupCode: '(def s "hello")',
    expected: 'HELLO',
    sample: '(apply str (into [] (map #(Character/toUpperCase %)) s))',
    hints: ['String is char sequence', 'Transduce then join'],
    tags: ['transduce', 'string', 'chars'],
  },
  {
    id: 'clj-xf-131',
    category: 'Transducers',
    difficulty: 'medium',
    title: 'Take-nth Transducer',
    text: 'Use take-nth transducer.',
    setup: '(def nums [1 2 3 4 5 6 7 8 9])',
    setupCode: '(def nums [1 2 3 4 5 6 7 8 9])',
    expected: [1, 4, 7],
    sample: '(into [] (take-nth 3) nums)',
    hints: ['take-nth takes every nth', 'Starting from first'],
    tags: ['take-nth', 'stride', 'transducer'],
  },
  {
    id: 'clj-xf-132',
    category: 'Transducers',
    difficulty: 'hard',
    title: 'Multiplex Transducers',
    text: 'Apply multiple transducers to same input.',
    setup: '(def nums [1 2 3 4 5])',
    setupCode: '(def nums [1 2 3 4 5])',
    expected: [[1, 3, 5], [2, 4]],
    sample: '[(into [] (filter odd?) nums) (into [] (filter even?) nums)]',
    hints: ['Process same source twice', 'Different transducers'],
    tags: ['multiple', 'transducer', 'parallel'],
  },
  {
    id: 'clj-xf-133',
    category: 'Transducers',
    difficulty: 'hard',
    title: 'Transducer Order Matters',
    text: 'Demonstrate transducer composition order.',
    setup: '(def nums [1 2 3 4 5 6])',
    setupCode: '(def nums [1 2 3 4 5 6])',
    expected: [4, 8, 12],
    sample: '(into [] (comp (filter even?) (map #(* 2 %))) nums)',
    hints: ['Left to right in comp', 'Filter then map'],
    tags: ['comp', 'order', 'transducer'],
  },
  {
    id: 'clj-xf-134',
    category: 'Transducers',
    difficulty: 'medium',
    title: 'Reduce with Transducer',
    text: 'Use transduce instead of reduce.',
    setup: '(def nums [1 2 3 4 5])',
    setupCode: '(def nums [1 2 3 4 5])',
    expected: 9,
    sample: '(transduce (filter odd?) + nums)',
    hints: ['transduce = transform + reduce', 'Single pass'],
    tags: ['transduce', 'reduce', 'filter'],
  },

  // ============================================================
  // Core.async (35 problems)
  // ============================================================

  {
    id: 'clj-async-100',
    category: 'Core.async',
    difficulty: 'medium',
    title: 'Create Channel',
    text: 'Create a core.async channel.',
    setup: '(require \'[clojure.core.async :as async])',
    setupCode: '(require \'[clojure.core.async :as async])',
    expected: true,
    sample: '(some? (async/chan))',
    hints: ['chan creates channel', 'Unbuffered by default'],
    tags: ['chan', 'create', 'async'],
  },
  {
    id: 'clj-async-101',
    category: 'Core.async',
    difficulty: 'medium',
    title: 'Buffered Channel',
    text: 'Create channel with buffer.',
    setup: '(require \'[clojure.core.async :as async])',
    setupCode: '(require \'[clojure.core.async :as async])',
    expected: true,
    sample: '(some? (async/chan 10))',
    hints: ['Pass number for buffer size', 'Fixed buffer'],
    tags: ['chan', 'buffer', 'async'],
  },
  {
    id: 'clj-async-102',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'Dropping Buffer',
    text: 'Create channel with dropping buffer.',
    setup: '(require \'[clojure.core.async :as async])',
    setupCode: '(require \'[clojure.core.async :as async])',
    expected: true,
    sample: '(some? (async/chan (async/dropping-buffer 10)))',
    hints: ['dropping-buffer drops new', 'When full'],
    tags: ['dropping-buffer', 'overflow', 'async'],
  },
  {
    id: 'clj-async-103',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'Sliding Buffer',
    text: 'Create channel with sliding buffer.',
    setup: '(require \'[clojure.core.async :as async])',
    setupCode: '(require \'[clojure.core.async :as async])',
    expected: true,
    sample: '(some? (async/chan (async/sliding-buffer 10)))',
    hints: ['sliding-buffer drops old', 'When full'],
    tags: ['sliding-buffer', 'window', 'async'],
  },
  {
    id: 'clj-async-104',
    category: 'Core.async',
    difficulty: 'medium',
    title: 'Put and Take',
    text: 'Use >!! and <!! for blocking operations.',
    setup: '(require \'[clojure.core.async :as async])\n(def c (async/chan 1))',
    setupCode: '(require \'[clojure.core.async :as async])\n(def c (async/chan 1))',
    expected: 42,
    sample: '(do (async/>!! c 42) (async/<!! c))',
    hints: ['>!! puts blocking', '<!! takes blocking'],
    tags: ['put', 'take', 'blocking'],
  },
  {
    id: 'clj-async-105',
    category: 'Core.async',
    difficulty: 'medium',
    title: 'Go Block',
    text: 'Use go block for async operations.',
    setup: '(require \'[clojure.core.async :as async :refer [go <! >!]])',
    setupCode: '(require \'[clojure.core.async :as async :refer [go <! >!]])',
    expected: true,
    sample: '(some? (go 42))',
    hints: ['go returns channel', 'Body runs async'],
    tags: ['go', 'async', 'block'],
  },
  {
    id: 'clj-async-106',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'Park in Go Block',
    text: 'Use <! to park in go block.',
    setup: '(require \'[clojure.core.async :as async :refer [go <! >! chan]])\n(def c (chan 1))',
    setupCode: '(require \'[clojure.core.async :as async :refer [go <! >! chan]])\n(def c (chan 1))',
    expected: 42,
    sample: '(do (go (>! c 42)) (async/<!! (go (<! c))))',
    hints: ['<! parks go block', 'Not blocking'],
    tags: ['park', 'go', 'take'],
  },
  {
    id: 'clj-async-107',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'Go-loop Pattern',
    text: 'Use go-loop for recurring async.',
    setup: '(require \'[clojure.core.async :as async :refer [go-loop <! chan close!]])',
    setupCode: '(require \'[clojure.core.async :as async :refer [go-loop <! chan close!]])',
    expected: true,
    sample: '(some? (go-loop [] (recur)))',
    hints: ['go-loop = go + loop', 'Common pattern'],
    tags: ['go-loop', 'loop', 'async'],
  },
  {
    id: 'clj-async-108',
    category: 'Core.async',
    difficulty: 'medium',
    title: 'Close Channel',
    text: 'Close a channel.',
    setup: '(require \'[clojure.core.async :as async])\n(def c (async/chan))',
    setupCode: '(require \'[clojure.core.async :as async])\n(def c (async/chan))',
    expected: true,
    sample: '(do (async/close! c) true)',
    hints: ['close! closes channel', 'No more puts'],
    tags: ['close!', 'channel', 'shutdown'],
  },
  {
    id: 'clj-async-109',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'Take from Closed',
    text: 'Take from closed channel returns nil.',
    setup: '(require \'[clojure.core.async :as async])\n(def c (async/chan 1))\n(async/>!! c 1)\n(async/close! c)',
    setupCode: '(require \'[clojure.core.async :as async])\n(def c (async/chan 1))\n(async/>!! c 1)\n(async/close! c)',
    expected: null,
    sample: '(do (async/<!! c) (async/<!! c))',
    hints: ['First take gets value', 'Second gets nil'],
    tags: ['close', 'nil', 'take'],
  },
  {
    id: 'clj-async-110',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'Alts!! Select',
    text: 'Use alts!! to select from multiple channels.',
    setup: '(require \'[clojure.core.async :as async])\n(def c1 (async/chan 1))\n(def c2 (async/chan 1))\n(async/>!! c1 :first)',
    setupCode: '(require \'[clojure.core.async :as async])\n(def c1 (async/chan 1))\n(def c2 (async/chan 1))\n(async/>!! c1 :first)',
    expected: 'first',
    sample: '(first (async/alts!! [c1 c2]))',
    hints: ['alts!! returns [value channel]', 'First available'],
    tags: ['alts!!', 'select', 'multiple'],
  },
  {
    id: 'clj-async-111',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'Alts! with Timeout',
    text: 'Use timeout channel with alts!.',
    setup: '(require \'[clojure.core.async :as async :refer [go alts! timeout]])',
    setupCode: '(require \'[clojure.core.async :as async :refer [go alts! timeout]])',
    expected: true,
    sample: '(some? (go (alts! [(timeout 1000)])))',
    hints: ['timeout creates timed channel', 'Closes after ms'],
    tags: ['timeout', 'alts!', 'deadline'],
  },
  {
    id: 'clj-async-112',
    category: 'Core.async',
    difficulty: 'medium',
    title: 'Timeout Channel',
    text: 'Create timeout channel.',
    setup: '(require \'[clojure.core.async :as async])',
    setupCode: '(require \'[clojure.core.async :as async])',
    expected: true,
    sample: '(some? (async/timeout 100))',
    hints: ['timeout returns channel', 'Closes after delay'],
    tags: ['timeout', 'delay', 'channel'],
  },
  {
    id: 'clj-async-113',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'Pipe Channels',
    text: 'Use pipe to connect channels.',
    setup: '(require \'[clojure.core.async :as async])\n(def from (async/chan 1))\n(def to (async/chan 1))',
    setupCode: '(require \'[clojure.core.async :as async])\n(def from (async/chan 1))\n(def to (async/chan 1))',
    expected: 42,
    sample: '(do (async/pipe from to) (async/>!! from 42) (async/<!! to))',
    hints: ['pipe copies values', 'From one to another'],
    tags: ['pipe', 'connect', 'channels'],
  },
  {
    id: 'clj-async-114',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'Merge Channels',
    text: 'Use merge to combine channels.',
    setup: '(require \'[clojure.core.async :as async])\n(def c1 (async/chan 1))\n(def c2 (async/chan 1))',
    setupCode: '(require \'[clojure.core.async :as async])\n(def c1 (async/chan 1))\n(def c2 (async/chan 1))',
    expected: true,
    sample: '(some? (async/merge [c1 c2]))',
    hints: ['merge combines inputs', 'Single output channel'],
    tags: ['merge', 'combine', 'channels'],
  },
  {
    id: 'clj-async-115',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'Split Channel',
    text: 'Use split to divide channel by predicate.',
    setup: '(require \'[clojure.core.async :as async])\n(def c (async/chan 10))',
    setupCode: '(require \'[clojure.core.async :as async])\n(def c (async/chan 10))',
    expected: 2,
    sample: '(count (async/split even? c))',
    hints: ['split returns [true-ch false-ch]', 'By predicate'],
    tags: ['split', 'predicate', 'channels'],
  },
  {
    id: 'clj-async-116',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'Mult for Broadcast',
    text: 'Use mult to broadcast to multiple channels.',
    setup: '(require \'[clojure.core.async :as async])\n(def c (async/chan))\n(def m (async/mult c))',
    setupCode: '(require \'[clojure.core.async :as async])\n(def c (async/chan))\n(def m (async/mult c))',
    expected: true,
    sample: '(some? m)',
    hints: ['mult creates multiplexer', 'tap to subscribe'],
    tags: ['mult', 'broadcast', 'pub-sub'],
  },
  {
    id: 'clj-async-117',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'Tap Mult',
    text: 'Use tap to subscribe to mult.',
    setup: '(require \'[clojure.core.async :as async])\n(def src (async/chan 1))\n(def m (async/mult src))\n(def dest (async/chan 1))',
    setupCode: '(require \'[clojure.core.async :as async])\n(def src (async/chan 1))\n(def m (async/mult src))\n(def dest (async/chan 1))',
    expected: 42,
    sample: '(do (async/tap m dest) (async/>!! src 42) (async/<!! dest))',
    hints: ['tap subscribes channel', 'Receives copies'],
    tags: ['tap', 'subscribe', 'mult'],
  },
  {
    id: 'clj-async-118',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'Pub-Sub Pattern',
    text: 'Use pub/sub for topic-based routing.',
    setup: '(require \'[clojure.core.async :as async])\n(def c (async/chan))\n(def p (async/pub c :topic))',
    setupCode: '(require \'[clojure.core.async :as async])\n(def c (async/chan))\n(def p (async/pub c :topic))',
    expected: true,
    sample: '(some? p)',
    hints: ['pub creates publisher', 'sub subscribes to topics'],
    tags: ['pub', 'sub', 'topics'],
  },
  {
    id: 'clj-async-119',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'Sub to Topic',
    text: 'Subscribe to a topic on pub.',
    setup: '(require \'[clojure.core.async :as async])\n(def c (async/chan 1))\n(def p (async/pub c :topic))\n(def sub-ch (async/chan 1))',
    setupCode: '(require \'[clojure.core.async :as async])\n(def c (async/chan 1))\n(def p (async/pub c :topic))\n(def sub-ch (async/chan 1))',
    expected: 'hello',
    sample: '(do (async/sub p :greeting sub-ch) (async/>!! c {:topic :greeting :msg "hello"}) (:msg (async/<!! sub-ch)))',
    hints: ['sub takes pub, topic, channel', 'Receives matching messages'],
    tags: ['sub', 'topic', 'routing'],
  },
  {
    id: 'clj-async-120',
    category: 'Core.async',
    difficulty: 'medium',
    title: 'Thread for Blocking',
    text: 'Use thread for blocking operations.',
    setup: '(require \'[clojure.core.async :as async])',
    setupCode: '(require \'[clojure.core.async :as async])',
    expected: 42,
    sample: '(async/<!! (async/thread 42))',
    hints: ['thread returns channel', 'For blocking IO'],
    tags: ['thread', 'blocking', 'io'],
  },
  {
    id: 'clj-async-121',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'Offer! Non-blocking Put',
    text: 'Use offer! for non-blocking put.',
    setup: '(require \'[clojure.core.async :as async])\n(def c (async/chan 1))',
    setupCode: '(require \'[clojure.core.async :as async])\n(def c (async/chan 1))',
    expected: true,
    sample: '(async/offer! c 42)',
    hints: ['offer! returns immediately', 'true if put, false if full'],
    tags: ['offer!', 'non-blocking', 'put'],
  },
  {
    id: 'clj-async-122',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'Poll! Non-blocking Take',
    text: 'Use poll! for non-blocking take.',
    setup: '(require \'[clojure.core.async :as async])\n(def c (async/chan 1))\n(async/>!! c 42)',
    setupCode: '(require \'[clojure.core.async :as async])\n(def c (async/chan 1))\n(async/>!! c 42)',
    expected: 42,
    sample: '(async/poll! c)',
    hints: ['poll! returns immediately', 'nil if empty'],
    tags: ['poll!', 'non-blocking', 'take'],
  },
  {
    id: 'clj-async-123',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'Into Channel',
    text: 'Use into to collect channel values.',
    setup: '(require \'[clojure.core.async :as async])\n(def c (async/chan))',
    setupCode: '(require \'[clojure.core.async :as async])\n(def c (async/chan))',
    expected: [1, 2, 3],
    sample: '(do (async/onto-chan! c [1 2 3]) (async/<!! (async/into [] c)))',
    hints: ['into collects to coll', 'Until channel closes'],
    tags: ['into', 'collect', 'channel'],
  },
  {
    id: 'clj-async-124',
    category: 'Core.async',
    difficulty: 'medium',
    title: 'Onto-chan! Put Sequence',
    text: 'Use onto-chan! to put sequence onto channel.',
    setup: '(require \'[clojure.core.async :as async])\n(def c (async/chan 10))',
    setupCode: '(require \'[clojure.core.async :as async])\n(def c (async/chan 10))',
    expected: 1,
    sample: '(do (async/onto-chan! c [1 2 3]) (async/<!! c))',
    hints: ['onto-chan! puts values', 'Closes channel by default'],
    tags: ['onto-chan!', 'sequence', 'put'],
  },
  {
    id: 'clj-async-125',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'To-chan!! From Sequence',
    text: 'Use to-chan!! to create channel from sequence.',
    setup: '(require \'[clojure.core.async :as async])',
    setupCode: '(require \'[clojure.core.async :as async])',
    expected: 1,
    sample: '(async/<!! (async/to-chan!! [1 2 3]))',
    hints: ['to-chan!! creates filled channel', 'From sequence'],
    tags: ['to-chan!!', 'create', 'sequence'],
  },
  {
    id: 'clj-async-126',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'Reduce Channel',
    text: 'Use reduce over channel values.',
    setup: '(require \'[clojure.core.async :as async])',
    setupCode: '(require \'[clojure.core.async :as async])',
    expected: 6,
    sample: '(async/<!! (async/reduce + 0 (async/to-chan!! [1 2 3])))',
    hints: ['reduce accumulates channel', 'Returns result channel'],
    tags: ['reduce', 'accumulate', 'channel'],
  },
  {
    id: 'clj-async-127',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'Map Channel',
    text: 'Use map over channels.',
    setup: '(require \'[clojure.core.async :as async])',
    setupCode: '(require \'[clojure.core.async :as async])',
    expected: [2, 4, 6],
    sample: '(async/<!! (async/into [] (async/map #(* 2 %) [(async/to-chan!! [1 2 3])])))',
    hints: ['map transforms channel', 'Returns new channel'],
    tags: ['map', 'transform', 'channel'],
  },
  {
    id: 'clj-async-128',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'Filter Channel',
    text: 'Use filter on channel.',
    setup: '(require \'[clojure.core.async :as async])',
    setupCode: '(require \'[clojure.core.async :as async])',
    expected: [2, 4, 6],
    sample: '(async/<!! (async/into [] (async/filter< even? (async/to-chan!! [1 2 3 4 5 6]))))',
    hints: ['filter< filters channel', 'Keeps matching'],
    tags: ['filter', 'channel', 'predicate'],
  },
  {
    id: 'clj-async-129',
    category: 'Core.async',
    difficulty: 'medium',
    title: 'Channel with Transducer',
    text: 'Create channel with transducer.',
    setup: '(require \'[clojure.core.async :as async])',
    setupCode: '(require \'[clojure.core.async :as async])',
    expected: 2,
    sample: '(let [c (async/chan 1 (map #(* 2 %)))] (async/>!! c 1) (async/<!! c))',
    hints: ['chan takes transducer', 'Transforms on put'],
    tags: ['chan', 'transducer', 'transform'],
  },
  {
    id: 'clj-async-130',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'Pipeline Transform',
    text: 'Use pipeline for parallel transformation.',
    setup: '(require \'[clojure.core.async :as async])\n(def from (async/to-chan!! [1 2 3 4 5]))\n(def to (async/chan 10))',
    setupCode: '(require \'[clojure.core.async :as async])\n(def from (async/to-chan!! [1 2 3 4 5]))\n(def to (async/chan 10))',
    expected: 5,
    sample: '(do (async/pipeline 2 to (map #(* 2 %)) from) (count (async/<!! (async/into [] to))))',
    hints: ['pipeline for parallel', 'Preserves order'],
    tags: ['pipeline', 'parallel', 'transform'],
  },
  {
    id: 'clj-async-131',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'Pipeline-async',
    text: 'Use pipeline-async for async transforms.',
    setup: '(require \'[clojure.core.async :as async :refer [go >!]])',
    setupCode: '(require \'[clojure.core.async :as async :refer [go >!]])',
    expected: true,
    sample: '(fn? async/pipeline-async)',
    hints: ['pipeline-async for async fns', 'Each returns channel'],
    tags: ['pipeline-async', 'async', 'transform'],
  },
  {
    id: 'clj-async-132',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'Pipeline-blocking',
    text: 'Use pipeline-blocking for IO.',
    setup: '(require \'[clojure.core.async :as async])',
    setupCode: '(require \'[clojure.core.async :as async])',
    expected: true,
    sample: '(fn? async/pipeline-blocking)',
    hints: ['pipeline-blocking for IO', 'Uses thread pool'],
    tags: ['pipeline-blocking', 'io', 'blocking'],
  },
  {
    id: 'clj-async-133',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'Alts! with Priority',
    text: 'Use :priority in alts! options.',
    setup: '(require \'[clojure.core.async :as async :refer [go alts! chan >!]])',
    setupCode: '(require \'[clojure.core.async :as async :refer [go alts! chan >!]])',
    expected: true,
    sample: '(some? (go (alts! [(chan) (chan)] :priority true)))',
    hints: [':priority true for order', 'First channel prioritized'],
    tags: ['alts!', 'priority', 'options'],
  },
  {
    id: 'clj-async-134',
    category: 'Core.async',
    difficulty: 'hard',
    title: 'Alts! with Default',
    text: 'Use :default in alts! for non-blocking.',
    setup: '(require \'[clojure.core.async :as async :refer [go alts! chan]])',
    setupCode: '(require \'[clojure.core.async :as async :refer [go alts! chan]])',
    expected: true,
    sample: '(some? (go (alts! [(chan)] :default :none)))',
    hints: [':default for immediate return', 'If nothing ready'],
    tags: ['alts!', 'default', 'non-blocking'],
  },

  // ============================================================
  // Specs (35 problems)
  // ============================================================

  {
    id: 'clj-spec-100',
    category: 'Specs',
    difficulty: 'medium',
    title: 'Define Simple Spec',
    text: 'Define a spec for positive integers.',
    setup: '(require \'[clojure.spec.alpha :as s])',
    setupCode: '(require \'[clojure.spec.alpha :as s])',
    expected: true,
    sample: '(do (s/def ::positive pos-int?) (s/valid? ::positive 1))',
    hints: ['s/def registers spec', 'Use predicate'],
    tags: ['s/def', 'define', 'spec'],
  },
  {
    id: 'clj-spec-101',
    category: 'Specs',
    difficulty: 'easy',
    title: 'Validate with Valid?',
    text: 'Use s/valid? to check if value matches spec.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::age pos-int?)',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::age pos-int?)',
    expected: true,
    sample: '(s/valid? ::age 25)',
    hints: ['s/valid? returns boolean', 'Checks against spec'],
    tags: ['s/valid?', 'check', 'validate'],
  },
  {
    id: 'clj-spec-102',
    category: 'Specs',
    difficulty: 'medium',
    title: 'Conform Value',
    text: 'Use s/conform to check and extract value.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::name string?)',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::name string?)',
    expected: 'Alice',
    sample: '(s/conform ::name "Alice")',
    hints: ['s/conform returns value or :clojure.spec.alpha/invalid', 'For valid values'],
    tags: ['s/conform', 'extract', 'validate'],
  },
  {
    id: 'clj-spec-103',
    category: 'Specs',
    difficulty: 'medium',
    title: 'Invalid Conform',
    text: 'Check what conform returns for invalid value.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::age pos-int?)',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::age pos-int?)',
    expected: 'clojure.spec.alpha/invalid',
    sample: '(s/conform ::age -5)',
    hints: ['Returns ::s/invalid', 'For non-matching'],
    tags: ['s/conform', 'invalid', 'check'],
  },
  {
    id: 'clj-spec-104',
    category: 'Specs',
    difficulty: 'medium',
    title: 'Explain Spec Failure',
    text: 'Use s/explain-str to get failure message.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::name string?)',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::name string?)',
    expected: true,
    sample: '(string? (s/explain-str ::name 123))',
    hints: ['s/explain-str returns string', 'Describes failure'],
    tags: ['s/explain-str', 'error', 'message'],
  },
  {
    id: 'clj-spec-105',
    category: 'Specs',
    difficulty: 'hard',
    title: 'And Spec',
    text: 'Use s/and to combine predicates.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::even-pos (s/and pos-int? even?))',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::even-pos (s/and pos-int? even?))',
    expected: true,
    sample: '(s/valid? ::even-pos 4)',
    hints: ['s/and combines specs', 'All must pass'],
    tags: ['s/and', 'combine', 'multiple'],
  },
  {
    id: 'clj-spec-106',
    category: 'Specs',
    difficulty: 'hard',
    title: 'Or Spec',
    text: 'Use s/or for alternative specs.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::id (s/or :num int? :str string?))',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::id (s/or :num int? :str string?))',
    expected: ['str', 'abc'],
    sample: '(s/conform ::id "abc")',
    hints: ['s/or tags alternatives', 'Conform returns [tag value]'],
    tags: ['s/or', 'alternative', 'tagged'],
  },
  {
    id: 'clj-spec-107',
    category: 'Specs',
    difficulty: 'medium',
    title: 'Keys Spec for Maps',
    text: 'Use s/keys to spec map structure.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::name string?)\n(s/def ::age pos-int?)\n(s/def ::person (s/keys :req [::name ::age]))',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::name string?)\n(s/def ::age pos-int?)\n(s/def ::person (s/keys :req [::name ::age]))',
    expected: true,
    sample: '(s/valid? ::person {::name "Alice" ::age 30})',
    hints: ['s/keys for map specs', ':req for required keys'],
    tags: ['s/keys', 'map', 'structure'],
  },
  {
    id: 'clj-spec-108',
    category: 'Specs',
    difficulty: 'hard',
    title: 'Optional Keys',
    text: 'Use :opt for optional keys in map spec.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::name string?)\n(s/def ::email string?)\n(s/def ::user (s/keys :req [::name] :opt [::email]))',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::name string?)\n(s/def ::email string?)\n(s/def ::user (s/keys :req [::name] :opt [::email]))',
    expected: true,
    sample: '(s/valid? ::user {::name "Alice"})',
    hints: [':opt for optional keys', 'Validated if present'],
    tags: ['s/keys', 'optional', ':opt'],
  },
  {
    id: 'clj-spec-109',
    category: 'Specs',
    difficulty: 'hard',
    title: 'Unqualified Keys',
    text: 'Use :req-un for unqualified keys.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::name string?)\n(s/def ::person (s/keys :req-un [::name]))',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::name string?)\n(s/def ::person (s/keys :req-un [::name]))',
    expected: true,
    sample: '(s/valid? ::person {:name "Alice"})',
    hints: [':req-un for plain keywords', 'Spec uses qualified, data uses unqualified'],
    tags: ['s/keys', 'unqualified', ':req-un'],
  },
  {
    id: 'clj-spec-110',
    category: 'Specs',
    difficulty: 'medium',
    title: 'Coll-of Spec',
    text: 'Use s/coll-of for collection specs.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::numbers (s/coll-of int?))',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::numbers (s/coll-of int?))',
    expected: true,
    sample: '(s/valid? ::numbers [1 2 3])',
    hints: ['s/coll-of for homogeneous colls', 'All elements match'],
    tags: ['s/coll-of', 'collection', 'elements'],
  },
  {
    id: 'clj-spec-111',
    category: 'Specs',
    difficulty: 'hard',
    title: 'Coll-of with Options',
    text: 'Use coll-of with :kind and :count.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::vec3 (s/coll-of int? :kind vector? :count 3))',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::vec3 (s/coll-of int? :kind vector? :count 3))',
    expected: true,
    sample: '(s/valid? ::vec3 [1 2 3])',
    hints: [':kind specifies collection type', ':count for size'],
    tags: ['s/coll-of', 'kind', 'count'],
  },
  {
    id: 'clj-spec-112',
    category: 'Specs',
    difficulty: 'medium',
    title: 'Map-of Spec',
    text: 'Use s/map-of for maps with specific key/val types.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::scores (s/map-of keyword? int?))',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::scores (s/map-of keyword? int?))',
    expected: true,
    sample: '(s/valid? ::scores {:a 1 :b 2})',
    hints: ['s/map-of for uniform maps', 'Key and value specs'],
    tags: ['s/map-of', 'map', 'types'],
  },
  {
    id: 'clj-spec-113',
    category: 'Specs',
    difficulty: 'hard',
    title: 'Tuple Spec',
    text: 'Use s/tuple for fixed-position specs.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::point (s/tuple int? int?))',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::point (s/tuple int? int?))',
    expected: true,
    sample: '(s/valid? ::point [1 2])',
    hints: ['s/tuple for positional', 'Each position specced'],
    tags: ['s/tuple', 'positional', 'fixed'],
  },
  {
    id: 'clj-spec-114',
    category: 'Specs',
    difficulty: 'hard',
    title: 'Cat for Sequences',
    text: 'Use s/cat for regex-like sequence specs.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::cmd (s/cat :op keyword? :val int?))',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::cmd (s/cat :op keyword? :val int?))',
    expected: { op: 'add', val: 5 },
    sample: '(s/conform ::cmd [:add 5])',
    hints: ['s/cat names positions', 'Conform returns map'],
    tags: ['s/cat', 'sequence', 'regex'],
  },
  {
    id: 'clj-spec-115',
    category: 'Specs',
    difficulty: 'hard',
    title: 'Alt for Alternatives',
    text: 'Use s/alt in sequence specs.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::op (s/alt :add (s/cat :a #{:+} :n int?) :sub (s/cat :a #{:-} :n int?)))',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::op (s/alt :add (s/cat :a #{:+} :n int?) :sub (s/cat :a #{:-} :n int?)))',
    expected: ['add', { a: '+', n: 5 }],
    sample: '(s/conform ::op [:+ 5])',
    hints: ['s/alt for alternatives', 'Tagged in conform'],
    tags: ['s/alt', 'alternative', 'sequence'],
  },
  {
    id: 'clj-spec-116',
    category: 'Specs',
    difficulty: 'hard',
    title: 'Star for Zero or More',
    text: 'Use s/* for zero or more matches.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::ints (s/* int?))',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::ints (s/* int?))',
    expected: [1, 2, 3],
    sample: '(s/conform ::ints [1 2 3])',
    hints: ['s/* for repetition', 'Zero or more'],
    tags: ['s/*', 'repetition', 'zero-more'],
  },
  {
    id: 'clj-spec-117',
    category: 'Specs',
    difficulty: 'hard',
    title: 'Plus for One or More',
    text: 'Use s/+ for one or more matches.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::some-ints (s/+ int?))',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::some-ints (s/+ int?))',
    expected: false,
    sample: '(s/valid? ::some-ints [])',
    hints: ['s/+ requires at least one', 'Empty fails'],
    tags: ['s/+', 'one-more', 'required'],
  },
  {
    id: 'clj-spec-118',
    category: 'Specs',
    difficulty: 'hard',
    title: 'Question Mark for Optional',
    text: 'Use s/? for optional match.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::maybe-int (s/? int?))',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::maybe-int (s/? int?))',
    expected: true,
    sample: '(s/valid? ::maybe-int [])',
    hints: ['s/? for optional', 'Zero or one'],
    tags: ['s/?', 'optional', 'maybe'],
  },
  {
    id: 'clj-spec-119',
    category: 'Specs',
    difficulty: 'hard',
    title: 'Fdef for Functions',
    text: 'Use s/fdef to spec function.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(defn add [a b] (+ a b))\n(s/fdef add :args (s/cat :a int? :b int?) :ret int?)',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(defn add [a b] (+ a b))\n(s/fdef add :args (s/cat :a int? :b int?) :ret int?)',
    expected: true,
    sample: '(s/valid? (s/get-spec `add) nil)',
    hints: ['s/fdef specs functions', ':args :ret :fn'],
    tags: ['s/fdef', 'function', 'signature'],
  },
  {
    id: 'clj-spec-120',
    category: 'Specs',
    difficulty: 'hard',
    title: 'Instrument Function',
    text: 'Use stest/instrument to check args at runtime.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(require \'[clojure.spec.test.alpha :as stest])',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(require \'[clojure.spec.test.alpha :as stest])',
    expected: true,
    sample: '(fn? stest/instrument)',
    hints: ['instrument adds checks', 'Development time validation'],
    tags: ['instrument', 'runtime', 'check'],
  },
  {
    id: 'clj-spec-121',
    category: 'Specs',
    difficulty: 'medium',
    title: 'Generate from Spec',
    text: 'Use gen/generate to create sample data.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(require \'[clojure.spec.gen.alpha :as gen])\n(s/def ::name string?)',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(require \'[clojure.spec.gen.alpha :as gen])\n(s/def ::name string?)',
    expected: true,
    sample: '(string? (gen/generate (s/gen ::name)))',
    hints: ['s/gen gets generator', 'gen/generate produces value'],
    tags: ['gen', 'generate', 'sample'],
  },
  {
    id: 'clj-spec-122',
    category: 'Specs',
    difficulty: 'medium',
    title: 'Sample from Spec',
    text: 'Use gen/sample for multiple examples.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(require \'[clojure.spec.gen.alpha :as gen])\n(s/def ::num int?)',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(require \'[clojure.spec.gen.alpha :as gen])\n(s/def ::num int?)',
    expected: 10,
    sample: '(count (gen/sample (s/gen ::num)))',
    hints: ['gen/sample generates 10', 'List of examples'],
    tags: ['gen/sample', 'examples', 'multiple'],
  },
  {
    id: 'clj-spec-123',
    category: 'Specs',
    difficulty: 'hard',
    title: 'Custom Generator',
    text: 'Use s/with-gen for custom generator.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(require \'[clojure.spec.gen.alpha :as gen])\n(s/def ::pos-even (s/with-gen (s/and int? even? pos?) #(gen/fmap (fn [n] (* 2 (inc (Math/abs n)))) (gen/int))))',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(require \'[clojure.spec.gen.alpha :as gen])\n(s/def ::pos-even (s/with-gen (s/and int? even? pos?) #(gen/fmap (fn [n] (* 2 (inc (Math/abs n)))) (gen/int))))',
    expected: true,
    sample: '(every? (every-pred int? even? pos?) (gen/sample (s/gen ::pos-even)))',
    hints: ['s/with-gen overrides generator', 'Custom generation logic'],
    tags: ['s/with-gen', 'custom', 'generator'],
  },
  {
    id: 'clj-spec-124',
    category: 'Specs',
    difficulty: 'hard',
    title: 'Multi-spec',
    text: 'Use s/multi-spec for polymorphic data.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(defmulti shape-type :type)\n(defmethod shape-type :circle [_] (s/keys :req-un [::type ::radius]))\n(defmethod shape-type :square [_] (s/keys :req-un [::type ::side]))\n(s/def ::shape (s/multi-spec shape-type :type))',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(defmulti shape-type :type)\n(defmethod shape-type :circle [_] (s/keys :req-un [::type ::radius]))\n(defmethod shape-type :square [_] (s/keys :req-un [::type ::side]))\n(s/def ::shape (s/multi-spec shape-type :type))',
    expected: true,
    sample: '(s/valid? ::shape {:type :circle :radius 5})',
    hints: ['s/multi-spec for dispatch', 'Different specs per type'],
    tags: ['s/multi-spec', 'polymorphic', 'dispatch'],
  },
  {
    id: 'clj-spec-125',
    category: 'Specs',
    difficulty: 'medium',
    title: 'Nilable Spec',
    text: 'Use s/nilable for optional nil.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::maybe-name (s/nilable string?))',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::maybe-name (s/nilable string?))',
    expected: true,
    sample: '(s/valid? ::maybe-name nil)',
    hints: ['s/nilable allows nil', 'Or matching value'],
    tags: ['s/nilable', 'nil', 'optional'],
  },
  {
    id: 'clj-spec-126',
    category: 'Specs',
    difficulty: 'hard',
    title: 'Merge Specs',
    text: 'Use s/merge to combine map specs.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::base (s/keys :req-un [::id]))\n(s/def ::named (s/keys :req-un [::name]))\n(s/def ::entity (s/merge ::base ::named))',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::base (s/keys :req-un [::id]))\n(s/def ::named (s/keys :req-un [::name]))\n(s/def ::entity (s/merge ::base ::named))',
    expected: true,
    sample: '(s/valid? ::entity {:id 1 :name "test"})',
    hints: ['s/merge combines map specs', 'All keys required'],
    tags: ['s/merge', 'combine', 'maps'],
  },
  {
    id: 'clj-spec-127',
    category: 'Specs',
    difficulty: 'medium',
    title: 'Int-in Range',
    text: 'Use s/int-in for integer range.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::percentage (s/int-in 0 101))',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::percentage (s/int-in 0 101))',
    expected: true,
    sample: '(s/valid? ::percentage 50)',
    hints: ['s/int-in for range', 'End exclusive'],
    tags: ['s/int-in', 'range', 'integer'],
  },
  {
    id: 'clj-spec-128',
    category: 'Specs',
    difficulty: 'medium',
    title: 'Double-in Range',
    text: 'Use s/double-in for double range.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::probability (s/double-in :min 0.0 :max 1.0))',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::probability (s/double-in :min 0.0 :max 1.0))',
    expected: true,
    sample: '(s/valid? ::probability 0.5)',
    hints: ['s/double-in for doubles', ':min :max bounds'],
    tags: ['s/double-in', 'range', 'double'],
  },
  {
    id: 'clj-spec-129',
    category: 'Specs',
    difficulty: 'hard',
    title: 'Inst-in Time Range',
    text: 'Use s/inst-in for time range.',
    setup: '(require \'[clojure.spec.alpha :as s])',
    setupCode: '(require \'[clojure.spec.alpha :as s])',
    expected: true,
    sample: '(fn? s/inst-in)',
    hints: ['s/inst-in for dates', 'Start and end instants'],
    tags: ['s/inst-in', 'time', 'range'],
  },
  {
    id: 'clj-spec-130',
    category: 'Specs',
    difficulty: 'hard',
    title: 'Describe Spec',
    text: 'Use s/describe to get spec description.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::pos (s/and int? pos?))',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::pos (s/and int? pos?))',
    expected: true,
    sample: '(some? (s/describe ::pos))',
    hints: ['s/describe returns form', 'Human readable'],
    tags: ['s/describe', 'inspect', 'metadata'],
  },
  {
    id: 'clj-spec-131',
    category: 'Specs',
    difficulty: 'hard',
    title: 'Form of Spec',
    text: 'Use s/form to get spec definition.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::num int?)',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::num int?)',
    expected: true,
    sample: '(some? (s/form ::num))',
    hints: ['s/form returns definition', 'As data'],
    tags: ['s/form', 'definition', 'inspect'],
  },
  {
    id: 'clj-spec-132',
    category: 'Specs',
    difficulty: 'hard',
    title: 'Registry Lookup',
    text: 'Look up spec in registry.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::test int?)',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::test int?)',
    expected: true,
    sample: '(some? (s/get-spec ::test))',
    hints: ['s/get-spec retrieves', 'From registry'],
    tags: ['s/get-spec', 'registry', 'lookup'],
  },
  {
    id: 'clj-spec-133',
    category: 'Specs',
    difficulty: 'hard',
    title: 'Unform Value',
    text: 'Use s/unform to reverse conform.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::id (s/or :num int? :str string?))',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::id (s/or :num int? :str string?))',
    expected: 42,
    sample: '(s/unform ::id [:num 42])',
    hints: ['s/unform reverses conform', 'From tagged to value'],
    tags: ['s/unform', 'reverse', 'conform'],
  },
  {
    id: 'clj-spec-134',
    category: 'Specs',
    difficulty: 'hard',
    title: 'Every Spec',
    text: 'Use s/every for flexible collection specs.',
    setup: '(require \'[clojure.spec.alpha :as s])\n(s/def ::nums (s/every int? :min-count 1))',
    setupCode: '(require \'[clojure.spec.alpha :as s])\n(s/def ::nums (s/every int? :min-count 1))',
    expected: true,
    sample: '(s/valid? ::nums [1 2 3])',
    hints: ['s/every for collections', 'More options than coll-of'],
    tags: ['s/every', 'collection', 'flexible'],
  },
];

export default clojureProblems;
