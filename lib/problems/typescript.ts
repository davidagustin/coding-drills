import type { Problem } from '../types';

/**
 * TypeScript-specific coding drill problems
 * Focuses on type-safe patterns while including standard JS methods with proper typing
 */

export const typescriptProblems: Problem[] = [
  // ============================================================
  // Type-Safe Array Methods - Filter with Type Guards
  // ============================================================
  {
    id: 'ts-filter-type-guard-nullish',
    category: 'Type-Safe Array Methods',
    difficulty: 'easy',
    title: 'Filter Nullish Values with Type Guard',
    text: 'Filter out null and undefined values from the array using a type guard predicate',
    setup: 'const items: (string | null | undefined)[] = ["a", null, "b", undefined, "c"];',
    setupCode: 'const items: (string | null | undefined)[] = ["a", null, "b", undefined, "c"];',
    expected: ['a', 'b', 'c'],
    sample: 'items.filter((x): x is string => x != null)',
    hints: [
      'Use a type guard predicate: (x): x is Type => ...',
      'x != null checks for both null and undefined',
    ],
    validPatterns: [
      /\.filter\s*\(\s*\([^)]*\)\s*:\s*\w+\s+is\s+string/,
      /!==?\s*null|!==\s*null\s*&&[^)]*!==\s*undefined/,
    ],
    tags: ['filter', 'type-guard', 'nullish'],
  },
  {
    id: 'ts-filter-type-guard-numbers',
    category: 'Type-Safe Array Methods',
    difficulty: 'easy',
    title: 'Filter Numbers from Mixed Array',
    text: 'Filter only number values from the mixed array using a type guard',
    setup: 'const mixed: (string | number)[] = [1, "two", 3, "four", 5];',
    setupCode: 'const mixed: (string | number)[] = [1, "two", 3, "four", 5];',
    expected: [1, 3, 5],
    sample: 'mixed.filter((x): x is number => typeof x === "number")',
    hints: [
      'Use typeof to check for number type',
      'The type guard predicate narrows the result type',
    ],
    validPatterns: [
      /\.filter\s*\(\s*\([^)]*\)\s*:\s*\w+\s+is\s+number/,
      /typeof\s+\w+\s*===?\s*["']number["']/,
    ],
    tags: ['filter', 'type-guard', 'typeof'],
  },
  {
    id: 'ts-filter-type-guard-objects',
    category: 'Type-Safe Array Methods',
    difficulty: 'medium',
    title: 'Filter Objects with Specific Property',
    text: 'Filter items that have an "active" property set to true using a type guard',
    setup:
      'interface Item { name: string; active?: boolean; }\nconst items: Item[] = [{name: "a", active: true}, {name: "b"}, {name: "c", active: true}, {name: "d", active: false}];',
    setupCode:
      'interface Item { name: string; active?: boolean; }\nconst items: Item[] = [{name: "a", active: true}, {name: "b"}, {name: "c", active: true}, {name: "d", active: false}];',
    expected: [
      { name: 'a', active: true },
      { name: 'c', active: true },
    ],
    sample: 'items.filter((item): item is Item & { active: true } => item.active === true)',
    hints: [
      'Use intersection type to narrow the active property',
      'Check for active === true explicitly',
    ],
    validPatterns: [/\.filter\s*\(/, /active\s*===?\s*true/],
    tags: ['filter', 'type-guard', 'objects'],
  },
  {
    id: 'ts-filter-discriminated-union',
    category: 'Type-Safe Array Methods',
    difficulty: 'medium',
    title: 'Filter Discriminated Union by Type',
    text: 'Filter only "success" results from the array of discriminated union types',
    setup:
      'type Result = { type: "success"; data: string } | { type: "error"; message: string };\nconst results: Result[] = [{type: "success", data: "ok"}, {type: "error", message: "fail"}, {type: "success", data: "done"}];',
    setupCode:
      'type Result = { type: "success"; data: string } | { type: "error"; message: string };\nconst results: Result[] = [{type: "success", data: "ok"}, {type: "error", message: "fail"}, {type: "success", data: "done"}];',
    expected: [
      { type: 'success', data: 'ok' },
      { type: 'success', data: 'done' },
    ],
    sample:
      'results.filter((r): r is Extract<Result, { type: "success" }> => r.type === "success")',
    hints: [
      'Use Extract utility type to narrow discriminated unions',
      'Check the discriminant property (type)',
    ],
    validPatterns: [/\.filter\s*\(/, /type\s*===?\s*["']success["']/],
    tags: ['filter', 'type-guard', 'discriminated-union'],
  },

  // ============================================================
  // Type-Safe Array Methods - Map with Type Inference
  // ============================================================
  {
    id: 'ts-map-type-inference-basic',
    category: 'Type-Safe Array Methods',
    difficulty: 'easy',
    title: 'Map with Explicit Return Type',
    text: 'Map user objects to their names, ensuring the result is string[]',
    setup:
      'interface User { id: number; name: string; }\nconst users: User[] = [{id: 1, name: "Alice"}, {id: 2, name: "Bob"}];',
    setupCode:
      'interface User { id: number; name: string; }\nconst users: User[] = [{id: 1, name: "Alice"}, {id: 2, name: "Bob"}];',
    expected: ['Alice', 'Bob'],
    sample: 'users.map((user): string => user.name)',
    hints: [
      'Annotate the return type for clarity',
      'TypeScript will infer string[] for the result',
    ],
    validPatterns: [/\.map\s*\(\s*\([^)]*\)\s*(:\s*string)?\s*=>/, /\.name/],
    tags: ['map', 'type-inference'],
  },
  {
    id: 'ts-map-object-transformation',
    category: 'Type-Safe Array Methods',
    difficulty: 'medium',
    title: 'Map to New Object Shape',
    text: 'Transform users to a new shape with only id and fullName properties',
    setup:
      'interface User { id: number; firstName: string; lastName: string; email: string; }\nconst users: User[] = [{id: 1, firstName: "John", lastName: "Doe", email: "john@test.com"}];',
    setupCode:
      'interface User { id: number; firstName: string; lastName: string; email: string; }\nconst users: User[] = [{id: 1, firstName: "John", lastName: "Doe", email: "john@test.com"}];',
    expected: [{ id: 1, fullName: 'John Doe' }],
    sample:
      'users.map((u): { id: number; fullName: string } => ({ id: u.id, fullName: `${u.firstName} ${u.lastName}` }))',
    hints: [
      'Use object literal with explicit type annotation',
      'Template literals for string concatenation',
    ],
    validPatterns: [/\.map\s*\(/, /fullName/, /firstName.*lastName|lastName.*firstName/],
    tags: ['map', 'object-transformation'],
  },
  {
    id: 'ts-map-with-index',
    category: 'Type-Safe Array Methods',
    difficulty: 'easy',
    title: 'Map with Index Parameter',
    text: 'Map items to objects containing the value and its index',
    setup: 'const items: string[] = ["a", "b", "c"];',
    setupCode: 'const items: string[] = ["a", "b", "c"];',
    expected: [
      { value: 'a', index: 0 },
      { value: 'b', index: 1 },
      { value: 'c', index: 2 },
    ],
    sample: 'items.map((value, index) => ({ value, index }))',
    hints: ['map callback receives (value, index, array)', 'Use shorthand property syntax'],
    validPatterns: [/\.map\s*\(\s*\([^,]+,\s*\w+/, /index/i],
    tags: ['map', 'index'],
  },

  // ============================================================
  // Type-Safe Array Methods - Reduce with Explicit Types
  // ============================================================
  {
    id: 'ts-reduce-sum',
    category: 'Type-Safe Array Methods',
    difficulty: 'easy',
    title: 'Reduce to Sum with Explicit Type',
    text: 'Sum all numbers in the array using reduce with explicit type annotation',
    setup: 'const numbers: number[] = [1, 2, 3, 4, 5];',
    setupCode: 'const numbers: number[] = [1, 2, 3, 4, 5];',
    expected: 15,
    sample: 'numbers.reduce((acc: number, curr: number): number => acc + curr, 0)',
    hints: [
      'Provide type annotations for accumulator and current value',
      'Initial value should be 0 for sum',
    ],
    validPatterns: [/\.reduce\s*\(/, /\+/, /,\s*0\s*\)/],
    tags: ['reduce', 'sum'],
  },
  {
    id: 'ts-reduce-to-object',
    category: 'Type-Safe Array Methods',
    difficulty: 'medium',
    title: 'Reduce Array to Object Map',
    text: 'Convert array of users to an object keyed by id',
    setup:
      'interface User { id: number; name: string; }\nconst users: User[] = [{id: 1, name: "Alice"}, {id: 2, name: "Bob"}];',
    setupCode:
      'interface User { id: number; name: string; }\nconst users: User[] = [{id: 1, name: "Alice"}, {id: 2, name: "Bob"}];',
    expected: { 1: { id: 1, name: 'Alice' }, 2: { id: 2, name: 'Bob' } },
    sample: 'users.reduce<Record<number, User>>((acc, user) => ({ ...acc, [user.id]: user }), {})',
    hints: [
      'Use generic parameter reduce<T> to specify accumulator type',
      'Record<K, V> is useful for object maps',
    ],
    validPatterns: [/\.reduce\s*(<[^>]+>)?\s*\(/, /\[.*\.id\]/],
    tags: ['reduce', 'object', 'record'],
  },
  {
    id: 'ts-reduce-group-by',
    category: 'Type-Safe Array Methods',
    difficulty: 'hard',
    title: 'Reduce to Group By Category',
    text: 'Group items by their category property',
    setup:
      'interface Item { name: string; category: string; }\nconst items: Item[] = [{name: "a", category: "x"}, {name: "b", category: "y"}, {name: "c", category: "x"}];',
    setupCode:
      'interface Item { name: string; category: string; }\nconst items: Item[] = [{name: "a", category: "x"}, {name: "b", category: "y"}, {name: "c", category: "x"}];',
    expected: {
      x: [
        { name: 'a', category: 'x' },
        { name: 'c', category: 'x' },
      ],
      y: [{ name: 'b', category: 'y' }],
    },
    sample:
      'items.reduce<Record<string, Item[]>>((acc, item) => ({ ...acc, [item.category]: [...(acc[item.category] || []), item] }), {})',
    hints: [
      'Use Record<string, Item[]> for grouped structure',
      'Handle case where category key does not exist yet',
    ],
    validPatterns: [/\.reduce/, /category/, /\[\s*item\.category\s*\]/],
    tags: ['reduce', 'group-by'],
  },

  // ============================================================
  // Type-Safe Array Methods - Find with Type Narrowing
  // ============================================================
  {
    id: 'ts-find-with-predicate',
    category: 'Type-Safe Array Methods',
    difficulty: 'easy',
    title: 'Find Element with Predicate',
    text: 'Find the first user with age greater than 25',
    setup:
      'interface User { name: string; age: number; }\nconst users: User[] = [{name: "Alice", age: 20}, {name: "Bob", age: 30}, {name: "Carol", age: 25}];',
    setupCode:
      'interface User { name: string; age: number; }\nconst users: User[] = [{name: "Alice", age: 20}, {name: "Bob", age: 30}, {name: "Carol", age: 25}];',
    expected: { name: 'Bob', age: 30 },
    sample: 'users.find((user) => user.age > 25)',
    hints: ['find returns T | undefined', 'Use a simple predicate function'],
    validPatterns: [/\.find\s*\(/, /age\s*>\s*25/],
    tags: ['find', 'predicate'],
  },
  {
    id: 'ts-find-with-assertion',
    category: 'Type-Safe Array Methods',
    difficulty: 'medium',
    title: 'Find with Non-Null Assertion',
    text: 'Find the admin user (guaranteed to exist) using non-null assertion',
    setup:
      'interface User { name: string; role: "admin" | "user"; }\nconst users: User[] = [{name: "Alice", role: "user"}, {name: "Bob", role: "admin"}];',
    setupCode:
      'interface User { name: string; role: "admin" | "user"; }\nconst users: User[] = [{name: "Alice", role: "user"}, {name: "Bob", role: "admin"}];',
    expected: { name: 'Bob', role: 'admin' },
    sample: 'users.find((u) => u.role === "admin")!',
    hints: [
      'Use ! for non-null assertion when you know the value exists',
      'Be careful: this bypasses type safety',
    ],
    validPatterns: [/\.find\s*\([^)]+\)\s*!/, /role\s*===?\s*["']admin["']/],
    tags: ['find', 'non-null-assertion'],
  },

  // ============================================================
  // Utility Types in Practice
  // ============================================================
  {
    id: 'ts-partial-update',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Partial for Optional Updates',
    text: 'Use Partial<T> to create an update object with only name changed',
    setup:
      'interface User { id: number; name: string; email: string; }\nconst user: User = { id: 1, name: "Alice", email: "alice@test.com" };',
    setupCode:
      'interface User { id: number; name: string; email: string; }\nconst user: User = { id: 1, name: "Alice", email: "alice@test.com" };',
    expected: { id: 1, name: 'Bob', email: 'alice@test.com' },
    sample: '({ ...user, ...({ name: "Bob" } as Partial<User>) })',
    hints: [
      'Partial<T> makes all properties optional',
      'Spread the partial update over the original',
    ],
    validPatterns: [/Partial\s*<\s*User\s*>/, /name.*Bob|Bob.*name/],
    tags: ['partial', 'utility-types'],
  },
  {
    id: 'ts-pick-subset',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Pick Specific Properties',
    text: 'Create an object with only id and name from the user using Pick',
    setup:
      'interface User { id: number; name: string; email: string; age: number; }\nconst user: User = { id: 1, name: "Alice", email: "a@test.com", age: 30 };',
    setupCode:
      'interface User { id: number; name: string; email: string; age: number; }\nconst user: User = { id: 1, name: "Alice", email: "a@test.com", age: 30 };',
    expected: { id: 1, name: 'Alice' },
    sample: '(({ id, name }): Pick<User, "id" | "name"> => ({ id, name }))(user)',
    hints: [
      'Pick<T, K> extracts only specified properties',
      'Destructure to get only needed properties',
    ],
    validPatterns: [/Pick\s*<\s*User/, /["']id["'].*["']name["']|["']name["'].*["']id["']/],
    tags: ['pick', 'utility-types'],
  },
  {
    id: 'ts-omit-exclude-props',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Omit Sensitive Properties',
    text: 'Create a safe user object without password using Omit',
    setup:
      'interface User { id: number; name: string; password: string; }\nconst user: User = { id: 1, name: "Alice", password: "secret123" };',
    setupCode:
      'interface User { id: number; name: string; password: string; }\nconst user: User = { id: 1, name: "Alice", password: "secret123" };',
    expected: { id: 1, name: 'Alice' },
    sample: '(({ password, ...rest }): Omit<User, "password"> => rest)(user)',
    hints: [
      'Omit<T, K> removes specified properties',
      'Destructure with rest to exclude properties',
    ],
    validPatterns: [/Omit\s*<\s*User/, /password/],
    tags: ['omit', 'utility-types'],
  },
  {
    id: 'ts-record-create-map',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Record for Type-Safe Object Map',
    text: 'Create a Record mapping status strings to boolean values',
    setup: 'type Status = "pending" | "active" | "completed";',
    setupCode: 'type Status = "pending" | "active" | "completed";',
    expected: { pending: false, active: true, completed: false },
    sample: '({ pending: false, active: true, completed: false } as Record<Status, boolean>)',
    hints: [
      'Record<K, V> creates an object type with keys K and values V',
      'All keys from the union must be present',
    ],
    validPatterns: [/Record\s*<\s*Status\s*,\s*boolean\s*>/, /pending.*active.*completed/],
    tags: ['record', 'utility-types'],
  },
  {
    id: 'ts-required-make-mandatory',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Required to Remove Optional',
    text: 'Convert partial config to required config, providing all values',
    setup:
      'interface Config { host?: string; port?: number; debug?: boolean; }\nconst partial: Partial<Config> = { host: "localhost" };',
    setupCode:
      'interface Config { host?: string; port?: number; debug?: boolean; }\nconst partial: Partial<Config> = { host: "localhost" };',
    expected: { host: 'localhost', port: 3000, debug: false },
    sample:
      '({ host: partial.host || "localhost", port: partial.port || 3000, debug: partial.debug || false } as Required<Config>)',
    hints: [
      'Required<T> makes all properties mandatory',
      'Provide default values for missing properties',
    ],
    validPatterns: [/Required\s*<\s*Config\s*>/, /host.*port.*debug/],
    tags: ['required', 'utility-types'],
  },
  {
    id: 'ts-readonly-immutable',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Readonly for Immutable Data',
    text: 'Create a readonly version of the config object',
    setup:
      'interface Config { apiKey: string; timeout: number; }\nconst config: Config = { apiKey: "abc123", timeout: 5000 };',
    setupCode:
      'interface Config { apiKey: string; timeout: number; }\nconst config: Config = { apiKey: "abc123", timeout: 5000 };',
    expected: { apiKey: 'abc123', timeout: 5000 },
    sample: '(config as Readonly<Config>)',
    hints: ['Readonly<T> makes all properties readonly', 'Prevents accidental mutations'],
    validPatterns: [/Readonly\s*<\s*Config\s*>/],
    tags: ['readonly', 'utility-types'],
  },
  {
    id: 'ts-extract-union-member',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Extract Union Members',
    text: 'Extract only string types from the union',
    setup: 'type Mixed = string | number | boolean | null;\nconst value: Mixed = "hello";',
    setupCode: 'type Mixed = string | number | boolean | null;\nconst value: Mixed = "hello";',
    expected: 'hello',
    sample: '(value as Extract<Mixed, string>)',
    hints: [
      'Extract<T, U> extracts types from T that are assignable to U',
      'Useful for narrowing union types',
    ],
    validPatterns: [/Extract\s*<\s*Mixed\s*,\s*string\s*>/],
    tags: ['extract', 'utility-types'],
  },
  {
    id: 'ts-exclude-union-member',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Exclude Union Members',
    text: 'Create a type excluding null from the union and cast the value',
    setup: 'type MaybeString = string | null;\nconst value: MaybeString = "hello";',
    setupCode: 'type MaybeString = string | null;\nconst value: MaybeString = "hello";',
    expected: 'hello',
    sample: '(value as Exclude<MaybeString, null>)',
    hints: [
      'Exclude<T, U> removes types from T that are assignable to U',
      'Commonly used to remove null or undefined',
    ],
    validPatterns: [/Exclude\s*<\s*MaybeString\s*,\s*null\s*>/],
    tags: ['exclude', 'utility-types'],
  },
  {
    id: 'ts-nonnullable-type',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'NonNullable for Non-Null Values',
    text: 'Assert that the value is non-nullable',
    setup: 'type Maybe<T> = T | null | undefined;\nconst value: Maybe<string> = "hello";',
    setupCode: 'type Maybe<T> = T | null | undefined;\nconst value: Maybe<string> = "hello";',
    expected: 'hello',
    sample: '(value as NonNullable<Maybe<string>>)',
    hints: [
      'NonNullable<T> removes null and undefined from T',
      'Equivalent to Exclude<T, null | undefined>',
    ],
    validPatterns: [/NonNullable\s*</],
    tags: ['nonnullable', 'utility-types'],
  },

  // ============================================================
  // Object Operations
  // ============================================================
  {
    id: 'ts-object-keys-assertion',
    category: 'Object Operations',
    difficulty: 'medium',
    title: 'Object.keys with Type Assertion',
    text: 'Get typed keys of the object using Object.keys with assertion',
    setup:
      'interface User { name: string; age: number; }\nconst user: User = { name: "Alice", age: 30 };',
    setupCode:
      'interface User { name: string; age: number; }\nconst user: User = { name: "Alice", age: 30 };',
    expected: ['name', 'age'],
    sample: '(Object.keys(user) as (keyof User)[])',
    hints: ['Object.keys returns string[], not keyof T[]', 'Cast to (keyof T)[] for type safety'],
    validPatterns: [/Object\.keys\s*\(/, /as\s*\(\s*keyof\s+User\s*\)\s*\[\s*\]/],
    tags: ['object-keys', 'type-assertion'],
  },
  {
    id: 'ts-object-entries-typed',
    category: 'Object Operations',
    difficulty: 'medium',
    title: 'Object.entries with Types',
    text: 'Get typed entries of the scores object',
    setup: 'const scores: Record<string, number> = { alice: 100, bob: 85 };',
    setupCode: 'const scores: Record<string, number> = { alice: 100, bob: 85 };',
    expected: [
      ['alice', 100],
      ['bob', 85],
    ],
    sample: 'Object.entries(scores) as [string, number][]',
    hints: [
      'Object.entries returns [string, unknown][]',
      'Cast to specific tuple type for better typing',
    ],
    validPatterns: [/Object\.entries\s*\(/, /as\s*\[\s*string\s*,\s*number\s*\]\s*\[\s*\]/],
    tags: ['object-entries', 'type-assertion'],
  },
  {
    id: 'ts-object-values',
    category: 'Object Operations',
    difficulty: 'easy',
    title: 'Object.values with Type',
    text: 'Get all values from the config object',
    setup: 'const config: Record<string, string> = { host: "localhost", env: "dev" };',
    setupCode: 'const config: Record<string, string> = { host: "localhost", env: "dev" };',
    expected: ['localhost', 'dev'],
    sample: 'Object.values(config)',
    hints: ['Object.values extracts all values', 'Return type is inferred from Record value type'],
    validPatterns: [/Object\.values\s*\(\s*config\s*\)/],
    tags: ['object-values'],
  },
  {
    id: 'ts-object-fromentries',
    category: 'Object Operations',
    difficulty: 'medium',
    title: 'Object.fromEntries with Type',
    text: 'Create an object from key-value pairs with proper typing',
    setup: 'const entries: [string, number][] = [["a", 1], ["b", 2]];',
    setupCode: 'const entries: [string, number][] = [["a", 1], ["b", 2]];',
    expected: { a: 1, b: 2 },
    sample: 'Object.fromEntries(entries) as Record<string, number>',
    hints: ['Object.fromEntries converts entries to object', 'Cast to Record for better typing'],
    validPatterns: [/Object\.fromEntries\s*\(/],
    tags: ['object-fromEntries'],
  },
  {
    id: 'ts-object-assign-typed',
    category: 'Object Operations',
    difficulty: 'medium',
    title: 'Object.assign with Type Safety',
    text: 'Merge objects with type safety',
    setup:
      'interface Base { id: number; }\ninterface Extended extends Base { name: string; }\nconst base: Base = { id: 1 };',
    setupCode:
      'interface Base { id: number; }\ninterface Extended extends Base { name: string; }\nconst base: Base = { id: 1 };',
    expected: { id: 1, name: 'Alice' },
    sample: 'Object.assign({}, base, { name: "Alice" }) as Extended',
    hints: ['Object.assign merges objects left to right', 'Cast to the extended type'],
    validPatterns: [/Object\.assign\s*\(/, /name.*Alice/],
    tags: ['object-assign'],
  },

  // ============================================================
  // Standard Array Methods (with Types)
  // ============================================================
  {
    id: 'ts-array-some',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Array some with Predicate',
    text: 'Check if any number is greater than 10',
    setup: 'const numbers: number[] = [1, 5, 8, 12, 3];',
    setupCode: 'const numbers: number[] = [1, 5, 8, 12, 3];',
    expected: true,
    sample: 'numbers.some((n) => n > 10)',
    hints: ['some returns true if any element passes the test', 'Short-circuits on first true'],
    validPatterns: [/\.some\s*\(/, />\s*10/],
    tags: ['some', 'predicate'],
  },
  {
    id: 'ts-array-every',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Array every with Predicate',
    text: 'Check if all numbers are positive',
    setup: 'const numbers: number[] = [1, 5, 8, 12, 3];',
    setupCode: 'const numbers: number[] = [1, 5, 8, 12, 3];',
    expected: true,
    sample: 'numbers.every((n) => n > 0)',
    hints: ['every returns true if all elements pass the test', 'Short-circuits on first false'],
    validPatterns: [/\.every\s*\(/, />\s*0/],
    tags: ['every', 'predicate'],
  },
  {
    id: 'ts-array-includes',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Array includes Check',
    text: 'Check if the array includes the value 5',
    setup: 'const numbers: number[] = [1, 2, 3, 4, 5];',
    setupCode: 'const numbers: number[] = [1, 2, 3, 4, 5];',
    expected: true,
    sample: 'numbers.includes(5)',
    hints: ['includes uses strict equality', 'Returns boolean'],
    validPatterns: [/\.includes\s*\(\s*5\s*\)/],
    tags: ['includes'],
  },
  {
    id: 'ts-array-findindex',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Find Index of Element',
    text: 'Find the index of the first even number',
    setup: 'const numbers: number[] = [1, 3, 4, 7, 8];',
    setupCode: 'const numbers: number[] = [1, 3, 4, 7, 8];',
    expected: 2,
    sample: 'numbers.findIndex((n) => n % 2 === 0)',
    hints: ['findIndex returns -1 if not found', 'Returns index of first matching element'],
    validPatterns: [/\.findIndex\s*\(/, /%\s*2\s*===?\s*0/],
    tags: ['findIndex'],
  },
  {
    id: 'ts-array-flat',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Flatten Nested Array',
    text: 'Flatten the nested array by one level',
    setup: 'const nested: number[][] = [[1, 2], [3, 4], [5]];',
    setupCode: 'const nested: number[][] = [[1, 2], [3, 4], [5]];',
    expected: [1, 2, 3, 4, 5],
    sample: 'nested.flat()',
    hints: ['flat() flattens by depth 1 by default', 'Pass depth for deeper flattening'],
    validPatterns: [/\.flat\s*\(/],
    tags: ['flat'],
  },
  {
    id: 'ts-array-flatmap',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'FlatMap Array',
    text: 'Double each number and flatten the result',
    setup: 'const numbers: number[] = [1, 2, 3];',
    setupCode: 'const numbers: number[] = [1, 2, 3];',
    expected: [1, 1, 2, 2, 3, 3],
    sample: 'numbers.flatMap((n) => [n, n])',
    hints: ['flatMap = map + flat(1)', 'Return an array from the callback'],
    validPatterns: [/\.flatMap\s*\(/, /\[\s*n\s*,\s*n\s*\]/],
    tags: ['flatMap'],
  },
  {
    id: 'ts-array-slice',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Slice Array',
    text: 'Get elements from index 1 to 3 (exclusive)',
    setup: 'const arr: string[] = ["a", "b", "c", "d", "e"];',
    setupCode: 'const arr: string[] = ["a", "b", "c", "d", "e"];',
    expected: ['b', 'c'],
    sample: 'arr.slice(1, 3)',
    hints: ['slice(start, end) - end is exclusive', 'Does not modify original array'],
    validPatterns: [/\.slice\s*\(\s*1\s*,\s*3\s*\)/],
    tags: ['slice'],
  },
  {
    id: 'ts-array-concat',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Concatenate Arrays',
    text: 'Concatenate two number arrays',
    setup: 'const a: number[] = [1, 2];\nconst b: number[] = [3, 4];',
    setupCode: 'const a: number[] = [1, 2];\nconst b: number[] = [3, 4];',
    expected: [1, 2, 3, 4],
    sample: 'a.concat(b)',
    hints: ['concat creates a new array', 'Can also use spread: [...a, ...b]'],
    validPatterns: [/\.concat\s*\(|\.\.\.a.*\.\.\.b/],
    tags: ['concat'],
  },
  {
    id: 'ts-array-join',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Join Array Elements',
    text: 'Join array elements with a comma and space',
    setup: 'const words: string[] = ["Hello", "World"];',
    setupCode: 'const words: string[] = ["Hello", "World"];',
    expected: 'Hello, World',
    sample: 'words.join(", ")',
    hints: ['join converts array to string', 'Separator defaults to comma'],
    validPatterns: [/\.join\s*\(\s*["'],\s*["']\s*\)/],
    tags: ['join'],
  },
  {
    id: 'ts-array-reverse',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Reverse Array (Non-Mutating)',
    text: 'Reverse the array without mutating the original',
    setup: 'const arr: number[] = [1, 2, 3, 4, 5];',
    setupCode: 'const arr: number[] = [1, 2, 3, 4, 5];',
    expected: [5, 4, 3, 2, 1],
    sample: '[...arr].reverse()',
    hints: ['reverse() mutates the original array', 'Spread first to create a copy'],
    validPatterns: [/\[\s*\.\.\.arr\s*\]\.reverse\s*\(\)|arr\.slice\s*\(\s*\)\.reverse\s*\(\)/],
    tags: ['reverse', 'immutable'],
  },
  {
    id: 'ts-array-sort-numbers',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Sort Numbers Correctly',
    text: 'Sort numbers in ascending order',
    setup: 'const numbers: number[] = [10, 2, 30, 4, 5];',
    setupCode: 'const numbers: number[] = [10, 2, 30, 4, 5];',
    expected: [2, 4, 5, 10, 30],
    sample: '[...numbers].sort((a, b) => a - b)',
    hints: ['Default sort converts to strings', 'Use compare function for numbers'],
    validPatterns: [/\.sort\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>\s*\w+\s*-\s*\w+\s*\)/],
    tags: ['sort', 'numbers'],
  },
  {
    id: 'ts-array-fill',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Fill Array with Value',
    text: 'Create an array of 5 zeros',
    setup: 'const size: number = 5;',
    setupCode: 'const size: number = 5;',
    expected: [0, 0, 0, 0, 0],
    sample: 'new Array(size).fill(0)',
    hints: ['Array(n) creates empty array of length n', 'fill fills all elements with value'],
    validPatterns: [/Array\s*\(\s*size\s*\)\.fill\s*\(\s*0\s*\)|Array\.from\s*\(/],
    tags: ['fill', 'array-creation'],
  },
  {
    id: 'ts-array-from-range',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Create Range Array',
    text: 'Create an array [0, 1, 2, 3, 4] using Array.from',
    setup: 'const length: number = 5;',
    setupCode: 'const length: number = 5;',
    expected: [0, 1, 2, 3, 4],
    sample: 'Array.from({ length }, (_, i) => i)',
    hints: ['Array.from accepts array-like object', 'Second argument is map function'],
    validPatterns: [/Array\.from\s*\(\s*\{\s*length/],
    tags: ['Array.from', 'range'],
  },

  // ============================================================
  // String Methods
  // ============================================================
  {
    id: 'ts-string-split',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Split String to Array',
    text: 'Split the string by spaces',
    setup: 'const str: string = "Hello World TypeScript";',
    setupCode: 'const str: string = "Hello World TypeScript";',
    expected: ['Hello', 'World', 'TypeScript'],
    sample: 'str.split(" ")',
    hints: ['split returns string[]', 'Separator can be string or RegExp'],
    validPatterns: [/\.split\s*\(\s*["']\s*["']\s*\)/],
    tags: ['split'],
  },
  {
    id: 'ts-string-trim',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Trim Whitespace',
    text: 'Remove leading and trailing whitespace',
    setup: 'const str: string = "  Hello World  ";',
    setupCode: 'const str: string = "  Hello World  ";',
    expected: 'Hello World',
    sample: 'str.trim()',
    hints: [
      'trim removes both leading and trailing whitespace',
      'trimStart and trimEnd for one side only',
    ],
    validPatterns: [/\.trim\s*\(\s*\)/],
    tags: ['trim'],
  },
  {
    id: 'ts-string-replace',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Replace Substring',
    text: 'Replace "World" with "TypeScript"',
    setup: 'const str: string = "Hello World";',
    setupCode: 'const str: string = "Hello World";',
    expected: 'Hello TypeScript',
    sample: 'str.replace("World", "TypeScript")',
    hints: ['replace only replaces first occurrence', 'Use replaceAll for all occurrences'],
    validPatterns: [/\.replace\s*\(\s*["']World["']\s*,\s*["']TypeScript["']\s*\)/],
    tags: ['replace'],
  },
  {
    id: 'ts-string-startswith',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Check String Start',
    text: 'Check if the string starts with "Hello"',
    setup: 'const str: string = "Hello World";',
    setupCode: 'const str: string = "Hello World";',
    expected: true,
    sample: 'str.startsWith("Hello")',
    hints: ['startsWith is case-sensitive', 'Returns boolean'],
    validPatterns: [/\.startsWith\s*\(\s*["']Hello["']\s*\)/],
    tags: ['startsWith'],
  },
  {
    id: 'ts-string-padstart',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Pad String Start',
    text: 'Pad the number string to 5 characters with zeros',
    setup: 'const num: string = "42";',
    setupCode: 'const num: string = "42";',
    expected: '00042',
    sample: 'num.padStart(5, "0")',
    hints: ['padStart adds padding at the beginning', 'First arg is target length'],
    validPatterns: [/\.padStart\s*\(\s*5\s*,\s*["']0["']\s*\)/],
    tags: ['padStart'],
  },
  {
    id: 'ts-string-repeat',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Repeat String',
    text: 'Repeat the string 3 times',
    setup: 'const str: string = "ab";',
    setupCode: 'const str: string = "ab";',
    expected: 'ababab',
    sample: 'str.repeat(3)',
    hints: ['repeat returns new string', 'Count must be non-negative'],
    validPatterns: [/\.repeat\s*\(\s*3\s*\)/],
    tags: ['repeat'],
  },

  // ============================================================
  // Set Operations
  // ============================================================
  {
    id: 'ts-set-from-array',
    category: 'Set Operations',
    difficulty: 'easy',
    title: 'Create Set from Array',
    text: 'Create a Set from the array to get unique values',
    setup: 'const arr: number[] = [1, 2, 2, 3, 3, 3];',
    setupCode: 'const arr: number[] = [1, 2, 2, 3, 3, 3];',
    expected: [1, 2, 3],
    sample: '[...new Set(arr)]',
    hints: ['Set automatically removes duplicates', 'Spread to convert back to array'],
    validPatterns: [/new\s+Set\s*\(\s*arr\s*\)/, /\[\s*\.\.\./],
    tags: ['Set', 'unique'],
  },
  {
    id: 'ts-set-has',
    category: 'Set Operations',
    difficulty: 'easy',
    title: 'Check Set Membership',
    text: 'Check if the set contains the value 3',
    setup: 'const set: Set<number> = new Set([1, 2, 3, 4, 5]);',
    setupCode: 'const set: Set<number> = new Set([1, 2, 3, 4, 5]);',
    expected: true,
    sample: 'set.has(3)',
    hints: ['has returns boolean', 'O(1) lookup time'],
    validPatterns: [/\.has\s*\(\s*3\s*\)/],
    tags: ['Set', 'has'],
  },
  {
    id: 'ts-set-intersection',
    category: 'Set Operations',
    difficulty: 'medium',
    title: 'Set Intersection',
    text: 'Find common elements between two sets',
    setup:
      'const setA: Set<number> = new Set([1, 2, 3]);\nconst setB: Set<number> = new Set([2, 3, 4]);',
    setupCode:
      'const setA: Set<number> = new Set([1, 2, 3]);\nconst setB: Set<number> = new Set([2, 3, 4]);',
    expected: [2, 3],
    sample: '[...setA].filter((x) => setB.has(x))',
    hints: ['Convert to array and filter', 'Check membership with has()'],
    validPatterns: [/\.filter\s*\(/, /\.has\s*\(/],
    tags: ['Set', 'intersection'],
  },
  {
    id: 'ts-set-difference',
    category: 'Set Operations',
    difficulty: 'medium',
    title: 'Set Difference',
    text: 'Find elements in setA that are not in setB',
    setup:
      'const setA: Set<number> = new Set([1, 2, 3]);\nconst setB: Set<number> = new Set([2, 3, 4]);',
    setupCode:
      'const setA: Set<number> = new Set([1, 2, 3]);\nconst setB: Set<number> = new Set([2, 3, 4]);',
    expected: [1],
    sample: '[...setA].filter((x) => !setB.has(x))',
    hints: ['Filter elements not in the other set', 'Use negation with has()'],
    validPatterns: [/\.filter\s*\(/, /!\s*setB\.has|!setB\.has/],
    tags: ['Set', 'difference'],
  },

  // ============================================================
  // Map Operations
  // ============================================================
  {
    id: 'ts-map-create',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Create Map from Entries',
    text: 'Create a Map from the array of key-value pairs',
    setup: 'const entries: [string, number][] = [["a", 1], ["b", 2]];',
    setupCode: 'const entries: [string, number][] = [["a", 1], ["b", 2]];',
    expected: { a: 1, b: 2 },
    sample: 'Object.fromEntries(new Map(entries))',
    hints: ['Map constructor accepts array of entries', 'Convert to object for comparison'],
    validPatterns: [/new\s+Map\s*\(\s*entries\s*\)/],
    tags: ['Map', 'create'],
  },
  {
    id: 'ts-map-get-set',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Map Get and Set',
    text: 'Get the value for key "name" from the map',
    setup: 'const map: Map<string, string> = new Map([["name", "Alice"], ["role", "admin"]]);',
    setupCode: 'const map: Map<string, string> = new Map([["name", "Alice"], ["role", "admin"]]);',
    expected: 'Alice',
    sample: 'map.get("name")',
    hints: ['get returns T | undefined', 'Use has() to check existence first'],
    validPatterns: [/\.get\s*\(\s*["']name["']\s*\)/],
    tags: ['Map', 'get'],
  },
  {
    id: 'ts-map-to-object',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Convert Map to Object',
    text: 'Convert the Map to a plain object',
    setup: 'const map: Map<string, number> = new Map([["x", 1], ["y", 2]]);',
    setupCode: 'const map: Map<string, number> = new Map([["x", 1], ["y", 2]]);',
    expected: { x: 1, y: 2 },
    sample: 'Object.fromEntries(map)',
    hints: ['Object.fromEntries works with Map directly', 'Map is iterable as entries'],
    validPatterns: [/Object\.fromEntries\s*\(\s*map\s*\)/],
    tags: ['Map', 'conversion'],
  },
  {
    id: 'ts-map-keys-values',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Get Map Keys as Array',
    text: 'Get all keys from the map as an array',
    setup: 'const map: Map<string, number> = new Map([["a", 1], ["b", 2], ["c", 3]]);',
    setupCode: 'const map: Map<string, number> = new Map([["a", 1], ["b", 2], ["c", 3]]);',
    expected: ['a', 'b', 'c'],
    sample: '[...map.keys()]',
    hints: ['keys() returns an iterator', 'Spread to convert to array'],
    validPatterns: [/\.keys\s*\(\s*\)/, /\[\s*\.\.\./],
    tags: ['Map', 'keys'],
  },

  // ============================================================
  // Generic Patterns
  // ============================================================
  {
    id: 'ts-generic-identity',
    category: 'Generic Patterns',
    difficulty: 'easy',
    title: 'Generic Identity Function',
    text: 'Call the identity function with explicit type parameter',
    setup: 'function identity<T>(value: T): T { return value; }',
    setupCode: 'function identity<T>(value: T): T { return value; }',
    expected: 'hello',
    sample: 'identity<string>("hello")',
    hints: [
      'Specify type parameter with <Type>',
      'Type inference can also work without explicit type',
    ],
    validPatterns: [/identity\s*<\s*string\s*>\s*\(\s*["']hello["']\s*\)/],
    tags: ['generics', 'identity'],
  },
  {
    id: 'ts-generic-array-first',
    category: 'Generic Patterns',
    difficulty: 'medium',
    title: 'Generic First Element',
    text: 'Get the first element using the generic function',
    setup:
      'function first<T>(arr: T[]): T | undefined { return arr[0]; }\nconst nums: number[] = [10, 20, 30];',
    setupCode:
      'function first<T>(arr: T[]): T | undefined { return arr[0]; }\nconst nums: number[] = [10, 20, 30];',
    expected: 10,
    sample: 'first(nums)',
    hints: ['Type is inferred from argument', 'Return type is T | undefined'],
    validPatterns: [/first\s*\(\s*nums\s*\)/],
    tags: ['generics', 'array'],
  },
  {
    id: 'ts-generic-keyof-constraint',
    category: 'Generic Patterns',
    difficulty: 'hard',
    title: 'Generic with keyof Constraint',
    text: 'Get the "name" property from the object using the generic getter',
    setup:
      'function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] { return obj[key]; }\nconst user = { name: "Alice", age: 30 };',
    setupCode:
      'function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] { return obj[key]; }\nconst user = { name: "Alice", age: 30 };',
    expected: 'Alice',
    sample: 'getProperty(user, "name")',
    hints: ['K is constrained to keys of T', 'Return type T[K] is the value type'],
    validPatterns: [/getProperty\s*\(\s*user\s*,\s*["']name["']\s*\)/],
    tags: ['generics', 'keyof'],
  },

  // ============================================================
  // Type Assertions and Casts
  // ============================================================
  {
    id: 'ts-as-assertion',
    category: 'Type Assertions',
    difficulty: 'easy',
    title: 'Type Assertion with as',
    text: 'Assert the unknown value as a string',
    setup: 'const value: unknown = "hello";',
    setupCode: 'const value: unknown = "hello";',
    expected: 'hello',
    sample: 'value as string',
    hints: ['as syntax for type assertion', 'Use when you know more than the compiler'],
    validPatterns: [/value\s+as\s+string/],
    tags: ['type-assertion', 'as'],
  },
  {
    id: 'ts-satisfies-operator',
    category: 'Type Assertions',
    difficulty: 'medium',
    title: 'Satisfies Operator',
    text: 'Use satisfies to validate the object matches the type while preserving literal types',
    setup: 'type Colors = Record<string, [number, number, number]>;',
    setupCode: 'type Colors = Record<string, [number, number, number]>;',
    expected: { red: [255, 0, 0] },
    sample: '({ red: [255, 0, 0] } satisfies Colors)',
    hints: ['satisfies validates without widening types', 'Preserves literal type information'],
    validPatterns: [/satisfies\s+Colors/],
    tags: ['satisfies', 'type-checking'],
  },
  {
    id: 'ts-const-assertion',
    category: 'Type Assertions',
    difficulty: 'medium',
    title: 'Const Assertion',
    text: 'Create a readonly tuple using const assertion',
    setup: 'const tuple = ["hello", 42] as const;',
    setupCode: 'const tuple = ["hello", 42] as const;',
    expected: ['hello', 42],
    sample: '[...tuple]',
    hints: ['as const makes values deeply readonly', 'Arrays become readonly tuples'],
    validPatterns: [/\[\s*\.\.\.tuple\s*\]/],
    tags: ['const-assertion', 'readonly'],
  },

  // ============================================================
  // Type Guards - typeof, instanceof, in, custom
  // ============================================================
  {
    id: 'ts-typeof-guard-string',
    category: 'Type Guards',
    difficulty: 'easy',
    title: 'typeof Guard for Strings',
    text: 'Use typeof to check if the value is a string and return its uppercase, otherwise return "not a string"',
    setup: 'const value: string | number = "hello";',
    setupCode: 'const value: string | number = "hello";',
    expected: 'HELLO',
    sample: 'typeof value === "string" ? value.toUpperCase() : "not a string"',
    hints: [
      'typeof returns "string", "number", "boolean", etc.',
      'TypeScript narrows the type after the check',
    ],
    validPatterns: [/typeof\s+value\s*===?\s*["']string["']/, /\.toUpperCase\s*\(\s*\)/],
    tags: ['type-guard', 'typeof'],
  },
  {
    id: 'ts-typeof-guard-function',
    category: 'Type Guards',
    difficulty: 'easy',
    title: 'typeof Guard for Functions',
    text: 'Check if the value is a function using typeof and call it if so, otherwise return the value directly',
    setup: 'const value: string | (() => string) = () => "called";',
    setupCode: 'const value: string | (() => string) = () => "called";',
    expected: 'called',
    sample: 'typeof value === "function" ? value() : value',
    hints: [
      'typeof function returns "function"',
      'After the check, TypeScript knows value is callable',
    ],
    validPatterns: [/typeof\s+value\s*===?\s*["']function["']/, /value\s*\(\s*\)/],
    tags: ['type-guard', 'typeof', 'function'],
  },
  {
    id: 'ts-instanceof-guard-date',
    category: 'Type Guards',
    difficulty: 'easy',
    title: 'instanceof Guard for Date',
    text: 'Check if the value is a Date instance and return its year, otherwise return -1',
    setup: 'const value: Date | string = new Date("2024-01-15");',
    setupCode: 'const value: Date | string = new Date("2024-01-15");',
    expected: 2024,
    sample: 'value instanceof Date ? value.getFullYear() : -1',
    hints: [
      'instanceof checks the prototype chain',
      'Works with classes and built-in constructors',
    ],
    validPatterns: [/value\s+instanceof\s+Date/, /\.getFullYear\s*\(\s*\)/],
    tags: ['type-guard', 'instanceof'],
  },
  {
    id: 'ts-instanceof-guard-array',
    category: 'Type Guards',
    difficulty: 'easy',
    title: 'instanceof Guard for Array',
    text: 'Check if the value is an array and return its length, otherwise return 0',
    setup: 'const value: number[] | number = [1, 2, 3, 4, 5];',
    setupCode: 'const value: number[] | number = [1, 2, 3, 4, 5];',
    expected: 5,
    sample: 'Array.isArray(value) ? value.length : 0',
    hints: [
      'Array.isArray is preferred over instanceof Array',
      'Works across different realms/frames',
    ],
    validPatterns: [/Array\.isArray\s*\(\s*value\s*\)|value\s+instanceof\s+Array/, /\.length/],
    tags: ['type-guard', 'instanceof', 'array'],
  },
  {
    id: 'ts-in-guard-property',
    category: 'Type Guards',
    difficulty: 'medium',
    title: 'in Operator Type Guard',
    text: 'Use the "in" operator to check if the object has an "error" property and return its message, otherwise return "success"',
    setup:
      'type Success = { data: string };\ntype Failure = { error: string };\nconst result: Success | Failure = { error: "Something went wrong" };',
    setupCode:
      'type Success = { data: string };\ntype Failure = { error: string };\nconst result: Success | Failure = { error: "Something went wrong" };',
    expected: 'Something went wrong',
    sample: '"error" in result ? result.error : "success"',
    hints: [
      '"in" operator checks for property existence',
      'TypeScript narrows based on discriminating properties',
    ],
    validPatterns: [/["']error["']\s+in\s+result/, /result\.error/],
    tags: ['type-guard', 'in-operator'],
  },
  {
    id: 'ts-custom-type-guard',
    category: 'Type Guards',
    difficulty: 'medium',
    title: 'Custom Type Guard Function',
    text: 'Use the custom type guard to filter only Bird objects from the array',
    setup:
      'interface Bird { fly: () => void; species: string; }\ninterface Fish { swim: () => void; species: string; }\nfunction isBird(animal: Bird | Fish): animal is Bird { return "fly" in animal; }\nconst animals: (Bird | Fish)[] = [{fly: () => {}, species: "Eagle"}, {swim: () => {}, species: "Salmon"}, {fly: () => {}, species: "Sparrow"}];',
    setupCode:
      'interface Bird { fly: () => void; species: string; }\ninterface Fish { swim: () => void; species: string; }\nfunction isBird(animal: Bird | Fish): animal is Bird { return "fly" in animal; }\nconst animals: (Bird | Fish)[] = [{fly: () => {}, species: "Eagle"}, {swim: () => {}, species: "Salmon"}, {fly: () => {}, species: "Sparrow"}];',
    expected: ['Eagle', 'Sparrow'],
    sample: 'animals.filter(isBird).map(b => b.species)',
    hints: [
      'Custom type guards use "x is Type" syntax',
      'filter with type guard narrows array type',
    ],
    validPatterns: [/\.filter\s*\(\s*isBird\s*\)/, /\.map\s*\(/],
    tags: ['type-guard', 'custom', 'filter'],
  },
  {
    id: 'ts-type-guard-assertion',
    category: 'Type Guards',
    difficulty: 'hard',
    title: 'Assertion Type Guard',
    text: 'Use the assertion function to validate the user exists, then access the name',
    setup:
      'interface User { name: string; }\nfunction assertUser(value: unknown): asserts value is User { if (typeof value !== "object" || value === null || !("name" in value)) throw new Error("Not a user"); }\nconst data: unknown = { name: "Alice" };',
    setupCode:
      'interface User { name: string; }\nfunction assertUser(value: unknown): asserts value is User { if (typeof value !== "object" || value === null || !("name" in value)) throw new Error("Not a user"); }\nconst data: unknown = { name: "Alice" };',
    expected: 'Alice',
    sample: '(assertUser(data), (data as User).name)',
    hints: [
      'Assertion functions use "asserts x is Type"',
      'After assertion, the type is narrowed for the rest of the scope',
    ],
    validPatterns: [/assertUser\s*\(\s*data\s*\)/, /\.name/],
    tags: ['type-guard', 'assertion', 'asserts'],
  },

  // ============================================================
  // Utility Types - Advanced Usage
  // ============================================================
  {
    id: 'ts-utility-returntype',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'ReturnType Utility',
    text: 'Extract the return type of the function and create a value of that type',
    setup: 'function createUser() { return { id: 1, name: "Alice", active: true }; }',
    setupCode: 'function createUser() { return { id: 1, name: "Alice", active: true }; }',
    expected: { id: 2, name: 'Bob', active: false },
    sample: '({ id: 2, name: "Bob", active: false } as ReturnType<typeof createUser>)',
    hints: [
      'ReturnType<T> extracts the return type of a function type',
      'Use typeof to get the function type first',
    ],
    validPatterns: [/ReturnType\s*<\s*typeof\s+createUser\s*>/],
    tags: ['utility-types', 'returntype'],
  },
  {
    id: 'ts-utility-parameters',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Parameters Utility',
    text: 'Extract the parameter types and create a tuple matching them',
    setup: 'function greet(name: string, age: number): string { return `${name} is ${age}`; }',
    setupCode: 'function greet(name: string, age: number): string { return `${name} is ${age}`; }',
    expected: ['Alice', 30],
    sample: '(["Alice", 30] as Parameters<typeof greet>)',
    hints: ['Parameters<T> returns a tuple of parameter types', 'Useful for forwarding arguments'],
    validPatterns: [/Parameters\s*<\s*typeof\s+greet\s*>/],
    tags: ['utility-types', 'parameters'],
  },
  {
    id: 'ts-utility-awaited',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Awaited Utility',
    text: 'Get the resolved type of the promise',
    setup: 'const promise: Promise<{ data: string }> = Promise.resolve({ data: "hello" });',
    setupCode: 'const promise: Promise<{ data: string }> = Promise.resolve({ data: "hello" });',
    expected: { data: 'result' },
    sample: '({ data: "result" } as Awaited<typeof promise>)',
    hints: ['Awaited<T> unwraps Promise types recursively', 'Works with nested promises too'],
    validPatterns: [/Awaited\s*<\s*typeof\s+promise\s*>/],
    tags: ['utility-types', 'awaited', 'promise'],
  },
  {
    id: 'ts-utility-record-enum',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Record with String Literal Union',
    text: 'Create a Record that maps each HTTP method to a handler function result',
    setup: 'type HttpMethod = "GET" | "POST" | "PUT" | "DELETE";',
    setupCode: 'type HttpMethod = "GET" | "POST" | "PUT" | "DELETE";',
    expected: { GET: 'get', POST: 'post', PUT: 'put', DELETE: 'delete' },
    sample:
      '({ GET: "get", POST: "post", PUT: "put", DELETE: "delete" } as Record<HttpMethod, string>)',
    hints: ['Record enforces all keys from the union', 'Missing keys will cause a type error'],
    validPatterns: [/Record\s*<\s*HttpMethod\s*,\s*string\s*>/],
    tags: ['utility-types', 'record', 'union'],
  },
  {
    id: 'ts-utility-omit-multiple',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Omit Multiple Properties',
    text: 'Create a public user type by omitting password and secretKey',
    setup:
      'interface FullUser { id: number; name: string; password: string; secretKey: string; }\nconst user: FullUser = { id: 1, name: "Alice", password: "secret", secretKey: "key123" };',
    setupCode:
      'interface FullUser { id: number; name: string; password: string; secretKey: string; }\nconst user: FullUser = { id: 1, name: "Alice", password: "secret", secretKey: "key123" };',
    expected: { id: 1, name: 'Alice' },
    sample: '(({ id, name }) => ({ id, name }))(user) as Omit<FullUser, "password" | "secretKey">',
    hints: ['Omit accepts a union of keys to remove', 'Use | to combine multiple keys'],
    validPatterns: [/Omit\s*<\s*FullUser\s*,\s*["']password["']\s*\|\s*["']secretKey["']\s*>/],
    tags: ['utility-types', 'omit'],
  },

  // ============================================================
  // Generic Methods - Array, Map, Custom
  // ============================================================
  {
    id: 'ts-generic-array-method',
    category: 'Generic Methods',
    difficulty: 'easy',
    title: 'Generic Array Wrapper',
    text: 'Call the generic wrap function to put the value in an array',
    setup: 'function wrap<T>(value: T): T[] { return [value]; }',
    setupCode: 'function wrap<T>(value: T): T[] { return [value]; }',
    expected: [42],
    sample: 'wrap(42)',
    hints: ['Type parameter is inferred from argument', 'Result is T[] where T is inferred'],
    validPatterns: [/wrap\s*\(\s*42\s*\)/],
    tags: ['generics', 'array'],
  },
  {
    id: 'ts-generic-map-entries',
    category: 'Generic Methods',
    difficulty: 'medium',
    title: 'Generic Map Builder',
    text: 'Use the generic function to create a Map from the object',
    setup:
      'function toMap<K extends string, V>(obj: Record<K, V>): Map<K, V> { return new Map(Object.entries(obj) as [K, V][]); }\nconst scores = { alice: 100, bob: 85 };',
    setupCode:
      'function toMap<K extends string, V>(obj: Record<K, V>): Map<K, V> { return new Map(Object.entries(obj) as [K, V][]); }\nconst scores = { alice: 100, bob: 85 };',
    expected: { alice: 100, bob: 85 },
    sample: 'Object.fromEntries(toMap(scores))',
    hints: ['Generic constraints can use extends', 'K extends string ensures keys are strings'],
    validPatterns: [/toMap\s*\(\s*scores\s*\)/],
    tags: ['generics', 'map', 'record'],
  },
  {
    id: 'ts-generic-tuple-swap',
    category: 'Generic Methods',
    difficulty: 'medium',
    title: 'Generic Tuple Swap',
    text: 'Use the swap function to reverse the tuple elements',
    setup:
      'function swap<A, B>(tuple: [A, B]): [B, A] { return [tuple[1], tuple[0]]; }\nconst pair: [string, number] = ["hello", 42];',
    setupCode:
      'function swap<A, B>(tuple: [A, B]): [B, A] { return [tuple[1], tuple[0]]; }\nconst pair: [string, number] = ["hello", 42];',
    expected: [42, 'hello'],
    sample: 'swap(pair)',
    hints: ['Multiple type parameters can be used', 'Tuple types preserve position'],
    validPatterns: [/swap\s*\(\s*pair\s*\)/],
    tags: ['generics', 'tuple'],
  },
  {
    id: 'ts-generic-filter-type',
    category: 'Generic Methods',
    difficulty: 'hard',
    title: 'Generic Type Filter',
    text: 'Use the generic filterByType function to get only numbers from the array',
    setup:
      'function filterByType<T, U extends T>(arr: T[], guard: (x: T) => x is U): U[] { return arr.filter(guard); }\nconst mixed: (string | number)[] = [1, "a", 2, "b", 3];\nconst isNumber = (x: string | number): x is number => typeof x === "number";',
    setupCode:
      'function filterByType<T, U extends T>(arr: T[], guard: (x: T) => x is U): U[] { return arr.filter(guard); }\nconst mixed: (string | number)[] = [1, "a", 2, "b", 3];\nconst isNumber = (x: string | number): x is number => typeof x === "number";',
    expected: [1, 2, 3],
    sample: 'filterByType(mixed, isNumber)',
    hints: [
      'U extends T ensures U is a subtype of T',
      'Type guard function narrows the array type',
    ],
    validPatterns: [/filterByType\s*\(\s*mixed\s*,\s*isNumber\s*\)/],
    tags: ['generics', 'filter', 'type-guard'],
  },
  {
    id: 'ts-generic-default-param',
    category: 'Generic Methods',
    difficulty: 'easy',
    title: 'Generic with Default Type',
    text: 'Call the createContainer function without explicit type (uses default)',
    setup: 'function createContainer<T = string>(value: T): { value: T } { return { value }; }',
    setupCode: 'function createContainer<T = string>(value: T): { value: T } { return { value }; }',
    expected: { value: 'hello' },
    sample: 'createContainer("hello")',
    hints: ['Default type parameters use = syntax', 'Inferred type takes precedence over default'],
    validPatterns: [/createContainer\s*\(\s*["']hello["']\s*\)/],
    tags: ['generics', 'default'],
  },

  // ============================================================
  // Mapped Types and keyof
  // ============================================================
  {
    id: 'ts-keyof-basic',
    category: 'Mapped Types',
    difficulty: 'easy',
    title: 'keyof Type Operator',
    text: 'Use keyof to get a valid key for the user object',
    setup:
      'interface User { name: string; age: number; email: string; }\nconst user: User = { name: "Alice", age: 30, email: "alice@example.com" };',
    setupCode:
      'interface User { name: string; age: number; email: string; }\nconst user: User = { name: "Alice", age: 30, email: "alice@example.com" };',
    expected: 'Alice',
    sample: 'user["name" as keyof User]',
    hints: ['keyof creates a union of property names', 'Result is "name" | "age" | "email"'],
    validPatterns: [/keyof\s+User/, /\[\s*["']name["']/],
    tags: ['keyof', 'mapped-types'],
  },
  {
    id: 'ts-mapped-readonly',
    category: 'Mapped Types',
    difficulty: 'medium',
    title: 'Custom Readonly Mapped Type',
    text: 'Apply the custom MyReadonly type to make the config immutable',
    setup:
      'type MyReadonly<T> = { readonly [K in keyof T]: T[K] };\ninterface Config { host: string; port: number; }\nconst config: Config = { host: "localhost", port: 3000 };',
    setupCode:
      'type MyReadonly<T> = { readonly [K in keyof T]: T[K] };\ninterface Config { host: string; port: number; }\nconst config: Config = { host: "localhost", port: 3000 };',
    expected: { host: 'localhost', port: 3000 },
    sample: '(config as MyReadonly<Config>)',
    hints: [
      'Mapped types iterate over keys with [K in keyof T]',
      'readonly modifier makes properties immutable',
    ],
    validPatterns: [/MyReadonly\s*<\s*Config\s*>/],
    tags: ['mapped-types', 'readonly'],
  },
  {
    id: 'ts-mapped-optional',
    category: 'Mapped Types',
    difficulty: 'medium',
    title: 'Custom Partial Mapped Type',
    text: 'Use the custom MyPartial type to create an optional update object',
    setup:
      'type MyPartial<T> = { [K in keyof T]?: T[K] };\ninterface User { name: string; age: number; }\nconst user: User = { name: "Alice", age: 30 };',
    setupCode:
      'type MyPartial<T> = { [K in keyof T]?: T[K] };\ninterface User { name: string; age: number; }\nconst user: User = { name: "Alice", age: 30 };',
    expected: { name: 'Bob', age: 30 },
    sample: '({ ...user, ...({ name: "Bob" } as MyPartial<User>) })',
    hints: ['? modifier makes properties optional', 'Mapped types can add or remove modifiers'],
    validPatterns: [/MyPartial\s*<\s*User\s*>/],
    tags: ['mapped-types', 'optional'],
  },
  {
    id: 'ts-mapped-value-transform',
    category: 'Mapped Types',
    difficulty: 'hard',
    title: 'Mapped Type with Value Transformation',
    text: 'Use the Getters type to create an object with getter functions for each property',
    setup:
      'type Getters<T> = { [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K] };\ninterface Person { name: string; age: number; }',
    setupCode:
      'type Getters<T> = { [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K] };\ninterface Person { name: string; age: number; }',
    expected: { getName: 'Alice', getAge: 30 },
    sample:
      '({ getName: () => "Alice", getAge: () => 30 } as Getters<Person>).getName() + (({ getName: () => "Alice", getAge: () => 30 } as Getters<Person>).getAge())',
    hints: [
      'Key remapping uses "as" clause in mapped types',
      'Template literal types transform key names',
    ],
    validPatterns: [/Getters\s*<\s*Person\s*>/, /getName|getAge/],
    tags: ['mapped-types', 'template-literal'],
  },
  {
    id: 'ts-keyof-index-access',
    category: 'Mapped Types',
    difficulty: 'easy',
    title: 'Index Access Types',
    text: 'Use index access type to get the type of the name property',
    setup:
      'interface User { name: string; age: number; active: boolean; }\nconst userName: User["name"] = "Alice";',
    setupCode:
      'interface User { name: string; age: number; active: boolean; }\nconst userName: User["name"] = "Alice";',
    expected: 'Alice',
    sample: 'userName',
    hints: ['T["key"] accesses the type of a property', 'Can use union of keys: T["a" | "b"]'],
    validPatterns: [/userName/],
    tags: ['keyof', 'index-access'],
  },

  // ============================================================
  // Conditional Types
  // ============================================================
  {
    id: 'ts-conditional-basic',
    category: 'Conditional Types',
    difficulty: 'medium',
    title: 'Basic Conditional Type',
    text: 'Use the IsString type to check the type and return the appropriate value',
    setup: 'type IsString<T> = T extends string ? "yes" : "no";\ntype Result = IsString<"hello">;',
    setupCode:
      'type IsString<T> = T extends string ? "yes" : "no";\ntype Result = IsString<"hello">;',
    expected: 'yes',
    sample: '("yes" as Result)',
    hints: [
      'Conditional types use T extends U ? X : Y syntax',
      'Similar to ternary operator but for types',
    ],
    validPatterns: [/as\s+Result/, /["']yes["']/],
    tags: ['conditional-types'],
  },
  {
    id: 'ts-conditional-infer',
    category: 'Conditional Types',
    difficulty: 'hard',
    title: 'Conditional Type with infer',
    text: 'Use the ArrayElement type to extract the element type from the array type',
    setup:
      'type ArrayElement<T> = T extends (infer U)[] ? U : never;\ntype NumberArray = number[];\ntype Element = ArrayElement<NumberArray>;',
    setupCode:
      'type ArrayElement<T> = T extends (infer U)[] ? U : never;\ntype NumberArray = number[];\ntype Element = ArrayElement<NumberArray>;',
    expected: 42,
    sample: '(42 as Element)',
    hints: [
      'infer keyword introduces a type variable in extends clause',
      'Extracts types from complex structures',
    ],
    validPatterns: [/as\s+Element/, /42/],
    tags: ['conditional-types', 'infer'],
  },
  {
    id: 'ts-conditional-exclude-null',
    category: 'Conditional Types',
    difficulty: 'medium',
    title: 'Conditional Type for NonNullable',
    text: 'Use the custom NonNull type to remove null from the union',
    setup:
      'type NonNull<T> = T extends null | undefined ? never : T;\ntype MaybeString = string | null | undefined;\ntype JustString = NonNull<MaybeString>;',
    setupCode:
      'type NonNull<T> = T extends null | undefined ? never : T;\ntype MaybeString = string | null | undefined;\ntype JustString = NonNull<MaybeString>;',
    expected: 'hello',
    sample: '("hello" as JustString)',
    hints: ['Conditional types distribute over unions', 'never in a union disappears'],
    validPatterns: [/as\s+JustString/, /["']hello["']/],
    tags: ['conditional-types', 'union'],
  },
  {
    id: 'ts-conditional-function-return',
    category: 'Conditional Types',
    difficulty: 'hard',
    title: 'Extract Function Return Type',
    text: 'Use the custom GetReturn type to extract the return type',
    setup:
      'type GetReturn<T> = T extends (...args: unknown[]) => infer R ? R : never;\ntype Fn = (x: number) => string;\ntype FnReturn = GetReturn<Fn>;',
    setupCode:
      'type GetReturn<T> = T extends (...args: unknown[]) => infer R ? R : never;\ntype Fn = (x: number) => string;\ntype FnReturn = GetReturn<Fn>;',
    expected: 'result',
    sample: '("result" as FnReturn)',
    hints: [
      'infer R captures the return type position',
      'This is how ReturnType utility is implemented',
    ],
    validPatterns: [/as\s+FnReturn/, /["']result["']/],
    tags: ['conditional-types', 'infer', 'function'],
  },
  {
    id: 'ts-conditional-distributive',
    category: 'Conditional Types',
    difficulty: 'hard',
    title: 'Distributive Conditional Types',
    text: 'Use the ToArray type that distributes over unions',
    setup:
      'type ToArray<T> = T extends unknown ? T[] : never;\ntype Union = string | number;\ntype Arrays = ToArray<Union>;',
    setupCode:
      'type ToArray<T> = T extends unknown ? T[] : never;\ntype Union = string | number;\ntype Arrays = ToArray<Union>;',
    expected: [1, 2, 3],
    sample: '([1, 2, 3] as Arrays)',
    hints: [
      'Conditional types distribute when T is a naked type parameter',
      'Result is string[] | number[], not (string | number)[]',
    ],
    validPatterns: [/as\s+Arrays/, /\[\s*1\s*,\s*2\s*,\s*3\s*\]/],
    tags: ['conditional-types', 'distributive'],
  },

  // ============================================================
  // Advanced Type Manipulation - Template Literal Types
  // ============================================================
  {
    id: 'ts-type-template-event-handler',
    category: 'Template Literal Types',
    difficulty: 'easy',
    title: 'Event Handler Template Literal',
    text: 'Create a typed event handler name using template literal types',
    setup:
      'type EventName = "click" | "focus" | "blur";\ntype Handler<E extends string> = `on${Capitalize<E>}`;\nconst handler: Handler<"click"> = "onClick";',
    setupCode:
      'type EventName = "click" | "focus" | "blur";\ntype Handler<E extends string> = `on${Capitalize<E>}`;\nconst handler: Handler<"click"> = "onClick";',
    expected: 'onClick',
    sample: 'handler',
    hints: [
      'Template literal types create string literal types from patterns',
      'Capitalize<T> uppercases the first character',
    ],
    validPatterns: [/handler/],
    tags: ['template-literal', 'capitalize', 'intrinsic-types'],
  },
  {
    id: 'ts-type-template-css-property',
    category: 'Template Literal Types',
    difficulty: 'medium',
    title: 'CSS Property Template Literal',
    text: 'Create CSS variable names using template literal types',
    setup:
      'type CSSVar<T extends string> = `--${T}`;\ntype Theme = "primary" | "secondary";\ntype ThemeVar = CSSVar<Theme>;\nconst cssVar: ThemeVar = "--primary";',
    setupCode:
      'type CSSVar<T extends string> = `--${T}`;\ntype Theme = "primary" | "secondary";\ntype ThemeVar = CSSVar<Theme>;\nconst cssVar: ThemeVar = "--primary";',
    expected: '--primary',
    sample: 'cssVar',
    hints: [
      'Template literals distribute over unions',
      'ThemeVar becomes "--primary" | "--secondary"',
    ],
    validPatterns: [/cssVar/],
    tags: ['template-literal', 'css', 'union'],
  },
  {
    id: 'ts-type-template-route-params',
    category: 'Template Literal Types',
    difficulty: 'hard',
    title: 'Extract Route Parameters',
    text: 'Use template literal inference to extract route parameters',
    setup:
      'type ExtractParam<T extends string> = T extends `${string}:${infer P}` ? P : never;\ntype Route = "/users/:id";\ntype Param = ExtractParam<Route>;\nconst param: Param = "id";',
    setupCode:
      'type ExtractParam<T extends string> = T extends `${string}:${infer P}` ? P : never;\ntype Route = "/users/:id";\ntype Param = ExtractParam<Route>;\nconst param: Param = "id";',
    expected: 'id',
    sample: 'param',
    hints: ['infer can capture parts of template literal types', 'Useful for type-safe routing'],
    validPatterns: [/param/],
    tags: ['template-literal', 'infer', 'routing'],
  },
  {
    id: 'ts-type-template-getter-setter',
    category: 'Template Literal Types',
    difficulty: 'medium',
    title: 'Getter and Setter Names',
    text: 'Generate getter and setter method names from property name',
    setup:
      'type PropMethods<T extends string> = `get${Capitalize<T>}` | `set${Capitalize<T>}`;\ntype NameMethods = PropMethods<"name">;\nconst method: NameMethods = "getName";',
    setupCode:
      'type PropMethods<T extends string> = `get${Capitalize<T>}` | `set${Capitalize<T>}`;\ntype NameMethods = PropMethods<"name">;\nconst method: NameMethods = "getName";',
    expected: 'getName',
    sample: 'method',
    hints: [
      'Union in template literal creates multiple patterns',
      'Result is "getName" | "setName"',
    ],
    validPatterns: [/method/],
    tags: ['template-literal', 'getter-setter', 'union'],
  },

  // ============================================================
  // Advanced Type Manipulation - Recursive Types
  // ============================================================
  {
    id: 'ts-type-recursive-deep-partial',
    category: 'Recursive Types',
    difficulty: 'medium',
    title: 'DeepPartial Recursive Type',
    text: 'Use DeepPartial to make all nested properties optional',
    setup:
      'type DeepPartial<T> = T extends object ? { [K in keyof T]?: DeepPartial<T[K]> } : T;\ninterface Config { server: { host: string; port: number }; }\nconst partial: DeepPartial<Config> = { server: { host: "localhost" } };',
    setupCode:
      'type DeepPartial<T> = T extends object ? { [K in keyof T]?: DeepPartial<T[K]> } : T;\ninterface Config { server: { host: string; port: number }; }\nconst partial: DeepPartial<Config> = { server: { host: "localhost" } };',
    expected: { server: { host: 'localhost' } },
    sample: 'partial',
    hints: [
      'DeepPartial recursively applies Partial to nested objects',
      'Base case is when T is not an object',
    ],
    validPatterns: [/partial/],
    tags: ['recursive-types', 'deep-partial', 'mapped-types'],
  },
  {
    id: 'ts-type-recursive-path',
    category: 'Recursive Types',
    difficulty: 'hard',
    title: 'Recursive Path Type',
    text: 'Use the Paths type to get all possible dot-notation paths',
    setup:
      'type Paths<T> = T extends object ? { [K in keyof T]: K extends string ? K | `${K}.${Paths<T[K]> & string}` : never }[keyof T] : never;\ninterface User { name: string; address: { city: string } }\ntype UserPaths = Paths<User>;\nconst path: UserPaths = "address.city";',
    setupCode:
      'type Paths<T> = T extends object ? { [K in keyof T]: K extends string ? K | `${K}.${Paths<T[K]> & string}` : never }[keyof T] : never;\ninterface User { name: string; address: { city: string } }\ntype UserPaths = Paths<User>;\nconst path: UserPaths = "address.city";',
    expected: 'address.city',
    sample: 'path',
    hints: ['Recursive types can generate nested paths', 'Template literals join keys with dots'],
    validPatterns: [/path/],
    tags: ['recursive-types', 'template-literal', 'paths'],
  },
  {
    id: 'ts-type-recursive-linked-list',
    category: 'Recursive Types',
    difficulty: 'easy',
    title: 'Linked List Type',
    text: 'Create a type-safe linked list using recursive types',
    setup:
      'type LinkedList<T> = { value: T; next: LinkedList<T> | null };\nconst list: LinkedList<number> = { value: 1, next: { value: 2, next: { value: 3, next: null } } };',
    setupCode:
      'type LinkedList<T> = { value: T; next: LinkedList<T> | null };\nconst list: LinkedList<number> = { value: 1, next: { value: 2, next: { value: 3, next: null } } };',
    expected: 1,
    sample: 'list.value',
    hints: ['Recursive types can reference themselves', 'null terminates the recursion at runtime'],
    validPatterns: [/list\.value/],
    tags: ['recursive-types', 'data-structures', 'linked-list'],
  },

  // ============================================================
  // Advanced Type Manipulation - Infer Keyword
  // ============================================================
  {
    id: 'ts-type-infer-constructor-params',
    category: 'Infer Keyword',
    difficulty: 'medium',
    title: 'Infer Constructor Parameters',
    text: 'Extract constructor parameter types using infer',
    setup:
      'type ConstructorParams<T> = T extends new (...args: infer P) => unknown ? P : never;\nclass User { constructor(public name: string, public age: number) {} }\ntype UserParams = ConstructorParams<typeof User>;\nconst params: UserParams = ["Alice", 30];',
    setupCode:
      'type ConstructorParams<T> = T extends new (...args: infer P) => unknown ? P : never;\nclass User { constructor(public name: string, public age: number) {} }\ntype UserParams = ConstructorParams<typeof User>;\nconst params: UserParams = ["Alice", 30];',
    expected: ['Alice', 30],
    sample: 'params',
    hints: [
      'new (...args: infer P) matches constructor signatures',
      'Similar to built-in ConstructorParameters<T>',
    ],
    validPatterns: [/params/],
    tags: ['infer', 'constructor', 'parameters'],
  },
  {
    id: 'ts-type-infer-instance-type',
    category: 'Infer Keyword',
    difficulty: 'easy',
    title: 'Infer Instance Type',
    text: 'Extract the instance type from a constructor using infer',
    setup:
      'type Instance<T> = T extends new (...args: unknown[]) => infer I ? I : never;\nclass User { name = "Alice"; }\ntype UserInstance = Instance<typeof User>;\nconst user: UserInstance = new User();',
    setupCode:
      'type Instance<T> = T extends new (...args: unknown[]) => infer I ? I : never;\nclass User { name = "Alice"; }\ntype UserInstance = Instance<typeof User>;\nconst user: UserInstance = new User();',
    expected: 'Alice',
    sample: 'user.name',
    hints: ['infer I captures what the constructor returns', 'Similar to built-in InstanceType<T>'],
    validPatterns: [/user\.name/],
    tags: ['infer', 'instance', 'class'],
  },
  {
    id: 'ts-type-infer-this-param',
    category: 'Infer Keyword',
    difficulty: 'medium',
    title: 'Infer This Parameter',
    text: 'Extract the this parameter type from a function',
    setup:
      'type ThisParam<T> = T extends (this: infer U, ...args: unknown[]) => unknown ? U : never;\nfunction greet(this: { name: string }) { return this.name; }\ntype Context = ThisParam<typeof greet>;\nconst ctx: Context = { name: "World" };',
    setupCode:
      'type ThisParam<T> = T extends (this: infer U, ...args: unknown[]) => unknown ? U : never;\nfunction greet(this: { name: string }) { return this.name; }\ntype Context = ThisParam<typeof greet>;\nconst ctx: Context = { name: "World" };',
    expected: 'World',
    sample: 'ctx.name',
    hints: ['Functions can have a typed this parameter', 'infer extracts the this type'],
    validPatterns: [/ctx\.name/],
    tags: ['infer', 'this', 'function'],
  },

  // ============================================================
  // Advanced Type Manipulation - Discriminated Unions
  // ============================================================
  {
    id: 'ts-type-discriminated-shape',
    category: 'Discriminated Unions',
    difficulty: 'easy',
    title: 'Shape Discriminated Union',
    text: 'Calculate area based on shape type using discriminated union',
    setup:
      'type Shape = { kind: "circle"; radius: number } | { kind: "square"; side: number };\nfunction area(shape: Shape): number { return shape.kind === "circle" ? Math.PI * shape.radius ** 2 : shape.side ** 2; }\nconst square: Shape = { kind: "square", side: 4 };',
    setupCode:
      'type Shape = { kind: "circle"; radius: number } | { kind: "square"; side: number };\nfunction area(shape: Shape): number { return shape.kind === "circle" ? Math.PI * shape.radius ** 2 : shape.side ** 2; }\nconst square: Shape = { kind: "square", side: 4 };',
    expected: 16,
    sample: 'area(square)',
    hints: [
      'Discriminated unions have a common literal property',
      'TypeScript narrows based on the discriminant check',
    ],
    validPatterns: [/area\s*\(\s*square\s*\)/],
    tags: ['discriminated-union', 'type-narrowing', 'shape'],
  },
  {
    id: 'ts-type-discriminated-fetch',
    category: 'Discriminated Unions',
    difficulty: 'medium',
    title: 'Fetch Result Discriminated Union',
    text: 'Handle loading states using discriminated union',
    setup:
      'type FetchState<T> = { status: "loading" } | { status: "success"; data: T } | { status: "error"; message: string };\nfunction getData(state: FetchState<string>): string { switch(state.status) { case "loading": return "Loading..."; case "success": return state.data; case "error": return state.message; } }\nconst state: FetchState<string> = { status: "success", data: "Hello" };',
    setupCode:
      'type FetchState<T> = { status: "loading" } | { status: "success"; data: T } | { status: "error"; message: string };\nfunction getData(state: FetchState<string>): string { switch(state.status) { case "loading": return "Loading..."; case "success": return state.data; case "error": return state.message; } }\nconst state: FetchState<string> = { status: "success", data: "Hello" };',
    expected: 'Hello',
    sample: 'getData(state)',
    hints: [
      'Generic discriminated unions can carry type-safe payloads',
      'Switch provides exhaustive checking',
    ],
    validPatterns: [/getData\s*\(\s*state\s*\)/],
    tags: ['discriminated-union', 'generic', 'fetch'],
  },
  {
    id: 'ts-type-discriminated-exhaustive',
    category: 'Discriminated Unions',
    difficulty: 'medium',
    title: 'Exhaustive Check with never',
    text: 'Ensure all union cases are handled using never',
    setup:
      'type Animal = { type: "dog"; bark: () => string } | { type: "cat"; meow: () => string };\nfunction assertNever(x: never): never { throw new Error("Unexpected"); }\nfunction sound(animal: Animal): string { switch(animal.type) { case "dog": return animal.bark(); case "cat": return animal.meow(); default: return assertNever(animal); } }\nconst dog: Animal = { type: "dog", bark: () => "Woof" };',
    setupCode:
      'type Animal = { type: "dog"; bark: () => string } | { type: "cat"; meow: () => string };\nfunction assertNever(x: never): never { throw new Error("Unexpected"); }\nfunction sound(animal: Animal): string { switch(animal.type) { case "dog": return animal.bark(); case "cat": return animal.meow(); default: return assertNever(animal); } }\nconst dog: Animal = { type: "dog", bark: () => "Woof" };',
    expected: 'Woof',
    sample: 'sound(dog)',
    hints: [
      'never type ensures all cases are handled',
      'Adding new union members causes compile error in default',
    ],
    validPatterns: [/sound\s*\(\s*dog\s*\)/],
    tags: ['discriminated-union', 'never', 'exhaustive'],
  },

  // ============================================================
  // Advanced Type Manipulation - Branded Types
  // ============================================================
  {
    id: 'ts-type-branded-id',
    category: 'Branded Types',
    difficulty: 'easy',
    title: 'Branded ID Types',
    text: 'Create type-safe IDs using branded types',
    setup:
      'type UserId = string & { readonly __brand: unique symbol };\ntype PostId = string & { readonly __brand: unique symbol };\nfunction createUserId(id: string): UserId { return id as UserId; }\nconst userId = createUserId("user-123");',
    setupCode:
      'type UserId = string & { readonly __brand: unique symbol };\ntype PostId = string & { readonly __brand: unique symbol };\nfunction createUserId(id: string): UserId { return id as UserId; }\nconst userId = createUserId("user-123");',
    expected: 'user-123',
    sample: 'userId',
    hints: [
      'Branded types prevent mixing semantically different values',
      'unique symbol ensures brands are incompatible',
    ],
    validPatterns: [/userId/],
    tags: ['branded-types', 'id', 'type-safety'],
  },
  {
    id: 'ts-type-branded-positive',
    category: 'Branded Types',
    difficulty: 'medium',
    title: 'Branded Positive Number',
    text: 'Create a validated positive number type',
    setup:
      'type Positive = number & { readonly __positive: true };\nfunction positive(n: number): Positive | null { return n > 0 ? n as Positive : null; }\nconst pos = positive(42);',
    setupCode:
      'type Positive = number & { readonly __positive: true };\nfunction positive(n: number): Positive | null { return n > 0 ? n as Positive : null; }\nconst pos = positive(42);',
    expected: 42,
    sample: 'pos',
    hints: [
      'Branded types can encode runtime validations in the type system',
      'Factory function performs validation',
    ],
    validPatterns: [/pos/],
    tags: ['branded-types', 'validation', 'number'],
  },
  {
    id: 'ts-type-branded-json-string',
    category: 'Branded Types',
    difficulty: 'medium',
    title: 'Branded JSON String',
    text: 'Create a type for validated JSON strings',
    setup:
      'type JSONString<T> = string & { readonly __json: T };\nfunction toJSON<T>(value: T): JSONString<T> { return JSON.stringify(value) as JSONString<T>; }\nconst json = toJSON({ name: "Alice" });',
    setupCode:
      'type JSONString<T> = string & { readonly __json: T };\nfunction toJSON<T>(value: T): JSONString<T> { return JSON.stringify(value) as JSONString<T>; }\nconst json = toJSON({ name: "Alice" });',
    expected: '{"name":"Alice"}',
    sample: 'json',
    hints: [
      'Branded types can carry type information',
      'The phantom type T tracks the serialized type',
    ],
    validPatterns: [/json/],
    tags: ['branded-types', 'json', 'phantom-types'],
  },

  // ============================================================
  // Advanced Type Manipulation - Type Narrowing
  // ============================================================
  {
    id: 'ts-type-narrowing-null-check',
    category: 'Type Narrowing',
    difficulty: 'easy',
    title: 'Null Check Narrowing',
    text: 'Narrow nullable type using null check',
    setup:
      'function getLength(value: string | null): number { if (value === null) return 0; return value.length; }\nconst result = getLength("hello");',
    setupCode:
      'function getLength(value: string | null): number { if (value === null) return 0; return value.length; }\nconst result = getLength("hello");',
    expected: 5,
    sample: 'result',
    hints: ['Null checks narrow the type to non-null', 'After the check, value is just string'],
    validPatterns: [/result/],
    tags: ['type-narrowing', 'null', 'control-flow'],
  },
  {
    id: 'ts-type-narrowing-truthiness',
    category: 'Type Narrowing',
    difficulty: 'easy',
    title: 'Truthiness Narrowing',
    text: 'Use truthiness to narrow optional values',
    setup:
      'function greet(name?: string): string { if (name) { return `Hello, ${name}!`; } return "Hello, stranger!"; }\nconst greeting = greet("Alice");',
    setupCode:
      'function greet(name?: string): string { if (name) { return `Hello, ${name}!`; } return "Hello, stranger!"; }\nconst greeting = greet("Alice");',
    expected: 'Hello, Alice!',
    sample: 'greeting',
    hints: [
      'Truthiness check narrows out null, undefined, empty string, 0',
      'Be careful with values that can be falsy',
    ],
    validPatterns: [/greeting/],
    tags: ['type-narrowing', 'truthiness', 'optional'],
  },
  {
    id: 'ts-type-narrowing-equality',
    category: 'Type Narrowing',
    difficulty: 'medium',
    title: 'Equality Narrowing',
    text: 'Narrow union by comparing to specific value',
    setup:
      'type Status = "pending" | "active" | "completed";\nfunction isActive(status: Status): boolean { return status === "active"; }\nconst active = isActive("active");',
    setupCode:
      'type Status = "pending" | "active" | "completed";\nfunction isActive(status: Status): boolean { return status === "active"; }\nconst active = isActive("active");',
    expected: true,
    sample: 'active',
    hints: [
      'Equality narrows to the specific literal type',
      'Works with string, number, and boolean literals',
    ],
    validPatterns: [/active/],
    tags: ['type-narrowing', 'equality', 'literal'],
  },

  // ============================================================
  // Advanced Type Manipulation - Readonly and DeepReadonly
  // ============================================================
  {
    id: 'ts-type-readonly-mapped',
    category: 'Readonly Patterns',
    difficulty: 'medium',
    title: 'Readonly Mapped Type',
    text: 'Create a custom readonly mapped type',
    setup:
      'type Immutable<T> = { readonly [K in keyof T]: T[K] };\ninterface User { name: string; age: number; }\nconst user: Immutable<User> = { name: "Alice", age: 30 };',
    setupCode:
      'type Immutable<T> = { readonly [K in keyof T]: T[K] };\ninterface User { name: string; age: number; }\nconst user: Immutable<User> = { name: "Alice", age: 30 };',
    expected: 'Alice',
    sample: 'user.name',
    hints: ['Mapped types can add readonly modifier', 'Equivalent to built-in Readonly<T>'],
    validPatterns: [/user\.name/],
    tags: ['readonly', 'mapped-types', 'immutable'],
  },
  {
    id: 'ts-type-deep-readonly',
    category: 'Readonly Patterns',
    difficulty: 'hard',
    title: 'DeepReadonly Implementation',
    text: 'Use DeepReadonly for nested immutable structures',
    setup:
      'type DeepReadonly<T> = T extends (infer U)[] ? ReadonlyArray<DeepReadonly<U>> : T extends object ? { readonly [K in keyof T]: DeepReadonly<T[K]> } : T;\ninterface State { user: { name: string; settings: { theme: string } } }\nconst state: DeepReadonly<State> = { user: { name: "Alice", settings: { theme: "dark" } } };',
    setupCode:
      'type DeepReadonly<T> = T extends (infer U)[] ? ReadonlyArray<DeepReadonly<U>> : T extends object ? { readonly [K in keyof T]: DeepReadonly<T[K]> } : T;\ninterface State { user: { name: string; settings: { theme: string } } }\nconst state: DeepReadonly<State> = { user: { name: "Alice", settings: { theme: "dark" } } };',
    expected: 'dark',
    sample: 'state.user.settings.theme',
    hints: [
      'DeepReadonly handles arrays and objects differently',
      'Recursively applies readonly to all levels',
    ],
    validPatterns: [/state\.user\.settings\.theme/],
    tags: ['readonly', 'deep-readonly', 'recursive-types'],
  },

  // ============================================================
  // Advanced Type Manipulation - Type Assertions vs Guards
  // ============================================================
  {
    id: 'ts-type-assertion-unknown',
    category: 'Type Assertions',
    difficulty: 'easy',
    title: 'Assertion from Unknown',
    text: 'Assert unknown value to a specific type',
    setup:
      'const data: unknown = { name: "Alice", age: 30 };\ninterface User { name: string; age: number; }',
    setupCode:
      'const data: unknown = { name: "Alice", age: 30 };\ninterface User { name: string; age: number; }',
    expected: 'Alice',
    sample: '(data as User).name',
    hints: ['Type assertions override the compiler', 'Use when you know more than TypeScript'],
    validPatterns: [/\(\s*data\s+as\s+User\s*\)\.name/],
    tags: ['type-assertion', 'unknown', 'as'],
  },
  {
    id: 'ts-type-guard-vs-assertion',
    category: 'Type Assertions',
    difficulty: 'medium',
    title: 'Type Guard for Runtime Safety',
    text: 'Use type guard instead of assertion for runtime safety',
    setup:
      'interface User { name: string; }\nfunction isUser(obj: unknown): obj is User { return typeof obj === "object" && obj !== null && "name" in obj && typeof (obj as User).name === "string"; }\nconst data: unknown = { name: "Alice" };',
    setupCode:
      'interface User { name: string; }\nfunction isUser(obj: unknown): obj is User { return typeof obj === "object" && obj !== null && "name" in obj && typeof (obj as User).name === "string"; }\nconst data: unknown = { name: "Alice" };',
    expected: true,
    sample: 'isUser(data)',
    hints: ['Type guards provide runtime validation', 'Safer than assertions for external data'],
    validPatterns: [/isUser\s*\(\s*data\s*\)/],
    tags: ['type-guard', 'type-assertion', 'runtime'],
  },
  {
    id: 'ts-type-template-kebab-case',
    category: 'Template Literal Types',
    difficulty: 'hard',
    title: 'Kebab-Case Conversion Type',
    text: 'Use template literal types to convert camelCase to kebab-case',
    setup:
      'type KebabCase<S extends string> = S extends `${infer First}${infer Rest}` ? First extends Lowercase<First> ? `${First}${KebabCase<Rest>}` : `-${Lowercase<First>}${KebabCase<Rest>}` : S;\ntype Result = KebabCase<"backgroundColor">;\nconst kebab: Result = "-background-color";',
    setupCode:
      'type KebabCase<S extends string> = S extends `${infer First}${infer Rest}` ? First extends Lowercase<First> ? `${First}${KebabCase<Rest>}` : `-${Lowercase<First>}${KebabCase<Rest>}` : S;\ntype Result = KebabCase<"backgroundColor">;\nconst kebab: Result = "-background-color";',
    expected: '-background-color',
    sample: 'kebab',
    hints: [
      'Template literal types can process strings character by character',
      'Lowercase<T> converts a string literal to lowercase',
    ],
    validPatterns: [/kebab/],
    tags: ['template-literal', 'recursive-types', 'string-manipulation'],
  },

  // ============================================================
  // Typed Array Operations - Generic Array Methods
  // ============================================================
  {
    id: 'ts-arr-generic-map',
    category: 'Typed Array Operations',
    difficulty: 'easy',
    title: 'Generic Array Map with Type Inference',
    text: 'Use a generic map function to transform numbers to strings with proper type inference',
    setup:
      'function mapArray<T, U>(arr: T[], fn: (item: T) => U): U[] { return arr.map(fn); }\nconst numbers: number[] = [1, 2, 3, 4, 5];',
    setupCode:
      'function mapArray<T, U>(arr: T[], fn: (item: T) => U): U[] { return arr.map(fn); }\nconst numbers: number[] = [1, 2, 3, 4, 5];',
    expected: ['1', '2', '3', '4', '5'],
    sample: 'mapArray(numbers, (n) => String(n))',
    hints: ['Generic functions infer types from arguments', 'T is inferred as number, U as string'],
    validPatterns: [/mapArray\s*\(\s*numbers/, /String\s*\(\s*n\s*\)|\.toString\s*\(\s*\)/],
    tags: ['generics', 'map', 'type-inference', 'typed-array'],
  },
  {
    id: 'ts-arr-generic-filter',
    category: 'Typed Array Operations',
    difficulty: 'easy',
    title: 'Generic Array Filter with Predicate',
    text: 'Use a generic filter function with a predicate to get even numbers',
    setup:
      'function filterArray<T>(arr: T[], predicate: (item: T) => boolean): T[] { return arr.filter(predicate); }\nconst nums: number[] = [1, 2, 3, 4, 5, 6];',
    setupCode:
      'function filterArray<T>(arr: T[], predicate: (item: T) => boolean): T[] { return arr.filter(predicate); }\nconst nums: number[] = [1, 2, 3, 4, 5, 6];',
    expected: [2, 4, 6],
    sample: 'filterArray(nums, (n) => n % 2 === 0)',
    hints: ['Predicate returns boolean for filtering', 'Result type is same as input array type'],
    validPatterns: [/filterArray\s*\(\s*nums/, /%\s*2\s*===?\s*0/],
    tags: ['generics', 'filter', 'predicate', 'typed-array'],
  },
  {
    id: 'ts-arr-generic-reduce-accumulator',
    category: 'Typed Array Operations',
    difficulty: 'medium',
    title: 'Generic Reduce with Typed Accumulator',
    text: 'Use the generic reduce function to count occurrences of each string',
    setup:
      'function reduceArray<T, U>(arr: T[], fn: (acc: U, item: T) => U, initial: U): U { return arr.reduce(fn, initial); }\nconst words: string[] = ["a", "b", "a", "c", "b", "a"];',
    setupCode:
      'function reduceArray<T, U>(arr: T[], fn: (acc: U, item: T) => U, initial: U): U { return arr.reduce(fn, initial); }\nconst words: string[] = ["a", "b", "a", "c", "b", "a"];',
    expected: { a: 3, b: 2, c: 1 },
    sample:
      'reduceArray(words, (acc, word) => ({ ...acc, [word]: (acc[word] || 0) + 1 }), {} as Record<string, number>)',
    hints: [
      'U is the accumulator type, different from T',
      'Initial value determines the accumulator type',
    ],
    validPatterns: [/reduceArray\s*\(\s*words/, /Record\s*<\s*string\s*,\s*number\s*>/],
    tags: ['generics', 'reduce', 'accumulator', 'typed-array'],
  },
  {
    id: 'ts-arr-generic-find-or-default',
    category: 'Typed Array Operations',
    difficulty: 'easy',
    title: 'Generic Find with Default Value',
    text: 'Use the generic findOrDefault function to find a user or return a default',
    setup:
      'function findOrDefault<T>(arr: T[], predicate: (item: T) => boolean, defaultValue: T): T { return arr.find(predicate) ?? defaultValue; }\ninterface User { id: number; name: string; }\nconst users: User[] = [{ id: 1, name: "Alice" }, { id: 2, name: "Bob" }];\nconst defaultUser: User = { id: 0, name: "Guest" };',
    setupCode:
      'function findOrDefault<T>(arr: T[], predicate: (item: T) => boolean, defaultValue: T): T { return arr.find(predicate) ?? defaultValue; }\ninterface User { id: number; name: string; }\nconst users: User[] = [{ id: 1, name: "Alice" }, { id: 2, name: "Bob" }];\nconst defaultUser: User = { id: 0, name: "Guest" };',
    expected: { id: 0, name: 'Guest' },
    sample: 'findOrDefault(users, (u) => u.id === 99, defaultUser)',
    hints: ['Nullish coalescing (??) provides the default', 'Return type is T, not T | undefined'],
    validPatterns: [/findOrDefault\s*\(\s*users/, /defaultUser/],
    tags: ['generics', 'find', 'default', 'typed-array'],
  },

  // ============================================================
  // Typed Array Operations - ReadonlyArray
  // ============================================================
  {
    id: 'ts-arr-readonly-basic',
    category: 'Typed Array Operations',
    difficulty: 'easy',
    title: 'ReadonlyArray Basic Usage',
    text: 'Use ReadonlyArray to create an immutable view and access elements',
    setup:
      'const mutable: number[] = [1, 2, 3, 4, 5];\nconst immutable: ReadonlyArray<number> = mutable;',
    setupCode:
      'const mutable: number[] = [1, 2, 3, 4, 5];\nconst immutable: ReadonlyArray<number> = mutable;',
    expected: 3,
    sample: 'immutable[2]',
    hints: [
      'ReadonlyArray allows reading but not mutating',
      'Index access still works on ReadonlyArray',
    ],
    validPatterns: [/immutable\s*\[\s*2\s*\]/],
    tags: ['readonly', 'array', 'immutable', 'typed-array'],
  },
  {
    id: 'ts-arr-readonly-methods',
    category: 'Typed Array Operations',
    difficulty: 'easy',
    title: 'ReadonlyArray Non-Mutating Methods',
    text: 'Use slice on ReadonlyArray to get a portion without mutation',
    setup: 'const items: ReadonlyArray<string> = ["a", "b", "c", "d", "e"];',
    setupCode: 'const items: ReadonlyArray<string> = ["a", "b", "c", "d", "e"];',
    expected: ['b', 'c', 'd'],
    sample: 'items.slice(1, 4)',
    hints: [
      'slice, map, filter are available on ReadonlyArray',
      'Methods that mutate (push, pop) are not available',
    ],
    validPatterns: [/items\.slice\s*\(\s*1\s*,\s*4\s*\)/],
    tags: ['readonly', 'array', 'slice', 'typed-array'],
  },
  {
    id: 'ts-arr-readonly-to-mutable',
    category: 'Typed Array Operations',
    difficulty: 'medium',
    title: 'Convert ReadonlyArray to Mutable',
    text: 'Create a mutable copy of the ReadonlyArray using spread',
    setup: 'const frozen: ReadonlyArray<number> = [10, 20, 30];',
    setupCode: 'const frozen: ReadonlyArray<number> = [10, 20, 30];',
    expected: [10, 20, 30, 40],
    sample: '[...frozen, 40]',
    hints: ['Spread creates a new mutable array', 'The new array is number[], not ReadonlyArray'],
    validPatterns: [/\[\s*\.\.\.frozen\s*,\s*40\s*\]/],
    tags: ['readonly', 'spread', 'mutable', 'typed-array'],
  },
  {
    id: 'ts-arr-readonly-deep',
    category: 'Typed Array Operations',
    difficulty: 'medium',
    title: 'Deep Readonly Array',
    text: 'Use the DeepReadonly type to create a deeply immutable structure and access nested data',
    setup:
      'type DeepReadonly<T> = { readonly [K in keyof T]: DeepReadonly<T[K]> };\ninterface Data { items: { name: string; value: number }[] }\nconst data: DeepReadonly<Data> = { items: [{ name: "a", value: 1 }, { name: "b", value: 2 }] };',
    setupCode:
      'type DeepReadonly<T> = { readonly [K in keyof T]: DeepReadonly<T[K]> };\ninterface Data { items: { name: string; value: number }[] }\nconst data: DeepReadonly<Data> = { items: [{ name: "a", value: 1 }, { name: "b", value: 2 }] };',
    expected: 'a',
    sample: 'data.items[0].name',
    hints: [
      'DeepReadonly recursively applies readonly',
      'Nested objects and arrays become immutable',
    ],
    validPatterns: [/data\.items\s*\[\s*0\s*\]\.name/],
    tags: ['readonly', 'deep', 'mapped-types', 'typed-array'],
  },

  // ============================================================
  // Typed Array Operations - Tuple Manipulation
  // ============================================================
  {
    id: 'ts-arr-tuple-basic',
    category: 'Typed Array Operations',
    difficulty: 'easy',
    title: 'Basic Tuple Type',
    text: 'Access elements from a typed tuple with different types',
    setup: 'const tuple: [string, number, boolean] = ["hello", 42, true];',
    setupCode: 'const tuple: [string, number, boolean] = ["hello", 42, true];',
    expected: ['hello', 42],
    sample: '[tuple[0], tuple[1]]',
    hints: [
      'Tuple elements have specific types by position',
      'Each index has its own inferred type',
    ],
    validPatterns: [/tuple\s*\[\s*0\s*\]/, /tuple\s*\[\s*1\s*\]/],
    tags: ['tuple', 'index-access', 'typed-array'],
  },
  {
    id: 'ts-arr-tuple-rest',
    category: 'Typed Array Operations',
    difficulty: 'medium',
    title: 'Tuple with Rest Element',
    text: 'Use a tuple with rest element to represent a function with variable arguments',
    setup:
      'type VarArgs = [first: string, ...rest: number[]];\nconst args: VarArgs = ["sum", 1, 2, 3, 4, 5];',
    setupCode:
      'type VarArgs = [first: string, ...rest: number[]];\nconst args: VarArgs = ["sum", 1, 2, 3, 4, 5];',
    expected: 15,
    sample: 'args.slice(1).reduce((a, b) => (a as number) + (b as number), 0)',
    hints: ['Rest element captures remaining items', 'First element is string, rest are numbers'],
    validPatterns: [/args\.slice\s*\(\s*1\s*\)/, /\.reduce\s*\(/],
    tags: ['tuple', 'rest', 'variadic', 'typed-array'],
  },
  {
    id: 'ts-arr-tuple-spread',
    category: 'Typed Array Operations',
    difficulty: 'medium',
    title: 'Tuple Spread and Concatenation',
    text: 'Concatenate two tuples using spread with proper typing',
    setup:
      'const tuple1: [number, string] = [1, "a"];\nconst tuple2: [boolean, null] = [true, null];',
    setupCode:
      'const tuple1: [number, string] = [1, "a"];\nconst tuple2: [boolean, null] = [true, null];',
    expected: [1, 'a', true, null],
    sample: '[...tuple1, ...tuple2] as [number, string, boolean, null]',
    hints: [
      'Spreading tuples preserves element types',
      'Result type is concatenation of tuple types',
    ],
    validPatterns: [/\[\s*\.\.\.tuple1\s*,\s*\.\.\.tuple2\s*\]/, /as\s*\[/],
    tags: ['tuple', 'spread', 'concatenation', 'typed-array'],
  },
  {
    id: 'ts-arr-tuple-destructure',
    category: 'Typed Array Operations',
    difficulty: 'easy',
    title: 'Tuple Destructuring with Types',
    text: 'Destructure a tuple and use the typed values',
    setup: 'const point: [x: number, y: number, label: string] = [10, 20, "origin"];',
    setupCode: 'const point: [x: number, y: number, label: string] = [10, 20, "origin"];',
    expected: { x: 10, y: 20, label: 'origin' },
    sample: '(([x, y, label]) => ({ x, y, label }))(point)',
    hints: ['Named tuple elements improve readability', 'Destructuring preserves individual types'],
    validPatterns: [/\[\s*x\s*,\s*y\s*,\s*label\s*\]/, /\(\s*point\s*\)/],
    tags: ['tuple', 'destructuring', 'named-elements', 'typed-array'],
  },
  {
    id: 'ts-arr-tuple-length',
    category: 'Typed Array Operations',
    difficulty: 'hard',
    title: 'Tuple Length Type',
    text: 'Use the Length type to get the compile-time length of a tuple',
    setup:
      'type Length<T extends readonly unknown[]> = T["length"];\nconst tuple = [1, 2, 3, 4, 5] as const;\ntype TupleLength = Length<typeof tuple>;',
    setupCode:
      'type Length<T extends readonly unknown[]> = T["length"];\nconst tuple = [1, 2, 3, 4, 5] as const;\ntype TupleLength = Length<typeof tuple>;',
    expected: 5,
    sample: '(5 as TupleLength)',
    hints: ['Tuple types have a literal length property', 'as const creates a readonly tuple type'],
    validPatterns: [/as\s+TupleLength/, /5/],
    tags: ['tuple', 'length', 'type-level', 'typed-array'],
  },

  // ============================================================
  // Typed Array Operations - Array Type Narrowing
  // ============================================================
  {
    id: 'ts-arr-narrow-nonempty',
    category: 'Typed Array Operations',
    difficulty: 'medium',
    title: 'Non-Empty Array Type Guard',
    text: 'Use the type guard to narrow to a non-empty array and access first element safely',
    setup:
      'type NonEmptyArray<T> = [T, ...T[]];\nfunction isNonEmpty<T>(arr: T[]): arr is NonEmptyArray<T> { return arr.length > 0; }\nconst items: string[] = ["first", "second", "third"];',
    setupCode:
      'type NonEmptyArray<T> = [T, ...T[]];\nfunction isNonEmpty<T>(arr: T[]): arr is NonEmptyArray<T> { return arr.length > 0; }\nconst items: string[] = ["first", "second", "third"];',
    expected: 'first',
    sample: 'isNonEmpty(items) ? items[0] : "empty"',
    hints: [
      'NonEmptyArray guarantees at least one element',
      'After the guard, items[0] is guaranteed to exist',
    ],
    validPatterns: [/isNonEmpty\s*\(\s*items\s*\)/, /items\s*\[\s*0\s*\]/],
    tags: ['type-guard', 'narrowing', 'non-empty', 'typed-array'],
  },
  {
    id: 'ts-arr-narrow-specific-length',
    category: 'Typed Array Operations',
    difficulty: 'medium',
    title: 'Specific Length Array Guard',
    text: 'Use the type guard to narrow to a pair (2-element tuple)',
    setup:
      'type Pair<T> = [T, T];\nfunction isPair<T>(arr: T[]): arr is Pair<T> { return arr.length === 2; }\nconst coords: number[] = [10, 20];',
    setupCode:
      'type Pair<T> = [T, T];\nfunction isPair<T>(arr: T[]): arr is Pair<T> { return arr.length === 2; }\nconst coords: number[] = [10, 20];',
    expected: 30,
    sample: 'isPair(coords) ? coords[0] + coords[1] : 0',
    hints: ['Pair type is a 2-element tuple', 'After guard, both indices are safely accessible'],
    validPatterns: [
      /isPair\s*\(\s*coords\s*\)/,
      /coords\s*\[\s*0\s*\]\s*\+\s*coords\s*\[\s*1\s*\]/,
    ],
    tags: ['type-guard', 'narrowing', 'tuple', 'typed-array'],
  },
  {
    id: 'ts-arr-narrow-array-of-type',
    category: 'Typed Array Operations',
    difficulty: 'medium',
    title: 'Array Element Type Guard',
    text: 'Use the isArrayOf guard to verify all elements are numbers',
    setup:
      'function isArrayOf<T>(arr: unknown[], guard: (x: unknown) => x is T): arr is T[] { return arr.every(guard); }\nfunction isNumber(x: unknown): x is number { return typeof x === "number"; }\nconst mixed: unknown[] = [1, 2, 3, 4, 5];',
    setupCode:
      'function isArrayOf<T>(arr: unknown[], guard: (x: unknown) => x is T): arr is T[] { return arr.every(guard); }\nfunction isNumber(x: unknown): x is number { return typeof x === "number"; }\nconst mixed: unknown[] = [1, 2, 3, 4, 5];',
    expected: 15,
    sample: 'isArrayOf(mixed, isNumber) ? mixed.reduce((a, b) => a + b, 0) : 0',
    hints: [
      'isArrayOf validates all elements match the type',
      'After guard, array is narrowed to T[]',
    ],
    validPatterns: [/isArrayOf\s*\(\s*mixed\s*,\s*isNumber\s*\)/, /\.reduce\s*\(/],
    tags: ['type-guard', 'narrowing', 'every', 'typed-array'],
  },

  // ============================================================
  // Typed Array Operations - Typed Reduce Operations
  // ============================================================
  {
    id: 'ts-arr-reduce-to-map',
    category: 'Typed Array Operations',
    difficulty: 'medium',
    title: 'Reduce to Map with Generics',
    text: 'Use reduce to convert array to a Map keyed by a property',
    setup:
      'interface Product { sku: string; name: string; price: number; }\nconst products: Product[] = [{ sku: "A1", name: "Widget", price: 10 }, { sku: "B2", name: "Gadget", price: 20 }];',
    setupCode:
      'interface Product { sku: string; name: string; price: number; }\nconst products: Product[] = [{ sku: "A1", name: "Widget", price: 10 }, { sku: "B2", name: "Gadget", price: 20 }];',
    expected: { A1: 'Widget', B2: 'Gadget' },
    sample:
      'Object.fromEntries(products.reduce<Map<string, string>>((map, p) => map.set(p.sku, p.name), new Map()))',
    hints: ['reduce<Map<K,V>> specifies accumulator type', 'Map.set returns the Map for chaining'],
    validPatterns: [/\.reduce\s*<\s*Map\s*</, /\.set\s*\(\s*p\.sku/],
    tags: ['reduce', 'map', 'generics', 'typed-array'],
  },
  {
    id: 'ts-arr-reduce-partition',
    category: 'Typed Array Operations',
    difficulty: 'hard',
    title: 'Reduce to Partition Array',
    text: 'Use reduce to partition numbers into even and odd arrays',
    setup: 'const numbers: number[] = [1, 2, 3, 4, 5, 6, 7, 8];',
    setupCode: 'const numbers: number[] = [1, 2, 3, 4, 5, 6, 7, 8];',
    expected: { even: [2, 4, 6, 8], odd: [1, 3, 5, 7] },
    sample:
      'numbers.reduce<{ even: number[]; odd: number[] }>((acc, n) => { n % 2 === 0 ? acc.even.push(n) : acc.odd.push(n); return acc; }, { even: [], odd: [] })',
    hints: [
      'Accumulator type is an object with two arrays',
      'Mutate accumulator for better performance',
    ],
    validPatterns: [/\.reduce\s*<\s*\{\s*even\s*:/, /even\.push|odd\.push/],
    tags: ['reduce', 'partition', 'generics', 'typed-array'],
  },
  {
    id: 'ts-arr-reduce-unique',
    category: 'Typed Array Operations',
    difficulty: 'medium',
    title: 'Reduce to Unique Array with Type',
    text: 'Use reduce with Set to get unique values maintaining type',
    setup: 'const items: string[] = ["a", "b", "a", "c", "b", "d", "a"];',
    setupCode: 'const items: string[] = ["a", "b", "a", "c", "b", "d", "a"];',
    expected: ['a', 'b', 'c', 'd'],
    sample: 'items.reduce<string[]>((acc, item) => acc.includes(item) ? acc : [...acc, item], [])',
    hints: ['Check if item already exists before adding', 'Alternative: [...new Set(items)]'],
    validPatterns: [/\.reduce\s*<\s*string\s*\[\s*\]\s*>/, /\.includes\s*\(\s*item\s*\)/],
    tags: ['reduce', 'unique', 'dedup', 'typed-array'],
  },

  // ============================================================
  // Typed Array Operations - Array Assertion Functions
  // ============================================================
  {
    id: 'ts-arr-assert-nonempty',
    category: 'Typed Array Operations',
    difficulty: 'medium',
    title: 'Assert Non-Empty Array',
    text: 'Use the assertion function to guarantee the array is non-empty, then get first element',
    setup:
      'type NonEmptyArray<T> = [T, ...T[]];\nfunction assertNonEmpty<T>(arr: T[]): asserts arr is NonEmptyArray<T> { if (arr.length === 0) throw new Error("Array is empty"); }\nconst data: number[] = [10, 20, 30];',
    setupCode:
      'type NonEmptyArray<T> = [T, ...T[]];\nfunction assertNonEmpty<T>(arr: T[]): asserts arr is NonEmptyArray<T> { if (arr.length === 0) throw new Error("Array is empty"); }\nconst data: number[] = [10, 20, 30];',
    expected: 10,
    sample: '(assertNonEmpty(data), data[0])',
    hints: [
      'Assertion functions throw on failure',
      'After assertion, type is narrowed for rest of scope',
    ],
    validPatterns: [/assertNonEmpty\s*\(\s*data\s*\)/, /data\s*\[\s*0\s*\]/],
    tags: ['assertion', 'non-empty', 'asserts', 'typed-array'],
  },
  {
    id: 'ts-arr-assert-all-defined',
    category: 'Typed Array Operations',
    difficulty: 'hard',
    title: 'Assert All Elements Defined',
    text: 'Use the assertion function to guarantee no undefined elements exist',
    setup:
      'function assertAllDefined<T>(arr: (T | undefined)[]): asserts arr is T[] { if (arr.some(x => x === undefined)) throw new Error("Found undefined"); }\nconst maybeNumbers: (number | undefined)[] = [1, 2, 3, 4, 5];',
    setupCode:
      'function assertAllDefined<T>(arr: (T | undefined)[]): asserts arr is T[] { if (arr.some(x => x === undefined)) throw new Error("Found undefined"); }\nconst maybeNumbers: (number | undefined)[] = [1, 2, 3, 4, 5];',
    expected: 15,
    sample: '(assertAllDefined(maybeNumbers), maybeNumbers.reduce((a, b) => a + b, 0))',
    hints: [
      'asserts arr is T[] narrows away undefined',
      'After assertion, array elements are guaranteed defined',
    ],
    validPatterns: [/assertAllDefined\s*\(\s*maybeNumbers\s*\)/, /\.reduce\s*\(/],
    tags: ['assertion', 'defined', 'asserts', 'typed-array'],
  },

  // ============================================================
  // Typed Array Operations - as const with Arrays
  // ============================================================
  {
    id: 'ts-arr-const-literal',
    category: 'Typed Array Operations',
    difficulty: 'easy',
    title: 'Const Assertion for Literal Array',
    text: 'Use as const to create a readonly tuple with literal types',
    setup: 'const colors = ["red", "green", "blue"] as const;',
    setupCode: 'const colors = ["red", "green", "blue"] as const;',
    expected: 'green',
    sample: 'colors[1]',
    hints: [
      'as const creates readonly tuple with literal types',
      'Type is readonly ["red", "green", "blue"]',
    ],
    validPatterns: [/colors\s*\[\s*1\s*\]/],
    tags: ['const-assertion', 'literal', 'readonly', 'typed-array'],
  },
  {
    id: 'ts-arr-const-union',
    category: 'Typed Array Operations',
    difficulty: 'medium',
    title: 'Extract Union from Const Array',
    text: 'Use as const array to create a union type of its values',
    setup:
      'const statuses = ["pending", "active", "completed"] as const;\ntype Status = typeof statuses[number];',
    setupCode:
      'const statuses = ["pending", "active", "completed"] as const;\ntype Status = typeof statuses[number];',
    expected: 'active',
    sample: '("active" as Status)',
    hints: [
      'typeof arr[number] extracts union of element types',
      'Result is "pending" | "active" | "completed"',
    ],
    validPatterns: [/as\s+Status/, /["']active["']/],
    tags: ['const-assertion', 'union', 'typeof', 'typed-array'],
  },
  {
    id: 'ts-arr-const-object-array',
    category: 'Typed Array Operations',
    difficulty: 'medium',
    title: 'Const Assertion with Object Array',
    text: 'Use as const with an array of objects to preserve literal types',
    setup:
      'const routes = [{ path: "/", name: "home" }, { path: "/about", name: "about" }] as const;',
    setupCode:
      'const routes = [{ path: "/", name: "home" }, { path: "/about", name: "about" }] as const;',
    expected: '/',
    sample: 'routes[0].path',
    hints: [
      'as const makes nested objects readonly too',
      'Property types are literal, not widened to string',
    ],
    validPatterns: [/routes\s*\[\s*0\s*\]\.path/],
    tags: ['const-assertion', 'object', 'readonly', 'typed-array'],
  },

  // ============================================================
  // Typed Array Operations - Typed Filter with Predicates
  // ============================================================
  {
    id: 'ts-arr-filter-instance',
    category: 'Typed Array Operations',
    difficulty: 'medium',
    title: 'Filter by Instance Type',
    text: 'Filter array to only Error instances using type predicate',
    setup:
      'class CustomError extends Error { code: number = 0; }\nconst items: (string | Error | CustomError)[] = ["text", new Error("err"), new CustomError("custom")];',
    setupCode:
      'class CustomError extends Error { code: number = 0; }\nconst items: (string | Error | CustomError)[] = ["text", new Error("err"), new CustomError("custom")];',
    expected: ['err', 'custom'],
    sample: 'items.filter((x): x is Error => x instanceof Error).map(e => e.message)',
    hints: ['instanceof checks class hierarchy', 'CustomError extends Error, so both match'],
    validPatterns: [/\.filter\s*\(\s*\([^)]*\)\s*:\s*\w+\s+is\s+Error/, /instanceof\s+Error/],
    tags: ['filter', 'type-predicate', 'instanceof', 'typed-array'],
  },
  {
    id: 'ts-arr-filter-property',
    category: 'Typed Array Operations',
    difficulty: 'hard',
    title: 'Filter by Property Existence',
    text: 'Filter to objects that have an optional property defined',
    setup:
      'interface Item { id: number; metadata?: { timestamp: number } }\nconst items: Item[] = [{ id: 1 }, { id: 2, metadata: { timestamp: 100 } }, { id: 3, metadata: { timestamp: 200 } }];',
    setupCode:
      'interface Item { id: number; metadata?: { timestamp: number } }\nconst items: Item[] = [{ id: 1 }, { id: 2, metadata: { timestamp: 100 } }, { id: 3, metadata: { timestamp: 200 } }];',
    expected: [100, 200],
    sample:
      'items.filter((x): x is Item & { metadata: { timestamp: number } } => x.metadata !== undefined).map(x => x.metadata.timestamp)',
    hints: [
      'Use intersection type to add the required property',
      'After filter, metadata is guaranteed to exist',
    ],
    validPatterns: [/\.filter\s*\(\s*\([^)]*\)\s*:\s*\w+\s+is/, /metadata\s*!==\s*undefined/],
    tags: ['filter', 'type-predicate', 'optional', 'typed-array'],
  },
  {
    id: 'ts-arr-filter-narrow-union',
    category: 'Typed Array Operations',
    difficulty: 'hard',
    title: 'Filter and Narrow Union Array',
    text: 'Filter discriminated union array to specific variant and access its unique property',
    setup:
      'type Event = { type: "click"; x: number; y: number } | { type: "keypress"; key: string } | { type: "scroll"; delta: number };\nconst events: Event[] = [{ type: "click", x: 10, y: 20 }, { type: "keypress", key: "a" }, { type: "click", x: 30, y: 40 }];',
    setupCode:
      'type Event = { type: "click"; x: number; y: number } | { type: "keypress"; key: string } | { type: "scroll"; delta: number };\nconst events: Event[] = [{ type: "click", x: 10, y: 20 }, { type: "keypress", key: "a" }, { type: "click", x: 30, y: 40 }];',
    expected: [10, 30],
    sample:
      'events.filter((e): e is Extract<Event, { type: "click" }> => e.type === "click").map(e => e.x)',
    hints: ['Extract pulls specific variant from union', 'After filter, only click events remain'],
    validPatterns: [
      /\.filter\s*\(\s*\([^)]*\)\s*:\s*\w+\s+is\s+Extract/,
      /type\s*===?\s*["']click["']/,
    ],
    tags: ['filter', 'type-predicate', 'discriminated-union', 'typed-array'],
  },
  {
    id: 'ts-arr-filter-chain-narrow',
    category: 'Typed Array Operations',
    difficulty: 'hard',
    title: 'Chained Filter with Type Narrowing',
    text: 'Chain multiple filters with type predicates to progressively narrow the type',
    setup:
      'interface User { id: number; name?: string; email?: string; verified?: boolean }\nconst users: User[] = [{ id: 1, name: "Alice", email: "a@test.com", verified: true }, { id: 2, name: "Bob" }, { id: 3, email: "c@test.com", verified: true }, { id: 4, name: "Dave", email: "d@test.com", verified: true }];',
    setupCode:
      'interface User { id: number; name?: string; email?: string; verified?: boolean }\nconst users: User[] = [{ id: 1, name: "Alice", email: "a@test.com", verified: true }, { id: 2, name: "Bob" }, { id: 3, email: "c@test.com", verified: true }, { id: 4, name: "Dave", email: "d@test.com", verified: true }];',
    expected: ['Alice', 'Dave'],
    sample:
      'users.filter((u): u is User & { name: string } => u.name !== undefined).filter((u): u is User & { name: string; verified: true } => u.verified === true).map(u => u.name)',
    hints: ['Each filter narrows the type further', 'Intersection types accumulate requirements'],
    validPatterns: [/\.filter\s*\([^)]+\)\.filter\s*\(/, /u\s+is\s+User\s*&/],
    tags: ['filter', 'chaining', 'progressive-narrowing', 'typed-array'],
  },

  // ============================================================
  // Module & Declaration Patterns
  // ============================================================
  {
    id: 'ts-module-001',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Basic Named Export',
    text: 'Create a named export for the add function that takes two numbers and returns their sum',
    setup: '// Write your export statement',
    setupCode: '// Write your export statement',
    expected: 'export function add(a: number, b: number): number { return a + b; }',
    sample: 'export function add(a: number, b: number): number { return a + b; }',
    hints: [
      'Use the export keyword before function',
      'Named exports use the function name as the export name',
    ],
    tags: ['modules', 'export', 'named-export'],
  },
  {
    id: 'ts-module-002',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Named Import Statement',
    text: 'Import the multiply function from the ./math module',
    setup: '// Import multiply from ./math',
    setupCode: '// Import multiply from ./math',
    expected: 'import { multiply } from "./math";',
    sample: 'import { multiply } from "./math";',
    hints: ['Use curly braces for named imports', 'The module path should be in quotes'],
    tags: ['modules', 'import', 'named-import'],
  },
  {
    id: 'ts-module-003',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Default Export',
    text: 'Create a default export for a Calculator class',
    setup: 'class Calculator { add(a: number, b: number) { return a + b; } }',
    setupCode: 'class Calculator { add(a: number, b: number) { return a + b; } }',
    expected: 'export default Calculator',
    sample: 'export default Calculator;',
    hints: ['Use export default for the main export', 'Only one default export per module'],
    tags: ['modules', 'export', 'default-export'],
  },
  {
    id: 'ts-module-004',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Import Default Export',
    text: 'Import the default export from ./Calculator module',
    setup: '// Import default Calculator',
    setupCode: '// Import default Calculator',
    expected: 'import Calculator from "./Calculator";',
    sample: 'import Calculator from "./Calculator";',
    hints: ['Default imports do not use curly braces', 'You can name the import anything you want'],
    tags: ['modules', 'import', 'default-import'],
  },
  {
    id: 'ts-module-005',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Type-Only Import',
    text: 'Import only the User type from ./types module using type-only import syntax',
    setup: '// Import only the type, not the value',
    setupCode: '// Import only the type, not the value',
    expected: 'import type { User } from "./types";',
    sample: 'import type { User } from "./types";',
    hints: [
      'Use import type for type-only imports',
      'Type-only imports are erased at compile time',
    ],
    tags: ['modules', 'import', 'type-only-import'],
  },
  {
    id: 'ts-module-006',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Export Type',
    text: 'Export a type alias called Point that has x and y number properties',
    setup: '// Export a Point type',
    setupCode: '// Export a Point type',
    expected: 'export type Point = { x: number; y: number };',
    sample: 'export type Point = { x: number; y: number };',
    hints: ['Use export type for type exports', 'Type aliases use the type keyword'],
    tags: ['modules', 'export', 'type-export'],
  },
  {
    id: 'ts-module-007',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Export Interface',
    text: 'Export an interface called Config with a name string property',
    setup: '// Export a Config interface',
    setupCode: '// Export a Config interface',
    expected: 'export interface Config { name: string; }',
    sample: 'export interface Config { name: string; }',
    hints: ['Interfaces can be exported directly', 'Use the export keyword before interface'],
    tags: ['modules', 'export', 'interface-export'],
  },
  {
    id: 'ts-module-008',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Aliased Import',
    text: 'Import the utils function as helpers from ./utilities',
    setup: '// Import utils as helpers',
    setupCode: '// Import utils as helpers',
    expected: 'import { utils as helpers } from "./utilities";',
    sample: 'import { utils as helpers } from "./utilities";',
    hints: ['Use the as keyword to rename imports', 'The original name comes before as'],
    tags: ['modules', 'import', 'alias'],
  },
  {
    id: 'ts-module-009',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Namespace Import',
    text: 'Import all exports from ./math as a namespace called MathUtils',
    setup: '// Import everything as MathUtils',
    setupCode: '// Import everything as MathUtils',
    expected: 'import * as MathUtils from "./math";',
    sample: 'import * as MathUtils from "./math";',
    hints: ['Use * as to import everything', 'Access exports via MathUtils.functionName'],
    tags: ['modules', 'import', 'namespace-import'],
  },
  {
    id: 'ts-module-010',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Re-export Named Export',
    text: 'Re-export the format function from ./formatter module',
    setup: '// Re-export format from ./formatter',
    setupCode: '// Re-export format from ./formatter',
    expected: 'export { format } from "./formatter";',
    sample: 'export { format } from "./formatter";',
    hints: ['Combine export and from in one statement', 'No import keyword needed for re-exports'],
    tags: ['modules', 'export', 're-export'],
  },
  {
    id: 'ts-module-011',
    category: 'Declarations',
    difficulty: 'easy',
    title: 'Declare Variable',
    text: 'Declare an ambient variable VERSION of type string',
    setup: '// Declare VERSION exists globally',
    setupCode: '// Declare VERSION exists globally',
    expected: 'declare const VERSION: string;',
    sample: 'declare const VERSION: string;',
    hints: ['Use declare for ambient declarations', 'No value assignment in ambient declarations'],
    tags: ['declarations', 'declare', 'ambient'],
  },
  {
    id: 'ts-module-012',
    category: 'Declarations',
    difficulty: 'easy',
    title: 'Declare Function',
    text: 'Declare an ambient function called log that accepts a message string and returns void',
    setup: '// Declare log function',
    setupCode: '// Declare log function',
    expected: 'declare function log(message: string): void;',
    sample: 'declare function log(message: string): void;',
    hints: [
      'declare function defines function signature only',
      'No function body in ambient declarations',
    ],
    tags: ['declarations', 'declare', 'function'],
  },
  {
    id: 'ts-module-013',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Export Constant',
    text: 'Export a constant called PI with value 3.14159',
    setup: '// Export PI constant',
    setupCode: '// Export PI constant',
    expected: 'export const PI = 3.14159;',
    sample: 'export const PI = 3.14159;',
    hints: ['Use export const for constant exports', 'TypeScript infers the type from the value'],
    tags: ['modules', 'export', 'constant'],
  },
  {
    id: 'ts-module-014',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Import Multiple Named Exports',
    text: 'Import add, subtract, and multiply functions from ./math module',
    setup: '// Import multiple functions',
    setupCode: '// Import multiple functions',
    expected: 'import { add, subtract, multiply } from "./math";',
    sample: 'import { add, subtract, multiply } from "./math";',
    hints: ['Separate multiple imports with commas', 'All names go inside the curly braces'],
    tags: ['modules', 'import', 'multiple'],
  },
  {
    id: 'ts-module-015',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Export List',
    text: 'Export firstName and lastName variables that are already defined',
    setup: 'const firstName = "John";\nconst lastName = "Doe";',
    setupCode: 'const firstName = "John";\nconst lastName = "Doe";',
    expected: 'export { firstName, lastName };',
    sample: 'export { firstName, lastName };',
    hints: [
      'Use export list syntax for existing variables',
      'Curly braces contain the names to export',
    ],
    tags: ['modules', 'export', 'export-list'],
  },
  {
    id: 'ts-module-016',
    category: 'Declarations',
    difficulty: 'easy',
    title: 'Declare Class',
    text: 'Declare an ambient class called Logger with a log method accepting string',
    setup: '// Declare Logger class',
    setupCode: '// Declare Logger class',
    expected: 'declare class Logger { log(message: string): void; }',
    sample: 'declare class Logger { log(message: string): void; }',
    hints: ['declare class defines class shape only', 'Methods have signatures but no body'],
    tags: ['declarations', 'declare', 'class'],
  },
  {
    id: 'ts-module-017',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Side Effect Import',
    text: 'Import the ./polyfills module for its side effects only',
    setup: '// Import for side effects only',
    setupCode: '// Import for side effects only',
    expected: 'import "./polyfills";',
    sample: 'import "./polyfills";',
    hints: [
      'Omit the import clause for side-effect imports',
      'The module code runs but nothing is imported',
    ],
    tags: ['modules', 'import', 'side-effect'],
  },
  {
    id: 'ts-module-018',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Type-Only Re-export',
    text: 'Re-export only the types UserType and ConfigType from ./types',
    setup: '// Re-export types only',
    setupCode: '// Re-export types only',
    expected: 'export type { UserType, ConfigType } from "./types";',
    sample: 'export type { UserType, ConfigType } from "./types";',
    hints: ['Use export type for type-only re-exports', 'These are erased at compile time'],
    tags: ['modules', 'export', 'type-only-export'],
  },
  {
    id: 'ts-module-019',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Import Default and Named',
    text: 'Import default export as React and named export Component from "react"',
    setup: '// Import React and Component',
    setupCode: '// Import React and Component',
    expected: 'import React, { Component } from "react";',
    sample: 'import React, { Component } from "react";',
    hints: [
      'Default import comes first, then named imports',
      'Separate with comma before curly braces',
    ],
    tags: ['modules', 'import', 'mixed-import'],
  },
  {
    id: 'ts-module-020',
    category: 'Declarations',
    difficulty: 'easy',
    title: 'Declare Namespace',
    text: 'Declare a namespace called MyApp with a version string property',
    setup: '// Declare MyApp namespace',
    setupCode: '// Declare MyApp namespace',
    expected: 'declare namespace MyApp { const version: string; }',
    sample: 'declare namespace MyApp { const version: string; }',
    hints: [
      'Namespaces group related declarations',
      'Use declare namespace for ambient namespaces',
    ],
    tags: ['declarations', 'namespace', 'declare'],
  },
  {
    id: 'ts-module-021',
    category: 'Modules',
    difficulty: 'medium',
    title: 'Module Augmentation',
    text: 'Augment the express module to add a user property of type User to the Request interface',
    setup: 'interface User { id: string; name: string; }',
    setupCode: 'interface User { id: string; name: string; }',
    expected: 'declare module "express" { interface Request { user: User; } }',
    sample: 'declare module "express" { interface Request { user: User; } }',
    hints: [
      'Use declare module to augment existing modules',
      'Interface declarations merge automatically',
    ],
    tags: ['modules', 'augmentation', 'declaration-merging'],
  },
  {
    id: 'ts-module-022',
    category: 'Namespaces',
    difficulty: 'medium',
    title: 'Declaration Merging with Interface',
    text: 'Create a Box interface and a Box namespace that adds a create function',
    setup: '// Merge interface and namespace',
    setupCode: '// Merge interface and namespace',
    expected:
      'interface Box { width: number; height: number; }\nnamespace Box { export function create(): Box { return { width: 0, height: 0 }; } }',
    sample:
      'interface Box { width: number; height: number; }\nnamespace Box { export function create(): Box { return { width: 0, height: 0 }; } }',
    hints: ['Same name allows declaration merging', 'Namespace adds static members to interface'],
    tags: ['namespaces', 'declaration-merging', 'interface'],
  },
  {
    id: 'ts-module-023',
    category: 'Modules',
    difficulty: 'medium',
    title: 'Global Augmentation',
    text: 'Add a globalConfig property of type Config to the global scope',
    setup: 'interface Config { debug: boolean; }',
    setupCode: 'interface Config { debug: boolean; }',
    expected: 'declare global { var globalConfig: Config; }',
    sample: 'declare global { var globalConfig: Config; }',
    hints: [
      'Use declare global for global augmentation',
      'Must be inside a module (file with import/export)',
    ],
    tags: ['modules', 'global-augmentation', 'declare'],
  },
  {
    id: 'ts-module-024',
    category: 'Declarations',
    difficulty: 'medium',
    title: 'Ambient Module Declaration',
    text: 'Declare a module for *.css files that exports a default object with className strings',
    setup: '// Declare CSS module type',
    setupCode: '// Declare CSS module type',
    expected:
      'declare module "*.css" { const classes: { [key: string]: string }; export default classes; }',
    sample:
      'declare module "*.css" { const classes: { [key: string]: string }; export default classes; }',
    hints: ['Use wildcard patterns for file types', 'Default export for CSS modules'],
    tags: ['declarations', 'ambient-module', 'wildcard'],
  },
  {
    id: 'ts-module-025',
    category: 'Modules',
    difficulty: 'medium',
    title: 'Re-export with Alias',
    text: 'Re-export the default export from ./Button as ButtonComponent',
    setup: '// Re-export default as named',
    setupCode: '// Re-export default as named',
    expected: 'export { default as ButtonComponent } from "./Button";',
    sample: 'export { default as ButtonComponent } from "./Button";',
    hints: ['Use default as to rename default exports', 'This converts default to named export'],
    tags: ['modules', 're-export', 'alias'],
  },
  {
    id: 'ts-module-026',
    category: 'Declarations',
    difficulty: 'medium',
    title: 'Triple-Slash Reference',
    text: 'Add a triple-slash reference to include types from ./global.d.ts',
    setup: '// Reference types file',
    setupCode: '// Reference types file',
    expected: '/// <reference path="./global.d.ts" />',
    sample: '/// <reference path="./global.d.ts" />',
    hints: [
      'Triple-slash directives must be at file top',
      'Use reference path for local type files',
    ],
    tags: ['declarations', 'triple-slash', 'reference'],
  },
  {
    id: 'ts-module-027',
    category: 'Declarations',
    difficulty: 'medium',
    title: 'Reference Types Package',
    text: 'Add a triple-slash reference to include types from @types/node',
    setup: '// Reference node types',
    setupCode: '// Reference node types',
    expected: '/// <reference types="node" />',
    sample: '/// <reference types="node" />',
    hints: ['Use reference types for @types packages', 'Omit the @types/ prefix'],
    tags: ['declarations', 'triple-slash', 'types-package'],
  },
  {
    id: 'ts-module-028',
    category: 'Modules',
    difficulty: 'medium',
    title: 'Export All from Module',
    text: 'Re-export all exports from ./helpers module',
    setup: '// Re-export everything',
    setupCode: '// Re-export everything',
    expected: 'export * from "./helpers";',
    sample: 'export * from "./helpers";',
    hints: ['Use export * to re-export all named exports', 'Does not include default export'],
    tags: ['modules', 're-export', 'barrel'],
  },
  {
    id: 'ts-module-029',
    category: 'Modules',
    difficulty: 'medium',
    title: 'Export All as Namespace',
    text: 'Re-export all exports from ./validators as a namespace called Validators',
    setup: '// Re-export all as namespace',
    setupCode: '// Re-export all as namespace',
    expected: 'export * as Validators from "./validators";',
    sample: 'export * as Validators from "./validators";',
    hints: ['export * as creates a namespace export', 'Access via Validators.functionName'],
    tags: ['modules', 're-export', 'namespace'],
  },
  {
    id: 'ts-module-030',
    category: 'Declarations',
    difficulty: 'medium',
    title: 'Declare Module with Types',
    text: 'Declare a module "my-lib" that exports a Config interface and configure function',
    setup: '// Declare my-lib module',
    setupCode: '// Declare my-lib module',
    expected:
      'declare module "my-lib" { export interface Config { name: string; } export function configure(config: Config): void; }',
    sample:
      'declare module "my-lib" { export interface Config { name: string; } export function configure(config: Config): void; }',
    hints: [
      'Use declare module for ambient modules',
      'Export interfaces and functions normally inside',
    ],
    tags: ['declarations', 'ambient-module', 'types'],
  },
  {
    id: 'ts-module-031',
    category: 'Namespaces',
    difficulty: 'medium',
    title: 'Nested Namespace',
    text: 'Create a namespace App with nested namespace Utils containing a format function',
    setup: '// Create nested namespaces',
    setupCode: '// Create nested namespaces',
    expected:
      'namespace App { export namespace Utils { export function format(s: string): string { return s.trim(); } } }',
    sample:
      'namespace App { export namespace Utils { export function format(s: string): string { return s.trim(); } } }',
    hints: ['Namespaces can be nested', 'Export inner namespace to make it accessible'],
    tags: ['namespaces', 'nested', 'organization'],
  },
  {
    id: 'ts-module-032',
    category: 'Declarations',
    difficulty: 'medium',
    title: 'Declare Global Function',
    text: 'Declare that a global function gtag exists with specific signature for Google Analytics',
    setup: '// Declare gtag function globally',
    setupCode: '// Declare gtag function globally',
    expected: 'declare function gtag(command: string, ...args: unknown[]): void;',
    sample: 'declare function gtag(command: string, ...args: unknown[]): void;',
    hints: ['Global functions use declare function', 'Rest parameters handle variable arguments'],
    tags: ['declarations', 'global', 'function'],
  },
  {
    id: 'ts-module-033',
    category: 'Modules',
    difficulty: 'medium',
    title: 'Inline Type Import',
    text: 'Import a value and use inline type import for the UserProps type from ./user',
    setup: '// Import value and type separately',
    setupCode: '// Import value and type separately',
    expected: 'import { User, type UserProps } from "./user";',
    sample: 'import { User, type UserProps } from "./user";',
    hints: ['Use type keyword inline for individual imports', 'Mixes value and type imports'],
    tags: ['modules', 'import', 'inline-type'],
  },
  {
    id: 'ts-module-034',
    category: 'Namespaces',
    difficulty: 'medium',
    title: 'Namespace with Class',
    text: 'Create a namespace Shapes with an exported Circle class',
    setup: '// Create Shapes namespace',
    setupCode: '// Create Shapes namespace',
    expected:
      'namespace Shapes { export class Circle { constructor(public radius: number) {} area() { return Math.PI * this.radius ** 2; } } }',
    sample:
      'namespace Shapes { export class Circle { constructor(public radius: number) {} area() { return Math.PI * this.radius ** 2; } } }',
    hints: ['Classes can be exported from namespaces', 'Access via Shapes.Circle'],
    tags: ['namespaces', 'class', 'export'],
  },
  {
    id: 'ts-module-035',
    category: 'Declarations',
    difficulty: 'medium',
    title: 'Declare Enum',
    text: 'Declare an ambient const enum called Direction with North, South, East, West',
    setup: '// Declare Direction enum',
    setupCode: '// Declare Direction enum',
    expected: 'declare const enum Direction { North, South, East, West }',
    sample: 'declare const enum Direction { North, South, East, West }',
    hints: [
      'declare const enum is inlined at compile time',
      'Values are not needed in ambient enums',
    ],
    tags: ['declarations', 'enum', 'const-enum'],
  },
  {
    id: 'ts-module-036',
    category: 'Modules',
    difficulty: 'medium',
    title: 'Dynamic Import Type',
    text: 'Create a type for the dynamically imported Button module',
    setup: '// Type for dynamic import',
    setupCode: '// Type for dynamic import',
    expected: 'type ButtonModule = typeof import("./Button");',
    sample: 'type ButtonModule = typeof import("./Button");',
    hints: ['typeof import() gets the module type', 'Useful for lazy loading type checking'],
    tags: ['modules', 'dynamic-import', 'typeof'],
  },
  {
    id: 'ts-module-037',
    category: 'Declarations',
    difficulty: 'medium',
    title: 'Declare Window Extension',
    text: 'Extend the Window interface to include an analytics property',
    setup: 'interface Analytics { track(event: string): void; }',
    setupCode: 'interface Analytics { track(event: string): void; }',
    expected: 'declare global { interface Window { analytics: Analytics; } }',
    sample: 'declare global { interface Window { analytics: Analytics; } }',
    hints: ['Window is a global interface', 'Use declare global to extend it'],
    tags: ['declarations', 'global', 'window'],
  },
  {
    id: 'ts-module-038',
    category: 'Modules',
    difficulty: 'medium',
    title: 'Conditional Export Type',
    text: 'Export a type that extracts the return type of the exported function from a module',
    setup: 'export function getData(): Promise<string[]> { return Promise.resolve([]); }',
    setupCode: 'export function getData(): Promise<string[]> { return Promise.resolve([]); }',
    expected: 'export type DataResult = Awaited<ReturnType<typeof getData>>;',
    sample: 'export type DataResult = Awaited<ReturnType<typeof getData>>;',
    hints: ['Use ReturnType to extract function return type', 'Awaited unwraps Promise types'],
    tags: ['modules', 'export', 'utility-types'],
  },
  {
    id: 'ts-module-039',
    category: 'Declarations',
    difficulty: 'medium',
    title: 'Ambient Variable with Union',
    text: 'Declare a global ENV variable that can be "development", "staging", or "production"',
    setup: '// Declare ENV variable',
    setupCode: '// Declare ENV variable',
    expected: 'declare const ENV: "development" | "staging" | "production";',
    sample: 'declare const ENV: "development" | "staging" | "production";',
    hints: ['Use literal union types for specific values', 'declare const for immutable globals'],
    tags: ['declarations', 'ambient', 'literal-types'],
  },
  {
    id: 'ts-module-040',
    category: 'Namespaces',
    difficulty: 'medium',
    title: 'Namespace Alias',
    text: 'Create an alias IO for the deeply nested App.Services.IO namespace',
    setup:
      'namespace App { export namespace Services { export namespace IO { export function read(): string { return ""; } } } }',
    setupCode:
      'namespace App { export namespace Services { export namespace IO { export function read(): string { return ""; } } } }',
    expected: 'import IO = App.Services.IO;',
    sample: 'import IO = App.Services.IO;',
    hints: ['import = creates namespace aliases', 'Simplifies access to nested namespaces'],
    tags: ['namespaces', 'alias', 'import'],
  },
  {
    id: 'ts-module-041',
    category: 'Modules',
    difficulty: 'medium',
    title: 'Assert Module Type',
    text: 'Import JSON data with type assertion for import attributes',
    setup: '// Import JSON with assertion',
    setupCode: '// Import JSON with assertion',
    expected: 'import data from "./config.json" with { type: "json" };',
    sample: 'import data from "./config.json" with { type: "json" };',
    hints: ['Import attributes use with clause', 'type: "json" asserts JSON module type'],
    tags: ['modules', 'import', 'assertion'],
  },
  {
    id: 'ts-module-042',
    category: 'Declarations',
    difficulty: 'medium',
    title: 'Module Declaration for Images',
    text: 'Declare a module for *.png files that exports a string (the image URL)',
    setup: '// Declare PNG module',
    setupCode: '// Declare PNG module',
    expected: 'declare module "*.png" { const src: string; export default src; }',
    sample: 'declare module "*.png" { const src: string; export default src; }',
    hints: ['Image imports typically resolve to URLs', 'Use wildcard for file extensions'],
    tags: ['declarations', 'ambient-module', 'assets'],
  },
  {
    id: 'ts-module-043',
    category: 'Modules',
    difficulty: 'hard',
    title: 'Augment Third-Party Module Types',
    text: 'Augment lodash to add a custom mixin function called deepFreeze',
    setup: '// Augment lodash module',
    setupCode: '// Augment lodash module',
    expected:
      'declare module "lodash" { interface LoDashStatic { deepFreeze<T>(obj: T): Readonly<T>; } }',
    sample:
      'declare module "lodash" { interface LoDashStatic { deepFreeze<T>(obj: T): Readonly<T>; } }',
    hints: ['Find the main interface to extend', 'LoDashStatic is the main lodash type'],
    tags: ['modules', 'augmentation', 'third-party'],
  },
  {
    id: 'ts-module-044',
    category: 'Declarations',
    difficulty: 'hard',
    title: 'Declare Global with Overloads',
    text: 'Declare a global fetch function with overloads for string and Request input',
    setup: '// Declare fetch overloads',
    setupCode: '// Declare fetch overloads',
    expected:
      'declare function fetch(url: string, init?: RequestInit): Promise<Response>;\ndeclare function fetch(input: Request, init?: RequestInit): Promise<Response>;',
    sample:
      'declare function fetch(url: string, init?: RequestInit): Promise<Response>;\ndeclare function fetch(input: Request, init?: RequestInit): Promise<Response>;',
    hints: [
      'Multiple declare function statements for overloads',
      'Each overload has different parameter types',
    ],
    tags: ['declarations', 'overloads', 'global'],
  },
  {
    id: 'ts-module-045',
    category: 'Namespaces',
    difficulty: 'hard',
    title: 'Merge Class and Namespace',
    text: 'Create an Animal class and namespace that adds a static fromJSON factory method',
    setup: '// Merge class with namespace',
    setupCode: '// Merge class with namespace',
    expected:
      'class Animal { constructor(public name: string) {} }\nnamespace Animal { export function fromJSON(json: string): Animal { const data = JSON.parse(json); return new Animal(data.name); } }',
    sample:
      'class Animal { constructor(public name: string) {} }\nnamespace Animal { export function fromJSON(json: string): Animal { const data = JSON.parse(json); return new Animal(data.name); } }',
    hints: ['Namespaces merge with classes of same name', 'Adds static-like methods to the class'],
    tags: ['namespaces', 'declaration-merging', 'class'],
  },
  {
    id: 'ts-module-046',
    category: 'Modules',
    difficulty: 'hard',
    title: 'Generic Module Re-export',
    text: 'Create a barrel file that re-exports and renames generically typed components',
    setup: '// Re-export with generic type preservation',
    setupCode: '// Re-export with generic type preservation',
    expected:
      'export { List as GenericList } from "./List";\nexport type { ListProps as GenericListProps } from "./List";',
    sample:
      'export { List as GenericList } from "./List";\nexport type { ListProps as GenericListProps } from "./List";',
    hints: ['Generics are preserved in re-exports', 'Separate value and type re-exports'],
    tags: ['modules', 're-export', 'generics'],
  },
  {
    id: 'ts-module-047',
    category: 'Declarations',
    difficulty: 'hard',
    title: 'Declare Module with Generics',
    text: 'Declare a module "typed-storage" with get/set methods that preserve types',
    setup: '// Declare typed-storage module',
    setupCode: '// Declare typed-storage module',
    expected:
      'declare module "typed-storage" { export function get<T>(key: string): T | null; export function set<T>(key: string, value: T): void; }',
    sample:
      'declare module "typed-storage" { export function get<T>(key: string): T | null; export function set<T>(key: string, value: T): void; }',
    hints: ['Generic functions work in module declarations', 'Type parameter flows through usage'],
    tags: ['declarations', 'ambient-module', 'generics'],
  },
  {
    id: 'ts-module-048',
    category: 'Modules',
    difficulty: 'hard',
    title: 'Conditional Module Augmentation',
    text: 'Augment process.env to have strictly typed environment variables',
    setup: '// Type process.env variables',
    setupCode: '// Type process.env variables',
    expected:
      'declare global { namespace NodeJS { interface ProcessEnv { NODE_ENV: "development" | "production" | "test"; PORT?: string; DATABASE_URL: string; } } }',
    sample:
      'declare global { namespace NodeJS { interface ProcessEnv { NODE_ENV: "development" | "production" | "test"; PORT?: string; DATABASE_URL: string; } } }',
    hints: ['ProcessEnv is in NodeJS namespace', 'Use literal types for known values'],
    tags: ['modules', 'global-augmentation', 'node'],
  },
  {
    id: 'ts-module-049',
    category: 'Namespaces',
    difficulty: 'hard',
    title: 'Enum and Namespace Merge',
    text: 'Create a Status enum and merge with namespace to add helper functions',
    setup: '// Merge enum with namespace',
    setupCode: '// Merge enum with namespace',
    expected:
      'enum Status { Pending, Active, Completed }\nnamespace Status { export function isTerminal(status: Status): boolean { return status === Status.Completed; } }',
    sample:
      'enum Status { Pending, Active, Completed }\nnamespace Status { export function isTerminal(status: Status): boolean { return status === Status.Completed; } }',
    hints: ['Enums can merge with namespaces', 'Adds utility functions to enum'],
    tags: ['namespaces', 'declaration-merging', 'enum'],
  },
  {
    id: 'ts-module-050',
    category: 'Declarations',
    difficulty: 'hard',
    title: 'Complex Ambient Interface',
    text: 'Declare an ambient interface for a jQuery-like library with chainable methods',
    setup: '// Declare jQuery-like interface',
    setupCode: '// Declare jQuery-like interface',
    expected:
      'declare interface JQuery<T = HTMLElement> { addClass(className: string): this; removeClass(className: string): this; on(event: string, handler: (e: Event) => void): this; find(selector: string): JQuery<T>; }',
    sample:
      'declare interface JQuery<T = HTMLElement> { addClass(className: string): this; removeClass(className: string): this; on(event: string, handler: (e: Event) => void): this; find(selector: string): JQuery<T>; }',
    hints: ['Use this return type for chaining', 'Generic parameter for element type'],
    tags: ['declarations', 'interface', 'chainable'],
  },
  {
    id: 'ts-module-051',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Export Default Function',
    text: 'Export a default function called greet that takes a name and returns a greeting',
    setup: '// Export default function',
    setupCode: '// Export default function',
    expected: 'export default function greet(name: string): string { return `Hello, ${name}!`; }',
    sample: 'export default function greet(name: string): string { return `Hello, ${name}!`; }',
    hints: [
      'export default can be used with function declarations',
      'The function can be named or anonymous',
    ],
    tags: ['modules', 'export', 'default-function'],
  },
  {
    id: 'ts-module-052',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Export Default Class',
    text: 'Export a default class called Person with name property',
    setup: '// Export default class',
    setupCode: '// Export default class',
    expected: 'export default class Person { constructor(public name: string) {} }',
    sample: 'export default class Person { constructor(public name: string) {} }',
    hints: [
      'export default works directly with class declarations',
      'Parameter properties simplify constructor',
    ],
    tags: ['modules', 'export', 'default-class'],
  },
  {
    id: 'ts-module-053',
    category: 'Declarations',
    difficulty: 'easy',
    title: 'Declare Type Alias',
    text: 'Declare an ambient type alias ID that is a string',
    setup: '// Declare ID type',
    setupCode: '// Declare ID type',
    expected: 'declare type ID = string;',
    sample: 'declare type ID = string;',
    hints: ['declare type creates ambient type aliases', 'Useful in .d.ts files'],
    tags: ['declarations', 'type-alias', 'ambient'],
  },
  {
    id: 'ts-module-054',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Export Enum',
    text: 'Export an enum called Color with Red, Green, Blue values',
    setup: '// Export Color enum',
    setupCode: '// Export Color enum',
    expected: 'export enum Color { Red, Green, Blue }',
    sample: 'export enum Color { Red, Green, Blue }',
    hints: ['Enums can be exported directly', 'Values are auto-numbered from 0'],
    tags: ['modules', 'export', 'enum'],
  },
  {
    id: 'ts-module-055',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Import Enum',
    text: 'Import the Status enum from ./status module',
    setup: '// Import Status enum',
    setupCode: '// Import Status enum',
    expected: 'import { Status } from "./status";',
    sample: 'import { Status } from "./status";',
    hints: ['Enums are imported like regular values', 'They are both types and values'],
    tags: ['modules', 'import', 'enum'],
  },
  {
    id: 'ts-module-056',
    category: 'Declarations',
    difficulty: 'easy',
    title: 'Declare Interface',
    text: 'Declare an ambient interface called Point with x and y number properties',
    setup: '// Declare Point interface',
    setupCode: '// Declare Point interface',
    expected: 'declare interface Point { x: number; y: number; }',
    sample: 'declare interface Point { x: number; y: number; }',
    hints: ['declare interface for ambient interfaces', 'Commonly used in .d.ts files'],
    tags: ['declarations', 'interface', 'ambient'],
  },
  {
    id: 'ts-module-057',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Export As Clause',
    text: 'Export the internal _helper function as publicHelper',
    setup: 'function _helper() { return "help"; }',
    setupCode: 'function _helper() { return "help"; }',
    expected: 'export { _helper as publicHelper };',
    sample: 'export { _helper as publicHelper };',
    hints: ['Use as to rename during export', 'Internal names can be hidden'],
    tags: ['modules', 'export', 'alias'],
  },
  {
    id: 'ts-module-058',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Import Type Inline',
    text: 'Import only the Config type using inline type modifier from ./config',
    setup: '// Import Config as type',
    setupCode: '// Import Config as type',
    expected: 'import { type Config } from "./config";',
    sample: 'import { type Config } from "./config";',
    hints: ['type modifier before the import name', 'Erased during compilation'],
    tags: ['modules', 'import', 'inline-type'],
  },
  {
    id: 'ts-module-059',
    category: 'Declarations',
    difficulty: 'easy',
    title: 'Declare Let Variable',
    text: 'Declare an ambient mutable variable currentUser of type User or null',
    setup: 'interface User { name: string; }',
    setupCode: 'interface User { name: string; }',
    expected: 'declare let currentUser: User | null;',
    sample: 'declare let currentUser: User | null;',
    hints: ['Use declare let for mutable globals', 'Union with null for nullable variables'],
    tags: ['declarations', 'declare', 'let'],
  },
  {
    id: 'ts-module-060',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Re-export Default as Named',
    text: 'Re-export the default export from ./Modal as ModalDialog',
    setup: '// Re-export default as named',
    setupCode: '// Re-export default as named',
    expected: 'export { default as ModalDialog } from "./Modal";',
    sample: 'export { default as ModalDialog } from "./Modal";',
    hints: ['default can be used as identifier in re-exports', 'Converts default to named export'],
    tags: ['modules', 're-export', 'default-to-named'],
  },
  {
    id: 'ts-module-061',
    category: 'Namespaces',
    difficulty: 'medium',
    title: 'Namespace with Interface',
    text: 'Create a namespace API with an exported Response interface',
    setup: '// Create API namespace',
    setupCode: '// Create API namespace',
    expected:
      'namespace API { export interface Response<T> { data: T; status: number; message: string; } }',
    sample:
      'namespace API { export interface Response<T> { data: T; status: number; message: string; } }',
    hints: ['Interfaces can be exported from namespaces', 'Generics work inside namespaces'],
    tags: ['namespaces', 'interface', 'generics'],
  },
  {
    id: 'ts-module-062',
    category: 'Modules',
    difficulty: 'medium',
    title: 'Augment Array Prototype',
    text: 'Add a last() method to the Array interface that returns the last element',
    setup: '// Augment Array',
    setupCode: '// Augment Array',
    expected: 'declare global { interface Array<T> { last(): T | undefined; } }',
    sample: 'declare global { interface Array<T> { last(): T | undefined; } }',
    hints: ['Array is a global generic interface', 'Use declare global to extend'],
    tags: ['modules', 'global-augmentation', 'array'],
  },
  {
    id: 'ts-module-063',
    category: 'Declarations',
    difficulty: 'medium',
    title: 'Declare Class with Static',
    text: 'Declare an ambient class Math with static methods abs and sqrt',
    setup: '// Declare Math class',
    setupCode: '// Declare Math class',
    expected:
      'declare class Math { static abs(x: number): number; static sqrt(x: number): number; }',
    sample: 'declare class Math { static abs(x: number): number; static sqrt(x: number): number; }',
    hints: ['Static members use static keyword', 'No implementation in ambient declarations'],
    tags: ['declarations', 'class', 'static'],
  },
  {
    id: 'ts-module-064',
    category: 'Modules',
    difficulty: 'medium',
    title: 'Import JSON Module',
    text: 'Import a JSON configuration file with proper typing',
    setup: '// Import JSON with types',
    setupCode: '// Import JSON with types',
    expected: 'import config from "./config.json";\ntype ConfigType = typeof config;',
    sample: 'import config from "./config.json";\ntype ConfigType = typeof config;',
    hints: ['Enable resolveJsonModule in tsconfig', 'typeof extracts the inferred type'],
    tags: ['modules', 'import', 'json'],
  },
  {
    id: 'ts-module-065',
    category: 'Namespaces',
    difficulty: 'medium',
    title: 'Namespace Interface Merge',
    text: 'Merge a Vehicle interface with a Vehicle namespace containing a create function',
    setup: '// Merge Vehicle interface and namespace',
    setupCode: '// Merge Vehicle interface and namespace',
    expected:
      'interface Vehicle { wheels: number; brand: string; }\nnamespace Vehicle { export function create(brand: string, wheels: number): Vehicle { return { brand, wheels }; } }',
    sample:
      'interface Vehicle { wheels: number; brand: string; }\nnamespace Vehicle { export function create(brand: string, wheels: number): Vehicle { return { brand, wheels }; } }',
    hints: ['Same name enables merging', 'Namespace adds static utilities'],
    tags: ['namespaces', 'declaration-merging', 'factory'],
  },
  {
    id: 'ts-module-066',
    category: 'Declarations',
    difficulty: 'medium',
    title: 'Declare Constructor Type',
    text: 'Declare a constructor type for classes that can be instantiated with new',
    setup: '// Declare constructor type',
    setupCode: '// Declare constructor type',
    expected: 'declare type Constructor<T> = new (...args: unknown[]) => T;',
    sample: 'declare type Constructor<T> = new (...args: unknown[]) => T;',
    hints: ['new keyword in type indicates constructor', 'Generic for return instance type'],
    tags: ['declarations', 'constructor', 'generics'],
  },
  {
    id: 'ts-module-067',
    category: 'Modules',
    difficulty: 'medium',
    title: 'Export Type Query',
    text: 'Export a type that represents all keys of the exported Config object',
    setup: 'export const Config = { debug: true, version: "1.0", maxRetries: 3 };',
    setupCode: 'export const Config = { debug: true, version: "1.0", maxRetries: 3 };',
    expected: 'export type ConfigKeys = keyof typeof Config;',
    sample: 'export type ConfigKeys = keyof typeof Config;',
    hints: ['typeof gets the type of a value', 'keyof extracts the keys as a union'],
    tags: ['modules', 'export', 'keyof'],
  },
  {
    id: 'ts-module-068',
    category: 'Declarations',
    difficulty: 'medium',
    title: 'Declare Index Signature',
    text: 'Declare an ambient interface for a dictionary with string keys and number values',
    setup: '// Declare Dictionary interface',
    setupCode: '// Declare Dictionary interface',
    expected: 'declare interface NumberDict { [key: string]: number; }',
    sample: 'declare interface NumberDict { [key: string]: number; }',
    hints: ['Index signature uses [key: type]: valueType', 'All string keys map to numbers'],
    tags: ['declarations', 'interface', 'index-signature'],
  },
  {
    id: 'ts-module-069',
    category: 'Modules',
    difficulty: 'medium',
    title: 'Module Path Alias',
    text: 'Declare a path alias module @utils that maps to ./src/utils',
    setup: '// In .d.ts file: declare @utils module',
    setupCode: '// In .d.ts file: declare @utils module',
    expected: 'declare module "@utils" { export * from "./src/utils"; }',
    sample: 'declare module "@utils" { export * from "./src/utils"; }',
    hints: ['Path aliases need module declarations', 'Re-export actual module contents'],
    tags: ['modules', 'path-alias', 'declaration'],
  },
  {
    id: 'ts-module-070',
    category: 'Namespaces',
    difficulty: 'medium',
    title: 'Namespace with Types',
    text: 'Create a namespace Http with Status type and StatusCode interface',
    setup: '// Create Http namespace with types',
    setupCode: '// Create Http namespace with types',
    expected:
      'namespace Http { export type Status = "success" | "error" | "pending"; export interface StatusCode { code: number; message: string; } }',
    sample:
      'namespace Http { export type Status = "success" | "error" | "pending"; export interface StatusCode { code: number; message: string; } }',
    hints: ['Types and interfaces work in namespaces', 'Export makes them accessible outside'],
    tags: ['namespaces', 'types', 'interface'],
  },
  {
    id: 'ts-module-071',
    category: 'Declarations',
    difficulty: 'medium',
    title: 'Reference Lib Directive',
    text: 'Add a triple-slash reference to include ES2015 library definitions',
    setup: '// Reference ES2015 lib',
    setupCode: '// Reference ES2015 lib',
    expected: '/// <reference lib="es2015" />',
    sample: '/// <reference lib="es2015" />',
    hints: ['lib references include built-in type libs', 'Corresponds to tsconfig lib options'],
    tags: ['declarations', 'triple-slash', 'lib'],
  },
  {
    id: 'ts-module-072',
    category: 'Modules',
    difficulty: 'medium',
    title: 'Import Meta Type',
    text: 'Type the import.meta object to include custom properties',
    setup: '// Type import.meta',
    setupCode: '// Type import.meta',
    expected: 'interface ImportMeta { env: { MODE: string; BASE_URL: string }; }',
    sample: 'interface ImportMeta { env: { MODE: string; BASE_URL: string }; }',
    hints: ['ImportMeta is a special global interface', 'Used by bundlers like Vite'],
    tags: ['modules', 'import-meta', 'interface'],
  },
  {
    id: 'ts-module-073',
    category: 'Declarations',
    difficulty: 'hard',
    title: 'Declare Callable Interface',
    text: 'Declare an interface for a function that is also an object with methods',
    setup: '// Declare callable with properties',
    setupCode: '// Declare callable with properties',
    expected:
      'declare interface Logger { (message: string): void; level: "info" | "warn" | "error"; setLevel(level: Logger["level"]): void; }',
    sample:
      'declare interface Logger { (message: string): void; level: "info" | "warn" | "error"; setLevel(level: Logger["level"]): void; }',
    hints: ['Call signature makes interface callable', 'Add properties and methods as normal'],
    tags: ['declarations', 'interface', 'callable'],
  },
  {
    id: 'ts-module-074',
    category: 'Modules',
    difficulty: 'hard',
    title: 'Plugin Module Augmentation',
    text: 'Create a plugin system where plugins augment a Plugin interface',
    setup: 'interface Plugin { name: string; }',
    setupCode: 'interface Plugin { name: string; }',
    expected:
      'declare module "./core" { interface Plugin { hooks?: { beforeRun?: () => void; afterRun?: () => void }; } }',
    sample:
      'declare module "./core" { interface Plugin { hooks?: { beforeRun?: () => void; afterRun?: () => void }; } }',
    hints: [
      'Module augmentation extends existing interfaces',
      'Properties are merged into the interface',
    ],
    tags: ['modules', 'augmentation', 'plugin'],
  },
  {
    id: 'ts-module-075',
    category: 'Namespaces',
    difficulty: 'hard',
    title: 'Function and Namespace Merge',
    text: 'Create a function foo and namespace foo that adds configuration',
    setup: '// Merge function with namespace',
    setupCode: '// Merge function with namespace',
    expected:
      'function foo(x: number): number { return x * foo.multiplier; }\nnamespace foo { export let multiplier = 2; export function reset() { multiplier = 2; } }',
    sample:
      'function foo(x: number): number { return x * foo.multiplier; }\nnamespace foo { export let multiplier = 2; export function reset() { multiplier = 2; } }',
    hints: ['Functions can merge with namespaces', 'Adds properties to the function object'],
    tags: ['namespaces', 'declaration-merging', 'function'],
  },
  {
    id: 'ts-module-076',
    category: 'Declarations',
    difficulty: 'hard',
    title: 'Mapped Type in Declaration',
    text: 'Declare an ambient type that makes all properties of T optional and readonly',
    setup: '// Declare DeepPartial type',
    setupCode: '// Declare DeepPartial type',
    expected:
      'declare type DeepReadonlyPartial<T> = { readonly [P in keyof T]?: T[P] extends object ? DeepReadonlyPartial<T[P]> : T[P]; };',
    sample:
      'declare type DeepReadonlyPartial<T> = { readonly [P in keyof T]?: T[P] extends object ? DeepReadonlyPartial<T[P]> : T[P]; };',
    hints: ['Mapped types iterate over keys', 'Recursive for nested objects'],
    tags: ['declarations', 'mapped-types', 'recursive'],
  },
  {
    id: 'ts-module-077',
    category: 'Modules',
    difficulty: 'hard',
    title: 'Conditional Export Types',
    text: 'Export different types based on a configuration type parameter',
    setup: 'interface Config { strict: boolean; }',
    setupCode: 'interface Config { strict: boolean; }',
    expected:
      'export type ApiResponse<C extends Config> = C["strict"] extends true ? { data: unknown; errors: never } : { data: unknown; errors?: string[] };',
    sample:
      'export type ApiResponse<C extends Config> = C["strict"] extends true ? { data: unknown; errors: never } : { data: unknown; errors?: string[] };',
    hints: ['Conditional types use extends', 'Index access reads config properties'],
    tags: ['modules', 'export', 'conditional-types'],
  },
  {
    id: 'ts-module-078',
    category: 'Declarations',
    difficulty: 'hard',
    title: 'Declare Method Overloads',
    text: 'Declare a createElement function with overloads for different tag names',
    setup: '// Declare createElement overloads',
    setupCode: '// Declare createElement overloads',
    expected:
      'declare function createElement(tag: "div"): HTMLDivElement;\ndeclare function createElement(tag: "span"): HTMLSpanElement;\ndeclare function createElement(tag: string): HTMLElement;',
    sample:
      'declare function createElement(tag: "div"): HTMLDivElement;\ndeclare function createElement(tag: "span"): HTMLSpanElement;\ndeclare function createElement(tag: string): HTMLElement;',
    hints: ['Literal type overloads come first', 'General string overload is last'],
    tags: ['declarations', 'overloads', 'dom'],
  },
  {
    id: 'ts-module-079',
    category: 'Namespaces',
    difficulty: 'hard',
    title: 'Ambient Namespace Merge',
    text: 'Augment the global NodeJS namespace to add custom process properties',
    setup: '// Augment NodeJS namespace',
    setupCode: '// Augment NodeJS namespace',
    expected:
      'declare namespace NodeJS { interface Process { customProperty: string; customMethod(): void; } }',
    sample:
      'declare namespace NodeJS { interface Process { customProperty: string; customMethod(): void; } }',
    hints: ['NodeJS is a global namespace', 'Process interface can be extended'],
    tags: ['namespaces', 'ambient', 'node'],
  },
  {
    id: 'ts-module-080',
    category: 'Modules',
    difficulty: 'hard',
    title: 'Template Literal Module',
    text: 'Declare a module pattern for locale files using template literals',
    setup: '// Declare locale module pattern',
    setupCode: '// Declare locale module pattern',
    expected:
      'declare module `./locales/${string}.json` { const translations: Record<string, string>; export default translations; }',
    sample:
      'declare module `./locales/${string}.json` { const translations: Record<string, string>; export default translations; }',
    hints: ['Template literal modules match patterns', 'Useful for dynamic file imports'],
    tags: ['modules', 'ambient-module', 'template-literal'],
  },
  {
    id: 'ts-module-081',
    category: 'Declarations',
    difficulty: 'hard',
    title: 'Declare Hybrid Type',
    text: 'Declare an interface that acts as both a function and a constructor',
    setup: '// Declare hybrid function/constructor',
    setupCode: '// Declare hybrid function/constructor',
    expected:
      'declare interface DateConstructor { (): string; new (): Date; parse(s: string): number; UTC(...values: number[]): number; }',
    sample:
      'declare interface DateConstructor { (): string; new (): Date; parse(s: string): number; UTC(...values: number[]): number; }',
    hints: ['Call signature for function behavior', 'Construct signature for new behavior'],
    tags: ['declarations', 'interface', 'hybrid'],
  },
  {
    id: 'ts-module-082',
    category: 'Modules',
    difficulty: 'hard',
    title: 'Type-Safe Module Federation',
    text: 'Type a module federation remote module declaration',
    setup: '// Type federated module',
    setupCode: '// Type federated module',
    expected:
      'declare module "remote/Button" { import { FC } from "react"; interface ButtonProps { label: string; onClick: () => void; } const Button: FC<ButtonProps>; export default Button; }',
    sample:
      'declare module "remote/Button" { import { FC } from "react"; interface ButtonProps { label: string; onClick: () => void; } const Button: FC<ButtonProps>; export default Button; }',
    hints: [
      'Federated modules need explicit declarations',
      'Import types inside module declaration',
    ],
    tags: ['modules', 'federation', 'declaration'],
  },
  {
    id: 'ts-module-083',
    category: 'Namespaces',
    difficulty: 'hard',
    title: 'Global This Augmentation',
    text: 'Augment globalThis to add a custom app configuration',
    setup: 'interface AppConfig { name: string; version: string; }',
    setupCode: 'interface AppConfig { name: string; version: string; }',
    expected:
      'declare global { var __APP_CONFIG__: AppConfig; interface globalThis { __APP_CONFIG__: AppConfig; } }',
    sample:
      'declare global { var __APP_CONFIG__: AppConfig; interface globalThis { __APP_CONFIG__: AppConfig; } }',
    hints: ['globalThis interface for global properties', 'var declaration for runtime existence'],
    tags: ['namespaces', 'global-this', 'augmentation'],
  },
  {
    id: 'ts-module-084',
    category: 'Declarations',
    difficulty: 'hard',
    title: 'Declare Branded Type',
    text: 'Declare a branded type for validated email strings',
    setup: '// Declare ValidatedEmail type',
    setupCode: '// Declare ValidatedEmail type',
    expected:
      'declare const __brand: unique symbol;\ndeclare type ValidatedEmail = string & { readonly [__brand]: "ValidatedEmail" };',
    sample:
      'declare const __brand: unique symbol;\ndeclare type ValidatedEmail = string & { readonly [__brand]: "ValidatedEmail" };',
    hints: [
      'Branded types use intersection with unique symbol',
      'Prevents accidental type widening',
    ],
    tags: ['declarations', 'branded-types', 'type-safety'],
  },
  {
    id: 'ts-module-085',
    category: 'Modules',
    difficulty: 'hard',
    title: 'Infer Module Export Type',
    text: 'Create a type that extracts all exported types from a module',
    setup:
      'export const value = 1;\nexport type Type = string;\nexport interface Interface { x: number; }',
    setupCode:
      'export const value = 1;\nexport type Type = string;\nexport interface Interface { x: number; }',
    expected:
      'type ModuleExports = typeof import("./module");\ntype ExportedTypes = ModuleExports[keyof ModuleExports];',
    sample:
      'type ModuleExports = typeof import("./module");\ntype ExportedTypes = ModuleExports[keyof ModuleExports];',
    hints: ['typeof import gets module namespace type', 'Index with keyof for all exports'],
    tags: ['modules', 'typeof-import', 'inference'],
  },
  {
    id: 'ts-module-086',
    category: 'Declarations',
    difficulty: 'hard',
    title: 'Declare This Parameter',
    text: 'Declare a function that explicitly types its this context',
    setup: '// Declare function with this type',
    setupCode: '// Declare function with this type',
    expected:
      'declare interface Component { name: string; }\ndeclare function getName(this: Component): string;',
    sample:
      'declare interface Component { name: string; }\ndeclare function getName(this: Component): string;',
    hints: ['this parameter is a fake first parameter', 'Enforces correct call context'],
    tags: ['declarations', 'this', 'context'],
  },
  {
    id: 'ts-module-087',
    category: 'Modules',
    difficulty: 'medium',
    title: 'Export Type from Class',
    text: 'Export the instance type of a class as a separate type',
    setup: 'class User { constructor(public name: string, public age: number) {} }',
    setupCode: 'class User { constructor(public name: string, public age: number) {} }',
    expected: 'export { User };\nexport type UserInstance = InstanceType<typeof User>;',
    sample: 'export { User };\nexport type UserInstance = InstanceType<typeof User>;',
    hints: [
      'InstanceType extracts instance type from class',
      'typeof gets the class constructor type',
    ],
    tags: ['modules', 'export', 'instance-type'],
  },
  {
    id: 'ts-module-088',
    category: 'Namespaces',
    difficulty: 'medium',
    title: 'Namespace Constant Export',
    text: 'Create a namespace Constants with readonly exported values',
    setup: '// Create Constants namespace',
    setupCode: '// Create Constants namespace',
    expected:
      'namespace Constants { export const API_URL = "https://api.example.com" as const; export const TIMEOUT = 5000 as const; export const RETRIES = 3 as const; }',
    sample:
      'namespace Constants { export const API_URL = "https://api.example.com" as const; export const TIMEOUT = 5000 as const; export const RETRIES = 3 as const; }',
    hints: ['as const makes values literal types', 'Exports are accessible via namespace'],
    tags: ['namespaces', 'constants', 'as-const'],
  },
  {
    id: 'ts-module-089',
    category: 'Declarations',
    difficulty: 'medium',
    title: 'Declare Abstract Class',
    text: 'Declare an ambient abstract class Shape with abstract area method',
    setup: '// Declare abstract Shape',
    setupCode: '// Declare abstract Shape',
    expected:
      'declare abstract class Shape { abstract area(): number; abstract perimeter(): number; name: string; }',
    sample:
      'declare abstract class Shape { abstract area(): number; abstract perimeter(): number; name: string; }',
    hints: ['Abstract classes cannot be instantiated', 'Abstract methods have no implementation'],
    tags: ['declarations', 'abstract', 'class'],
  },
  {
    id: 'ts-module-090',
    category: 'Modules',
    difficulty: 'medium',
    title: 'Barrel Export Pattern',
    text: 'Create an index barrel file that re-exports from multiple modules',
    setup: '// Barrel file exports',
    setupCode: '// Barrel file exports',
    expected:
      'export * from "./user";\nexport * from "./product";\nexport * from "./order";\nexport { default as utils } from "./utils";',
    sample:
      'export * from "./user";\nexport * from "./product";\nexport * from "./order";\nexport { default as utils } from "./utils";',
    hints: ['Barrel files centralize exports', 'Mix export * with named re-exports'],
    tags: ['modules', 'barrel', 're-export'],
  },
  {
    id: 'ts-module-091',
    category: 'Declarations',
    difficulty: 'hard',
    title: 'Declare Variadic Tuple',
    text: 'Declare a function type that accepts variadic tuple parameters',
    setup: '// Declare variadic function',
    setupCode: '// Declare variadic function',
    expected:
      'declare function concat<T extends unknown[], U extends unknown[]>(arr1: [...T], arr2: [...U]): [...T, ...U];',
    sample:
      'declare function concat<T extends unknown[], U extends unknown[]>(arr1: [...T], arr2: [...U]): [...T, ...U];',
    hints: ['Spread in tuples for variadic types', 'Preserves tuple element types'],
    tags: ['declarations', 'variadic-tuple', 'generics'],
  },
  {
    id: 'ts-module-092',
    category: 'Modules',
    difficulty: 'hard',
    title: 'Recursive Module Type',
    text: 'Create a type for nested module structure with self-referencing exports',
    setup: '// Type nested modules',
    setupCode: '// Type nested modules',
    expected:
      'interface ModuleTree { [key: string]: ModuleTree | ((...args: unknown[]) => unknown); }\ndeclare const modules: ModuleTree;',
    sample:
      'interface ModuleTree { [key: string]: ModuleTree | ((...args: unknown[]) => unknown); }\ndeclare const modules: ModuleTree;',
    hints: ['Recursive interfaces for tree structures', 'Union with function type for leaves'],
    tags: ['modules', 'recursive', 'interface'],
  },
  {
    id: 'ts-module-093',
    category: 'Namespaces',
    difficulty: 'hard',
    title: 'Namespace with Generics',
    text: 'Create a namespace Collections with generic Stack and Queue classes',
    setup: '// Create Collections namespace',
    setupCode: '// Create Collections namespace',
    expected:
      'namespace Collections { export class Stack<T> { private items: T[] = []; push(item: T): void { this.items.push(item); } pop(): T | undefined { return this.items.pop(); } } export class Queue<T> { private items: T[] = []; enqueue(item: T): void { this.items.push(item); } dequeue(): T | undefined { return this.items.shift(); } } }',
    sample:
      'namespace Collections { export class Stack<T> { private items: T[] = []; push(item: T): void { this.items.push(item); } pop(): T | undefined { return this.items.pop(); } } export class Queue<T> { private items: T[] = []; enqueue(item: T): void { this.items.push(item); } dequeue(): T | undefined { return this.items.shift(); } } }',
    hints: ['Generic classes work in namespaces', 'Type parameter scoped to class'],
    tags: ['namespaces', 'generics', 'data-structures'],
  },
  {
    id: 'ts-module-094',
    category: 'Declarations',
    difficulty: 'hard',
    title: 'Declare Assertion Function',
    text: 'Declare an assertion function that narrows types',
    setup: '// Declare assertion function',
    setupCode: '// Declare assertion function',
    expected:
      'declare function assertIsString(value: unknown): asserts value is string;\ndeclare function assertNonNull<T>(value: T): asserts value is NonNullable<T>;',
    sample:
      'declare function assertIsString(value: unknown): asserts value is string;\ndeclare function assertNonNull<T>(value: T): asserts value is NonNullable<T>;',
    hints: ['asserts keyword for assertion functions', 'Narrows type after function call'],
    tags: ['declarations', 'assertion', 'type-narrowing'],
  },
  {
    id: 'ts-module-095',
    category: 'Modules',
    difficulty: 'hard',
    title: 'Module with Symbol Keys',
    text: 'Declare a module that exports unique symbols as keys',
    setup: '// Declare symbol-keyed module',
    setupCode: '// Declare symbol-keyed module',
    expected:
      'declare module "symbols" { export const ID: unique symbol; export const NAME: unique symbol; export interface Identifiable { [ID]: string; [NAME]: string; } }',
    sample:
      'declare module "symbols" { export const ID: unique symbol; export const NAME: unique symbol; export interface Identifiable { [ID]: string; [NAME]: string; } }',
    hints: ['unique symbol for distinct symbol types', 'Computed properties with symbol keys'],
    tags: ['modules', 'symbol', 'unique'],
  },
  {
    id: 'ts-module-096',
    category: 'Declarations',
    difficulty: 'easy',
    title: 'Declare Readonly Array',
    text: 'Declare an ambient readonly array of allowed roles',
    setup: '// Declare readonly roles array',
    setupCode: '// Declare readonly roles array',
    expected: 'declare const ROLES: readonly ["admin", "user", "guest"];',
    sample: 'declare const ROLES: readonly ["admin", "user", "guest"];',
    hints: ['readonly tuple for immutable arrays', 'Literal types preserve exact values'],
    tags: ['declarations', 'readonly', 'tuple'],
  },
  {
    id: 'ts-module-097',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Export Type Assertion',
    text: 'Export a const assertion object as a type',
    setup: 'const config = { env: "prod", debug: false } as const;',
    setupCode: 'const config = { env: "prod", debug: false } as const;',
    expected: 'export type Config = typeof config;',
    sample: 'export type Config = typeof config;',
    hints: ['as const makes properties readonly literals', 'typeof extracts the narrowed type'],
    tags: ['modules', 'export', 'as-const'],
  },
  {
    id: 'ts-module-098',
    category: 'Namespaces',
    difficulty: 'easy',
    title: 'Simple Namespace',
    text: 'Create a namespace Utils with add and multiply functions',
    setup: '// Create Utils namespace',
    setupCode: '// Create Utils namespace',
    expected:
      'namespace Utils { export function add(a: number, b: number): number { return a + b; } export function multiply(a: number, b: number): number { return a * b; } }',
    sample:
      'namespace Utils { export function add(a: number, b: number): number { return a + b; } export function multiply(a: number, b: number): number { return a * b; } }',
    hints: ['namespace groups related functions', 'export makes functions accessible'],
    tags: ['namespaces', 'basic', 'functions'],
  },
  {
    id: 'ts-module-099',
    category: 'Declarations',
    difficulty: 'medium',
    title: 'Declare Getter/Setter',
    text: 'Declare an interface with typed getters and setters',
    setup: '// Declare interface with accessors',
    setupCode: '// Declare interface with accessors',
    expected:
      'declare interface Person { get name(): string; set name(value: string); get age(): number; readonly id: string; }',
    sample:
      'declare interface Person { get name(): string; set name(value: string); get age(): number; readonly id: string; }',
    hints: ['get/set keywords for accessors', 'readonly for get-only properties'],
    tags: ['declarations', 'interface', 'accessors'],
  },
  {
    id: 'ts-module-100',
    category: 'Modules',
    difficulty: 'hard',
    title: 'Complete Module System',
    text: 'Create a complete module declaration with types, values, and namespace',
    setup: '// Complete module system',
    setupCode: '// Complete module system',
    expected:
      'declare module "complete-lib" { export interface Options { timeout: number; retries: number; } export type Status = "idle" | "loading" | "success" | "error"; export function init(options: Options): void; export function getStatus(): Status; export namespace internal { export function reset(): void; export const version: string; } export default { init, getStatus }; }',
    sample:
      'declare module "complete-lib" { export interface Options { timeout: number; retries: number; } export type Status = "idle" | "loading" | "success" | "error"; export function init(options: Options): void; export function getStatus(): Status; export namespace internal { export function reset(): void; export const version: string; } export default { init, getStatus }; }',
    hints: [
      'Combine interfaces, types, functions, and namespaces',
      'Default export for main API surface',
    ],
    tags: ['modules', 'complete', 'declaration'],
  },

  // ============================================================
  // Advanced Generics - Generic Functions
  // ============================================================
  {
    id: 'ts-generics-001',
    category: 'Advanced Generics',
    difficulty: 'easy',
    title: 'Basic Generic Identity Function',
    text: 'Create a generic identity function that returns the input value with its type preserved',
    setup: 'const value = 42;',
    setupCode: 'const value = 42;',
    expected: 42,
    sample: 'function identity<T>(arg: T): T { return arg; }\nidentity(value)',
    hints: [
      'Use a type parameter <T> to capture the input type',
      'The return type should match the input type',
    ],
    tags: ['generics', 'functions', 'identity'],
  },
  {
    id: 'ts-generics-002',
    category: 'Advanced Generics',
    difficulty: 'easy',
    title: 'Generic Array First Element',
    text: 'Create a generic function that returns the first element of an array',
    setup: 'const nums = [10, 20, 30];',
    setupCode: 'const nums = [10, 20, 30];',
    expected: 10,
    sample: 'function first<T>(arr: T[]): T | undefined { return arr[0]; }\nfirst(nums)',
    hints: [
      'The function should accept an array of any type',
      'Return type should be T | undefined for empty arrays',
    ],
    tags: ['generics', 'functions', 'arrays'],
  },
  {
    id: 'ts-generics-003',
    category: 'Advanced Generics',
    difficulty: 'easy',
    title: 'Generic Array Last Element',
    text: 'Create a generic function that returns the last element of an array',
    setup: 'const words = ["hello", "world", "typescript"];',
    setupCode: 'const words = ["hello", "world", "typescript"];',
    expected: 'typescript',
    sample:
      'function last<T>(arr: T[]): T | undefined { return arr[arr.length - 1]; }\nlast(words)',
    hints: [
      'Access the last element using arr.length - 1',
      'Generic type T preserves the element type',
    ],
    tags: ['generics', 'functions', 'arrays'],
  },
  {
    id: 'ts-generics-004',
    category: 'Advanced Generics',
    difficulty: 'easy',
    title: 'Generic Pair Creator',
    text: 'Create a generic function that creates a pair (tuple) from two values',
    setup: 'const a = "name"; const b = 42;',
    setupCode: 'const a = "name"; const b = 42;',
    expected: ['name', 42],
    sample:
      'function pair<T, U>(first: T, second: U): [T, U] { return [first, second]; }\npair(a, b)',
    hints: ['Use two type parameters T and U', 'Return type is a tuple [T, U]'],
    tags: ['generics', 'functions', 'tuples', 'multiple-type-params'],
  },
  {
    id: 'ts-generics-005',
    category: 'Advanced Generics',
    difficulty: 'easy',
    title: 'Generic Swap Function',
    text: 'Create a generic function that swaps the elements of a pair',
    setup: 'const original: [number, string] = [1, "one"];',
    setupCode: 'const original: [number, string] = [1, "one"];',
    expected: ['one', 1],
    sample:
      'function swap<T, U>(pair: [T, U]): [U, T] { return [pair[1], pair[0]]; }\nswap(original)',
    hints: ['Input is [T, U], output should be [U, T]', 'Destructure or index to swap elements'],
    tags: ['generics', 'functions', 'tuples'],
  },
  {
    id: 'ts-generics-006',
    category: 'Advanced Generics',
    difficulty: 'easy',
    title: 'Generic Wrapper Function',
    text: 'Create a generic function that wraps a value in an object with a value property',
    setup: 'const data = "wrapped";',
    setupCode: 'const data = "wrapped";',
    expected: { value: 'wrapped' },
    sample: 'function wrap<T>(value: T): { value: T } { return { value }; }\nwrap(data)',
    hints: ['Return an object with a value property', 'The value property type should be T'],
    tags: ['generics', 'functions', 'objects'],
  },
  {
    id: 'ts-generics-007',
    category: 'Advanced Generics',
    difficulty: 'easy',
    title: 'Generic Array Length',
    text: 'Create a generic function that returns the length of any array',
    setup: 'const items = [1, 2, 3, 4, 5];',
    setupCode: 'const items = [1, 2, 3, 4, 5];',
    expected: 5,
    sample: 'function len<T>(arr: T[]): number { return arr.length; }\nlen(items)',
    hints: ['Generic preserves array element type info', 'Return type is always number'],
    tags: ['generics', 'functions', 'arrays'],
  },
  {
    id: 'ts-generics-008',
    category: 'Advanced Generics',
    difficulty: 'easy',
    title: 'Generic Default Value',
    text: 'Create a generic function that returns a value or a default if the value is null/undefined',
    setup: 'const maybeValue: string | null = null; const defaultVal = "default";',
    setupCode: 'const maybeValue: string | null = null; const defaultVal = "default";',
    expected: 'default',
    sample:
      'function withDefault<T>(value: T | null | undefined, defaultValue: T): T { return value ?? defaultValue; }\nwithDefault(maybeValue, defaultVal)',
    hints: ['Use nullish coalescing operator ??', 'Both value and default should have same type T'],
    tags: ['generics', 'functions', 'nullish'],
  },
  {
    id: 'ts-generics-009',
    category: 'Advanced Generics',
    difficulty: 'easy',
    title: 'Generic Array Fill',
    text: 'Create a generic function that creates an array of n elements with the same value',
    setup: 'const count = 3; const item = "x";',
    setupCode: 'const count = 3; const item = "x";',
    expected: ['x', 'x', 'x'],
    sample:
      'function fill<T>(n: number, value: T): T[] { return Array(n).fill(value); }\nfill(count, item)',
    hints: ['Use Array(n).fill(value)', 'Return type is T[]'],
    tags: ['generics', 'functions', 'arrays'],
  },
  {
    id: 'ts-generics-010',
    category: 'Advanced Generics',
    difficulty: 'easy',
    title: 'Generic Reverse Array',
    text: 'Create a generic function that reverses an array without mutating the original',
    setup: 'const original = [1, 2, 3];',
    setupCode: 'const original = [1, 2, 3];',
    expected: [3, 2, 1],
    sample: 'function reverse<T>(arr: T[]): T[] { return [...arr].reverse(); }\nreverse(original)',
    hints: ['Spread the array first to avoid mutation', 'Then call reverse() on the copy'],
    tags: ['generics', 'functions', 'arrays', 'immutable'],
  },

  // ============================================================
  // Advanced Generics - Generic Interfaces
  // ============================================================
  {
    id: 'ts-generics-011',
    category: 'Advanced Generics',
    difficulty: 'easy',
    title: 'Generic Box Interface',
    text: 'Create a generic Box interface and instantiate it with a number',
    setup: 'interface Box<T> { contents: T; }',
    setupCode: 'interface Box<T> { contents: T; }',
    expected: { contents: 100 },
    sample: 'const box: Box<number> = { contents: 100 };\nbox',
    hints: [
      'Specify the type parameter when using the interface',
      'Box<number> means contents is a number',
    ],
    tags: ['generics', 'interfaces'],
  },
  {
    id: 'ts-generics-012',
    category: 'Advanced Generics',
    difficulty: 'easy',
    title: 'Generic Response Interface',
    text: 'Create a generic API response interface with data and status',
    setup: 'interface ApiResponse<T> { data: T; status: number; }',
    setupCode: 'interface ApiResponse<T> { data: T; status: number; }',
    expected: { data: { name: 'Alice' }, status: 200 },
    sample:
      'const response: ApiResponse<{ name: string }> = { data: { name: "Alice" }, status: 200 };\nresponse',
    hints: ['The data property type is determined by T', 'Status is always a number'],
    tags: ['generics', 'interfaces', 'api'],
  },
  {
    id: 'ts-generics-013',
    category: 'Advanced Generics',
    difficulty: 'easy',
    title: 'Generic Dictionary Interface',
    text: 'Create a generic dictionary interface mapping strings to values of type T',
    setup: 'interface Dictionary<T> { [key: string]: T; }',
    setupCode: 'interface Dictionary<T> { [key: string]: T; }',
    expected: { a: 1, b: 2, c: 3 },
    sample: 'const dict: Dictionary<number> = { a: 1, b: 2, c: 3 };\ndict',
    hints: [
      'Index signature [key: string]: T allows any string key',
      'All values must be of type T',
    ],
    tags: ['generics', 'interfaces', 'dictionary'],
  },
  {
    id: 'ts-generics-014',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic Result Interface',
    text: 'Create a generic Result type that represents success or failure',
    setup: 'type Result<T, E> = { ok: true; value: T } | { ok: false; error: E };',
    setupCode: 'type Result<T, E> = { ok: true; value: T } | { ok: false; error: E };',
    expected: { ok: true, value: 42 },
    sample: 'const success: Result<number, string> = { ok: true, value: 42 };\nsuccess',
    hints: [
      'Result is a discriminated union with ok as discriminant',
      'Two type parameters: T for success, E for error',
    ],
    tags: ['generics', 'interfaces', 'discriminated-union', 'result-type'],
  },
  {
    id: 'ts-generics-015',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic Linked List Node',
    text: 'Create a generic linked list node interface',
    setup: 'interface ListNode<T> { value: T; next: ListNode<T> | null; }',
    setupCode: 'interface ListNode<T> { value: T; next: ListNode<T> | null; }',
    expected: { value: 1, next: { value: 2, next: null } },
    sample: 'const node: ListNode<number> = { value: 1, next: { value: 2, next: null } };\nnode',
    hints: [
      'The interface references itself for the next property',
      'next can be null to indicate end of list',
    ],
    tags: ['generics', 'interfaces', 'linked-list', 'recursive'],
  },

  // ============================================================
  // Advanced Generics - Generic Constraints
  // ============================================================
  {
    id: 'ts-generics-016',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic with Length Constraint',
    text: 'Create a generic function that only accepts values with a length property',
    setup: 'const str = "hello"; const arr = [1, 2, 3];',
    setupCode: 'const str = "hello"; const arr = [1, 2, 3];',
    expected: 5,
    sample:
      'function getLength<T extends { length: number }>(arg: T): number { return arg.length; }\ngetLength(str)',
    hints: [
      'Use extends to constrain T to types with length',
      'Both strings and arrays have length property',
    ],
    tags: ['generics', 'constraints', 'extends'],
  },
  {
    id: 'ts-generics-017',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic Key Constraint',
    text: 'Create a generic function that gets a property from an object using a constrained key',
    setup: 'const person = { name: "Alice", age: 30 };',
    setupCode: 'const person = { name: "Alice", age: 30 };',
    expected: 'Alice',
    sample:
      'function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] { return obj[key]; }\ngetProperty(person, "name")',
    hints: [
      'K extends keyof T constrains K to valid keys of T',
      'Return type T[K] is the type of that property',
    ],
    tags: ['generics', 'constraints', 'keyof'],
  },
  {
    id: 'ts-generics-018',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic Number Constraint',
    text: 'Create a generic function that only accepts number types and doubles them',
    setup: 'const value = 21;',
    setupCode: 'const value = 21;',
    expected: 42,
    sample: 'function double<T extends number>(n: T): number { return n * 2; }\ndouble(value)',
    hints: [
      'T extends number constrains to numeric types',
      'Return type is number since multiplication returns number',
    ],
    tags: ['generics', 'constraints', 'number'],
  },
  {
    id: 'ts-generics-019',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic Array Element Constraint',
    text: 'Create a generic function that merges two arrays of compatible types',
    setup: 'const nums1 = [1, 2]; const nums2 = [3, 4];',
    setupCode: 'const nums1 = [1, 2]; const nums2 = [3, 4];',
    expected: [1, 2, 3, 4],
    sample:
      'function merge<T>(arr1: T[], arr2: T[]): T[] { return [...arr1, ...arr2]; }\nmerge(nums1, nums2)',
    hints: ['Both arrays must have the same element type T', 'Spread both arrays into a new array'],
    tags: ['generics', 'constraints', 'arrays'],
  },
  {
    id: 'ts-generics-020',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic Object Constraint',
    text: 'Create a generic function that only accepts objects (not primitives)',
    setup: 'const obj = { x: 10, y: 20 };',
    setupCode: 'const obj = { x: 10, y: 20 };',
    expected: ['x', 'y'],
    sample:
      'function keys<T extends object>(obj: T): (keyof T)[] { return Object.keys(obj) as (keyof T)[]; }\nkeys(obj)',
    hints: ['T extends object excludes primitive types', 'Cast Object.keys result to (keyof T)[]'],
    tags: ['generics', 'constraints', 'objects'],
  },
  {
    id: 'ts-generics-021',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Generic Constructor Constraint',
    text: 'Create a generic factory function that accepts a constructor and creates an instance',
    setup: 'class Point { constructor(public x: number, public y: number) {} }',
    setupCode: 'class Point { constructor(public x: number, public y: number) {} }',
    expected: { x: 5, y: 10 },
    sample:
      'function create<T>(ctor: new (x: number, y: number) => T, x: number, y: number): T { return new ctor(x, y); }\ncreate(Point, 5, 10)',
    hints: [
      'Use new (...args) => T to represent a constructor',
      'The constraint ensures ctor can be called with new',
    ],
    tags: ['generics', 'constraints', 'constructor', 'factory'],
  },
  {
    id: 'ts-generics-022',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Generic Multiple Constraints',
    text: 'Create a generic function with multiple constraints using intersection',
    setup:
      'interface Named { name: string; }\ninterface Aged { age: number; }\nconst person = { name: "Bob", age: 25 };',
    setupCode:
      'interface Named { name: string; }\ninterface Aged { age: number; }\nconst person = { name: "Bob", age: 25 };',
    expected: 'Bob is 25 years old',
    sample:
      'function describe<T extends Named & Aged>(entity: T): string { return `${entity.name} is ${entity.age} years old`; }\ndescribe(person)',
    hints: ['Use & to combine multiple constraints', 'T must have both name and age properties'],
    tags: ['generics', 'constraints', 'intersection'],
  },

  // ============================================================
  // Advanced Generics - Default Type Parameters
  // ============================================================
  {
    id: 'ts-generics-023',
    category: 'Advanced Generics',
    difficulty: 'easy',
    title: 'Generic with Default Type',
    text: 'Create a generic container type with a default type parameter of string',
    setup: 'type Container<T = string> = { value: T };',
    setupCode: 'type Container<T = string> = { value: T };',
    expected: { value: 'hello' },
    sample: 'const container: Container = { value: "hello" };\ncontainer',
    hints: [
      'T = string sets the default type',
      'When no type argument is provided, string is used',
    ],
    tags: ['generics', 'default-type', 'type-alias'],
  },
  {
    id: 'ts-generics-024',
    category: 'Advanced Generics',
    difficulty: 'easy',
    title: 'Generic Event Handler with Default',
    text: 'Create a generic event handler type with default event type',
    setup: 'type EventHandler<E = Event> = (event: E) => void;',
    setupCode: 'type EventHandler<E = Event> = (event: E) => void;',
    expected: 'function',
    sample:
      'const handler: EventHandler<MouseEvent> = (e) => console.log(e.clientX);\ntypeof handler',
    hints: ['Default type is Event', 'Can be overridden with specific event type'],
    tags: ['generics', 'default-type', 'events'],
  },
  {
    id: 'ts-generics-025',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic State with Default',
    text: 'Create a generic state container with default empty object type',
    setup: 'type State<T = {}> = { current: T; previous: T | null };',
    setupCode: 'type State<T = {}> = { current: T; previous: T | null };',
    expected: { current: { count: 0 }, previous: null },
    sample:
      'const state: State<{ count: number }> = { current: { count: 0 }, previous: null };\nstate',
    hints: ['Default type is empty object {}', 'Can be specialized with specific state shape'],
    tags: ['generics', 'default-type', 'state'],
  },
  {
    id: 'ts-generics-026',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic Map with Defaults',
    text: 'Create a generic map type with default key and value types',
    setup: 'type TypedMap<K = string, V = unknown> = Map<K, V>;',
    setupCode: 'type TypedMap<K = string, V = unknown> = Map<K, V>;',
    expected: 2,
    sample: 'const map: TypedMap<string, number> = new Map([["a", 1], ["b", 2]]);\nmap.size',
    hints: [
      'Multiple defaults: K defaults to string, V to unknown',
      'Can override one or both defaults',
    ],
    tags: ['generics', 'default-type', 'map'],
  },

  // ============================================================
  // Advanced Generics - Type Inference
  // ============================================================
  {
    id: 'ts-generics-027',
    category: 'Advanced Generics',
    difficulty: 'easy',
    title: 'Generic Type Inference Basic',
    text: 'Let TypeScript infer the generic type from the argument',
    setup: 'function identity<T>(arg: T): T { return arg; }',
    setupCode: 'function identity<T>(arg: T): T { return arg; }',
    expected: 'inferred',
    sample: 'identity("inferred")',
    hints: [
      'TypeScript can infer T from the argument type',
      'No need to explicitly specify <string>',
    ],
    tags: ['generics', 'inference'],
  },
  {
    id: 'ts-generics-028',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic Inference from Array',
    text: 'Let TypeScript infer the element type from an array literal',
    setup: 'function firstElement<T>(arr: T[]): T | undefined { return arr[0]; }',
    setupCode: 'function firstElement<T>(arr: T[]): T | undefined { return arr[0]; }',
    expected: 1,
    sample: 'firstElement([1, 2, 3])',
    hints: ['T is inferred as number from the array literal', 'Works with any array type'],
    tags: ['generics', 'inference', 'arrays'],
  },
  {
    id: 'ts-generics-029',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic Inference from Multiple Args',
    text: 'Infer type from multiple arguments of the same type',
    setup:
      'function longest<T extends { length: number }>(a: T, b: T): T { return a.length >= b.length ? a : b; }',
    setupCode:
      'function longest<T extends { length: number }>(a: T, b: T): T { return a.length >= b.length ? a : b; }',
    expected: 'longer',
    sample: 'longest("hi", "longer")',
    hints: ['Both arguments must be of the same type T', 'T is inferred from the common type'],
    tags: ['generics', 'inference', 'constraints'],
  },
  {
    id: 'ts-generics-030',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Infer Return Type from Callback',
    text: 'Create a generic function that infers the return type from a callback',
    setup: 'function map<T, U>(arr: T[], fn: (item: T) => U): U[] { return arr.map(fn); }',
    setupCode: 'function map<T, U>(arr: T[], fn: (item: T) => U): U[] { return arr.map(fn); }',
    expected: [2, 4, 6],
    sample: 'map([1, 2, 3], x => x * 2)',
    hints: ['T is inferred from the array elements', 'U is inferred from the callback return type'],
    tags: ['generics', 'inference', 'callbacks'],
  },

  // ============================================================
  // Advanced Generics - Conditional Types
  // ============================================================
  {
    id: 'ts-generics-031',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Basic Conditional Type',
    text: 'Create a conditional type that returns string if T is number, else T',
    setup: 'type Stringify<T> = T extends number ? string : T;',
    setupCode: 'type Stringify<T> = T extends number ? string : T;',
    expected: 'hello',
    sample: 'const result: Stringify<boolean> = true as any;\n"hello" as Stringify<number>',
    hints: [
      'T extends number checks if T is assignable to number',
      'Returns string for numbers, T otherwise',
    ],
    tags: ['generics', 'conditional-types'],
  },
  {
    id: 'ts-generics-032',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Conditional Type for Arrays',
    text: 'Create a type that extracts the element type if T is an array',
    setup: 'type Flatten<T> = T extends (infer U)[] ? U : T;',
    setupCode: 'type Flatten<T> = T extends (infer U)[] ? U : T;',
    expected: 42,
    sample: 'const val: Flatten<number[]> = 42;\nval',
    hints: ['Use infer to extract the array element type', 'Returns T unchanged if not an array'],
    tags: ['generics', 'conditional-types', 'infer'],
  },
  {
    id: 'ts-generics-033',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Conditional Type for Functions',
    text: 'Create a type that extracts the return type of a function',
    setup: 'type GetReturnType<T> = T extends (...args: any[]) => infer R ? R : never;',
    setupCode: 'type GetReturnType<T> = T extends (...args: any[]) => infer R ? R : never;',
    expected: 'number',
    sample: 'type Fn = () => number;\nconst returnType: GetReturnType<Fn> = 42;\ntypeof returnType',
    hints: ['Use infer R to capture the return type', 'Pattern matches function signature'],
    tags: ['generics', 'conditional-types', 'infer', 'functions'],
  },
  {
    id: 'ts-generics-034',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Conditional Type for Parameters',
    text: 'Create a type that extracts the first parameter type of a function',
    setup: 'type FirstParam<T> = T extends (first: infer F, ...rest: any[]) => any ? F : never;',
    setupCode:
      'type FirstParam<T> = T extends (first: infer F, ...rest: any[]) => any ? F : never;',
    expected: 'hello',
    sample:
      'type Fn = (s: string, n: number) => void;\nconst param: FirstParam<Fn> = "hello";\nparam',
    hints: ['Use infer F to capture the first parameter', 'Rest parameters handle remaining args'],
    tags: ['generics', 'conditional-types', 'infer', 'parameters'],
  },
  {
    id: 'ts-generics-035',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Distributive Conditional Types',
    text: 'Understand how conditional types distribute over unions',
    setup: 'type ToArray<T> = T extends any ? T[] : never;',
    setupCode: 'type ToArray<T> = T extends any ? T[] : never;',
    expected: [1],
    sample: 'const arr: ToArray<string | number> = [1];\narr',
    hints: [
      'Conditional types distribute over union members',
      'string | number becomes string[] | number[]',
    ],
    tags: ['generics', 'conditional-types', 'distributive'],
  },
  {
    id: 'ts-generics-036',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Non-Distributive Conditional Type',
    text: 'Prevent distribution by wrapping in tuple',
    setup: 'type ToArrayNonDist<T> = [T] extends [any] ? T[] : never;',
    setupCode: 'type ToArrayNonDist<T> = [T] extends [any] ? T[] : never;',
    expected: ['a', 1],
    sample: 'const arr: ToArrayNonDist<string | number> = ["a", 1];\narr',
    hints: [
      'Wrapping T in [T] prevents distribution',
      'Result is (string | number)[] not string[] | number[]',
    ],
    tags: ['generics', 'conditional-types', 'non-distributive'],
  },
  {
    id: 'ts-generics-037',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Conditional Type with infer in Nested Position',
    text: 'Extract the promise value type from a nested Promise',
    setup:
      'type UnwrapPromise<T> = T extends Promise<infer U> ? (U extends Promise<infer V> ? V : U) : T;',
    setupCode:
      'type UnwrapPromise<T> = T extends Promise<infer U> ? (U extends Promise<infer V> ? V : U) : T;',
    expected: 'resolved',
    sample:
      'type Nested = Promise<Promise<string>>;\nconst val: UnwrapPromise<Nested> = "resolved";\nval',
    hints: ['Check for Promise wrapper recursively', 'Nested infer unwraps multiple layers'],
    tags: ['generics', 'conditional-types', 'infer', 'promise'],
  },

  // ============================================================
  // Advanced Generics - Mapped Types
  // ============================================================
  {
    id: 'ts-generics-038',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Basic Mapped Type',
    text: 'Create a mapped type that makes all properties optional',
    setup: 'type MyPartial<T> = { [K in keyof T]?: T[K] };',
    setupCode: 'type MyPartial<T> = { [K in keyof T]?: T[K] };',
    expected: { name: 'Alice' },
    sample:
      'interface User { name: string; age: number; }\nconst partial: MyPartial<User> = { name: "Alice" };\npartial',
    hints: ['[K in keyof T] iterates over all keys', '? makes each property optional'],
    tags: ['generics', 'mapped-types'],
  },
  {
    id: 'ts-generics-039',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Mapped Type with Readonly',
    text: 'Create a mapped type that makes all properties readonly',
    setup: 'type MyReadonly<T> = { readonly [K in keyof T]: T[K] };',
    setupCode: 'type MyReadonly<T> = { readonly [K in keyof T]: T[K] };',
    expected: { x: 10, y: 20 },
    sample:
      'interface Point { x: number; y: number; }\nconst p: MyReadonly<Point> = { x: 10, y: 20 };\np',
    hints: ['Add readonly modifier before property', 'Properties cannot be reassigned'],
    tags: ['generics', 'mapped-types', 'readonly'],
  },
  {
    id: 'ts-generics-040',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Mapped Type Removing Modifier',
    text: 'Create a mapped type that removes readonly modifier',
    setup: 'type Mutable<T> = { -readonly [K in keyof T]: T[K] };',
    setupCode: 'type Mutable<T> = { -readonly [K in keyof T]: T[K] };',
    expected: { x: 5, y: 15 },
    sample:
      'interface ReadonlyPoint { readonly x: number; readonly y: number; }\nconst p: Mutable<ReadonlyPoint> = { x: 5, y: 15 };\np.x = 5;\np',
    hints: ['-readonly removes the readonly modifier', 'Properties become mutable'],
    tags: ['generics', 'mapped-types', 'mutable'],
  },
  {
    id: 'ts-generics-041',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Mapped Type Required',
    text: 'Create a mapped type that makes all properties required',
    setup: 'type MyRequired<T> = { [K in keyof T]-?: T[K] };',
    setupCode: 'type MyRequired<T> = { [K in keyof T]-?: T[K] };',
    expected: { name: 'Bob', age: 30 },
    sample:
      'interface PartialUser { name?: string; age?: number; }\nconst user: MyRequired<PartialUser> = { name: "Bob", age: 30 };\nuser',
    hints: ['-? removes the optional modifier', 'All properties become required'],
    tags: ['generics', 'mapped-types', 'required'],
  },
  {
    id: 'ts-generics-042',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Mapped Type with New Value Type',
    text: 'Create a mapped type that converts all property values to booleans',
    setup: 'type Flags<T> = { [K in keyof T]: boolean };',
    setupCode: 'type Flags<T> = { [K in keyof T]: boolean };',
    expected: { name: true, age: false },
    sample:
      'interface User { name: string; age: number; }\nconst flags: Flags<User> = { name: true, age: false };\nflags',
    hints: ['Replace T[K] with boolean', 'All values become booleans'],
    tags: ['generics', 'mapped-types', 'transformation'],
  },
  {
    id: 'ts-generics-043',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Mapped Type with Filtering',
    text: 'Create a mapped type that extracts only string properties',
    setup:
      'type StringProperties<T> = { [K in keyof T as T[K] extends string ? K : never]: T[K] };',
    setupCode:
      'type StringProperties<T> = { [K in keyof T as T[K] extends string ? K : never]: T[K] };',
    expected: { name: 'Alice', email: 'alice@test.com' },
    sample:
      'interface User { name: string; age: number; email: string; }\nconst strings: StringProperties<User> = { name: "Alice", email: "alice@test.com" };\nstrings',
    hints: ['Use as clause with conditional type', 'never keys are filtered out'],
    tags: ['generics', 'mapped-types', 'filtering', 'key-remapping'],
  },
  {
    id: 'ts-generics-044',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Mapped Type Deep Readonly',
    text: 'Create a recursive mapped type for deep readonly',
    setup:
      'type DeepReadonly<T> = { readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K] };',
    setupCode:
      'type DeepReadonly<T> = { readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K] };',
    expected: { user: { name: 'Alice' } },
    sample:
      'interface Data { user: { name: string } }\nconst data: DeepReadonly<Data> = { user: { name: "Alice" } };\ndata',
    hints: ['Recursively apply readonly to nested objects', 'Check if property extends object'],
    tags: ['generics', 'mapped-types', 'deep-readonly', 'recursive'],
  },

  // ============================================================
  // Advanced Generics - Key Remapping with as
  // ============================================================
  {
    id: 'ts-generics-045',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Key Remapping to Uppercase',
    text: 'Create a mapped type that uppercases all keys',
    setup: 'type UppercaseKeys<T> = { [K in keyof T as Uppercase<string & K>]: T[K] };',
    setupCode: 'type UppercaseKeys<T> = { [K in keyof T as Uppercase<string & K>]: T[K] };',
    expected: { NAME: 'Alice', AGE: 30 },
    sample:
      'interface User { name: string; age: number; }\nconst upper: UppercaseKeys<User> = { NAME: "Alice", AGE: 30 };\nupper',
    hints: ['Use as clause to remap keys', 'Uppercase<string & K> transforms key to uppercase'],
    tags: ['generics', 'key-remapping', 'template-literal'],
  },
  {
    id: 'ts-generics-046',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Key Remapping with Prefix',
    text: 'Create a mapped type that prefixes all keys with "get"',
    setup: 'type Getters<T> = { [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K] };',
    setupCode:
      'type Getters<T> = { [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K] };',
    expected: 'function',
    sample:
      'interface User { name: string; }\nconst getters: Getters<User> = { getName: () => "Alice" };\ntypeof getters.getName',
    hints: ['Template literal creates new key name', 'Capitalize ensures proper camelCase'],
    tags: ['generics', 'key-remapping', 'getters'],
  },
  {
    id: 'ts-generics-047',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Key Remapping with Setter Pattern',
    text: 'Create a mapped type that creates setters for all properties',
    setup:
      'type Setters<T> = { [K in keyof T as `set${Capitalize<string & K>}`]: (value: T[K]) => void };',
    setupCode:
      'type Setters<T> = { [K in keyof T as `set${Capitalize<string & K>}`]: (value: T[K]) => void };',
    expected: 'function',
    sample:
      'interface User { name: string; }\nconst setters: Setters<User> = { setName: (v) => console.log(v) };\ntypeof setters.setName',
    hints: ['Setter function takes value of property type', 'Returns void as setters typically do'],
    tags: ['generics', 'key-remapping', 'setters'],
  },
  {
    id: 'ts-generics-048',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Key Remapping Filter and Transform',
    text: 'Create a type that only keeps function properties and prefixes them with "call"',
    setup:
      'type CallableMethods<T> = { [K in keyof T as T[K] extends Function ? `call${Capitalize<string & K>}` : never]: T[K] };',
    setupCode:
      'type CallableMethods<T> = { [K in keyof T as T[K] extends Function ? `call${Capitalize<string & K>}` : never]: T[K] };',
    expected: 'function',
    sample:
      'interface Obj { name: string; greet: () => string; }\nconst callable: CallableMethods<Obj> = { callGreet: () => "hi" };\ntypeof callable.callGreet',
    hints: ['Filter with conditional type in as clause', 'Only function properties are kept'],
    tags: ['generics', 'key-remapping', 'filtering', 'functions'],
  },

  // ============================================================
  // Advanced Generics - Template Literal Types
  // ============================================================
  {
    id: 'ts-generics-049',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Basic Template Literal Type',
    text: 'Create a type that prepends "on" to a string type',
    setup: 'type EventName<T extends string> = `on${Capitalize<T>}`;',
    setupCode: 'type EventName<T extends string> = `on${Capitalize<T>}`;',
    expected: 'onClick',
    sample: 'const event: EventName<"click"> = "onClick";\nevent',
    hints: ['Template literal types use backticks', 'Capitalize transforms first letter'],
    tags: ['generics', 'template-literal'],
  },
  {
    id: 'ts-generics-050',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Template Literal with Multiple Parts',
    text: 'Create a type for CSS property values with units',
    setup: 'type CSSValue<N extends number, U extends string> = `${N}${U}`;',
    setupCode: 'type CSSValue<N extends number, U extends string> = `${N}${U}`;',
    expected: '100px',
    sample: 'const width: CSSValue<100, "px"> = "100px";\nwidth',
    hints: [
      'Multiple type parameters in template',
      'Number and string combine into single literal',
    ],
    tags: ['generics', 'template-literal', 'css'],
  },
  {
    id: 'ts-generics-051',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Template Literal Type Extraction',
    text: 'Create a type that extracts the event name from "onXxx" pattern',
    setup: 'type ExtractEvent<T> = T extends `on${infer E}` ? Uncapitalize<E> : never;',
    setupCode: 'type ExtractEvent<T> = T extends `on${infer E}` ? Uncapitalize<E> : never;',
    expected: 'click',
    sample: 'const event: ExtractEvent<"onClick"> = "click";\nevent',
    hints: [
      'Use infer to extract part of template',
      'Uncapitalize converts first letter to lowercase',
    ],
    tags: ['generics', 'template-literal', 'infer', 'extraction'],
  },
  {
    id: 'ts-generics-052',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Template Literal Split Type',
    text: 'Create a type that splits a string at a delimiter',
    setup:
      'type Split<S extends string, D extends string> = S extends `${infer H}${D}${infer T}` ? [H, ...Split<T, D>] : [S];',
    setupCode:
      'type Split<S extends string, D extends string> = S extends `${infer H}${D}${infer T}` ? [H, ...Split<T, D>] : [S];',
    expected: ['a', 'b', 'c'],
    sample: 'const parts: Split<"a-b-c", "-"> = ["a", "b", "c"];\nparts',
    hints: ['Recursively match and split string', 'Base case returns single element array'],
    tags: ['generics', 'template-literal', 'recursive', 'split'],
  },
  {
    id: 'ts-generics-053',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Template Literal Join Type',
    text: 'Create a type that joins tuple elements with a delimiter',
    setup:
      'type Join<T extends string[], D extends string> = T extends [infer F extends string, ...infer R extends string[]] ? R["length"] extends 0 ? F : `${F}${D}${Join<R, D>}` : "";',
    setupCode:
      'type Join<T extends string[], D extends string> = T extends [infer F extends string, ...infer R extends string[]] ? R["length"] extends 0 ? F : `${F}${D}${Join<R, D>}` : "";',
    expected: 'a-b-c',
    sample: 'const joined: Join<["a", "b", "c"], "-"> = "a-b-c";\njoined',
    hints: [
      'Recursively join elements with delimiter',
      'Handle last element without trailing delimiter',
    ],
    tags: ['generics', 'template-literal', 'recursive', 'join'],
  },

  // ============================================================
  // Advanced Generics - Variance
  // ============================================================
  {
    id: 'ts-generics-054',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Covariance in Return Types',
    text: 'Demonstrate covariance with function return types',
    setup:
      'interface Animal { name: string; }\ninterface Dog extends Animal { breed: string; }\ntype AnimalFactory = () => Animal;\ntype DogFactory = () => Dog;',
    setupCode:
      'interface Animal { name: string; }\ninterface Dog extends Animal { breed: string; }\ntype AnimalFactory = () => Animal;\ntype DogFactory = () => Dog;',
    expected: { name: 'Rex', breed: 'German Shepherd' },
    sample:
      'const dogFactory: DogFactory = () => ({ name: "Rex", breed: "German Shepherd" });\nconst animalFactory: AnimalFactory = dogFactory;\nanimalFactory()',
    hints: ['Return types are covariant', 'DogFactory is assignable to AnimalFactory'],
    tags: ['generics', 'variance', 'covariance'],
  },
  {
    id: 'ts-generics-055',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Contravariance in Parameters',
    text: 'Demonstrate contravariance with function parameters',
    setup:
      'interface Animal { name: string; }\ninterface Dog extends Animal { breed: string; }\ntype AnimalHandler = (animal: Animal) => void;\ntype DogHandler = (dog: Dog) => void;',
    setupCode:
      'interface Animal { name: string; }\ninterface Dog extends Animal { breed: string; }\ntype AnimalHandler = (animal: Animal) => void;\ntype DogHandler = (dog: Dog) => void;',
    expected: 'handled',
    sample:
      'const animalHandler: AnimalHandler = (a) => console.log(a.name);\nconst handler: DogHandler = animalHandler;\n"handled"',
    hints: [
      'Parameter types are contravariant',
      'AnimalHandler can be used where DogHandler is expected',
    ],
    tags: ['generics', 'variance', 'contravariance'],
  },
  {
    id: 'ts-generics-056',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Invariant Generic Type',
    text: 'Create an invariant container type',
    setup:
      'class Container<T> { private value: T; constructor(value: T) { this.value = value; } get(): T { return this.value; } set(value: T) { this.value = value; } }',
    setupCode:
      'class Container<T> { private value: T; constructor(value: T) { this.value = value; } get(): T { return this.value; } set(value: T) { this.value = value; } }',
    expected: 42,
    sample: 'const container = new Container(42);\ncontainer.get()',
    hints: [
      'Both get and set methods make T invariant',
      'Container<Dog> is not assignable to Container<Animal>',
    ],
    tags: ['generics', 'variance', 'invariance', 'class'],
  },

  // ============================================================
  // Advanced Generics - Generic Classes
  // ============================================================
  {
    id: 'ts-generics-057',
    category: 'Advanced Generics',
    difficulty: 'easy',
    title: 'Basic Generic Class',
    text: 'Create a generic Stack class with push and pop methods',
    setup:
      'class Stack<T> { private items: T[] = []; push(item: T) { this.items.push(item); } pop(): T | undefined { return this.items.pop(); } }',
    setupCode:
      'class Stack<T> { private items: T[] = []; push(item: T) { this.items.push(item); } pop(): T | undefined { return this.items.pop(); } }',
    expected: 3,
    sample:
      'const stack = new Stack<number>();\nstack.push(1);\nstack.push(2);\nstack.push(3);\nstack.pop()',
    hints: [
      'Generic class maintains type safety for its contents',
      'T is determined when instantiating',
    ],
    tags: ['generics', 'class', 'stack'],
  },
  {
    id: 'ts-generics-058',
    category: 'Advanced Generics',
    difficulty: 'easy',
    title: 'Generic Queue Class',
    text: 'Create a generic Queue class with enqueue and dequeue methods',
    setup:
      'class Queue<T> { private items: T[] = []; enqueue(item: T) { this.items.push(item); } dequeue(): T | undefined { return this.items.shift(); } }',
    setupCode:
      'class Queue<T> { private items: T[] = []; enqueue(item: T) { this.items.push(item); } dequeue(): T | undefined { return this.items.shift(); } }',
    expected: 'first',
    sample:
      'const queue = new Queue<string>();\nqueue.enqueue("first");\nqueue.enqueue("second");\nqueue.dequeue()',
    hints: ['Queue is FIFO (first in, first out)', 'Use shift() to remove from front'],
    tags: ['generics', 'class', 'queue'],
  },
  {
    id: 'ts-generics-059',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic Repository Class',
    text: 'Create a generic repository class for CRUD operations',
    setup:
      'class Repository<T extends { id: number }> {\n  private items: T[] = [];\n  add(item: T) { this.items.push(item); }\n  findById(id: number): T | undefined { return this.items.find(i => i.id === id); }\n  getAll(): T[] { return [...this.items]; }\n}',
    setupCode:
      'class Repository<T extends { id: number }> {\n  private items: T[] = [];\n  add(item: T) { this.items.push(item); }\n  findById(id: number): T | undefined { return this.items.find(i => i.id === id); }\n  getAll(): T[] { return [...this.items]; }\n}',
    expected: { id: 1, name: 'Alice' },
    sample:
      'interface User { id: number; name: string; }\nconst repo = new Repository<User>();\nrepo.add({ id: 1, name: "Alice" });\nrepo.findById(1)',
    hints: [
      'Constraint T extends { id: number } ensures id property exists',
      'findById can safely access id on items',
    ],
    tags: ['generics', 'class', 'repository', 'constraints'],
  },
  {
    id: 'ts-generics-060',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic Observable Class',
    text: 'Create a generic Observable class with subscribe and notify',
    setup:
      'class Observable<T> {\n  private observers: ((value: T) => void)[] = [];\n  subscribe(observer: (value: T) => void) { this.observers.push(observer); }\n  notify(value: T) { this.observers.forEach(o => o(value)); }\n}',
    setupCode:
      'class Observable<T> {\n  private observers: ((value: T) => void)[] = [];\n  subscribe(observer: (value: T) => void) { this.observers.push(observer); }\n  notify(value: T) { this.observers.forEach(o => o(value)); }\n}',
    expected: 'notified',
    sample:
      'const obs = new Observable<string>();\nlet result = "";\nobs.subscribe(v => result = v);\nobs.notify("notified");\nresult',
    hints: [
      'Observers are callbacks that receive values of type T',
      'notify calls all registered observers',
    ],
    tags: ['generics', 'class', 'observable', 'callbacks'],
  },
  {
    id: 'ts-generics-061',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Generic State Machine Class',
    text: 'Create a generic state machine with typed transitions',
    setup:
      'class StateMachine<S extends string, E extends string> {\n  constructor(private state: S, private transitions: Record<S, Partial<Record<E, S>>>) {}\n  getState(): S { return this.state; }\n  dispatch(event: E): S {\n    const nextState = this.transitions[this.state]?.[event];\n    if (nextState) this.state = nextState;\n    return this.state;\n  }\n}',
    setupCode:
      'class StateMachine<S extends string, E extends string> {\n  constructor(private state: S, private transitions: Record<S, Partial<Record<E, S>>>) {}\n  getState(): S { return this.state; }\n  dispatch(event: E): S {\n    const nextState = this.transitions[this.state]?.[event];\n    if (nextState) this.state = nextState;\n    return this.state;\n  }\n}',
    expected: 'green',
    sample:
      'type Light = "red" | "yellow" | "green";\ntype Event = "next";\nconst sm = new StateMachine<Light, Event>("red", { red: { next: "green" }, green: { next: "yellow" }, yellow: { next: "red" } });\nsm.dispatch("next")',
    hints: [
      'S is constrained to string union for states',
      'Transitions map current state to events to next state',
    ],
    tags: ['generics', 'class', 'state-machine', 'constraints'],
  },

  // ============================================================
  // Advanced Generics - Utility Types Implementation
  // ============================================================
  {
    id: 'ts-generics-062',
    category: 'Advanced Generics',
    difficulty: 'easy',
    title: 'Implement Pick Utility Type',
    text: 'Create your own Pick utility type',
    setup: 'type MyPick<T, K extends keyof T> = { [P in K]: T[P] };',
    setupCode: 'type MyPick<T, K extends keyof T> = { [P in K]: T[P] };',
    expected: { name: 'Alice' },
    sample:
      'interface User { name: string; age: number; email: string; }\nconst picked: MyPick<User, "name"> = { name: "Alice" };\npicked',
    hints: ['K extends keyof T ensures K is valid key of T', 'Iterate only over keys in K'],
    tags: ['generics', 'utility-types', 'pick'],
  },
  {
    id: 'ts-generics-063',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Implement Omit Utility Type',
    text: 'Create your own Omit utility type',
    setup: 'type MyOmit<T, K extends keyof T> = { [P in Exclude<keyof T, K>]: T[P] };',
    setupCode: 'type MyOmit<T, K extends keyof T> = { [P in Exclude<keyof T, K>]: T[P] };',
    expected: { age: 30, email: 'test@test.com' },
    sample:
      'interface User { name: string; age: number; email: string; }\nconst omitted: MyOmit<User, "name"> = { age: 30, email: "test@test.com" };\nomitted',
    hints: ['Use Exclude to remove K from keyof T', 'Iterate over remaining keys'],
    tags: ['generics', 'utility-types', 'omit'],
  },
  {
    id: 'ts-generics-064',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Implement Record Utility Type',
    text: 'Create your own Record utility type',
    setup: 'type MyRecord<K extends keyof any, V> = { [P in K]: V };',
    setupCode: 'type MyRecord<K extends keyof any, V> = { [P in K]: V };',
    expected: { a: 1, b: 2 },
    sample: 'const record: MyRecord<"a" | "b", number> = { a: 1, b: 2 };\nrecord',
    hints: [
      'K extends keyof any accepts string | number | symbol',
      'All keys have the same value type V',
    ],
    tags: ['generics', 'utility-types', 'record'],
  },
  {
    id: 'ts-generics-065',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Implement Exclude Utility Type',
    text: 'Create your own Exclude utility type',
    setup: 'type MyExclude<T, U> = T extends U ? never : T;',
    setupCode: 'type MyExclude<T, U> = T extends U ? never : T;',
    expected: 'c',
    sample:
      'type ABC = "a" | "b" | "c";\nconst excluded: MyExclude<ABC, "a" | "b"> = "c";\nexcluded',
    hints: ['Distributive conditional type over union', 'Returns never for excluded types'],
    tags: ['generics', 'utility-types', 'exclude', 'conditional-types'],
  },
  {
    id: 'ts-generics-066',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Implement Extract Utility Type',
    text: 'Create your own Extract utility type',
    setup: 'type MyExtract<T, U> = T extends U ? T : never;',
    setupCode: 'type MyExtract<T, U> = T extends U ? T : never;',
    expected: 'a',
    sample:
      'type ABC = "a" | "b" | "c";\nconst extracted: MyExtract<ABC, "a" | "d"> = "a";\nextracted',
    hints: ['Opposite of Exclude', 'Keeps types that extend U'],
    tags: ['generics', 'utility-types', 'extract', 'conditional-types'],
  },
  {
    id: 'ts-generics-067',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Implement NonNullable Utility Type',
    text: 'Create your own NonNullable utility type',
    setup: 'type MyNonNullable<T> = T extends null | undefined ? never : T;',
    setupCode: 'type MyNonNullable<T> = T extends null | undefined ? never : T;',
    expected: 'hello',
    sample:
      'type MaybeString = string | null | undefined;\nconst value: MyNonNullable<MaybeString> = "hello";\nvalue',
    hints: ['Exclude null and undefined from union', 'Distributive conditional type does the work'],
    tags: ['generics', 'utility-types', 'non-nullable', 'conditional-types'],
  },
  {
    id: 'ts-generics-068',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Implement Parameters Utility Type',
    text: 'Create your own Parameters utility type',
    setup:
      'type MyParameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;',
    setupCode:
      'type MyParameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;',
    expected: ['hello', 42],
    sample:
      'type Fn = (a: string, b: number) => void;\nconst params: MyParameters<Fn> = ["hello", 42];\nparams',
    hints: ['Use infer to capture the args tuple', 'Constraint ensures T is a function'],
    tags: ['generics', 'utility-types', 'parameters', 'infer'],
  },
  {
    id: 'ts-generics-069',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Implement ConstructorParameters Utility Type',
    text: 'Create your own ConstructorParameters utility type',
    setup:
      'type MyConstructorParams<T extends abstract new (...args: any) => any> = T extends abstract new (...args: infer P) => any ? P : never;',
    setupCode:
      'type MyConstructorParams<T extends abstract new (...args: any) => any> = T extends abstract new (...args: infer P) => any ? P : never;',
    expected: ['Alice', 30],
    sample:
      'class User { constructor(public name: string, public age: number) {} }\nconst args: MyConstructorParams<typeof User> = ["Alice", 30];\nargs',
    hints: [
      'Use new (...args) => any for constructor type',
      'infer P captures constructor parameters',
    ],
    tags: ['generics', 'utility-types', 'constructor', 'infer'],
  },
  {
    id: 'ts-generics-070',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Implement InstanceType Utility Type',
    text: 'Create your own InstanceType utility type',
    setup:
      'type MyInstanceType<T extends abstract new (...args: any) => any> = T extends abstract new (...args: any) => infer R ? R : never;',
    setupCode:
      'type MyInstanceType<T extends abstract new (...args: any) => any> = T extends abstract new (...args: any) => infer R ? R : never;',
    expected: { name: 'Bob', age: 25 },
    sample:
      'class User { constructor(public name: string, public age: number) {} }\nconst user: MyInstanceType<typeof User> = new User("Bob", 25);\nuser',
    hints: [
      'infer R captures the return type of constructor',
      'Returns the instance type of the class',
    ],
    tags: ['generics', 'utility-types', 'instance-type', 'infer'],
  },

  // ============================================================
  // Advanced Generics - Complex Patterns
  // ============================================================
  {
    id: 'ts-generics-071',
    category: 'Advanced Generics',
    difficulty: 'easy',
    title: 'Generic Tuple to Union',
    text: 'Create a type that converts a tuple to a union of its elements',
    setup: 'type TupleToUnion<T extends readonly any[]> = T[number];',
    setupCode: 'type TupleToUnion<T extends readonly any[]> = T[number];',
    expected: 1,
    sample: 'type Tuple = [1, 2, 3];\nconst value: TupleToUnion<Tuple> = 1;\nvalue',
    hints: ['T[number] indexes into tuple with number', 'Returns union of all element types'],
    tags: ['generics', 'tuple', 'union'],
  },
  {
    id: 'ts-generics-072',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic Union to Intersection',
    text: 'Create a type that converts a union to an intersection',
    setup:
      'type UnionToIntersection<U> = (U extends any ? (x: U) => void : never) extends (x: infer I) => void ? I : never;',
    setupCode:
      'type UnionToIntersection<U> = (U extends any ? (x: U) => void : never) extends (x: infer I) => void ? I : never;',
    expected: { a: 1, b: 2 },
    sample:
      'type Union = { a: number } | { b: number };\nconst obj: UnionToIntersection<Union> = { a: 1, b: 2 };\nobj',
    hints: [
      'Uses contravariant position to force intersection',
      'Function parameters are contravariant',
    ],
    tags: ['generics', 'union', 'intersection', 'variance'],
  },
  {
    id: 'ts-generics-073',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic Promisify',
    text: 'Create a type that wraps return type in Promise if not already',
    setup: 'type Promisify<T> = T extends Promise<any> ? T : Promise<T>;',
    setupCode: 'type Promisify<T> = T extends Promise<any> ? T : Promise<T>;',
    expected: 'resolved',
    sample: 'const p: Promisify<string> = Promise.resolve("resolved");\np.then(v => v)',
    hints: ['Check if already a Promise', 'Wrap in Promise if not'],
    tags: ['generics', 'promise', 'conditional-types'],
  },
  {
    id: 'ts-generics-074',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic Awaited Type',
    text: 'Create a type that recursively unwraps Promise types',
    setup: 'type MyAwaited<T> = T extends Promise<infer U> ? MyAwaited<U> : T;',
    setupCode: 'type MyAwaited<T> = T extends Promise<infer U> ? MyAwaited<U> : T;',
    expected: 'value',
    sample:
      'type Nested = Promise<Promise<Promise<string>>>;\nconst value: MyAwaited<Nested> = "value";\nvalue',
    hints: ['Recursively unwrap Promise layers', 'Stop when no longer a Promise'],
    tags: ['generics', 'promise', 'recursive', 'awaited'],
  },
  {
    id: 'ts-generics-075',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Generic DeepPartial',
    text: 'Create a type that makes all properties optional recursively',
    setup: 'type DeepPartial<T> = T extends object ? { [K in keyof T]?: DeepPartial<T[K]> } : T;',
    setupCode:
      'type DeepPartial<T> = T extends object ? { [K in keyof T]?: DeepPartial<T[K]> } : T;',
    expected: { user: { name: 'Alice' } },
    sample:
      'interface Data { user: { name: string; age: number } }\nconst partial: DeepPartial<Data> = { user: { name: "Alice" } };\npartial',
    hints: ['Recursively apply Partial to nested objects', 'Base case for non-objects returns T'],
    tags: ['generics', 'deep-partial', 'recursive', 'mapped-types'],
  },
  {
    id: 'ts-generics-076',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Generic Paths Type',
    text: 'Create a type that generates all dot-notation paths of an object',
    setup:
      'type Paths<T> = T extends object ? { [K in keyof T]: K extends string ? T[K] extends object ? K | `${K}.${Paths<T[K]> & string}` : K : never }[keyof T] : never;',
    setupCode:
      'type Paths<T> = T extends object ? { [K in keyof T]: K extends string ? T[K] extends object ? K | `${K}.${Paths<T[K]> & string}` : K : never }[keyof T] : never;',
    expected: 'user.name',
    sample:
      'interface Data { user: { name: string; age: number } }\nconst path: Paths<Data> = "user.name";\npath',
    hints: ['Recursively build paths for nested objects', 'Use template literal for dot notation'],
    tags: ['generics', 'paths', 'recursive', 'template-literal'],
  },
  {
    id: 'ts-generics-077',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Generic Get Type by Path',
    text: 'Create a type that gets nested property type by dot-notation path',
    setup:
      'type Get<T, P extends string> = P extends `${infer K}.${infer Rest}` ? K extends keyof T ? Get<T[K], Rest> : never : P extends keyof T ? T[P] : never;',
    setupCode:
      'type Get<T, P extends string> = P extends `${infer K}.${infer Rest}` ? K extends keyof T ? Get<T[K], Rest> : never : P extends keyof T ? T[P] : never;',
    expected: 'Alice',
    sample:
      'interface Data { user: { name: string } }\nconst name: Get<Data, "user.name"> = "Alice";\nname',
    hints: ['Split path at first dot', 'Recursively traverse object structure'],
    tags: ['generics', 'paths', 'recursive', 'template-literal'],
  },
  {
    id: 'ts-generics-078',
    category: 'Advanced Generics',
    difficulty: 'easy',
    title: 'Generic Array Element Type',
    text: 'Create a type that extracts the element type from an array',
    setup:
      'type ElementType<T extends readonly any[]> = T extends readonly (infer E)[] ? E : never;',
    setupCode:
      'type ElementType<T extends readonly any[]> = T extends readonly (infer E)[] ? E : never;',
    expected: 42,
    sample: 'type NumArray = number[];\nconst element: ElementType<NumArray> = 42;\nelement',
    hints: ['Use infer to capture element type', 'Works with both regular and readonly arrays'],
    tags: ['generics', 'arrays', 'infer', 'element-type'],
  },
  {
    id: 'ts-generics-079',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic Tuple Length',
    text: 'Create a type that gets the length of a tuple type',
    setup: 'type TupleLength<T extends readonly any[]> = T["length"];',
    setupCode: 'type TupleLength<T extends readonly any[]> = T["length"];',
    expected: 3,
    sample: 'type Triple = [1, 2, 3];\nconst len: TupleLength<Triple> = 3;\nlen',
    hints: ['Tuple types have literal length type', 'Access with ["length"]'],
    tags: ['generics', 'tuple', 'length'],
  },
  {
    id: 'ts-generics-080',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic Push to Tuple',
    text: 'Create a type that adds an element to the end of a tuple',
    setup: 'type Push<T extends any[], E> = [...T, E];',
    setupCode: 'type Push<T extends any[], E> = [...T, E];',
    expected: [1, 2, 3],
    sample: 'type Pair = [1, 2];\nconst triple: Push<Pair, 3> = [1, 2, 3];\ntriple',
    hints: ['Use spread operator in tuple type', 'Append E at the end'],
    tags: ['generics', 'tuple', 'spread'],
  },
  {
    id: 'ts-generics-081',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic Unshift to Tuple',
    text: 'Create a type that adds an element to the start of a tuple',
    setup: 'type Unshift<T extends any[], E> = [E, ...T];',
    setupCode: 'type Unshift<T extends any[], E> = [E, ...T];',
    expected: [0, 1, 2],
    sample: 'type Pair = [1, 2];\nconst triple: Unshift<Pair, 0> = [0, 1, 2];\ntriple',
    hints: ['Place E before spread of T', 'Creates new tuple with E first'],
    tags: ['generics', 'tuple', 'spread'],
  },
  {
    id: 'ts-generics-082',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Generic Pop from Tuple',
    text: 'Create a type that removes the last element from a tuple',
    setup: 'type Pop<T extends any[]> = T extends [...infer R, any] ? R : never;',
    setupCode: 'type Pop<T extends any[]> = T extends [...infer R, any] ? R : never;',
    expected: [1, 2],
    sample: 'type Triple = [1, 2, 3];\nconst pair: Pop<Triple> = [1, 2];\npair',
    hints: ['Use infer with rest pattern', 'Capture all but last element'],
    tags: ['generics', 'tuple', 'infer', 'spread'],
  },
  {
    id: 'ts-generics-083',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Generic Shift from Tuple',
    text: 'Create a type that removes the first element from a tuple',
    setup: 'type Shift<T extends any[]> = T extends [any, ...infer R] ? R : never;',
    setupCode: 'type Shift<T extends any[]> = T extends [any, ...infer R] ? R : never;',
    expected: [2, 3],
    sample: 'type Triple = [1, 2, 3];\nconst pair: Shift<Triple> = [2, 3];\npair',
    hints: ['Match first element and rest', 'Return rest elements'],
    tags: ['generics', 'tuple', 'infer', 'spread'],
  },

  // ============================================================
  // Advanced Generics - Function Overloads with Generics
  // ============================================================
  {
    id: 'ts-generics-084',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic Function with Overloads',
    text: 'Create a generic function with overloaded signatures for different return types',
    setup: 'function getValue<T extends string>(key: T): T extends "count" ? number : string;',
    setupCode: 'function getValue<T extends string>(key: T): T extends "count" ? number : string;',
    expected: 'value',
    sample:
      'function getValue<T extends string>(key: T): any { return key === "count" ? 42 : "value"; }\ngetValue("name")',
    hints: ['Conditional return type based on key', 'Implementation must handle all cases'],
    tags: ['generics', 'overloads', 'conditional-types'],
  },
  {
    id: 'ts-generics-085',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Generic Type-Safe Event Emitter',
    text: 'Create a type-safe event emitter with generic event map',
    setup:
      'type EventMap = { click: { x: number; y: number }; input: { value: string } };\nclass Emitter<T extends Record<string, any>> {\n  on<K extends keyof T>(event: K, handler: (data: T[K]) => void) {}\n  emit<K extends keyof T>(event: K, data: T[K]) {}\n}',
    setupCode:
      'type EventMap = { click: { x: number; y: number }; input: { value: string } };\nclass Emitter<T extends Record<string, any>> {\n  on<K extends keyof T>(event: K, handler: (data: T[K]) => void) {}\n  emit<K extends keyof T>(event: K, data: T[K]) {}\n}',
    expected: 'object',
    sample:
      'const emitter = new Emitter<EventMap>();\nemitter.on("click", (data) => console.log(data.x));\ntypeof emitter',
    hints: [
      'K extends keyof T ensures valid event name',
      'T[K] gives the data type for that event',
    ],
    tags: ['generics', 'events', 'type-safe', 'class'],
  },

  // ============================================================
  // Advanced Generics - Builder Patterns
  // ============================================================
  {
    id: 'ts-generics-086',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic Builder Pattern',
    text: 'Create a generic builder that accumulates properties',
    setup:
      'class Builder<T extends object = {}> {\n  private obj: T = {} as T;\n  with<K extends string, V>(key: K, value: V): Builder<T & Record<K, V>> {\n    (this.obj as any)[key] = value;\n    return this as any;\n  }\n  build(): T { return this.obj; }\n}',
    setupCode:
      'class Builder<T extends object = {}> {\n  private obj: T = {} as T;\n  with<K extends string, V>(key: K, value: V): Builder<T & Record<K, V>> {\n    (this.obj as any)[key] = value;\n    return this as any;\n  }\n  build(): T { return this.obj; }\n}',
    expected: { name: 'Alice', age: 30 },
    sample: 'const result = new Builder().with("name", "Alice").with("age", 30).build();\nresult',
    hints: ['Each with() call extends the type', 'Return type includes new property'],
    tags: ['generics', 'builder', 'fluent-api'],
  },
  {
    id: 'ts-generics-087',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Generic Type-Safe Query Builder',
    text: 'Create a query builder with type-safe field selection',
    setup:
      'class QueryBuilder<T, S extends keyof T = keyof T> {\n  constructor(private fields: S[] = []) {}\n  select<K extends keyof T>(...fields: K[]): QueryBuilder<T, K> {\n    return new QueryBuilder(fields);\n  }\n  getFields(): S[] { return this.fields; }\n}',
    setupCode:
      'class QueryBuilder<T, S extends keyof T = keyof T> {\n  constructor(private fields: S[] = []) {}\n  select<K extends keyof T>(...fields: K[]): QueryBuilder<T, K> {\n    return new QueryBuilder(fields);\n  }\n  getFields(): S[] { return this.fields; }\n}',
    expected: ['name', 'email'],
    sample:
      'interface User { name: string; age: number; email: string }\nconst qb = new QueryBuilder<User>().select("name", "email");\nqb.getFields()',
    hints: ['Track selected fields in type parameter S', 'select() narrows the available fields'],
    tags: ['generics', 'builder', 'query', 'type-safe'],
  },

  // ============================================================
  // Advanced Generics - Higher Kinded Types Simulation
  // ============================================================
  {
    id: 'ts-generics-088',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Generic Functor Interface',
    text: 'Create a generic Functor-like interface with map',
    setup:
      'interface Functor<T> {\n  map<U>(fn: (value: T) => U): Functor<U>;\n}\nclass Box<T> implements Functor<T> {\n  constructor(public value: T) {}\n  map<U>(fn: (value: T) => U): Box<U> { return new Box(fn(this.value)); }\n}',
    setupCode:
      'interface Functor<T> {\n  map<U>(fn: (value: T) => U): Functor<U>;\n}\nclass Box<T> implements Functor<T> {\n  constructor(public value: T) {}\n  map<U>(fn: (value: T) => U): Box<U> { return new Box(fn(this.value)); }\n}',
    expected: { value: 10 },
    sample: 'const box = new Box(5).map(x => x * 2);\nbox',
    hints: [
      'Functor allows mapping over contained value',
      'map returns new container with transformed value',
    ],
    tags: ['generics', 'functor', 'functional'],
  },
  {
    id: 'ts-generics-089',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Generic Monad-like Interface',
    text: 'Create a generic Maybe monad with map and flatMap',
    setup:
      'class Maybe<T> {\n  constructor(private value: T | null) {}\n  static of<T>(value: T): Maybe<T> { return new Maybe(value); }\n  static none<T>(): Maybe<T> { return new Maybe<T>(null); }\n  map<U>(fn: (value: T) => U): Maybe<U> {\n    return this.value === null ? Maybe.none() : Maybe.of(fn(this.value));\n  }\n  flatMap<U>(fn: (value: T) => Maybe<U>): Maybe<U> {\n    return this.value === null ? Maybe.none() : fn(this.value);\n  }\n  getOrElse(defaultValue: T): T { return this.value ?? defaultValue; }\n}',
    setupCode:
      'class Maybe<T> {\n  constructor(private value: T | null) {}\n  static of<T>(value: T): Maybe<T> { return new Maybe(value); }\n  static none<T>(): Maybe<T> { return new Maybe<T>(null); }\n  map<U>(fn: (value: T) => U): Maybe<U> {\n    return this.value === null ? Maybe.none() : Maybe.of(fn(this.value));\n  }\n  flatMap<U>(fn: (value: T) => Maybe<U>): Maybe<U> {\n    return this.value === null ? Maybe.none() : fn(this.value);\n  }\n  getOrElse(defaultValue: T): T { return this.value ?? defaultValue; }\n}',
    expected: 10,
    sample: 'Maybe.of(5).map(x => x * 2).getOrElse(0)',
    hints: [
      'Maybe handles null/undefined safely',
      'flatMap allows chaining Maybe-returning functions',
    ],
    tags: ['generics', 'monad', 'maybe', 'functional'],
  },

  // ============================================================
  // Advanced Generics - Recursive Types
  // ============================================================
  {
    id: 'ts-generics-090',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic Recursive JSON Type',
    text: 'Create a recursive type for JSON values',
    setup:
      'type JSONValue = string | number | boolean | null | JSONValue[] | { [key: string]: JSONValue };',
    setupCode:
      'type JSONValue = string | number | boolean | null | JSONValue[] | { [key: string]: JSONValue };',
    expected: { name: 'Alice', scores: [1, 2, 3] },
    sample: 'const json: JSONValue = { name: "Alice", scores: [1, 2, 3] };\njson',
    hints: ['JSONValue references itself recursively', 'Covers all valid JSON structures'],
    tags: ['generics', 'recursive', 'json'],
  },
  {
    id: 'ts-generics-091',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Generic Tree Type',
    text: 'Create a generic recursive tree type with typed nodes',
    setup: 'interface TreeNode<T> { value: T; children: TreeNode<T>[]; }',
    setupCode: 'interface TreeNode<T> { value: T; children: TreeNode<T>[]; }',
    expected: {
      value: 1,
      children: [
        { value: 2, children: [] },
        { value: 3, children: [] },
      ],
    },
    sample:
      'const tree: TreeNode<number> = { value: 1, children: [{ value: 2, children: [] }, { value: 3, children: [] }] };\ntree',
    hints: ['TreeNode references itself for children', 'Each node has value of type T'],
    tags: ['generics', 'recursive', 'tree'],
  },
  {
    id: 'ts-generics-092',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Generic Flatten Nested Arrays',
    text: 'Create a type that deeply flattens nested array types',
    setup: 'type DeepFlatten<T> = T extends (infer U)[] ? DeepFlatten<U> : T;',
    setupCode: 'type DeepFlatten<T> = T extends (infer U)[] ? DeepFlatten<U> : T;',
    expected: 42,
    sample: 'type Nested = number[][][];\nconst flat: DeepFlatten<Nested> = 42;\nflat',
    hints: ['Recursively unwrap array layers', 'Stop when no longer an array'],
    tags: ['generics', 'recursive', 'flatten', 'arrays'],
  },

  // ============================================================
  // Advanced Generics - String Manipulation
  // ============================================================
  {
    id: 'ts-generics-093',
    category: 'Advanced Generics',
    difficulty: 'easy',
    title: 'Generic CamelCase to KebabCase',
    text: 'Apply built-in Lowercase utility to a string type',
    setup: 'type Lower<T extends string> = Lowercase<T>;',
    setupCode: 'type Lower<T extends string> = Lowercase<T>;',
    expected: 'hello',
    sample: 'const lower: Lower<"HELLO"> = "hello";\nlower',
    hints: [
      'Lowercase is a built-in template literal type',
      'Converts all characters to lowercase',
    ],
    tags: ['generics', 'template-literal', 'string-manipulation'],
  },
  {
    id: 'ts-generics-094',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic Capitalize Words',
    text: 'Create a type that capitalizes the first letter of a string type',
    setup: 'type Cap<T extends string> = Capitalize<T>;',
    setupCode: 'type Cap<T extends string> = Capitalize<T>;',
    expected: 'Hello',
    sample: 'const cap: Cap<"hello"> = "Hello";\ncap',
    hints: [
      'Capitalize transforms first letter to uppercase',
      'Built-in template literal type utility',
    ],
    tags: ['generics', 'template-literal', 'capitalize'],
  },
  {
    id: 'ts-generics-095',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Generic CamelCase Type',
    text: 'Create a type that converts snake_case to camelCase',
    setup:
      'type CamelCase<S extends string> = S extends `${infer P}_${infer R}` ? `${Lowercase<P>}${Capitalize<CamelCase<R>>}` : Lowercase<S>;',
    setupCode:
      'type CamelCase<S extends string> = S extends `${infer P}_${infer R}` ? `${Lowercase<P>}${Capitalize<CamelCase<R>>}` : Lowercase<S>;',
    expected: 'helloWorld',
    sample: 'const camel: CamelCase<"hello_world"> = "helloWorld";\ncamel',
    hints: ['Split at underscore recursively', 'Capitalize subsequent parts'],
    tags: ['generics', 'template-literal', 'camelCase', 'recursive'],
  },
  {
    id: 'ts-generics-096',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Generic SnakeCase Type',
    text: 'Create a type that converts camelCase to snake_case',
    setup:
      'type SnakeCase<S extends string> = S extends `${infer C}${infer R}` ? C extends Uppercase<C> ? `_${Lowercase<C>}${SnakeCase<R>}` : `${C}${SnakeCase<R>}` : S;',
    setupCode:
      'type SnakeCase<S extends string> = S extends `${infer C}${infer R}` ? C extends Uppercase<C> ? `_${Lowercase<C>}${SnakeCase<R>}` : `${C}${SnakeCase<R>}` : S;',
    expected: 'hello_world',
    sample: 'const snake: SnakeCase<"helloWorld"> = "hello_world";\nsnake',
    hints: ['Check each character for uppercase', 'Insert underscore before uppercase letters'],
    tags: ['generics', 'template-literal', 'snake_case', 'recursive'],
  },

  // ============================================================
  // Advanced Generics - Advanced Inference
  // ============================================================
  {
    id: 'ts-generics-097',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Infer Function This Type',
    text: 'Create a type that extracts the this parameter type from a function',
    setup: 'type ThisType<T> = T extends (this: infer U, ...args: any[]) => any ? U : never;',
    setupCode: 'type ThisType<T> = T extends (this: infer U, ...args: any[]) => any ? U : never;',
    expected: { name: 'test' },
    sample:
      'type Fn = (this: { name: string }) => void;\nconst thisArg: ThisType<Fn> = { name: "test" };\nthisArg',
    hints: ['Use infer in this position', 'Captures the this parameter type'],
    tags: ['generics', 'infer', 'this', 'functions'],
  },
  {
    id: 'ts-generics-098',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Generic Strict Object Keys',
    text: 'Create a type that enforces exact object shape (no extra properties at type level)',
    setup:
      'type Exact<T, Shape> = T extends Shape ? Exclude<keyof T, keyof Shape> extends never ? T : never : never;',
    setupCode:
      'type Exact<T, Shape> = T extends Shape ? Exclude<keyof T, keyof Shape> extends never ? T : never : never;',
    expected: { name: 'Alice' },
    sample:
      'interface Shape { name: string }\nfunction create<T>(obj: Exact<T, Shape> & Shape): Shape { return obj; }\nconst result = create({ name: "Alice" });\nresult',
    hints: ['Check that T has no extra keys beyond Shape', 'Exclude finds extra keys'],
    tags: ['generics', 'exact', 'strict', 'objects'],
  },
  {
    id: 'ts-generics-099',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Generic Merge Objects Type',
    text: 'Create a type that deeply merges two object types',
    setup:
      'type Merge<A, B> = { [K in keyof A | keyof B]: K extends keyof B ? K extends keyof A ? A[K] extends object ? B[K] extends object ? Merge<A[K], B[K]> : B[K] : B[K] : B[K] : K extends keyof A ? A[K] : never };',
    setupCode:
      'type Merge<A, B> = { [K in keyof A | keyof B]: K extends keyof B ? K extends keyof A ? A[K] extends object ? B[K] extends object ? Merge<A[K], B[K]> : B[K] : B[K] : B[K] : K extends keyof A ? A[K] : never };',
    expected: { a: 1, b: { c: 2, d: 3 } },
    sample:
      'type A = { a: number; b: { c: number } };\ntype B = { b: { d: number } };\nconst merged: Merge<A, B> = { a: 1, b: { c: 2, d: 3 } };\nmerged',
    hints: ['Iterate over keys from both types', 'Recursively merge nested objects'],
    tags: ['generics', 'merge', 'deep', 'recursive'],
  },
  {
    id: 'ts-generics-100',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Generic Branded Types',
    text: 'Create branded types for type-safe IDs',
    setup:
      'type Brand<T, B> = T & { __brand: B };\ntype UserId = Brand<number, "UserId">;\ntype PostId = Brand<number, "PostId">;',
    setupCode:
      'type Brand<T, B> = T & { __brand: B };\ntype UserId = Brand<number, "UserId">;\ntype PostId = Brand<number, "PostId">;',
    expected: 123,
    sample:
      'function createUserId(id: number): UserId { return id as UserId; }\nfunction getUserById(id: UserId): number { return id; }\nconst userId = createUserId(123);\ngetUserById(userId)',
    hints: [
      'Brand adds a phantom property for type safety',
      'UserId and PostId are incompatible despite both being numbers',
    ],
    tags: ['generics', 'branded-types', 'type-safe', 'phantom-types'],
  },

  // ============================================================
  // Advanced Generics - Generic Functions
  // ============================================================
  {
    id: 'ts-generic-001',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Basic Identity Function',
    text: 'Create a generic identity function that returns its argument unchanged',
    setup: 'function identity<T>(x: T): T { return x; }',
    setupCode: 'function identity<T>(x: T): T { return x; }',
    expected: 42,
    sample: 'identity(42)',
    hints: [
      'The type parameter T captures the input type',
      'The return type matches the input type',
    ],
    tags: ['generics', 'functions', 'identity'],
  },
  {
    id: 'ts-generic-002',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Array First Element',
    text: 'Create a generic function that returns the first element of an array',
    setup: 'function first<T>(arr: T[]): T | undefined { return arr[0]; }',
    setupCode: 'function first<T>(arr: T[]): T | undefined { return arr[0]; }',
    expected: 'hello',
    sample: 'first(["hello", "world"])',
    hints: ['Use T[] for array of generic type', 'Return T | undefined for empty array safety'],
    tags: ['generics', 'arrays', 'functions'],
  },
  {
    id: 'ts-generic-003',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Array Last Element',
    text: 'Create a generic function that returns the last element of an array',
    setup: 'function last<T>(arr: T[]): T | undefined { return arr[arr.length - 1]; }',
    setupCode: 'function last<T>(arr: T[]): T | undefined { return arr[arr.length - 1]; }',
    expected: 3,
    sample: 'last([1, 2, 3])',
    hints: ['Access array at length - 1', 'Handle empty array with undefined return type'],
    tags: ['generics', 'arrays', 'functions'],
  },
  {
    id: 'ts-generic-004',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Pair Type',
    text: 'Create a generic function that creates a pair from two values',
    setup: 'function pair<T, U>(a: T, b: U): [T, U] { return [a, b]; }',
    setupCode: 'function pair<T, U>(a: T, b: U): [T, U] { return [a, b]; }',
    expected: ['hello', 42],
    sample: 'pair("hello", 42)',
    hints: ['Use two type parameters for different types', 'Return a tuple type [T, U]'],
    tags: ['generics', 'tuples', 'functions'],
  },
  {
    id: 'ts-generic-005',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Swap Function',
    text: 'Create a generic function that swaps the elements of a pair',
    setup: 'function swap<T, U>(pair: [T, U]): [U, T] { return [pair[1], pair[0]]; }',
    setupCode: 'function swap<T, U>(pair: [T, U]): [U, T] { return [pair[1], pair[0]]; }',
    expected: [2, 'a'],
    sample: 'swap(["a", 2])',
    hints: ['Input is [T, U], output is [U, T]', 'Return elements in reverse order'],
    tags: ['generics', 'tuples', 'functions'],
  },
  {
    id: 'ts-generic-006',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Wrap in Array',
    text: 'Create a generic function that wraps a value in an array',
    setup: 'function wrapInArray<T>(value: T): T[] { return [value]; }',
    setupCode: 'function wrapInArray<T>(value: T): T[] { return [value]; }',
    expected: [5],
    sample: 'wrapInArray(5)',
    hints: ['Return type is T[] (array of T)', 'Wrap single value in array literal'],
    tags: ['generics', 'arrays', 'functions'],
  },
  {
    id: 'ts-generic-007',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Repeat Value',
    text: 'Create a generic function that creates an array with a value repeated n times',
    setup: 'function repeat<T>(value: T, n: number): T[] { return Array(n).fill(value); }',
    setupCode: 'function repeat<T>(value: T, n: number): T[] { return Array(n).fill(value); }',
    expected: ['x', 'x', 'x'],
    sample: 'repeat("x", 3)',
    hints: ['Use Array(n).fill() to create repeated values', 'Return type is T[]'],
    tags: ['generics', 'arrays', 'functions'],
  },
  {
    id: 'ts-generic-008',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Nullable Type',
    text: 'Create a generic function that returns value or null based on condition',
    setup:
      'function nullable<T>(value: T, isNull: boolean): T | null { return isNull ? null : value; }',
    setupCode:
      'function nullable<T>(value: T, isNull: boolean): T | null { return isNull ? null : value; }',
    expected: null,
    sample: 'nullable("test", true)',
    hints: ['Return type is T | null union', 'Use ternary to conditionally return null'],
    tags: ['generics', 'nullable', 'functions'],
  },
  {
    id: 'ts-generic-009',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Default Value',
    text: 'Create a generic function that returns value or default if null/undefined',
    setup:
      'function withDefault<T>(value: T | null | undefined, defaultVal: T): T { return value ?? defaultVal; }',
    setupCode:
      'function withDefault<T>(value: T | null | undefined, defaultVal: T): T { return value ?? defaultVal; }',
    expected: 'default',
    sample: 'withDefault(null, "default")',
    hints: ['Use nullish coalescing operator ??', 'Both value and default share same type T'],
    tags: ['generics', 'nullish', 'functions'],
  },
  {
    id: 'ts-generic-010',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Array Length',
    text: 'Create a generic function that returns the length of an array',
    setup: 'function len<T>(arr: T[]): number { return arr.length; }',
    setupCode: 'function len<T>(arr: T[]): number { return arr.length; }',
    expected: 4,
    sample: 'len([1, 2, 3, 4])',
    hints: ['Access .length property on array', 'Return type is number, not generic'],
    tags: ['generics', 'arrays', 'functions'],
  },

  // ============================================================
  // Advanced Generics - Generic Constraints
  // ============================================================
  {
    id: 'ts-generic-011',
    category: 'Generic Constraints',
    difficulty: 'easy',
    title: 'Constrained to Object with Length',
    text: 'Create a function that accepts only values with a length property',
    setup:
      'function getLength<T extends { length: number }>(obj: T): number { return obj.length; }',
    setupCode:
      'function getLength<T extends { length: number }>(obj: T): number { return obj.length; }',
    expected: 5,
    sample: 'getLength("hello")',
    hints: ['Use extends to constrain the type', 'Constraint requires length: number property'],
    tags: ['generics', 'constraints', 'extends'],
  },
  {
    id: 'ts-generic-012',
    category: 'Generic Constraints',
    difficulty: 'easy',
    title: 'Constrained to String Keys',
    text: 'Create a function that gets a property from an object using a string key',
    setup: 'function getProp<T, K extends keyof T>(obj: T, key: K): T[K] { return obj[key]; }',
    setupCode: 'function getProp<T, K extends keyof T>(obj: T, key: K): T[K] { return obj[key]; }',
    expected: 'Alice',
    sample: 'getProp({ name: "Alice", age: 30 }, "name")',
    hints: ['K extends keyof T constrains to valid keys', 'Return type T[K] is the property type'],
    tags: ['generics', 'constraints', 'keyof'],
  },
  {
    id: 'ts-generic-013',
    category: 'Generic Constraints',
    difficulty: 'medium',
    title: 'Constrained to Number Type',
    text: 'Create a function that only accepts number types and doubles them',
    setup: 'function double<T extends number>(value: T): number { return value * 2; }',
    setupCode: 'function double<T extends number>(value: T): number { return value * 2; }',
    expected: 10,
    sample: 'double(5)',
    hints: ['T extends number restricts to numeric types', 'Arithmetic operations are allowed'],
    tags: ['generics', 'constraints', 'number'],
  },
  {
    id: 'ts-generic-014',
    category: 'Generic Constraints',
    difficulty: 'medium',
    title: 'Constrained to Function Type',
    text: 'Create a function that calls a callback and returns its result',
    setup:
      'function call<T extends (...args: any[]) => any>(fn: T): ReturnType<T> { return fn(); }',
    setupCode:
      'function call<T extends (...args: any[]) => any>(fn: T): ReturnType<T> { return fn(); }',
    expected: 42,
    sample: 'call(() => 42)',
    hints: ['Constrain T to function type', 'Use ReturnType utility for return type'],
    tags: ['generics', 'constraints', 'functions'],
  },
  {
    id: 'ts-generic-015',
    category: 'Generic Constraints',
    difficulty: 'medium',
    title: 'Constrained to Array Type',
    text: 'Create a function that flattens a nested array by one level',
    setup: 'function flatten<T extends any[]>(arr: T[]): T[number][] { return arr.flat(); }',
    setupCode: 'function flatten<T extends any[]>(arr: T[]): T[number][] { return arr.flat(); }',
    expected: [1, 2, 3, 4],
    sample: 'flatten([[1, 2], [3, 4]])',
    hints: ['T extends any[] constrains to arrays', 'T[number] gets element type of array'],
    tags: ['generics', 'constraints', 'arrays'],
  },
  {
    id: 'ts-generic-016',
    category: 'Generic Constraints',
    difficulty: 'medium',
    title: 'Multiple Constraints with Intersection',
    text: 'Create a function that requires both name and id properties',
    setup:
      'function identify<T extends { name: string } & { id: number }>(obj: T): string { return `${obj.id}: ${obj.name}`; }',
    setupCode:
      'function identify<T extends { name: string } & { id: number }>(obj: T): string { return `${obj.id}: ${obj.name}`; }',
    expected: '1: Alice',
    sample: 'identify({ id: 1, name: "Alice" })',
    hints: ['Use & to combine constraints', 'Object must have both properties'],
    tags: ['generics', 'constraints', 'intersection'],
  },
  {
    id: 'ts-generic-017',
    category: 'Generic Constraints',
    difficulty: 'medium',
    title: 'Constrained Generic with Default',
    text: 'Create a function with a constrained generic that has a default type',
    setup:
      'function createArray<T extends object = { value: number }>(item: T): T[] { return [item]; }',
    setupCode:
      'function createArray<T extends object = { value: number }>(item: T): T[] { return [item]; }',
    expected: [{ value: 10 }],
    sample: 'createArray({ value: 10 })',
    hints: ['Use = after extends for default type', 'Default applies when type not specified'],
    tags: ['generics', 'constraints', 'default'],
  },
  {
    id: 'ts-generic-018',
    category: 'Generic Constraints',
    difficulty: 'hard',
    title: 'Recursive Constraint',
    text: 'Create a type that constrains to objects with nested same structure',
    setup:
      'type TreeNode<T> = { value: T; children?: TreeNode<T>[] };\nfunction sumTree(node: TreeNode<number>): number { return node.value + (node.children?.reduce((s, c) => s + sumTree(c), 0) ?? 0); }',
    setupCode:
      'type TreeNode<T> = { value: T; children?: TreeNode<T>[] };\nfunction sumTree(node: TreeNode<number>): number { return node.value + (node.children?.reduce((s, c) => s + sumTree(c), 0) ?? 0); }',
    expected: 6,
    sample: 'sumTree({ value: 1, children: [{ value: 2 }, { value: 3 }] })',
    hints: ['TreeNode references itself in children', 'Recursive types allow nested structures'],
    tags: ['generics', 'constraints', 'recursive'],
  },
  {
    id: 'ts-generic-019',
    category: 'Generic Constraints',
    difficulty: 'easy',
    title: 'Constrained to String Type',
    text: 'Create a function that only accepts string types and returns uppercase',
    setup:
      'function upper<T extends string>(str: T): Uppercase<T> { return str.toUpperCase() as Uppercase<T>; }',
    setupCode:
      'function upper<T extends string>(str: T): Uppercase<T> { return str.toUpperCase() as Uppercase<T>; }',
    expected: 'HELLO',
    sample: 'upper("hello")',
    hints: ['T extends string constrains to strings', 'Uppercase<T> is a template literal type'],
    tags: ['generics', 'constraints', 'string'],
  },
  {
    id: 'ts-generic-020',
    category: 'Generic Constraints',
    difficulty: 'medium',
    title: 'Constrained to Promise Type',
    text: 'Create a function that unwraps a Promise type',
    setup:
      'async function unwrap<T extends Promise<any>>(promise: T): Promise<Awaited<T>> { return await promise; }',
    setupCode:
      'async function unwrap<T extends Promise<any>>(promise: T): Promise<Awaited<T>> { return await promise; }',
    expected: 'resolved',
    sample: 'await unwrap(Promise.resolve("resolved"))',
    hints: ['Constrain T to Promise type', 'Awaited extracts the resolved type'],
    tags: ['generics', 'constraints', 'promise'],
  },

  // ============================================================
  // Advanced Generics - Generic Interfaces
  // ============================================================
  {
    id: 'ts-generic-021',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Container Interface',
    text: 'Create a generic container interface that holds a value',
    setup: 'interface Container<T> { value: T; }\nconst box: Container<number> = { value: 42 };',
    setupCode:
      'interface Container<T> { value: T; }\nconst box: Container<number> = { value: 42 };',
    expected: 42,
    sample: 'box.value',
    hints: [
      'Interface takes type parameter in angle brackets',
      'T is used for the value property type',
    ],
    tags: ['generics', 'interfaces', 'container'],
  },
  {
    id: 'ts-generic-022',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Result Interface',
    text: 'Create a generic Result interface for success/error handling',
    setup:
      'interface Result<T, E> { success: boolean; data?: T; error?: E; }\nconst result: Result<string, Error> = { success: true, data: "done" };',
    setupCode:
      'interface Result<T, E> { success: boolean; data?: T; error?: E; }\nconst result: Result<string, Error> = { success: true, data: "done" };',
    expected: 'done',
    sample: 'result.data',
    hints: ['Use two type parameters for data and error', 'Optional properties with ? modifier'],
    tags: ['generics', 'interfaces', 'result'],
  },
  {
    id: 'ts-generic-023',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Generic Repository Interface',
    text: 'Create a generic repository interface for CRUD operations',
    setup:
      'interface Repository<T, ID> { findById(id: ID): T | null; save(item: T): void; }\nclass UserRepo implements Repository<{name: string}, number> { private users: {name: string}[] = []; findById(id: number) { return this.users[id] ?? null; } save(item: {name: string}) { this.users.push(item); } }',
    setupCode:
      'interface Repository<T, ID> { findById(id: ID): T | null; save(item: T): void; }\nclass UserRepo implements Repository<{name: string}, number> { private users: {name: string}[] = []; findById(id: number) { return this.users[id] ?? null; } save(item: {name: string}) { this.users.push(item); } }',
    expected: { name: 'Alice' },
    sample: 'const repo = new UserRepo();\nrepo.save({ name: "Alice" });\nrepo.findById(0)',
    hints: ['T is entity type, ID is identifier type', 'Methods use generic types in signatures'],
    tags: ['generics', 'interfaces', 'repository'],
  },
  {
    id: 'ts-generic-024',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Generic Comparable Interface',
    text: 'Create a generic Comparable interface for sorting',
    setup:
      'interface Comparable<T> { compareTo(other: T): number; }\nclass Num implements Comparable<Num> { constructor(public val: number) {} compareTo(other: Num) { return this.val - other.val; } }',
    setupCode:
      'interface Comparable<T> { compareTo(other: T): number; }\nclass Num implements Comparable<Num> { constructor(public val: number) {} compareTo(other: Num) { return this.val - other.val; } }',
    expected: -1,
    sample: 'new Num(5).compareTo(new Num(10))',
    hints: [
      'compareTo returns negative, zero, or positive',
      'Self-referential generic: Comparable<Num>',
    ],
    tags: ['generics', 'interfaces', 'comparable'],
  },
  {
    id: 'ts-generic-025',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Stack Interface',
    text: 'Create a generic Stack interface with push, pop, and peek',
    setup:
      'interface Stack<T> { push(item: T): void; pop(): T | undefined; peek(): T | undefined; }\nconst stack: Stack<number> = { items: [] as number[], push(item) { this.items.push(item); }, pop() { return this.items.pop(); }, peek() { return this.items[this.items.length - 1]; } };',
    setupCode:
      'interface Stack<T> { push(item: T): void; pop(): T | undefined; peek(): T | undefined; }\nconst stack: Stack<number> = { items: [] as number[], push(item) { this.items.push(item); }, pop() { return this.items.pop(); }, peek() { return this.items[this.items.length - 1]; } };',
    expected: 3,
    sample: 'stack.push(1); stack.push(2); stack.push(3); stack.peek()',
    hints: ['Stack operations use same type T', 'pop and peek return T | undefined for empty'],
    tags: ['generics', 'interfaces', 'stack'],
  },
  {
    id: 'ts-generic-026',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Generic Event Emitter Interface',
    text: 'Create a generic event emitter interface with typed events',
    setup:
      'interface EventEmitter<E extends Record<string, any>> { on<K extends keyof E>(event: K, cb: (data: E[K]) => void): void; emit<K extends keyof E>(event: K, data: E[K]): void; }\ntype Events = { click: { x: number; y: number }; load: string };\nconst emitter: EventEmitter<Events> & { handlers: any } = { handlers: {}, on(e, cb) { this.handlers[e] = cb; }, emit(e, data) { this.handlers[e]?.(data); } };',
    setupCode:
      'interface EventEmitter<E extends Record<string, any>> { on<K extends keyof E>(event: K, cb: (data: E[K]) => void): void; emit<K extends keyof E>(event: K, data: E[K]): void; }\ntype Events = { click: { x: number; y: number }; load: string };\nconst emitter: EventEmitter<Events> & { handlers: any } = { handlers: {}, on(e, cb) { this.handlers[e] = cb; }, emit(e, data) { this.handlers[e]?.(data); } };',
    expected: { x: 10, y: 20 },
    sample:
      'let result: any;\nemitter.on("click", (data) => { result = data; });\nemitter.emit("click", { x: 10, y: 20 });\nresult',
    hints: ['E maps event names to payload types', 'K extends keyof E constrains to valid events'],
    tags: ['generics', 'interfaces', 'events'],
  },

  // ============================================================
  // Advanced Generics - Generic Classes
  // ============================================================
  {
    id: 'ts-generic-027',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Box Class',
    text: 'Create a generic Box class that wraps a value',
    setup: 'class Box<T> { constructor(public value: T) {} getValue(): T { return this.value; } }',
    setupCode:
      'class Box<T> { constructor(public value: T) {} getValue(): T { return this.value; } }',
    expected: 'hello',
    sample: 'new Box("hello").getValue()',
    hints: ['Class takes type parameter after name', 'Constructor and methods use the type T'],
    tags: ['generics', 'classes', 'box'],
  },
  {
    id: 'ts-generic-028',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Pair Class',
    text: 'Create a generic Pair class holding two values of different types',
    setup:
      'class Pair<T, U> { constructor(public first: T, public second: U) {} toArray(): [T, U] { return [this.first, this.second]; } }',
    setupCode:
      'class Pair<T, U> { constructor(public first: T, public second: U) {} toArray(): [T, U] { return [this.first, this.second]; } }',
    expected: ['name', 42],
    sample: 'new Pair("name", 42).toArray()',
    hints: ['Use two type parameters T and U', 'Return tuple type [T, U] from toArray'],
    tags: ['generics', 'classes', 'pair'],
  },
  {
    id: 'ts-generic-029',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Generic Queue Class',
    text: 'Create a generic Queue class with enqueue and dequeue',
    setup:
      'class Queue<T> { private items: T[] = []; enqueue(item: T): void { this.items.push(item); } dequeue(): T | undefined { return this.items.shift(); } size(): number { return this.items.length; } }',
    setupCode:
      'class Queue<T> { private items: T[] = []; enqueue(item: T): void { this.items.push(item); } dequeue(): T | undefined { return this.items.shift(); } size(): number { return this.items.length; } }',
    expected: 'first',
    sample:
      'const q = new Queue<string>();\nq.enqueue("first");\nq.enqueue("second");\nq.dequeue()',
    hints: ['Use array as internal storage', 'shift() removes and returns first element'],
    tags: ['generics', 'classes', 'queue'],
  },
  {
    id: 'ts-generic-030',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Generic LinkedList Node',
    text: 'Create a generic LinkedList node class',
    setup:
      'class ListNode<T> { next: ListNode<T> | null = null; constructor(public value: T) {} append(val: T): ListNode<T> { const node = new ListNode(val); this.next = node; return node; } }',
    setupCode:
      'class ListNode<T> { next: ListNode<T> | null = null; constructor(public value: T) {} append(val: T): ListNode<T> { const node = new ListNode(val); this.next = node; return node; } }',
    expected: 2,
    sample: 'const head = new ListNode(1);\nhead.append(2);\nhead.next?.value',
    hints: ['Self-referential: next is ListNode<T> | null', 'Recursive structure for linked list'],
    tags: ['generics', 'classes', 'linkedlist'],
  },
  {
    id: 'ts-generic-031',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Generic Cache Class',
    text: 'Create a generic Cache class with get, set, and has methods',
    setup:
      'class Cache<K, V> { private store = new Map<K, V>(); get(key: K): V | undefined { return this.store.get(key); } set(key: K, value: V): void { this.store.set(key, value); } has(key: K): boolean { return this.store.has(key); } }',
    setupCode:
      'class Cache<K, V> { private store = new Map<K, V>(); get(key: K): V | undefined { return this.store.get(key); } set(key: K, value: V): void { this.store.set(key, value); } has(key: K): boolean { return this.store.has(key); } }',
    expected: 'value1',
    sample:
      'const cache = new Cache<string, string>();\ncache.set("key1", "value1");\ncache.get("key1")',
    hints: ['Use Map<K, V> for internal storage', 'Two type parameters: K for key, V for value'],
    tags: ['generics', 'classes', 'cache'],
  },
  {
    id: 'ts-generic-032',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Generic Observable Class',
    text: 'Create a generic Observable class with subscribe and notify',
    setup:
      'class Observable<T> { private observers: ((value: T) => void)[] = []; subscribe(fn: (value: T) => void): () => void { this.observers.push(fn); return () => { this.observers = this.observers.filter(o => o !== fn); }; } notify(value: T): void { this.observers.forEach(fn => fn(value)); } }',
    setupCode:
      'class Observable<T> { private observers: ((value: T) => void)[] = []; subscribe(fn: (value: T) => void): () => void { this.observers.push(fn); return () => { this.observers = this.observers.filter(o => o !== fn); }; } notify(value: T): void { this.observers.forEach(fn => fn(value)); } }',
    expected: 'hello',
    sample:
      'const obs = new Observable<string>();\nlet result = "";\nobs.subscribe(v => { result = v; });\nobs.notify("hello");\nresult',
    hints: ['Observers are functions taking T', 'subscribe returns unsubscribe function'],
    tags: ['generics', 'classes', 'observable'],
  },

  // ============================================================
  // Advanced Generics - Default Type Parameters
  // ============================================================
  {
    id: 'ts-generic-033',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Default Type Parameter Basic',
    text: 'Create a generic type with a default type parameter',
    setup:
      'type Container<T = string> = { value: T };\nconst container: Container = { value: "default" };',
    setupCode:
      'type Container<T = string> = { value: T };\nconst container: Container = { value: "default" };',
    expected: 'default',
    sample: 'container.value',
    hints: ['Use = after type parameter for default', 'Default is used when type not specified'],
    tags: ['generics', 'default', 'type-parameter'],
  },
  {
    id: 'ts-generic-034',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Default Type with Override',
    text: 'Use a generic type with an explicit type overriding the default',
    setup:
      'type Response<T = any> = { data: T; status: number };\nconst resp: Response<number[]> = { data: [1, 2, 3], status: 200 };',
    setupCode:
      'type Response<T = any> = { data: T; status: number };\nconst resp: Response<number[]> = { data: [1, 2, 3], status: 200 };',
    expected: [1, 2, 3],
    sample: 'resp.data',
    hints: ['Default is any, but we specify number[]', 'Explicit type overrides the default'],
    tags: ['generics', 'default', 'override'],
  },
  {
    id: 'ts-generic-035',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Multiple Defaults',
    text: 'Create a type with multiple default type parameters',
    setup:
      'type ApiResponse<T = unknown, E = Error> = { data?: T; error?: E; ok: boolean };\nconst success: ApiResponse<string> = { data: "result", ok: true };',
    setupCode:
      'type ApiResponse<T = unknown, E = Error> = { data?: T; error?: E; ok: boolean };\nconst success: ApiResponse<string> = { data: "result", ok: true };',
    expected: 'result',
    sample: 'success.data',
    hints: ['Each parameter can have its own default', 'Later defaults use earlier parameters'],
    tags: ['generics', 'default', 'multiple'],
  },
  {
    id: 'ts-generic-036',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Default Depends on Previous',
    text: 'Create a type where default depends on a previous type parameter',
    setup:
      'type KeyValue<K extends string = string, V = K> = { key: K; value: V };\nconst kv: KeyValue = { key: "test", value: "test" };',
    setupCode:
      'type KeyValue<K extends string = string, V = K> = { key: K; value: V };\nconst kv: KeyValue = { key: "test", value: "test" };',
    expected: 'test',
    sample: 'kv.value',
    hints: ['V = K means V defaults to same type as K', 'Dependencies between type parameters'],
    tags: ['generics', 'default', 'dependent'],
  },

  // ============================================================
  // Advanced Generics - Generic Type Inference
  // ============================================================
  {
    id: 'ts-generic-037',
    category: 'Generic Inference',
    difficulty: 'easy',
    title: 'Infer from Argument',
    text: 'Let TypeScript infer the generic type from the argument',
    setup: 'function echo<T>(value: T): T { return value; }',
    setupCode: 'function echo<T>(value: T): T { return value; }',
    expected: true,
    sample: 'echo(true)',
    hints: ['No need to specify <boolean>', 'Type inferred from argument value'],
    tags: ['generics', 'inference', 'arguments'],
  },
  {
    id: 'ts-generic-038',
    category: 'Generic Inference',
    difficulty: 'easy',
    title: 'Infer Array Element Type',
    text: 'Infer element type from an array argument',
    setup: 'function head<T>(arr: T[]): T | undefined { return arr[0]; }',
    setupCode: 'function head<T>(arr: T[]): T | undefined { return arr[0]; }',
    expected: 1,
    sample: 'head([1, 2, 3])',
    hints: ['T is inferred as number from [1, 2, 3]', 'Array literal provides inference context'],
    tags: ['generics', 'inference', 'arrays'],
  },
  {
    id: 'ts-generic-039',
    category: 'Generic Inference',
    difficulty: 'medium',
    title: 'Infer from Multiple Arguments',
    text: 'Infer a common type from multiple arguments',
    setup: 'function merge<T>(a: T, b: T): T[] { return [a, b]; }',
    setupCode: 'function merge<T>(a: T, b: T): T[] { return [a, b]; }',
    expected: [1, 2],
    sample: 'merge(1, 2)',
    hints: ['Both arguments must be same type T', 'TypeScript finds common type'],
    tags: ['generics', 'inference', 'multiple'],
  },
  {
    id: 'ts-generic-040',
    category: 'Generic Inference',
    difficulty: 'medium',
    title: 'Infer from Return Context',
    text: 'Let generic be inferred from expected return type context',
    setup: 'function create<T>(): T[] { return []; }',
    setupCode: 'function create<T>(): T[] { return []; }',
    expected: true,
    sample: 'const nums: number[] = create();\nArray.isArray(nums)',
    hints: ['Return type annotation provides context', 'T inferred as number from context'],
    tags: ['generics', 'inference', 'context'],
  },
  {
    id: 'ts-generic-041',
    category: 'Generic Inference',
    difficulty: 'medium',
    title: 'Infer Object Property Types',
    text: 'Infer types from object literal properties',
    setup:
      'function keys<T extends object>(obj: T): (keyof T)[] { return Object.keys(obj) as (keyof T)[]; }',
    setupCode:
      'function keys<T extends object>(obj: T): (keyof T)[] { return Object.keys(obj) as (keyof T)[]; }',
    expected: ['a', 'b'],
    sample: 'keys({ a: 1, b: 2 })',
    hints: ['T inferred as { a: number; b: number }', 'keyof T gives "a" | "b"'],
    tags: ['generics', 'inference', 'objects'],
  },
  {
    id: 'ts-generic-042',
    category: 'Generic Inference',
    difficulty: 'hard',
    title: 'Infer Function Parameter Type',
    text: 'Infer the parameter type of a callback function',
    setup: 'function map<T, U>(arr: T[], fn: (item: T) => U): U[] { return arr.map(fn); }',
    setupCode: 'function map<T, U>(arr: T[], fn: (item: T) => U): U[] { return arr.map(fn); }',
    expected: [2, 4, 6],
    sample: 'map([1, 2, 3], x => x * 2)',
    hints: ['T inferred from array, U from callback return', 'x is inferred as number'],
    tags: ['generics', 'inference', 'callbacks'],
  },
  {
    id: 'ts-generic-043',
    category: 'Generic Inference',
    difficulty: 'hard',
    title: 'Infer Tuple Types',
    text: 'Infer tuple types preserving element types',
    setup: 'function tuple<T extends any[]>(...args: T): T { return args; }',
    setupCode: 'function tuple<T extends any[]>(...args: T): T { return args; }',
    expected: ['a', 1, true],
    sample: 'tuple("a", 1, true)',
    hints: [
      'Rest parameter with generic array type',
      'Tuple type [string, number, boolean] inferred',
    ],
    tags: ['generics', 'inference', 'tuples'],
  },

  // ============================================================
  // Advanced Generics - Conditional Types
  // ============================================================
  {
    id: 'ts-generic-044',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Basic Conditional Type',
    text: 'Create a type that returns different types based on a condition',
    setup: 'type IsString<T> = T extends string ? true : false;',
    setupCode: 'type IsString<T> = T extends string ? true : false;',
    expected: true,
    sample: 'const result: IsString<"hello"> = true;\nresult',
    hints: ['Use extends for type condition', 'Ternary-like syntax for conditional types'],
    tags: ['generics', 'conditional', 'extends'],
  },
  {
    id: 'ts-generic-045',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Conditional Return Type',
    text: 'Create a function with conditional return type',
    setup:
      'function process<T>(value: T): T extends string ? number : string { return (typeof value === "string" ? value.length : String(value)) as any; }',
    setupCode:
      'function process<T>(value: T): T extends string ? number : string { return (typeof value === "string" ? value.length : String(value)) as any; }',
    expected: 5,
    sample: 'process("hello")',
    hints: ['Return type depends on input type', 'String input returns length (number)'],
    tags: ['generics', 'conditional', 'return-type'],
  },
  {
    id: 'ts-generic-046',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Exclude Type',
    text: 'Use conditional type to exclude types from a union',
    setup: 'type MyExclude<T, U> = T extends U ? never : T;',
    setupCode: 'type MyExclude<T, U> = T extends U ? never : T;',
    expected: 'a',
    sample: 'const val: MyExclude<"a" | "b" | "c", "b" | "c"> = "a";\nval',
    hints: ['Conditional distributes over unions', 'never removes type from union'],
    tags: ['generics', 'conditional', 'exclude'],
  },
  {
    id: 'ts-generic-047',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Extract Type',
    text: 'Use conditional type to extract matching types from a union',
    setup: 'type MyExtract<T, U> = T extends U ? T : never;',
    setupCode: 'type MyExtract<T, U> = T extends U ? T : never;',
    expected: 'b',
    sample: 'const val: MyExtract<"a" | "b" | "c", "b" | "d"> = "b";\nval',
    hints: ['Opposite of Exclude logic', 'Keeps types that match U'],
    tags: ['generics', 'conditional', 'extract'],
  },
  {
    id: 'ts-generic-048',
    category: 'Generics',
    difficulty: 'hard',
    title: 'NonNullable Type',
    text: 'Create a type that removes null and undefined from a union',
    setup: 'type MyNonNullable<T> = T extends null | undefined ? never : T;',
    setupCode: 'type MyNonNullable<T> = T extends null | undefined ? never : T;',
    expected: 'value',
    sample: 'const val: MyNonNullable<string | null | undefined> = "value";\nval',
    hints: ['Exclude null and undefined', 'Uses conditional distribution'],
    tags: ['generics', 'conditional', 'nonnullable'],
  },
  {
    id: 'ts-generic-049',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Flatten Conditional Type',
    text: 'Create a type that flattens nested arrays',
    setup: 'type Flatten<T> = T extends (infer U)[] ? Flatten<U> : T;',
    setupCode: 'type Flatten<T> = T extends (infer U)[] ? Flatten<U> : T;',
    expected: 1,
    sample: 'const val: Flatten<number[][][]> = 1;\nval',
    hints: ['Recursively check for array type', 'infer U gets element type'],
    tags: ['generics', 'conditional', 'flatten', 'recursive'],
  },
  {
    id: 'ts-generic-050',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Distributive Conditional Type',
    text: 'Understand how conditional types distribute over unions',
    setup: 'type ToArray<T> = T extends any ? T[] : never;',
    setupCode: 'type ToArray<T> = T extends any ? T[] : never;',
    expected: [1],
    sample: 'const val: ToArray<string | number> = [1];\nval',
    hints: ['Distributes: ToArray<A | B> = A[] | B[]', 'Each union member processed separately'],
    tags: ['generics', 'conditional', 'distributive'],
  },

  // ============================================================
  // Advanced Generics - Infer Keyword
  // ============================================================
  {
    id: 'ts-generic-051',
    category: 'Generic Inference',
    difficulty: 'medium',
    title: 'Infer Array Element',
    text: 'Use infer to extract the element type of an array',
    setup: 'type ElementOf<T> = T extends (infer E)[] ? E : never;',
    setupCode: 'type ElementOf<T> = T extends (infer E)[] ? E : never;',
    expected: 'test',
    sample: 'const val: ElementOf<string[]> = "test";\nval',
    hints: ['infer E captures the element type', 'Pattern matches array structure'],
    tags: ['generics', 'infer', 'array'],
  },
  {
    id: 'ts-generic-052',
    category: 'Generic Inference',
    difficulty: 'medium',
    title: 'Infer Function Return Type',
    text: 'Use infer to extract the return type of a function',
    setup: 'type MyReturnType<T> = T extends (...args: any[]) => infer R ? R : never;',
    setupCode: 'type MyReturnType<T> = T extends (...args: any[]) => infer R ? R : never;',
    expected: 42,
    sample: 'type Fn = () => number;\nconst val: MyReturnType<Fn> = 42;\nval',
    hints: ['infer R captures the return type', 'Pattern matches function signature'],
    tags: ['generics', 'infer', 'return-type'],
  },
  {
    id: 'ts-generic-053',
    category: 'Generic Inference',
    difficulty: 'medium',
    title: 'Infer Function Parameters',
    text: 'Use infer to extract the parameter types of a function',
    setup: 'type MyParameters<T> = T extends (...args: infer P) => any ? P : never;',
    setupCode: 'type MyParameters<T> = T extends (...args: infer P) => any ? P : never;',
    expected: ['hello', 42],
    sample:
      'type Fn = (a: string, b: number) => void;\nconst params: MyParameters<Fn> = ["hello", 42];\nparams',
    hints: ['infer P captures parameter tuple', 'Rest parameter pattern in signature'],
    tags: ['generics', 'infer', 'parameters'],
  },
  {
    id: 'ts-generic-054',
    category: 'Generic Inference',
    difficulty: 'hard',
    title: 'Infer Promise Type',
    text: 'Use infer to extract the resolved type of a Promise',
    setup: 'type Unpromise<T> = T extends Promise<infer U> ? U : T;',
    setupCode: 'type Unpromise<T> = T extends Promise<infer U> ? U : T;',
    expected: 'resolved',
    sample: 'const val: Unpromise<Promise<string>> = "resolved";\nval',
    hints: ['infer U captures Promise generic type', 'Non-promise types pass through'],
    tags: ['generics', 'infer', 'promise'],
  },
  {
    id: 'ts-generic-055',
    category: 'Generic Inference',
    difficulty: 'hard',
    title: 'Infer First Argument',
    text: 'Use infer to extract the first parameter type of a function',
    setup: 'type FirstArg<T> = T extends (first: infer F, ...rest: any[]) => any ? F : never;',
    setupCode: 'type FirstArg<T> = T extends (first: infer F, ...rest: any[]) => any ? F : never;',
    expected: 'first',
    sample:
      'type Fn = (a: string, b: number, c: boolean) => void;\nconst val: FirstArg<Fn> = "first";\nval',
    hints: ['Pattern match first parameter separately', 'Rest collects remaining parameters'],
    tags: ['generics', 'infer', 'first-arg'],
  },
  {
    id: 'ts-generic-056',
    category: 'Generic Inference',
    difficulty: 'hard',
    title: 'Infer Constructor Instance',
    text: 'Use infer to extract the instance type from a constructor',
    setup: 'type InstanceOf<T> = T extends new (...args: any[]) => infer I ? I : never;',
    setupCode: 'type InstanceOf<T> = T extends new (...args: any[]) => infer I ? I : never;',
    expected: { name: 'test' },
    sample:
      'class Foo { name = "test"; }\nconst instance: InstanceOf<typeof Foo> = new Foo();\n({ name: instance.name })',
    hints: ['new keyword indicates constructor', 'infer I captures instance type'],
    tags: ['generics', 'infer', 'constructor'],
  },
  {
    id: 'ts-generic-057',
    category: 'Generic Inference',
    difficulty: 'hard',
    title: 'Infer Tuple Last Element',
    text: 'Use infer to extract the last element type of a tuple',
    setup: 'type Last<T extends any[]> = T extends [...infer _, infer L] ? L : never;',
    setupCode: 'type Last<T extends any[]> = T extends [...infer _, infer L] ? L : never;',
    expected: true,
    sample: 'const val: Last<[string, number, boolean]> = true;\nval',
    hints: ['Spread infer captures all but last', 'L captures the last element'],
    tags: ['generics', 'infer', 'tuple', 'last'],
  },
  {
    id: 'ts-generic-058',
    category: 'Generic Inference',
    difficulty: 'hard',
    title: 'Infer Tuple First Element',
    text: 'Use infer to extract the first element type of a tuple',
    setup: 'type First<T extends any[]> = T extends [infer F, ...infer _] ? F : never;',
    setupCode: 'type First<T extends any[]> = T extends [infer F, ...infer _] ? F : never;',
    expected: 'first',
    sample: 'const val: First<[string, number, boolean]> = "first";\nval',
    hints: ['F captures first element', 'Spread infer captures the rest'],
    tags: ['generics', 'infer', 'tuple', 'first'],
  },

  // ============================================================
  // Advanced Generics - Mapped Types
  // ============================================================
  {
    id: 'ts-generic-059',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Basic Mapped Type',
    text: 'Create a mapped type that makes all properties optional',
    setup: 'type MyPartial<T> = { [K in keyof T]?: T[K] };',
    setupCode: 'type MyPartial<T> = { [K in keyof T]?: T[K] };',
    expected: { name: 'Alice' },
    sample:
      'type Person = { name: string; age: number };\nconst partial: MyPartial<Person> = { name: "Alice" };\npartial',
    hints: ['K in keyof T iterates over keys', '? makes each property optional'],
    tags: ['generics', 'mapped-types', 'partial'],
  },
  {
    id: 'ts-generic-060',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Required Mapped Type',
    text: 'Create a mapped type that makes all properties required',
    setup: 'type MyRequired<T> = { [K in keyof T]-?: T[K] };',
    setupCode: 'type MyRequired<T> = { [K in keyof T]-?: T[K] };',
    expected: { name: 'Bob', age: 25 },
    sample:
      'type Person = { name?: string; age?: number };\nconst required: MyRequired<Person> = { name: "Bob", age: 25 };\nrequired',
    hints: ['-? removes optional modifier', 'All properties become required'],
    tags: ['generics', 'mapped-types', 'required'],
  },
  {
    id: 'ts-generic-061',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Readonly Mapped Type',
    text: 'Create a mapped type that makes all properties readonly',
    setup: 'type MyReadonly<T> = { readonly [K in keyof T]: T[K] };',
    setupCode: 'type MyReadonly<T> = { readonly [K in keyof T]: T[K] };',
    expected: 42,
    sample:
      'type Data = { value: number };\nconst data: MyReadonly<Data> = { value: 42 };\ndata.value',
    hints: ['readonly modifier prevents reassignment', 'Applied to each property'],
    tags: ['generics', 'mapped-types', 'readonly'],
  },
  {
    id: 'ts-generic-062',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Pick Mapped Type',
    text: 'Create a mapped type that picks specific properties',
    setup: 'type MyPick<T, K extends keyof T> = { [P in K]: T[P] };',
    setupCode: 'type MyPick<T, K extends keyof T> = { [P in K]: T[P] };',
    expected: { name: 'Alice' },
    sample:
      'type Person = { name: string; age: number; email: string };\nconst picked: MyPick<Person, "name"> = { name: "Alice" };\npicked',
    hints: ['K extends keyof T constrains to valid keys', 'Only iterate over specified keys'],
    tags: ['generics', 'mapped-types', 'pick'],
  },
  {
    id: 'ts-generic-063',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Omit Mapped Type',
    text: 'Create a mapped type that omits specific properties',
    setup: 'type MyOmit<T, K extends keyof T> = { [P in Exclude<keyof T, K>]: T[P] };',
    setupCode: 'type MyOmit<T, K extends keyof T> = { [P in Exclude<keyof T, K>]: T[P] };',
    expected: { age: 30 },
    sample:
      'type Person = { name: string; age: number };\nconst omitted: MyOmit<Person, "name"> = { age: 30 };\nomitted',
    hints: ['Use Exclude to remove keys', 'Iterate over remaining keys'],
    tags: ['generics', 'mapped-types', 'omit'],
  },
  {
    id: 'ts-generic-064',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Record Mapped Type',
    text: 'Create a mapped type that creates an object type with specific keys',
    setup: 'type MyRecord<K extends string, V> = { [P in K]: V };',
    setupCode: 'type MyRecord<K extends string, V> = { [P in K]: V };',
    expected: { a: 1, b: 1 },
    sample: 'const record: MyRecord<"a" | "b", number> = { a: 1, b: 1 };\nrecord',
    hints: ['K is a union of keys', 'All keys map to same value type V'],
    tags: ['generics', 'mapped-types', 'record'],
  },
  {
    id: 'ts-generic-065',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Nullable Properties Mapped Type',
    text: 'Create a mapped type that makes all properties nullable',
    setup: 'type Nullable<T> = { [K in keyof T]: T[K] | null };',
    setupCode: 'type Nullable<T> = { [K in keyof T]: T[K] | null };',
    expected: { name: null, age: 25 },
    sample:
      'type Person = { name: string; age: number };\nconst nullable: Nullable<Person> = { name: null, age: 25 };\nnullable',
    hints: ['Add | null to each property type', 'Original type preserved in union'],
    tags: ['generics', 'mapped-types', 'nullable'],
  },
  {
    id: 'ts-generic-066',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Key Remapping Mapped Type',
    text: 'Create a mapped type that prefixes all keys',
    setup: 'type Prefixed<T, P extends string> = { [K in keyof T as `${P}${K & string}`]: T[K] };',
    setupCode:
      'type Prefixed<T, P extends string> = { [K in keyof T as `${P}${K & string}`]: T[K] };',
    expected: { get_name: 'Alice' },
    sample:
      'type Person = { name: string };\nconst prefixed: Prefixed<Person, "get_"> = { get_name: "Alice" };\nprefixed',
    hints: ['Use as clause for key remapping', 'Template literal creates new key'],
    tags: ['generics', 'mapped-types', 'key-remapping'],
  },
  {
    id: 'ts-generic-067',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Getters Mapped Type',
    text: 'Create a mapped type that converts properties to getter methods',
    setup: 'type Getters<T> = { [K in keyof T as `get${Capitalize<K & string>}`]: () => T[K] };',
    setupCode:
      'type Getters<T> = { [K in keyof T as `get${Capitalize<K & string>}`]: () => T[K] };',
    expected: 'Alice',
    sample:
      'type Person = { name: string };\nconst getters: Getters<Person> = { getName: () => "Alice" };\ngetters.getName()',
    hints: [
      'Capitalize transforms first letter',
      'Property becomes function returning original type',
    ],
    tags: ['generics', 'mapped-types', 'getters'],
  },
  {
    id: 'ts-generic-068',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Deep Readonly Mapped Type',
    text: 'Create a recursive mapped type that makes all nested properties readonly',
    setup:
      'type DeepReadonly<T> = { readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K] };',
    setupCode:
      'type DeepReadonly<T> = { readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K] };',
    expected: 'nested',
    sample:
      'type Data = { a: { b: string } };\nconst data: DeepReadonly<Data> = { a: { b: "nested" } };\ndata.a.b',
    hints: ['Recursively apply for object properties', 'Base case for non-object types'],
    tags: ['generics', 'mapped-types', 'deep', 'readonly'],
  },

  // ============================================================
  // Advanced Generics - Variadic Tuple Types
  // ============================================================
  {
    id: 'ts-generic-069',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Variadic Tuple Concat',
    text: 'Create a type that concatenates two tuple types',
    setup: 'type Concat<T extends any[], U extends any[]> = [...T, ...U];',
    setupCode: 'type Concat<T extends any[], U extends any[]> = [...T, ...U];',
    expected: [1, 2, 'a', 'b'],
    sample: 'const result: Concat<[1, 2], ["a", "b"]> = [1, 2, "a", "b"];\nresult',
    hints: ['Spread both tuples into new tuple', 'Order is preserved'],
    tags: ['generics', 'variadic', 'tuple', 'concat'],
  },
  {
    id: 'ts-generic-070',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Variadic Tuple Push',
    text: 'Create a type that adds an element to the end of a tuple',
    setup: 'type Push<T extends any[], E> = [...T, E];',
    setupCode: 'type Push<T extends any[], E> = [...T, E];',
    expected: [1, 2, 3],
    sample: 'const result: Push<[1, 2], 3> = [1, 2, 3];\nresult',
    hints: ['Spread existing tuple, add new element', 'E is appended at the end'],
    tags: ['generics', 'variadic', 'tuple', 'push'],
  },
  {
    id: 'ts-generic-071',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Variadic Tuple Unshift',
    text: 'Create a type that adds an element to the beginning of a tuple',
    setup: 'type Unshift<T extends any[], E> = [E, ...T];',
    setupCode: 'type Unshift<T extends any[], E> = [E, ...T];',
    expected: [0, 1, 2],
    sample: 'const result: Unshift<[1, 2], 0> = [0, 1, 2];\nresult',
    hints: ['New element first, then spread tuple', 'E is prepended at the start'],
    tags: ['generics', 'variadic', 'tuple', 'unshift'],
  },
  {
    id: 'ts-generic-072',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Variadic Tuple Pop',
    text: 'Create a type that removes the last element from a tuple',
    setup: 'type Pop<T extends any[]> = T extends [...infer R, any] ? R : never;',
    setupCode: 'type Pop<T extends any[]> = T extends [...infer R, any] ? R : never;',
    expected: [1, 2],
    sample: 'const result: Pop<[1, 2, 3]> = [1, 2];\nresult',
    hints: ['Use infer with spread to capture all but last', 'any matches the last element'],
    tags: ['generics', 'variadic', 'tuple', 'pop'],
  },
  {
    id: 'ts-generic-073',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Variadic Tuple Shift',
    text: 'Create a type that removes the first element from a tuple',
    setup: 'type Shift<T extends any[]> = T extends [any, ...infer R] ? R : never;',
    setupCode: 'type Shift<T extends any[]> = T extends [any, ...infer R] ? R : never;',
    expected: [2, 3],
    sample: 'const result: Shift<[1, 2, 3]> = [2, 3];\nresult',
    hints: ['Match first element as any', 'Infer rest of tuple'],
    tags: ['generics', 'variadic', 'tuple', 'shift'],
  },
  {
    id: 'ts-generic-074',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Variadic Tuple Length',
    text: 'Create a type that returns the length of a tuple as a literal type',
    setup: 'type Length<T extends any[]> = T["length"];',
    setupCode: 'type Length<T extends any[]> = T["length"];',
    expected: 3,
    sample: 'const len: Length<[1, 2, 3]> = 3;\nlen',
    hints: ['Tuple types have literal length', 'Access length property of tuple type'],
    tags: ['generics', 'variadic', 'tuple', 'length'],
  },
  {
    id: 'ts-generic-075',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Variadic Function Parameters',
    text: 'Create a function that accepts variadic tuple parameters',
    setup:
      'function combine<T extends any[], U extends any[]>(a: [...T], b: [...U]): [...T, ...U] { return [...a, ...b]; }',
    setupCode:
      'function combine<T extends any[], U extends any[]>(a: [...T], b: [...U]): [...T, ...U] { return [...a, ...b]; }',
    expected: [1, 'a', true, 2],
    sample: 'combine([1, "a"], [true, 2])',
    hints: ['Spread operator in function signature', 'Return type combines both tuples'],
    tags: ['generics', 'variadic', 'functions'],
  },

  // ============================================================
  // Advanced Generics - Complex Patterns
  // ============================================================
  {
    id: 'ts-generic-076',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Type Alias',
    text: 'Create a generic type alias for a callback function',
    setup:
      'type Callback<T> = (value: T) => void;\nconst logNum: Callback<number> = (n) => console.log(n);',
    setupCode:
      'type Callback<T> = (value: T) => void;\nconst logNum: Callback<number> = (n) => console.log(n);',
    expected: 'function',
    sample: 'typeof logNum',
    hints: ['Type alias can be generic', 'T is used in function parameter'],
    tags: ['generics', 'type-alias', 'callback'],
  },
  {
    id: 'ts-generic-077',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Union Type',
    text: 'Create a generic type that represents success or failure',
    setup: 'type Result<T> = { ok: true; value: T } | { ok: false; error: string };',
    setupCode: 'type Result<T> = { ok: true; value: T } | { ok: false; error: string };',
    expected: 42,
    sample:
      'const success: Result<number> = { ok: true, value: 42 };\nsuccess.ok ? success.value : 0',
    hints: ['Union of success and failure cases', 'Discriminated union with ok property'],
    tags: ['generics', 'union', 'result'],
  },
  {
    id: 'ts-generic-078',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Generic Builder Pattern',
    text: 'Create a generic builder that chains method calls',
    setup:
      'class Builder<T extends object> { private obj: T = {} as T; set<K extends string, V>(key: K, value: V): Builder<T & Record<K, V>> { (this.obj as any)[key] = value; return this as any; } build(): T { return this.obj; } }',
    setupCode:
      'class Builder<T extends object> { private obj: T = {} as T; set<K extends string, V>(key: K, value: V): Builder<T & Record<K, V>> { (this.obj as any)[key] = value; return this as any; } build(): T { return this.obj; } }',
    expected: { name: 'test', age: 25 },
    sample: 'new Builder().set("name", "test").set("age", 25).build()',
    hints: ['Each set call expands the type', 'Returns new Builder with extended type'],
    tags: ['generics', 'builder', 'pattern'],
  },
  {
    id: 'ts-generic-079',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Generic Singleton Pattern',
    text: 'Create a generic singleton factory',
    setup:
      'function singleton<T>(create: () => T): () => T { let instance: T | null = null; return () => { if (instance === null) instance = create(); return instance; }; }',
    setupCode:
      'function singleton<T>(create: () => T): () => T { let instance: T | null = null; return () => { if (instance === null) instance = create(); return instance; }; }',
    expected: true,
    sample: 'const getConfig = singleton(() => ({ debug: true }));\ngetConfig() === getConfig()',
    hints: ['Factory returns same instance always', 'Lazy initialization on first call'],
    tags: ['generics', 'singleton', 'pattern'],
  },
  {
    id: 'ts-generic-080',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Generic Memoization',
    text: 'Create a generic memoization function',
    setup:
      'function memoize<T extends (...args: any[]) => any>(fn: T): T { const cache = new Map<string, ReturnType<T>>(); return ((...args: Parameters<T>) => { const key = JSON.stringify(args); if (!cache.has(key)) cache.set(key, fn(...args)); return cache.get(key)!; }) as T; }',
    setupCode:
      'function memoize<T extends (...args: any[]) => any>(fn: T): T { const cache = new Map<string, ReturnType<T>>(); return ((...args: Parameters<T>) => { const key = JSON.stringify(args); if (!cache.has(key)) cache.set(key, fn(...args)); return cache.get(key)!; }) as T; }',
    expected: 8,
    sample: 'const cube = memoize((n: number) => n ** 3);\ncube(2)',
    hints: ['Cache results by stringified args', 'Return cached value if available'],
    tags: ['generics', 'memoize', 'pattern'],
  },
  {
    id: 'ts-generic-081',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Generic Pipe Function',
    text: 'Create a generic pipe function that composes functions left to right',
    setup:
      'function pipe<A, B>(f: (a: A) => B): (a: A) => B;\nfunction pipe<A, B, C>(f: (a: A) => B, g: (b: B) => C): (a: A) => C;\nfunction pipe<A, B, C, D>(f: (a: A) => B, g: (b: B) => C, h: (c: C) => D): (a: A) => D;\nfunction pipe(...fns: Function[]): Function { return (x: any) => fns.reduce((v, f) => f(v), x); }',
    setupCode:
      'function pipe<A, B>(f: (a: A) => B): (a: A) => B;\nfunction pipe<A, B, C>(f: (a: A) => B, g: (b: B) => C): (a: A) => C;\nfunction pipe<A, B, C, D>(f: (a: A) => B, g: (b: B) => C, h: (c: C) => D): (a: A) => D;\nfunction pipe(...fns: Function[]): Function { return (x: any) => fns.reduce((v, f) => f(v), x); }',
    expected: 6,
    sample: 'const process = pipe((x: number) => x + 1, (x: number) => x * 2);\nprocess(2)',
    hints: ['Overloads handle different arities', 'Each function output feeds next input'],
    tags: ['generics', 'pipe', 'composition'],
  },
  {
    id: 'ts-generic-082',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Generic Curry Function',
    text: 'Create a generic curry function for two arguments',
    setup:
      'function curry<A, B, R>(fn: (a: A, b: B) => R): (a: A) => (b: B) => R { return (a: A) => (b: B) => fn(a, b); }',
    setupCode:
      'function curry<A, B, R>(fn: (a: A, b: B) => R): (a: A) => (b: B) => R { return (a: A) => (b: B) => fn(a, b); }',
    expected: 5,
    sample: 'const add = curry((a: number, b: number) => a + b);\nadd(2)(3)',
    hints: ['Returns nested functions', 'Each function takes one argument'],
    tags: ['generics', 'curry', 'functions'],
  },
  {
    id: 'ts-generic-083',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Generic State Machine Type',
    text: 'Create generic types for a type-safe state machine',
    setup:
      'type State<S extends string, D = void> = { state: S; data: D };\ntype Transition<From extends string, To extends string> = { from: From; to: To };\nfunction transition<S extends string, D, T extends string>(current: State<S, D>, to: T): State<T, D> { return { state: to, data: current.data }; }',
    setupCode:
      'type State<S extends string, D = void> = { state: S; data: D };\ntype Transition<From extends string, To extends string> = { from: From; to: To };\nfunction transition<S extends string, D, T extends string>(current: State<S, D>, to: T): State<T, D> { return { state: to, data: current.data }; }',
    expected: 'active',
    sample:
      'const idle: State<"idle", number> = { state: "idle", data: 42 };\nconst active = transition(idle, "active");\nactive.state',
    hints: ['State type pairs state name with data', 'Transition changes state type'],
    tags: ['generics', 'state-machine', 'pattern'],
  },
  {
    id: 'ts-generic-084',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Predicate Type',
    text: 'Create a generic predicate type for filtering',
    setup:
      'type Predicate<T> = (value: T) => boolean;\nconst isEven: Predicate<number> = (n) => n % 2 === 0;',
    setupCode:
      'type Predicate<T> = (value: T) => boolean;\nconst isEven: Predicate<number> = (n) => n % 2 === 0;',
    expected: [2, 4],
    sample: '[1, 2, 3, 4, 5].filter(isEven)',
    hints: ['Predicate returns boolean', 'Used for filtering operations'],
    tags: ['generics', 'predicate', 'filter'],
  },
  {
    id: 'ts-generic-085',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Comparator Type',
    text: 'Create a generic comparator type for sorting',
    setup:
      'type Comparator<T> = (a: T, b: T) => number;\nconst byLength: Comparator<string> = (a, b) => a.length - b.length;',
    setupCode:
      'type Comparator<T> = (a: T, b: T) => number;\nconst byLength: Comparator<string> = (a, b) => a.length - b.length;',
    expected: ['a', 'bb', 'ccc'],
    sample: '["ccc", "a", "bb"].sort(byLength)',
    hints: ['Comparator returns negative, zero, or positive', 'Used for sorting operations'],
    tags: ['generics', 'comparator', 'sort'],
  },

  // ============================================================
  // Utility Types - Partial
  // ============================================================
  {
    id: 'ts-utility-001',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Basic Partial Type',
    text: 'Create a partial user object where all properties are optional using the Partial utility type',
    setup: 'interface User { id: number; name: string; email: string; }',
    setupCode: 'interface User { id: number; name: string; email: string; }',
    expected: { name: 'Alice' },
    sample: 'const partialUser: Partial<User> = { name: "Alice" };\npartialUser',
    hints: ['Partial<T> makes all properties optional', 'You can include any subset of properties'],
    tags: ['utility-types', 'partial'],
  },
  {
    id: 'ts-utility-002',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Partial for Update Functions',
    text: 'Use Partial to create a function that accepts partial updates to a user object',
    setup:
      'interface User { id: number; name: string; email: string; }\nconst user: User = { id: 1, name: "Bob", email: "bob@test.com" };',
    setupCode:
      'interface User { id: number; name: string; email: string; }\nconst user: User = { id: 1, name: "Bob", email: "bob@test.com" };',
    expected: { id: 1, name: 'Bob', email: 'bob@new.com' },
    sample:
      'function updateUser(user: User, updates: Partial<User>): User {\n  return { ...user, ...updates };\n}\nupdateUser(user, { email: "bob@new.com" })',
    hints: [
      'Partial allows passing only the fields to update',
      'Spread operator merges the updates',
    ],
    tags: ['utility-types', 'partial', 'functions'],
  },
  {
    id: 'ts-utility-003',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Partial with Nested Objects',
    text: 'Create a partially filled configuration object with nested properties',
    setup:
      'interface Config { server: { host: string; port: number; }; database: { url: string; }; }',
    setupCode:
      'interface Config { server: { host: string; port: number; }; database: { url: string; }; }',
    expected: { server: { host: 'localhost', port: 3000 } },
    sample:
      'const config: Partial<Config> = { server: { host: "localhost", port: 3000 } };\nconfig',
    hints: [
      'Partial only makes top-level properties optional',
      'Nested objects still require all their properties',
    ],
    tags: ['utility-types', 'partial', 'nested'],
  },
  {
    id: 'ts-utility-004',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'Deep Partial Type',
    text: 'Implement a DeepPartial type that makes all nested properties optional recursively',
    setup:
      'type DeepPartial<T> = T extends object ? { [P in keyof T]?: DeepPartial<T[P]> } : T;\ninterface Config { server: { host: string; port: number; }; }',
    setupCode:
      'type DeepPartial<T> = T extends object ? { [P in keyof T]?: DeepPartial<T[P]> } : T;\ninterface Config { server: { host: string; port: number; }; }',
    expected: { server: { host: 'localhost' } },
    sample: 'const config: DeepPartial<Config> = { server: { host: "localhost" } };\nconfig',
    hints: ['Use recursive conditional types', 'Check if T extends object before recursing'],
    tags: ['utility-types', 'partial', 'deep', 'recursive'],
  },
  {
    id: 'ts-utility-005',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'Partial with Required Keys',
    text: 'Create a type that makes all properties optional except specified keys',
    setup:
      'type PartialExcept<T, K extends keyof T> = Partial<T> & Pick<T, K>;\ninterface User { id: number; name: string; email: string; }',
    setupCode:
      'type PartialExcept<T, K extends keyof T> = Partial<T> & Pick<T, K>;\ninterface User { id: number; name: string; email: string; }',
    expected: { id: 1, name: 'Alice' },
    sample: 'const user: PartialExcept<User, "id"> = { id: 1, name: "Alice" };\nuser',
    hints: ['Combine Partial and Pick with intersection', 'Pick extracts required keys'],
    tags: ['utility-types', 'partial', 'pick', 'advanced'],
  },

  // ============================================================
  // Utility Types - Required
  // ============================================================
  {
    id: 'ts-utility-006',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Basic Required Type',
    text: 'Convert a type with optional properties to one where all properties are required',
    setup: 'interface OptionalUser { id?: number; name?: string; email?: string; }',
    setupCode: 'interface OptionalUser { id?: number; name?: string; email?: string; }',
    expected: { id: 1, name: 'Alice', email: 'alice@test.com' },
    sample:
      'const user: Required<OptionalUser> = { id: 1, name: "Alice", email: "alice@test.com" };\nuser',
    hints: ['Required<T> makes all properties required', 'All properties must be provided'],
    tags: ['utility-types', 'required'],
  },
  {
    id: 'ts-utility-007',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Required for Form Validation',
    text: 'Ensure all form fields are filled before submission using Required',
    setup:
      'interface FormData { username?: string; password?: string; }\nfunction validateForm(data: Required<FormData>): boolean { return data.username.length > 0 && data.password.length > 0; }',
    setupCode:
      'interface FormData { username?: string; password?: string; }\nfunction validateForm(data: Required<FormData>): boolean { return data.username.length > 0 && data.password.length > 0; }',
    expected: true,
    sample:
      'const formData: Required<FormData> = { username: "admin", password: "secret" };\nvalidateForm(formData)',
    hints: [
      'Required ensures no undefined values',
      'Safe to access properties without optional chaining',
    ],
    tags: ['utility-types', 'required', 'validation'],
  },
  {
    id: 'ts-utility-008',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Required with Partial Combination',
    text: 'Use Required to override Partial and ensure all properties exist',
    setup:
      'interface User { id: number; name: string; email: string; }\ntype PartialUser = Partial<User>;',
    setupCode:
      'interface User { id: number; name: string; email: string; }\ntype PartialUser = Partial<User>;',
    expected: { id: 1, name: 'Bob', email: 'bob@test.com' },
    sample:
      'const partial: PartialUser = { id: 1, name: "Bob" };\nconst complete: Required<PartialUser> = { ...partial, email: "bob@test.com" };\ncomplete',
    hints: ['Required<Partial<T>> equals T', 'Fill in missing properties to satisfy Required'],
    tags: ['utility-types', 'required', 'partial'],
  },
  {
    id: 'ts-utility-009',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'Deep Required Type',
    text: 'Implement a DeepRequired type that makes all nested properties required recursively',
    setup:
      'type DeepRequired<T> = T extends object ? { [P in keyof T]-?: DeepRequired<T[P]> } : T;\ninterface Config { server?: { host?: string; port?: number; }; }',
    setupCode:
      'type DeepRequired<T> = T extends object ? { [P in keyof T]-?: DeepRequired<T[P]> } : T;\ninterface Config { server?: { host?: string; port?: number; }; }',
    expected: { server: { host: 'localhost', port: 3000 } },
    sample:
      'const config: DeepRequired<Config> = { server: { host: "localhost", port: 3000 } };\nconfig',
    hints: ['Use -? to remove optional modifier', 'Recursively apply to nested objects'],
    tags: ['utility-types', 'required', 'deep', 'recursive'],
  },
  {
    id: 'ts-utility-010',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'Required Keys Extraction',
    text: 'Extract only the keys that are required (non-optional) from a type',
    setup:
      'type RequiredKeys<T> = { [K in keyof T]-?: {} extends Pick<T, K> ? never : K }[keyof T];\ninterface User { id: number; name: string; email?: string; }',
    setupCode:
      'type RequiredKeys<T> = { [K in keyof T]-?: {} extends Pick<T, K> ? never : K }[keyof T];\ninterface User { id: number; name: string; email?: string; }',
    expected: ['id', 'name'],
    sample: 'type Keys = RequiredKeys<User>;\nconst keys: Keys[] = ["id", "name"];\nkeys',
    hints: [
      'Check if {} extends Pick<T, K> to detect optional',
      'Optional keys return never and are filtered out',
    ],
    tags: ['utility-types', 'required', 'keys', 'advanced'],
  },

  // ============================================================
  // Utility Types - Readonly
  // ============================================================
  {
    id: 'ts-utility-011',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Basic Readonly Type',
    text: 'Create an immutable user object using the Readonly utility type',
    setup: 'interface User { id: number; name: string; }',
    setupCode: 'interface User { id: number; name: string; }',
    expected: { id: 1, name: 'Alice' },
    sample: 'const user: Readonly<User> = { id: 1, name: "Alice" };\nuser',
    hints: [
      'Readonly<T> makes all properties readonly',
      'Attempting to modify properties causes a compile error',
    ],
    tags: ['utility-types', 'readonly'],
  },
  {
    id: 'ts-utility-012',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Readonly Arrays',
    text: 'Create an immutable array that cannot be modified',
    setup: 'const numbers: number[] = [1, 2, 3];',
    setupCode: 'const numbers: number[] = [1, 2, 3];',
    expected: [1, 2, 3],
    sample: 'const readonlyNumbers: Readonly<number[]> = [1, 2, 3];\nreadonlyNumbers',
    hints: ['Readonly works on arrays too', 'Use ReadonlyArray<T> as an alternative'],
    tags: ['utility-types', 'readonly', 'arrays'],
  },
  {
    id: 'ts-utility-013',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'ReadonlyArray Type',
    text: 'Use ReadonlyArray to create an immutable array type',
    setup:
      'function sum(numbers: ReadonlyArray<number>): number { return numbers.reduce((a, b) => a + b, 0); }',
    setupCode:
      'function sum(numbers: ReadonlyArray<number>): number { return numbers.reduce((a, b) => a + b, 0); }',
    expected: 15,
    sample: 'const nums: ReadonlyArray<number> = [1, 2, 3, 4, 5];\nsum(nums)',
    hints: [
      'ReadonlyArray prevents push, pop, and mutations',
      'Read operations like reduce are allowed',
    ],
    tags: ['utility-types', 'readonly', 'arrays'],
  },
  {
    id: 'ts-utility-014',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'Deep Readonly Type',
    text: 'Implement a DeepReadonly type that makes all nested properties readonly recursively',
    setup:
      'type DeepReadonly<T> = T extends object ? { readonly [P in keyof T]: DeepReadonly<T[P]> } : T;\ninterface State { user: { name: string; settings: { theme: string; }; }; }',
    setupCode:
      'type DeepReadonly<T> = T extends object ? { readonly [P in keyof T]: DeepReadonly<T[P]> } : T;\ninterface State { user: { name: string; settings: { theme: string; }; }; }',
    expected: { user: { name: 'Alice', settings: { theme: 'dark' } } },
    sample:
      'const state: DeepReadonly<State> = { user: { name: "Alice", settings: { theme: "dark" } } };\nstate',
    hints: ['Recursively apply readonly to nested objects', 'Base case is non-object types'],
    tags: ['utility-types', 'readonly', 'deep', 'recursive'],
  },
  {
    id: 'ts-utility-015',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Mutable from Readonly',
    text: 'Create a Mutable type that removes readonly modifiers from all properties',
    setup:
      'type Mutable<T> = { -readonly [P in keyof T]: T[P] };\ninterface ReadonlyUser { readonly id: number; readonly name: string; }',
    setupCode:
      'type Mutable<T> = { -readonly [P in keyof T]: T[P] };\ninterface ReadonlyUser { readonly id: number; readonly name: string; }',
    expected: { id: 2, name: 'Bob' },
    sample:
      'const user: Mutable<ReadonlyUser> = { id: 1, name: "Alice" };\nuser.id = 2;\nuser.name = "Bob";\nuser',
    hints: [
      'Use -readonly to remove the readonly modifier',
      'Mapped types can modify property modifiers',
    ],
    tags: ['utility-types', 'readonly', 'mutable', 'mapped-types'],
  },

  // ============================================================
  // Utility Types - Pick
  // ============================================================
  {
    id: 'ts-utility-016',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Basic Pick Type',
    text: 'Pick only the name and email properties from a User type',
    setup: 'interface User { id: number; name: string; email: string; createdAt: Date; }',
    setupCode: 'interface User { id: number; name: string; email: string; createdAt: Date; }',
    expected: { name: 'Alice', email: 'alice@test.com' },
    sample:
      'const contact: Pick<User, "name" | "email"> = { name: "Alice", email: "alice@test.com" };\ncontact',
    hints: ['Pick<T, K> selects specific properties', 'Use union type for multiple keys'],
    tags: ['utility-types', 'pick'],
  },
  {
    id: 'ts-utility-017',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Pick Single Property',
    text: 'Create a type with only the id property from User',
    setup: 'interface User { id: number; name: string; email: string; }',
    setupCode: 'interface User { id: number; name: string; email: string; }',
    expected: { id: 42 },
    sample: 'const userId: Pick<User, "id"> = { id: 42 };\nuserId',
    hints: ['Pick works with a single key', 'Result type has only the picked property'],
    tags: ['utility-types', 'pick'],
  },
  {
    id: 'ts-utility-018',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Pick for API Response',
    text: 'Create a public user type by picking only non-sensitive fields',
    setup:
      'interface User { id: number; name: string; email: string; password: string; apiKey: string; }',
    setupCode:
      'interface User { id: number; name: string; email: string; password: string; apiKey: string; }',
    expected: { id: 1, name: 'Alice', email: 'alice@test.com' },
    sample:
      'type PublicUser = Pick<User, "id" | "name" | "email">;\nconst publicUser: PublicUser = { id: 1, name: "Alice", email: "alice@test.com" };\npublicUser',
    hints: [
      'Pick is useful for creating subset types',
      'Sensitive fields like password are excluded',
    ],
    tags: ['utility-types', 'pick', 'api'],
  },
  {
    id: 'ts-utility-019',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Pick with Generics',
    text: 'Create a generic function that picks specific properties from an object',
    setup:
      'function pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n  const result = {} as Pick<T, K>;\n  keys.forEach(key => result[key] = obj[key]);\n  return result;\n}\nconst user = { id: 1, name: "Alice", email: "alice@test.com", age: 30 };',
    setupCode:
      'function pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n  const result = {} as Pick<T, K>;\n  keys.forEach(key => result[key] = obj[key]);\n  return result;\n}\nconst user = { id: 1, name: "Alice", email: "alice@test.com", age: 30 };',
    expected: { name: 'Alice', age: 30 },
    sample: 'pick(user, ["name", "age"])',
    hints: ['K extends keyof T constrains keys', 'Pick<T, K> is the return type'],
    tags: ['utility-types', 'pick', 'generics'],
  },
  {
    id: 'ts-utility-020',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'Pick by Value Type',
    text: 'Create a type that picks only properties of a specific value type',
    setup:
      'type PickByType<T, V> = { [K in keyof T as T[K] extends V ? K : never]: T[K] };\ninterface Mixed { id: number; name: string; count: number; label: string; }',
    setupCode:
      'type PickByType<T, V> = { [K in keyof T as T[K] extends V ? K : never]: T[K] };\ninterface Mixed { id: number; name: string; count: number; label: string; }',
    expected: { id: 1, count: 5 },
    sample:
      'type NumberProps = PickByType<Mixed, number>;\nconst nums: NumberProps = { id: 1, count: 5 };\nnums',
    hints: ['Use key remapping with as clause', 'Filter keys based on value type'],
    tags: ['utility-types', 'pick', 'advanced', 'key-remapping'],
  },

  // ============================================================
  // Utility Types - Omit
  // ============================================================
  {
    id: 'ts-utility-021',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Basic Omit Type',
    text: 'Create a user type without the password field using Omit',
    setup: 'interface User { id: number; name: string; email: string; password: string; }',
    setupCode: 'interface User { id: number; name: string; email: string; password: string; }',
    expected: { id: 1, name: 'Alice', email: 'alice@test.com' },
    sample:
      'const user: Omit<User, "password"> = { id: 1, name: "Alice", email: "alice@test.com" };\nuser',
    hints: [
      'Omit<T, K> excludes specified properties',
      'Result has all properties except omitted ones',
    ],
    tags: ['utility-types', 'omit'],
  },
  {
    id: 'ts-utility-022',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Omit Multiple Properties',
    text: 'Remove multiple sensitive fields from a user type',
    setup:
      'interface User { id: number; name: string; email: string; password: string; apiKey: string; }',
    setupCode:
      'interface User { id: number; name: string; email: string; password: string; apiKey: string; }',
    expected: { id: 1, name: 'Alice', email: 'alice@test.com' },
    sample:
      'const safeUser: Omit<User, "password" | "apiKey"> = { id: 1, name: "Alice", email: "alice@test.com" };\nsafeUser',
    hints: ['Use union type to omit multiple keys', 'Omit is useful for sanitizing data'],
    tags: ['utility-types', 'omit', 'security'],
  },
  {
    id: 'ts-utility-023',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Omit for Extension',
    text: 'Create an extended type by omitting a property and adding a new one',
    setup: 'interface BaseUser { id: number; name: string; role: string; }',
    setupCode: 'interface BaseUser { id: number; name: string; role: string; }',
    expected: { id: 1, name: 'Alice', role: 'admin', permissions: ['read', 'write'] },
    sample:
      'type AdminUser = Omit<BaseUser, "role"> & { role: "admin"; permissions: string[]; };\nconst admin: AdminUser = { id: 1, name: "Alice", role: "admin", permissions: ["read", "write"] };\nadmin',
    hints: ['Omit the property you want to override', 'Use intersection to add new properties'],
    tags: ['utility-types', 'omit', 'extension'],
  },
  {
    id: 'ts-utility-024',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Omit with Generics',
    text: 'Create a generic function that omits specified properties from an object',
    setup:
      'function omit<T, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> {\n  const result = { ...obj };\n  keys.forEach(key => delete (result as any)[key]);\n  return result;\n}\nconst user = { id: 1, name: "Alice", password: "secret", apiKey: "key123" };',
    setupCode:
      'function omit<T, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> {\n  const result = { ...obj };\n  keys.forEach(key => delete (result as any)[key]);\n  return result;\n}\nconst user = { id: 1, name: "Alice", password: "secret", apiKey: "key123" };',
    expected: { id: 1, name: 'Alice' },
    sample: 'omit(user, ["password", "apiKey"])',
    hints: ['K extends keyof T constrains the keys', 'Omit<T, K> is the return type'],
    tags: ['utility-types', 'omit', 'generics'],
  },
  {
    id: 'ts-utility-025',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'Omit by Value Type',
    text: 'Create a type that omits properties of a specific value type',
    setup:
      'type OmitByType<T, V> = { [K in keyof T as T[K] extends V ? never : K]: T[K] };\ninterface Mixed { id: number; name: string; count: number; label: string; }',
    setupCode:
      'type OmitByType<T, V> = { [K in keyof T as T[K] extends V ? never : K]: T[K] };\ninterface Mixed { id: number; name: string; count: number; label: string; }',
    expected: { name: 'test', label: 'item' },
    sample:
      'type StringProps = OmitByType<Mixed, number>;\nconst strs: StringProps = { name: "test", label: "item" };\nstrs',
    hints: ['Use key remapping with as clause', 'Return never to exclude keys'],
    tags: ['utility-types', 'omit', 'advanced', 'key-remapping'],
  },

  // ============================================================
  // Utility Types - Record
  // ============================================================
  {
    id: 'ts-utility-026',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Basic Record Type',
    text: 'Create a record that maps string keys to number values',
    setup: 'type Scores = Record<string, number>;',
    setupCode: 'type Scores = Record<string, number>;',
    expected: { alice: 100, bob: 85, charlie: 92 },
    sample: 'const scores: Scores = { alice: 100, bob: 85, charlie: 92 };\nscores',
    hints: [
      'Record<K, V> creates an object type with key type K and value type V',
      'Useful for dictionary-like structures',
    ],
    tags: ['utility-types', 'record'],
  },
  {
    id: 'ts-utility-027',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Record with Union Keys',
    text: 'Create a record with specific literal type keys',
    setup: 'type Status = "pending" | "active" | "completed";',
    setupCode: 'type Status = "pending" | "active" | "completed";',
    expected: { pending: 5, active: 3, completed: 12 },
    sample:
      'const statusCounts: Record<Status, number> = { pending: 5, active: 3, completed: 12 };\nstatusCounts',
    hints: ['Union types can be used as keys', 'All union members must be present'],
    tags: ['utility-types', 'record', 'union'],
  },
  {
    id: 'ts-utility-028',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Record for Object Values',
    text: 'Create a record mapping user IDs to user objects',
    setup: 'interface User { name: string; email: string; }',
    setupCode: 'interface User { name: string; email: string; }',
    expected: {
      '1': { name: 'Alice', email: 'alice@test.com' },
      '2': { name: 'Bob', email: 'bob@test.com' },
    },
    sample:
      'const users: Record<string, User> = {\n  "1": { name: "Alice", email: "alice@test.com" },\n  "2": { name: "Bob", email: "bob@test.com" }\n};\nusers',
    hints: ['Record values can be complex types', 'Useful for lookup tables'],
    tags: ['utility-types', 'record', 'objects'],
  },
  {
    id: 'ts-utility-029',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Record for State Management',
    text: 'Create a type-safe state object using Record with specific states',
    setup:
      'type LoadingState = "idle" | "loading" | "success" | "error";\ninterface StateConfig { message: string; canRetry: boolean; }',
    setupCode:
      'type LoadingState = "idle" | "loading" | "success" | "error";\ninterface StateConfig { message: string; canRetry: boolean; }',
    expected: {
      idle: { message: 'Ready', canRetry: false },
      loading: { message: 'Loading...', canRetry: false },
      success: { message: 'Done!', canRetry: false },
      error: { message: 'Failed', canRetry: true },
    },
    sample:
      'const stateConfig: Record<LoadingState, StateConfig> = {\n  idle: { message: "Ready", canRetry: false },\n  loading: { message: "Loading...", canRetry: false },\n  success: { message: "Done!", canRetry: false },\n  error: { message: "Failed", canRetry: true }\n};\nstateConfig',
    hints: ['Record ensures all states are covered', 'Compile error if a state is missing'],
    tags: ['utility-types', 'record', 'state-management'],
  },
  {
    id: 'ts-utility-030',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Nested Record Types',
    text: 'Create a nested record for categorized items',
    setup:
      'type Category = "electronics" | "clothing";\ntype Item = { name: string; price: number; };',
    setupCode:
      'type Category = "electronics" | "clothing";\ntype Item = { name: string; price: number; };',
    expected: {
      electronics: { laptop: { name: 'MacBook', price: 1999 } },
      clothing: { shirt: { name: 'T-Shirt', price: 25 } },
    },
    sample:
      'const inventory: Record<Category, Record<string, Item>> = {\n  electronics: { laptop: { name: "MacBook", price: 1999 } },\n  clothing: { shirt: { name: "T-Shirt", price: 25 } }\n};\ninventory',
    hints: ['Records can be nested', 'Inner Record has string keys, Item values'],
    tags: ['utility-types', 'record', 'nested'],
  },
  {
    id: 'ts-utility-031',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'Record with Mapped Types',
    text: 'Create a Record type that makes all values optional',
    setup:
      'type PartialRecord<K extends keyof any, V> = { [P in K]?: V };\ntype Status = "pending" | "active" | "completed";',
    setupCode:
      'type PartialRecord<K extends keyof any, V> = { [P in K]?: V };\ntype Status = "pending" | "active" | "completed";',
    expected: { pending: 5, completed: 10 },
    sample: 'const counts: PartialRecord<Status, number> = { pending: 5, completed: 10 };\ncounts',
    hints: ['Combine Record pattern with optional modifier', 'Not all keys need to be present'],
    tags: ['utility-types', 'record', 'mapped-types', 'partial'],
  },

  // ============================================================
  // Utility Types - Exclude
  // ============================================================
  {
    id: 'ts-utility-032',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Basic Exclude Type',
    text: 'Exclude specific types from a union type',
    setup: 'type Status = "pending" | "active" | "completed" | "cancelled";',
    setupCode: 'type Status = "pending" | "active" | "completed" | "cancelled";',
    expected: 'active',
    sample:
      'type ActiveStatus = Exclude<Status, "pending" | "cancelled">;\nconst status: ActiveStatus = "active";\nstatus',
    hints: ['Exclude<T, U> removes U from union T', 'Result is the remaining union members'],
    tags: ['utility-types', 'exclude', 'union'],
  },
  {
    id: 'ts-utility-033',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Exclude Null and Undefined',
    text: 'Remove null and undefined from a union type',
    setup: 'type MaybeString = string | null | undefined;',
    setupCode: 'type MaybeString = string | null | undefined;',
    expected: 'hello',
    sample:
      'type DefiniteString = Exclude<MaybeString, null | undefined>;\nconst str: DefiniteString = "hello";\nstr',
    hints: ['Exclude can remove multiple types at once', 'Similar to NonNullable for this case'],
    tags: ['utility-types', 'exclude', 'nullish'],
  },
  {
    id: 'ts-utility-034',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Exclude Function Types',
    text: 'Exclude function types from a mixed union',
    setup: 'type Mixed = string | number | (() => void) | ((x: number) => number);',
    setupCode: 'type Mixed = string | number | (() => void) | ((x: number) => number);',
    expected: 'test',
    sample:
      'type NonFunction = Exclude<Mixed, Function>;\nconst value: NonFunction = "test";\nvalue',
    hints: ['Function is the base type for all functions', 'Exclude removes all function types'],
    tags: ['utility-types', 'exclude', 'functions'],
  },
  {
    id: 'ts-utility-035',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Exclude for Event Types',
    text: 'Create a type for non-mouse events by excluding mouse-related events',
    setup:
      'type Event = "click" | "mousedown" | "mouseup" | "keydown" | "keyup" | "focus" | "blur";',
    setupCode:
      'type Event = "click" | "mousedown" | "mouseup" | "keydown" | "keyup" | "focus" | "blur";',
    expected: 'keydown',
    sample:
      'type NonMouseEvent = Exclude<Event, "click" | "mousedown" | "mouseup">;\nconst event: NonMouseEvent = "keydown";\nevent',
    hints: ['List all mouse events to exclude', 'Remaining events are keyboard and focus events'],
    tags: ['utility-types', 'exclude', 'events'],
  },
  {
    id: 'ts-utility-036',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'Exclude with Template Literals',
    text: 'Exclude string literal types that match a pattern',
    setup: 'type Events = "onClick" | "onHover" | "onFocus" | "handleClick" | "handleHover";',
    setupCode: 'type Events = "onClick" | "onHover" | "onFocus" | "handleClick" | "handleHover";',
    expected: 'handleClick',
    sample:
      'type HandleEvents = Exclude<Events, `on${string}`>;\nconst event: HandleEvents = "handleClick";\nevent',
    hints: [
      'Template literal types can be used with Exclude',
      'Pattern `on${string}` matches strings starting with "on"',
    ],
    tags: ['utility-types', 'exclude', 'template-literals'],
  },

  // ============================================================
  // Utility Types - Extract
  // ============================================================
  {
    id: 'ts-utility-037',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Basic Extract Type',
    text: 'Extract specific types from a union type',
    setup: 'type Mixed = string | number | boolean | null;',
    setupCode: 'type Mixed = string | number | boolean | null;',
    expected: 'hello',
    sample:
      'type StringOrNumber = Extract<Mixed, string | number>;\nconst value: StringOrNumber = "hello";\nvalue',
    hints: ['Extract<T, U> keeps only types assignable to U', 'Opposite of Exclude'],
    tags: ['utility-types', 'extract', 'union'],
  },
  {
    id: 'ts-utility-038',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Extract Primitive Types',
    text: 'Extract only primitive types from a union',
    setup: 'type Data = string | number | { id: number } | string[];',
    setupCode: 'type Data = string | number | { id: number } | string[];',
    expected: 42,
    sample:
      'type Primitives = Extract<Data, string | number | boolean>;\nconst value: Primitives = 42;\nvalue',
    hints: ['Extract matches types that extend the filter', 'Objects and arrays are excluded'],
    tags: ['utility-types', 'extract', 'primitives'],
  },
  {
    id: 'ts-utility-039',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Extract Function Types',
    text: 'Extract only function types from a union',
    setup: 'type Mixed = string | (() => void) | number | ((x: number) => number);',
    setupCode: 'type Mixed = string | (() => void) | number | ((x: number) => number);',
    expected: 10,
    sample:
      'type Functions = Extract<Mixed, Function>;\nconst fn: Functions = (x: number) => x * 2;\nfn(5)',
    hints: ['Function is the base type for all functions', 'Extract keeps all function types'],
    tags: ['utility-types', 'extract', 'functions'],
  },
  {
    id: 'ts-utility-040',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Extract from Discriminated Union',
    text: 'Extract specific variants from a discriminated union type',
    setup:
      'type Result = { type: "success"; data: string } | { type: "error"; message: string } | { type: "loading" };',
    setupCode:
      'type Result = { type: "success"; data: string } | { type: "error"; message: string } | { type: "loading" };',
    expected: { type: 'success', data: 'Done!' },
    sample:
      'type SuccessResult = Extract<Result, { type: "success" }>;\nconst result: SuccessResult = { type: "success", data: "Done!" };\nresult',
    hints: ['Extract matches by structure', 'Only the variant with type "success" is kept'],
    tags: ['utility-types', 'extract', 'discriminated-union'],
  },
  {
    id: 'ts-utility-041',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'Extract with Template Literals',
    text: 'Extract string literal types matching a pattern',
    setup: 'type Events = "onClick" | "onHover" | "onFocus" | "handleClick" | "handleHover";',
    setupCode: 'type Events = "onClick" | "onHover" | "onFocus" | "handleClick" | "handleHover";',
    expected: 'onClick',
    sample:
      'type OnEvents = Extract<Events, `on${string}`>;\nconst event: OnEvents = "onClick";\nevent',
    hints: ['Template literals work with Extract', 'Pattern matches strings starting with "on"'],
    tags: ['utility-types', 'extract', 'template-literals'],
  },

  // ============================================================
  // Utility Types - NonNullable
  // ============================================================
  {
    id: 'ts-utility-042',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Basic NonNullable Type',
    text: 'Remove null and undefined from a type using NonNullable',
    setup: 'type MaybeUser = { name: string } | null | undefined;',
    setupCode: 'type MaybeUser = { name: string } | null | undefined;',
    expected: { name: 'Alice' },
    sample: 'type User = NonNullable<MaybeUser>;\nconst user: User = { name: "Alice" };\nuser',
    hints: ['NonNullable removes null and undefined', 'Result is guaranteed to be defined'],
    tags: ['utility-types', 'nonnullable', 'nullish'],
  },
  {
    id: 'ts-utility-043',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'NonNullable with Primitives',
    text: 'Ensure a string value is never null or undefined',
    setup: 'type MaybeString = string | null | undefined;',
    setupCode: 'type MaybeString = string | null | undefined;',
    expected: 'hello',
    sample:
      'type DefiniteString = NonNullable<MaybeString>;\nconst str: DefiniteString = "hello";\nstr',
    hints: ['NonNullable<string | null | undefined> = string', 'Only the string type remains'],
    tags: ['utility-types', 'nonnullable', 'primitives'],
  },
  {
    id: 'ts-utility-044',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'NonNullable in Generic Contexts',
    text: 'Use NonNullable to assert a value exists in a generic function',
    setup:
      'function assertDefined<T>(value: T): NonNullable<T> {\n  if (value === null || value === undefined) throw new Error("Value is null or undefined");\n  return value as NonNullable<T>;\n}',
    setupCode:
      'function assertDefined<T>(value: T): NonNullable<T> {\n  if (value === null || value === undefined) throw new Error("Value is null or undefined");\n  return value as NonNullable<T>;\n}',
    expected: 'test',
    sample:
      'const maybeValue: string | null = "test";\nconst definiteValue = assertDefined(maybeValue);\ndefiniteValue',
    hints: ['NonNullable narrows the return type', 'Runtime check ensures value exists'],
    tags: ['utility-types', 'nonnullable', 'generics', 'assertions'],
  },
  {
    id: 'ts-utility-045',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'NonNullable for Array Elements',
    text: 'Filter out null and undefined from array type',
    setup:
      'type Items = (string | null | undefined)[];\nfunction filterNullish<T>(arr: T[]): NonNullable<T>[] {\n  return arr.filter((x): x is NonNullable<T> => x != null);\n}',
    setupCode:
      'type Items = (string | null | undefined)[];\nfunction filterNullish<T>(arr: T[]): NonNullable<T>[] {\n  return arr.filter((x): x is NonNullable<T> => x != null);\n}',
    expected: ['a', 'b', 'c'],
    sample: 'const items: Items = ["a", null, "b", undefined, "c"];\nfilterNullish(items)',
    hints: ['Type guard narrows to NonNullable<T>', 'x != null checks both null and undefined'],
    tags: ['utility-types', 'nonnullable', 'arrays', 'type-guards'],
  },

  // ============================================================
  // Utility Types - ReturnType
  // ============================================================
  {
    id: 'ts-utility-046',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Basic ReturnType',
    text: 'Extract the return type of a function using ReturnType',
    setup: 'function getUser() { return { id: 1, name: "Alice" }; }',
    setupCode: 'function getUser() { return { id: 1, name: "Alice" }; }',
    expected: { id: 1, name: 'Alice' },
    sample:
      'type User = ReturnType<typeof getUser>;\nconst user: User = { id: 1, name: "Alice" };\nuser',
    hints: ['Use typeof to get the function type', 'ReturnType extracts what the function returns'],
    tags: ['utility-types', 'returntype', 'typeof'],
  },
  {
    id: 'ts-utility-047',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'ReturnType with Arrow Functions',
    text: 'Get the return type of an arrow function',
    setup: 'const multiply = (a: number, b: number) => a * b;',
    setupCode: 'const multiply = (a: number, b: number) => a * b;',
    expected: 6,
    sample:
      'type MultiplyResult = ReturnType<typeof multiply>;\nconst result: MultiplyResult = 6;\nresult',
    hints: ['ReturnType works with arrow functions', 'Returns number in this case'],
    tags: ['utility-types', 'returntype', 'arrow-functions'],
  },
  {
    id: 'ts-utility-048',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'ReturnType with Async Functions',
    text: 'Extract the unwrapped return type of an async function',
    setup:
      'async function fetchUser(): Promise<{ id: number; name: string }> { return { id: 1, name: "Alice" }; }',
    setupCode:
      'async function fetchUser(): Promise<{ id: number; name: string }> { return { id: 1, name: "Alice" }; }',
    expected: { id: 1, name: 'Alice' },
    sample:
      'type FetchResult = Awaited<ReturnType<typeof fetchUser>>;\nconst user: FetchResult = { id: 1, name: "Alice" };\nuser',
    hints: ['ReturnType gives Promise<T>', 'Use Awaited to unwrap the Promise'],
    tags: ['utility-types', 'returntype', 'async', 'awaited'],
  },
  {
    id: 'ts-utility-049',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'ReturnType with Overloaded Functions',
    text: 'Get the return type of the last overload signature',
    setup:
      'function parse(input: string): object;\nfunction parse(input: number): string;\nfunction parse(input: string | number): object | string { return typeof input === "string" ? {} : ""; }',
    setupCode:
      'function parse(input: string): object;\nfunction parse(input: number): string;\nfunction parse(input: string | number): object | string { return typeof input === "string" ? {} : ""; }',
    expected: '',
    sample: 'type ParseResult = ReturnType<typeof parse>;\nconst result: ParseResult = "";\nresult',
    hints: [
      'ReturnType uses the last overload signature',
      'Returns string | object for the implementation',
    ],
    tags: ['utility-types', 'returntype', 'overloads'],
  },
  {
    id: 'ts-utility-050',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'Conditional ReturnType',
    text: 'Create a type that extracts return type only for function types',
    setup:
      'type SafeReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\nconst fn = () => ({ value: 42 });\nconst notFn = "hello";',
    setupCode:
      'type SafeReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\nconst fn = () => ({ value: 42 });\nconst notFn = "hello";',
    expected: { value: 42 },
    sample:
      'type FnReturn = SafeReturnType<typeof fn>;\nconst result: FnReturn = { value: 42 };\nresult',
    hints: ['Use conditional type with infer', 'Returns never for non-function types'],
    tags: ['utility-types', 'returntype', 'conditional', 'infer'],
  },
  {
    id: 'ts-utility-051',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'ReturnType from Class Methods',
    text: 'Extract return types from class methods',
    setup:
      'class UserService {\n  getUser(id: number) { return { id, name: "User" }; }\n  getAllUsers() { return [{ id: 1, name: "User" }]; }\n}',
    setupCode:
      'class UserService {\n  getUser(id: number) { return { id, name: "User" }; }\n  getAllUsers() { return [{ id: 1, name: "User" }]; }\n}',
    expected: { id: 1, name: 'User' },
    sample:
      'type GetUserReturn = ReturnType<UserService["getUser"]>;\nconst user: GetUserReturn = { id: 1, name: "User" };\nuser',
    hints: ['Access method type with indexed access', 'UserService["getUser"] is the method type'],
    tags: ['utility-types', 'returntype', 'classes', 'methods'],
  },

  // ============================================================
  // Utility Types - Parameters
  // ============================================================
  {
    id: 'ts-utility-052',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Basic Parameters Type',
    text: 'Extract the parameter types of a function as a tuple',
    setup: 'function greet(name: string, age: number) { return `${name} is ${age}`; }',
    setupCode: 'function greet(name: string, age: number) { return `${name} is ${age}`; }',
    expected: ['Alice', 30],
    sample:
      'type GreetParams = Parameters<typeof greet>;\nconst params: GreetParams = ["Alice", 30];\nparams',
    hints: ['Parameters returns a tuple type', 'Use typeof to get the function type'],
    tags: ['utility-types', 'parameters', 'tuple'],
  },
  {
    id: 'ts-utility-053',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Parameters Tuple Access',
    text: 'Access individual parameter types from Parameters tuple',
    setup:
      'function createUser(name: string, email: string, age: number) { return { name, email, age }; }',
    setupCode:
      'function createUser(name: string, email: string, age: number) { return { name, email, age }; }',
    expected: 'Alice',
    sample:
      'type FirstParam = Parameters<typeof createUser>[0];\nconst name: FirstParam = "Alice";\nname',
    hints: [
      'Index into the tuple to get specific parameter types',
      '[0] gets the first parameter type',
    ],
    tags: ['utility-types', 'parameters', 'tuple-access'],
  },
  {
    id: 'ts-utility-054',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Parameters with Rest Arguments',
    text: 'Extract parameters including rest arguments',
    setup:
      'function logMessages(level: string, ...messages: string[]) { return { level, messages }; }',
    setupCode:
      'function logMessages(level: string, ...messages: string[]) { return { level, messages }; }',
    expected: ['error', 'msg1', 'msg2'],
    sample:
      'type LogParams = Parameters<typeof logMessages>;\nconst params: LogParams = ["error", "msg1", "msg2"];\nparams',
    hints: ['Rest parameters become array type in tuple', 'Tuple is [string, ...string[]]'],
    tags: ['utility-types', 'parameters', 'rest-arguments'],
  },
  {
    id: 'ts-utility-055',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Spread Parameters to Function',
    text: 'Use Parameters to spread arguments to another function',
    setup:
      'function original(a: number, b: string, c: boolean) { return { a, b, c }; }\nfunction wrapper<T extends (...args: any[]) => any>(fn: T, ...args: Parameters<T>): ReturnType<T> { return fn(...args); }',
    setupCode:
      'function original(a: number, b: string, c: boolean) { return { a, b, c }; }\nfunction wrapper<T extends (...args: any[]) => any>(fn: T, ...args: Parameters<T>): ReturnType<T> { return fn(...args); }',
    expected: { a: 1, b: 'test', c: true },
    sample: 'wrapper(original, 1, "test", true)',
    hints: ['Parameters<T> captures all parameter types', 'Spread into the inner function call'],
    tags: ['utility-types', 'parameters', 'generics', 'wrapper'],
  },
  {
    id: 'ts-utility-056',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Parameters for Callbacks',
    text: 'Type a callback function based on another functions parameters',
    setup:
      'function fetchData(url: string, options: { timeout: number }) { return { url, options }; }\ntype FetchCallback = (...args: Parameters<typeof fetchData>) => void;',
    setupCode:
      'function fetchData(url: string, options: { timeout: number }) { return { url, options }; }\ntype FetchCallback = (...args: Parameters<typeof fetchData>) => void;',
    expected: { url: 'https://api.com', timeout: 5000 },
    sample:
      'let captured: { url: string; timeout: number } | null = null;\nconst callback: FetchCallback = (url, options) => { captured = { url, timeout: options.timeout }; };\ncallback("https://api.com", { timeout: 5000 });\ncaptured',
    hints: [
      'FetchCallback has same parameters as fetchData',
      'Useful for creating matching callback types',
    ],
    tags: ['utility-types', 'parameters', 'callbacks'],
  },
  {
    id: 'ts-utility-057',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'Parameters with Overloaded Functions',
    text: 'Extract parameters from overloaded function (gets last overload)',
    setup:
      'function process(x: string): string;\nfunction process(x: number, y: number): number;\nfunction process(x: string | number, y?: number): string | number { return y !== undefined ? (x as number) + y : x; }',
    setupCode:
      'function process(x: string): string;\nfunction process(x: number, y: number): number;\nfunction process(x: string | number, y?: number): string | number { return y !== undefined ? (x as number) + y : x; }',
    expected: [5, 3],
    sample:
      'type ProcessParams = Parameters<typeof process>;\nconst params: ProcessParams = [5, 3];\nparams',
    hints: ['Parameters uses the last overload', 'Result is [number, number] from last signature'],
    tags: ['utility-types', 'parameters', 'overloads'],
  },

  // ============================================================
  // Utility Types - ConstructorParameters
  // ============================================================
  {
    id: 'ts-utility-058',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Basic ConstructorParameters',
    text: 'Extract constructor parameters from a class',
    setup: 'class User { constructor(public name: string, public age: number) {} }',
    setupCode: 'class User { constructor(public name: string, public age: number) {} }',
    expected: ['Alice', 30],
    sample:
      'type UserParams = ConstructorParameters<typeof User>;\nconst params: UserParams = ["Alice", 30];\nparams',
    hints: [
      'Use typeof to get the constructor type',
      'Returns tuple of constructor parameter types',
    ],
    tags: ['utility-types', 'constructorparameters', 'classes'],
  },
  {
    id: 'ts-utility-059',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'ConstructorParameters with Built-in Classes',
    text: 'Extract constructor parameters from built-in classes',
    setup: 'type DateParams = ConstructorParameters<typeof Date>;',
    setupCode: 'type DateParams = ConstructorParameters<typeof Date>;',
    expected: 2024,
    sample:
      'const params: [number, number, number] = [2024, 0, 15];\nnew Date(...params).getFullYear()',
    hints: ['Built-in classes have constructor types', 'Date has multiple constructor overloads'],
    tags: ['utility-types', 'constructorparameters', 'built-in'],
  },
  {
    id: 'ts-utility-060',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'ConstructorParameters for Factory',
    text: 'Use ConstructorParameters to create a factory function',
    setup:
      'class Product { constructor(public name: string, public price: number) {} }\nfunction createFactory<T extends new (...args: any[]) => any>(Ctor: T) {\n  return (...args: ConstructorParameters<T>): InstanceType<T> => new Ctor(...args);\n}',
    setupCode:
      'class Product { constructor(public name: string, public price: number) {} }\nfunction createFactory<T extends new (...args: any[]) => any>(Ctor: T) {\n  return (...args: ConstructorParameters<T>): InstanceType<T> => new Ctor(...args);\n}',
    expected: { name: 'Widget', price: 99 },
    sample:
      'const productFactory = createFactory(Product);\nconst product = productFactory("Widget", 99);\n({ name: product.name, price: product.price })',
    hints: ['ConstructorParameters types the factory args', 'InstanceType types the return value'],
    tags: ['utility-types', 'constructorparameters', 'factory', 'generics'],
  },
  {
    id: 'ts-utility-061',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'ConstructorParameters with Generics',
    text: 'Extract constructor parameters from a generic class',
    setup: 'class Container<T> { constructor(public value: T, public label: string) {} }',
    setupCode: 'class Container<T> { constructor(public value: T, public label: string) {} }',
    expected: [42, 'number'],
    sample:
      'type ContainerParams = ConstructorParameters<typeof Container<number>>;\nconst params: ContainerParams = [42, "number"];\nparams',
    hints: ['Specify the generic parameter explicitly', 'Container<number> fixes T to number'],
    tags: ['utility-types', 'constructorparameters', 'generics'],
  },
  {
    id: 'ts-utility-062',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'ConstructorParameters Constraint',
    text: 'Create a generic type that requires constructable types',
    setup:
      'type Constructable<T = any> = new (...args: any[]) => T;\nfunction instantiate<T extends Constructable>(Ctor: T, ...args: ConstructorParameters<T>): InstanceType<T> {\n  return new Ctor(...args);\n}\nclass Service { constructor(public name: string) {} }',
    setupCode:
      'type Constructable<T = any> = new (...args: any[]) => T;\nfunction instantiate<T extends Constructable>(Ctor: T, ...args: ConstructorParameters<T>): InstanceType<T> {\n  return new Ctor(...args);\n}\nclass Service { constructor(public name: string) {} }',
    expected: { name: 'API' },
    sample: 'const service = instantiate(Service, "API");\n({ name: service.name })',
    hints: ['Constructable constrains to newable types', 'ConstructorParameters extracts the args'],
    tags: ['utility-types', 'constructorparameters', 'constraints', 'advanced'],
  },

  // ============================================================
  // Utility Types - InstanceType
  // ============================================================
  {
    id: 'ts-utility-063',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Basic InstanceType',
    text: 'Extract the instance type from a class constructor',
    setup:
      'class User { constructor(public name: string) {} greet() { return `Hello, ${this.name}`; } }',
    setupCode:
      'class User { constructor(public name: string) {} greet() { return `Hello, ${this.name}`; } }',
    expected: 'Hello, Alice',
    sample:
      'type UserInstance = InstanceType<typeof User>;\nconst user: UserInstance = new User("Alice");\nuser.greet()',
    hints: ['InstanceType<typeof Class> equals Class', 'Useful when you only have the constructor'],
    tags: ['utility-types', 'instancetype', 'classes'],
  },
  {
    id: 'ts-utility-064',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'InstanceType with Built-in Classes',
    text: 'Get instance type from built-in constructors',
    setup: 'type RegExpInstance = InstanceType<typeof RegExp>;',
    setupCode: 'type RegExpInstance = InstanceType<typeof RegExp>;',
    expected: true,
    sample: 'const regex: RegExpInstance = new RegExp("test");\nregex.test("testing")',
    hints: ['Works with built-in classes', 'RegExpInstance is same as RegExp'],
    tags: ['utility-types', 'instancetype', 'built-in'],
  },
  {
    id: 'ts-utility-065',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'InstanceType for Factory Pattern',
    text: 'Use InstanceType to type factory function returns',
    setup:
      'class Logger { constructor(public prefix: string) {} log(msg: string) { return `${this.prefix}: ${msg}`; } }\nfunction createLogger<T extends new (...args: any[]) => any>(Ctor: T, ...args: ConstructorParameters<T>): InstanceType<T> {\n  return new Ctor(...args);\n}',
    setupCode:
      'class Logger { constructor(public prefix: string) {} log(msg: string) { return `${this.prefix}: ${msg}`; } }\nfunction createLogger<T extends new (...args: any[]) => any>(Ctor: T, ...args: ConstructorParameters<T>): InstanceType<T> {\n  return new Ctor(...args);\n}',
    expected: '[INFO]: Test message',
    sample: 'const logger = createLogger(Logger, "[INFO]");\nlogger.log("Test message")',
    hints: ['InstanceType infers the return type', 'Factory returns proper typed instance'],
    tags: ['utility-types', 'instancetype', 'factory'],
  },
  {
    id: 'ts-utility-066',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'InstanceType with Abstract Classes',
    text: 'Work with instance types of abstract classes',
    setup:
      'abstract class Animal { abstract speak(): string; move() { return "moving"; } }\nclass Dog extends Animal { speak() { return "woof"; } }',
    setupCode:
      'abstract class Animal { abstract speak(): string; move() { return "moving"; } }\nclass Dog extends Animal { speak() { return "woof"; } }',
    expected: 'woof',
    sample:
      'type AnimalInstance = InstanceType<typeof Dog>;\nconst dog: AnimalInstance = new Dog();\ndog.speak()',
    hints: ['Cannot use InstanceType on abstract class directly', 'Use concrete subclass instead'],
    tags: ['utility-types', 'instancetype', 'abstract'],
  },
  {
    id: 'ts-utility-067',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'Generic InstanceType Constraint',
    text: 'Create a generic function that accepts any class and returns its instance type',
    setup:
      'type Constructor<T = {}> = new (...args: any[]) => T;\nfunction singleton<T extends Constructor>(Ctor: T): () => InstanceType<T> {\n  let instance: InstanceType<T> | null = null;\n  return () => instance ?? (instance = new Ctor() as InstanceType<T>);\n}\nclass Config { value = "default"; }',
    setupCode:
      'type Constructor<T = {}> = new (...args: any[]) => T;\nfunction singleton<T extends Constructor>(Ctor: T): () => InstanceType<T> {\n  let instance: InstanceType<T> | null = null;\n  return () => instance ?? (instance = new Ctor() as InstanceType<T>);\n}\nclass Config { value = "default"; }',
    expected: true,
    sample:
      'const getConfig = singleton(Config);\nconst c1 = getConfig();\nconst c2 = getConfig();\nc1 === c2',
    hints: ['InstanceType gives the instance type', 'Constructor type constrains to newable'],
    tags: ['utility-types', 'instancetype', 'generics', 'singleton'],
  },

  // ============================================================
  // Utility Types - ThisParameterType
  // ============================================================
  {
    id: 'ts-utility-068',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Basic ThisParameterType',
    text: 'Extract the this parameter type from a function',
    setup: 'function greet(this: { name: string }) { return `Hello, ${this.name}`; }',
    setupCode: 'function greet(this: { name: string }) { return `Hello, ${this.name}`; }',
    expected: { name: 'Alice' },
    sample:
      'type GreetThis = ThisParameterType<typeof greet>;\nconst context: GreetThis = { name: "Alice" };\ncontext',
    hints: ['ThisParameterType extracts the this type', 'Returns unknown if no this parameter'],
    tags: ['utility-types', 'thisparametertype', 'this'],
  },
  {
    id: 'ts-utility-069',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'ThisParameterType with Methods',
    text: 'Extract this type from object method',
    setup:
      'const obj = {\n  name: "Widget",\n  getName(this: { name: string; id: number }) { return this.name; }\n};',
    setupCode:
      'const obj = {\n  name: "Widget",\n  getName(this: { name: string; id: number }) { return this.name; }\n};',
    expected: { name: 'Test', id: 1 },
    sample:
      'type GetNameThis = ThisParameterType<typeof obj.getName>;\nconst context: GetNameThis = { name: "Test", id: 1 };\ncontext',
    hints: ['Method can have explicit this type', 'ThisParameterType extracts it'],
    tags: ['utility-types', 'thisparametertype', 'methods'],
  },
  {
    id: 'ts-utility-070',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'ThisParameterType for Call/Apply',
    text: 'Use ThisParameterType to type-check call/apply context',
    setup:
      'function formatName(this: { firstName: string; lastName: string }) {\n  return `${this.firstName} ${this.lastName}`;\n}',
    setupCode:
      'function formatName(this: { firstName: string; lastName: string }) {\n  return `${this.firstName} ${this.lastName}`;\n}',
    expected: 'John Doe',
    sample:
      'type Context = ThisParameterType<typeof formatName>;\nconst person: Context = { firstName: "John", lastName: "Doe" };\nformatName.call(person)',
    hints: ['call/apply need proper this context', 'ThisParameterType ensures type safety'],
    tags: ['utility-types', 'thisparametertype', 'call', 'apply'],
  },
  {
    id: 'ts-utility-071',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'ThisParameterType in Decorators',
    text: 'Use ThisParameterType to preserve this type in decorators',
    setup:
      'function logMethod<T extends (this: any, ...args: any[]) => any>(\n  fn: T\n): (this: ThisParameterType<T>, ...args: Parameters<OmitThisParameter<T>>) => ReturnType<T> {\n  return function(this: ThisParameterType<T>, ...args: Parameters<OmitThisParameter<T>>) {\n    return fn.apply(this, args);\n  };\n}\nconst obj = { value: 10, getValue(this: { value: number }) { return this.value; } };',
    setupCode:
      'function logMethod<T extends (this: any, ...args: any[]) => any>(\n  fn: T\n): (this: ThisParameterType<T>, ...args: Parameters<OmitThisParameter<T>>) => ReturnType<T> {\n  return function(this: ThisParameterType<T>, ...args: Parameters<OmitThisParameter<T>>) {\n    return fn.apply(this, args);\n  };\n}\nconst obj = { value: 10, getValue(this: { value: number }) { return this.value; } };',
    expected: 10,
    sample: 'const logged = logMethod(obj.getValue);\nlogged.call({ value: 10 })',
    hints: ['Decorator preserves this type', 'Combine with OmitThisParameter for args'],
    tags: ['utility-types', 'thisparametertype', 'decorators', 'advanced'],
  },

  // ============================================================
  // Utility Types - OmitThisParameter
  // ============================================================
  {
    id: 'ts-utility-072',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Basic OmitThisParameter',
    text: 'Remove the this parameter from a function type',
    setup:
      'function greet(this: { name: string }, greeting: string) { return `${greeting}, ${this.name}`; }',
    setupCode:
      'function greet(this: { name: string }, greeting: string) { return `${greeting}, ${this.name}`; }',
    expected: 'Hello, World',
    sample:
      'type GreetFn = OmitThisParameter<typeof greet>;\nconst boundGreet: GreetFn = greet.bind({ name: "World" });\nboundGreet("Hello")',
    hints: ['OmitThisParameter removes this from signature', 'Useful for bound functions'],
    tags: ['utility-types', 'omitthisparameter', 'bind'],
  },
  {
    id: 'ts-utility-073',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'OmitThisParameter for Callbacks',
    text: 'Use OmitThisParameter to type bound callbacks',
    setup:
      'class Counter {\n  count = 0;\n  increment(this: Counter, amount: number) { this.count += amount; return this.count; }\n}',
    setupCode:
      'class Counter {\n  count = 0;\n  increment(this: Counter, amount: number) { this.count += amount; return this.count; }\n}',
    expected: 5,
    sample:
      'const counter = new Counter();\ntype IncrementFn = OmitThisParameter<typeof counter.increment>;\nconst boundIncrement: IncrementFn = counter.increment.bind(counter);\nboundIncrement(5)',
    hints: ['bind() returns function without this', 'OmitThisParameter types the bound function'],
    tags: ['utility-types', 'omitthisparameter', 'callbacks', 'bind'],
  },
  {
    id: 'ts-utility-074',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'OmitThisParameter with Arrow Functions',
    text: 'Demonstrate that arrow functions have no this parameter',
    setup:
      'const regular = function(this: { x: number }) { return this.x; };\nconst arrow = () => 42;',
    setupCode:
      'const regular = function(this: { x: number }) { return this.x; };\nconst arrow = () => 42;',
    expected: 42,
    sample:
      'type RegularWithoutThis = OmitThisParameter<typeof regular>;\ntype ArrowType = OmitThisParameter<typeof arrow>;\nconst fn: ArrowType = () => 42;\nfn()',
    hints: ['Arrow functions have no this parameter', 'OmitThisParameter is identity for arrows'],
    tags: ['utility-types', 'omitthisparameter', 'arrow-functions'],
  },
  {
    id: 'ts-utility-075',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'OmitThisParameter in Method Extraction',
    text: 'Extract class methods as standalone functions',
    setup:
      'class Calculator {\n  constructor(private base: number) {}\n  add(this: Calculator, n: number) { return this.base + n; }\n  multiply(this: Calculator, n: number) { return this.base * n; }\n}\ntype MethodsOf<T> = { [K in keyof T]: T[K] extends (this: any, ...args: infer A) => infer R ? (...args: A) => R : never };',
    setupCode:
      'class Calculator {\n  constructor(private base: number) {}\n  add(this: Calculator, n: number) { return this.base + n; }\n  multiply(this: Calculator, n: number) { return this.base * n; }\n}\ntype MethodsOf<T> = { [K in keyof T]: T[K] extends (this: any, ...args: infer A) => infer R ? (...args: A) => R : never };',
    expected: 15,
    sample:
      'const calc = new Calculator(10);\nconst boundAdd: OmitThisParameter<typeof calc.add> = calc.add.bind(calc);\nboundAdd(5)',
    hints: [
      'OmitThisParameter enables method extraction',
      'Bound methods become standalone functions',
    ],
    tags: ['utility-types', 'omitthisparameter', 'methods', 'advanced'],
  },

  // ============================================================
  // Utility Types - Awaited
  // ============================================================
  {
    id: 'ts-utility-076',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Basic Awaited Type',
    text: 'Unwrap a Promise type using Awaited',
    setup: 'type UserPromise = Promise<{ id: number; name: string }>;',
    setupCode: 'type UserPromise = Promise<{ id: number; name: string }>;',
    expected: { id: 1, name: 'Alice' },
    sample: 'type User = Awaited<UserPromise>;\nconst user: User = { id: 1, name: "Alice" };\nuser',
    hints: ['Awaited unwraps Promise types', 'Result is the resolved value type'],
    tags: ['utility-types', 'awaited', 'promises'],
  },
  {
    id: 'ts-utility-077',
    category: 'Utility Types',
    difficulty: 'easy',
    title: 'Awaited with Non-Promise',
    text: 'Awaited on non-Promise types returns the same type',
    setup: 'type MaybeAsync = string | Promise<string>;',
    setupCode: 'type MaybeAsync = string | Promise<string>;',
    expected: 'hello',
    sample: 'type Resolved = Awaited<MaybeAsync>;\nconst value: Resolved = "hello";\nvalue',
    hints: [
      'Awaited handles both Promise and non-Promise',
      'Non-Promise types pass through unchanged',
    ],
    tags: ['utility-types', 'awaited', 'union'],
  },
  {
    id: 'ts-utility-078',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Awaited with Nested Promises',
    text: 'Unwrap deeply nested Promise types',
    setup: 'type DeepPromise = Promise<Promise<Promise<number>>>;',
    setupCode: 'type DeepPromise = Promise<Promise<Promise<number>>>;',
    expected: 42,
    sample: 'type Value = Awaited<DeepPromise>;\nconst num: Value = 42;\nnum',
    hints: ['Awaited recursively unwraps Promises', 'Handles any nesting depth'],
    tags: ['utility-types', 'awaited', 'nested'],
  },
  {
    id: 'ts-utility-079',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Awaited for Async Function Returns',
    text: 'Get the resolved type of an async function return',
    setup:
      'async function fetchData(): Promise<{ items: string[]; total: number }> {\n  return { items: ["a", "b"], total: 2 };\n}',
    setupCode:
      'async function fetchData(): Promise<{ items: string[]; total: number }> {\n  return { items: ["a", "b"], total: 2 };\n}',
    expected: { items: ['a', 'b'], total: 2 },
    sample:
      'type FetchResult = Awaited<ReturnType<typeof fetchData>>;\nconst result: FetchResult = { items: ["a", "b"], total: 2 };\nresult',
    hints: ['Combine with ReturnType for async functions', 'Awaited unwraps the Promise'],
    tags: ['utility-types', 'awaited', 'async', 'returntype'],
  },
  {
    id: 'ts-utility-080',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Awaited with Promise.all',
    text: 'Type the result of Promise.all using Awaited',
    setup:
      'const promises = [Promise.resolve(1), Promise.resolve("two"), Promise.resolve(true)] as const;',
    setupCode:
      'const promises = [Promise.resolve(1), Promise.resolve("two"), Promise.resolve(true)] as const;',
    expected: [1, 'two', true],
    sample:
      'type AllResults = Awaited<typeof promises[number]>[];\nconst results: [number, string, boolean] = [1, "two", true];\nresults',
    hints: ['Promise.all resolves all promises', 'Awaited unwraps each Promise type'],
    tags: ['utility-types', 'awaited', 'promise-all'],
  },
  {
    id: 'ts-utility-081',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'Awaited in Generic Context',
    text: 'Use Awaited in a generic function to handle both sync and async',
    setup:
      'type MaybePromise<T> = T | Promise<T>;\nasync function resolve<T>(value: MaybePromise<T>): Promise<Awaited<T>> {\n  return await value as Awaited<T>;\n}',
    setupCode:
      'type MaybePromise<T> = T | Promise<T>;\nasync function resolve<T>(value: MaybePromise<T>): Promise<Awaited<T>> {\n  return await value as Awaited<T>;\n}',
    expected: 42,
    sample: 'resolve(Promise.resolve(42)).then(v => v)',
    hints: ['MaybePromise accepts both types', 'Awaited normalizes the result'],
    tags: ['utility-types', 'awaited', 'generics', 'advanced'],
  },

  // ============================================================
  // Utility Types - NoInfer
  // ============================================================
  {
    id: 'ts-utility-082',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Basic NoInfer Type',
    text: 'Use NoInfer to prevent type inference from certain positions',
    setup:
      'function createState<T>(initial: T, defaultValue: NoInfer<T>): { value: T; default: T } {\n  return { value: initial, default: defaultValue };\n}',
    setupCode:
      'function createState<T>(initial: T, defaultValue: NoInfer<T>): { value: T; default: T } {\n  return { value: initial, default: defaultValue };\n}',
    expected: { value: 'hello', default: '' },
    sample: 'const state = createState("hello", "");\nstate',
    hints: [
      'NoInfer prevents inference from that parameter',
      'T is inferred from first argument only',
    ],
    tags: ['utility-types', 'noinfer', 'inference'],
  },
  {
    id: 'ts-utility-083',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'NoInfer for Default Values',
    text: 'Prevent default value from widening inferred type',
    setup:
      'function withDefault<T>(value: T | undefined, defaultValue: NoInfer<T>): T {\n  return value ?? defaultValue;\n}',
    setupCode:
      'function withDefault<T>(value: T | undefined, defaultValue: NoInfer<T>): T {\n  return value ?? defaultValue;\n}',
    expected: 'fallback',
    sample:
      'const result = withDefault(undefined as "a" | "b" | undefined, "fallback" as "a" | "b");\nresult',
    hints: ['NoInfer keeps T narrow', 'Default does not affect inference'],
    tags: ['utility-types', 'noinfer', 'defaults'],
  },
  {
    id: 'ts-utility-084',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'NoInfer in Generic Constraints',
    text: 'Use NoInfer to control which arguments influence type inference',
    setup: 'function matchPair<T>(a: T, b: NoInfer<T>): boolean {\n  return a === b;\n}',
    setupCode: 'function matchPair<T>(a: T, b: NoInfer<T>): boolean {\n  return a === b;\n}',
    expected: true,
    sample: 'const result = matchPair("test", "test");\nresult',
    hints: ['T inferred from first argument only', 'Second argument must match inferred type'],
    tags: ['utility-types', 'noinfer', 'constraints'],
  },
  {
    id: 'ts-utility-085',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'NoInfer for Event Handlers',
    text: 'Use NoInfer to type event handlers without widening',
    setup:
      'type Events = { click: { x: number; y: number }; keydown: { key: string } };\nfunction on<K extends keyof Events>(event: K, handler: (data: NoInfer<Events[K]>) => void): void {}',
    setupCode:
      'type Events = { click: { x: number; y: number }; keydown: { key: string } };\nfunction on<K extends keyof Events>(event: K, handler: (data: NoInfer<Events[K]>) => void): void {}',
    expected: 'registered',
    sample: 'on("click", (data) => { const x = data.x; });\n"registered"',
    hints: ['K inferred from event name', 'Handler data type follows from K'],
    tags: ['utility-types', 'noinfer', 'events', 'advanced'],
  },
  {
    id: 'ts-utility-086',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'Branded Type with Utility',
    text: 'Create a branded type for UserId using intersection with a unique symbol',
    setup:
      'type UserId = string & { readonly __brand: unique symbol };\nfunction createUserId(id: string): UserId { return id as UserId; }\nconst userId = createUserId("123");',
    setupCode:
      'type UserId = string & { readonly __brand: unique symbol };\nfunction createUserId(id: string): UserId { return id as UserId; }\nconst userId = createUserId("123");',
    expected: '123',
    sample: 'String(userId)',
    hints: ['Branded types prevent accidental mixing', 'Use unique symbol for brand'],
    tags: ['utility-types', 'branded', 'type-safety', 'advanced'],
  },

  // ============================================================
  // Function Types & Overloads
  // ============================================================
  {
    id: 'ts-func-001',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Basic Function Type Expression',
    text: 'Define a type for a function that takes a number and returns a string',
    setup: '// Define a function type',
    setupCode: '// Define a function type',
    expected: '42',
    sample:
      'type NumberToString = (n: number) => string;\nconst convert: NumberToString = n => String(n);\nconvert(42)',
    hints: [
      'Use arrow syntax for function types: (param: Type) => ReturnType',
      'The function takes a number and returns a string',
    ],
    tags: ['function-types', 'type-expression', 'basics'],
  },
  {
    id: 'ts-func-002',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Void Return Type',
    text: 'Create a callback type that takes a string and returns nothing',
    setup: '// Define a callback that logs messages',
    setupCode: '// Define a callback that logs messages',
    expected: undefined,
    sample:
      'type Logger = (message: string) => void;\nconst log: Logger = msg => console.log(msg);\nlog("hello")',
    hints: [
      'Use void for functions that do not return a value',
      'void indicates the return value should not be used',
    ],
    tags: ['function-types', 'void', 'callbacks'],
  },
  {
    id: 'ts-func-003',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Multiple Parameters Function Type',
    text: 'Define a type for a function that adds two numbers',
    setup: '// Define an adder function type',
    setupCode: '// Define an adder function type',
    expected: 15,
    sample:
      'type Adder = (a: number, b: number) => number;\nconst add: Adder = (a, b) => a + b;\nadd(10, 5)',
    hints: [
      'List all parameters with their types in parentheses',
      'Parameters are separated by commas',
    ],
    tags: ['function-types', 'parameters', 'basics'],
  },
  {
    id: 'ts-func-004',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Function Type with Object Parameter',
    text: 'Create a type for a function that takes a user object and returns their full name',
    setup: 'interface User { firstName: string; lastName: string; }',
    setupCode: 'interface User { firstName: string; lastName: string; }',
    expected: 'John Doe',
    sample:
      'type GetFullName = (user: User) => string;\nconst getFullName: GetFullName = u => `${u.firstName} ${u.lastName}`;\ngetFullName({ firstName: "John", lastName: "Doe" })',
    hints: ['The parameter type can be an interface', 'Use template literals to combine strings'],
    tags: ['function-types', 'objects', 'interfaces'],
  },
  {
    id: 'ts-func-005',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Boolean Predicate Function Type',
    text: 'Define a predicate function type that checks if a number is positive',
    setup: '// Define a predicate type',
    setupCode: '// Define a predicate type',
    expected: true,
    sample:
      'type IsPositive = (n: number) => boolean;\nconst isPositive: IsPositive = n => n > 0;\nisPositive(5)',
    hints: ['Predicates return boolean values', 'Use comparison operators to return true/false'],
    tags: ['function-types', 'predicates', 'boolean'],
  },
  {
    id: 'ts-func-006',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Array Callback Function Type',
    text: 'Create a type for a forEach callback that receives element and index',
    setup: 'const numbers = [1, 2, 3];',
    setupCode: 'const numbers = [1, 2, 3];',
    expected: [0, 2, 6],
    sample:
      'type ForEachCallback<T> = (element: T, index: number) => void;\nconst results: number[] = [];\nconst cb: ForEachCallback<number> = (el, idx) => results.push(el * idx);\nnumbers.forEach(cb);\nresults',
    hints: [
      'Array callbacks typically receive element and index',
      'Generic type parameter allows reuse with different array types',
    ],
    tags: ['function-types', 'callbacks', 'arrays'],
  },
  {
    id: 'ts-func-007',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Event Handler Function Type',
    text: 'Define an event handler type that takes an event object with target property',
    setup: 'interface ClickEvent { target: { id: string }; }',
    setupCode: 'interface ClickEvent { target: { id: string }; }',
    expected: 'btn-submit',
    sample:
      'type ClickHandler = (event: ClickEvent) => void;\nlet clicked = "";\nconst handler: ClickHandler = e => { clicked = e.target.id; };\nhandler({ target: { id: "btn-submit" } });\nclicked',
    hints: [
      'Event handlers typically return void',
      'The event object contains information about what happened',
    ],
    tags: ['function-types', 'events', 'handlers'],
  },
  {
    id: 'ts-func-008',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Comparator Function Type',
    text: 'Create a comparator function type for sorting numbers',
    setup: 'const nums = [3, 1, 4, 1, 5];',
    setupCode: 'const nums = [3, 1, 4, 1, 5];',
    expected: [1, 1, 3, 4, 5],
    sample:
      'type Comparator = (a: number, b: number) => number;\nconst compare: Comparator = (a, b) => a - b;\n[...nums].sort(compare)',
    hints: [
      'Comparators return negative, zero, or positive numbers',
      'Return a - b for ascending order',
    ],
    tags: ['function-types', 'comparator', 'sorting'],
  },
  {
    id: 'ts-func-009',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Transformer Function Type',
    text: 'Define a type for a function that transforms a string to uppercase',
    setup: '// Define a string transformer',
    setupCode: '// Define a string transformer',
    expected: 'HELLO',
    sample:
      'type StringTransformer = (input: string) => string;\nconst toUpper: StringTransformer = s => s.toUpperCase();\ntoUpper("hello")',
    hints: [
      'Transformers take input and return transformed output of same or different type',
      'Use built-in string methods',
    ],
    tags: ['function-types', 'transformer', 'strings'],
  },
  {
    id: 'ts-func-010',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Factory Function Type',
    text: 'Create a type for a factory function that creates user objects',
    setup: 'interface User { id: number; name: string; }',
    setupCode: 'interface User { id: number; name: string; }',
    expected: { id: 1, name: 'Alice' },
    sample:
      'type UserFactory = (id: number, name: string) => User;\nconst createUser: UserFactory = (id, name) => ({ id, name });\ncreateUser(1, "Alice")',
    hints: [
      'Factory functions create and return new objects',
      'Use shorthand property syntax when names match',
    ],
    tags: ['function-types', 'factory', 'objects'],
  },
  {
    id: 'ts-func-011',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Async Function Type',
    text: 'Define a type for an async function that fetches a number',
    setup: '// Define async function type',
    setupCode: '// Define async function type',
    expected: 42,
    sample:
      'type AsyncNumberFetcher = () => Promise<number>;\nconst fetchNum: AsyncNumberFetcher = async () => 42;\nfetchNum().then(n => n)',
    hints: ['Async functions return Promise<T>', 'Use Promise<T> as the return type'],
    tags: ['function-types', 'async', 'promises'],
  },
  {
    id: 'ts-func-012',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Nullable Return Type',
    text: 'Create a function type that may return a number or null',
    setup: 'const data: Record<string, number> = { a: 1, b: 2 };',
    setupCode: 'const data: Record<string, number> = { a: 1, b: 2 };',
    expected: null,
    sample:
      'type Finder = (key: string) => number | null;\nconst find: Finder = key => data[key] ?? null;\nfind("c")',
    hints: [
      'Use union types for nullable returns: Type | null',
      'Nullish coalescing (??) provides default for undefined/null',
    ],
    tags: ['function-types', 'nullable', 'union-types'],
  },
  {
    id: 'ts-func-013',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'No Parameters Function Type',
    text: 'Define a type for a function that takes no parameters and returns a timestamp',
    setup: '// Define a timestamp generator type',
    setupCode: '// Define a timestamp generator type',
    expected: true,
    sample:
      'type GetTimestamp = () => number;\nconst now: GetTimestamp = () => Date.now();\ntypeof now() === "number"',
    hints: [
      'Use empty parentheses for no parameters: () => Type',
      'Date.now() returns a numeric timestamp',
    ],
    tags: ['function-types', 'no-params', 'basics'],
  },
  {
    id: 'ts-func-014',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Tuple Return Type',
    text: 'Create a function type that returns a tuple of [success, data]',
    setup: '// Define result tuple type',
    setupCode: '// Define result tuple type',
    expected: [true, 42],
    sample:
      'type ResultFn = () => [boolean, number];\nconst getResult: ResultFn = () => [true, 42];\ngetResult()',
    hints: [
      'Use tuple syntax for return type: [Type1, Type2]',
      'Tuples have fixed length and types at each position',
    ],
    tags: ['function-types', 'tuples', 'return-types'],
  },
  {
    id: 'ts-func-015',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Union Parameter Type',
    text: 'Define a function type that accepts either a string or number',
    setup: '// Define flexible input type',
    setupCode: '// Define flexible input type',
    expected: '42',
    sample:
      'type Stringify = (value: string | number) => string;\nconst stringify: Stringify = v => String(v);\nstringify(42)',
    hints: [
      'Use union types for parameters that accept multiple types',
      'String() works on both strings and numbers',
    ],
    tags: ['function-types', 'union-types', 'parameters'],
  },
  {
    id: 'ts-func-016',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Promise Executor Function Type',
    text: 'Define the type for a Promise executor function',
    setup: '// Define promise executor type',
    setupCode: '// Define promise executor type',
    expected: 'resolved',
    sample:
      'type Executor<T> = (resolve: (value: T) => void, reject: (reason?: any) => void) => void;\nconst executor: Executor<string> = (resolve, reject) => resolve("resolved");\nnew Promise(executor).then(v => v)',
    hints: ['Executor receives resolve and reject callbacks', 'Both callbacks return void'],
    tags: ['function-types', 'promises', 'executor'],
  },
  {
    id: 'ts-func-017',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Then Callback Type',
    text: 'Define the type for a .then() callback',
    setup: '// Define then callback type',
    setupCode: '// Define then callback type',
    expected: 10,
    sample:
      'type ThenCallback<T, R> = (value: T) => R | PromiseLike<R>;\nconst doubler: ThenCallback<number, number> = n => n * 2;\nPromise.resolve(5).then(doubler).then(r => r)',
    hints: ['Then callbacks can return value or Promise', 'PromiseLike allows returning thenables'],
    tags: ['function-types', 'promises', 'then'],
  },
  {
    id: 'ts-func-018',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Cleanup Function Type',
    text: 'Define a type for a cleanup/dispose function',
    setup: '// Define cleanup function type',
    setupCode: '// Define cleanup function type',
    expected: 'cleaned',
    sample:
      'type Cleanup = () => void;\nlet status = "active";\nconst cleanup: Cleanup = () => { status = "cleaned"; };\ncleanup();\nstatus',
    hints: ['Cleanup functions take no arguments', 'Return void as they just perform side effects'],
    tags: ['function-types', 'cleanup', 'side-effects'],
  },
  {
    id: 'ts-func-019',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Unsubscribe Function Type',
    text: 'Define a subscribe function that returns an unsubscribe function',
    setup: '// Define subscription types',
    setupCode: '// Define subscription types',
    expected: 0,
    sample:
      'type Unsubscribe = () => void;\ntype Subscribe<T> = (callback: (value: T) => void) => Unsubscribe;\nconst subscribers: ((v: number) => void)[] = [];\nconst subscribe: Subscribe<number> = cb => {\n  subscribers.push(cb);\n  return () => { subscribers.splice(subscribers.indexOf(cb), 1); };\n};\nconst unsub = subscribe(v => console.log(v));\nunsub();\nsubscribers.length',
    hints: [
      'Subscribe returns a function to cancel subscription',
      'Unsubscribe removes callback from listeners',
    ],
    tags: ['function-types', 'subscription', 'patterns'],
  },
  {
    id: 'ts-func-020',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Getter Function Type',
    text: 'Define a type for a getter function that returns object property',
    setup: 'interface Config { apiUrl: string; timeout: number; }',
    setupCode: 'interface Config { apiUrl: string; timeout: number; }',
    expected: 'https://api.example.com',
    sample:
      'type Getter<T, K extends keyof T> = (obj: T) => T[K];\nconst getApiUrl: Getter<Config, "apiUrl"> = obj => obj.apiUrl;\ngetApiUrl({ apiUrl: "https://api.example.com", timeout: 5000 })',
    hints: ['Use keyof to constrain key parameter', 'T[K] is the type of property K in T'],
    tags: ['function-types', 'generics', 'property-access'],
  },
  {
    id: 'ts-func-021',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Setter Function Type',
    text: 'Define a type for a setter function that updates object property',
    setup: 'interface State { count: number; name: string; }',
    setupCode: 'interface State { count: number; name: string; }',
    expected: { count: 10, name: 'test' },
    sample:
      'type Setter<T, K extends keyof T> = (obj: T, value: T[K]) => T;\nconst setCount: Setter<State, "count"> = (obj, value) => ({ ...obj, count: value });\nsetCount({ count: 0, name: "test" }, 10)',
    hints: ['Setter takes object and new value', 'Return new object with updated property'],
    tags: ['function-types', 'generics', 'property-access'],
  },
  {
    id: 'ts-func-022',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Filter Predicate Type',
    text: 'Define the predicate function type used by Array.filter',
    setup: 'const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];',
    setupCode: 'const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];',
    expected: [2, 4, 6, 8, 10],
    sample:
      'type FilterPredicate<T> = (value: T, index: number, array: T[]) => boolean;\nconst isEven: FilterPredicate<number> = n => n % 2 === 0;\nnumbers.filter(isEven)',
    hints: ['Filter predicates return boolean', 'Receives value, index, and array like map'],
    tags: ['function-types', 'predicates', 'arrays'],
  },
  {
    id: 'ts-func-023',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Sort Compare Function Type',
    text: 'Define the compare function type used by Array.sort',
    setup: 'const items = [{ name: "Charlie" }, { name: "Alice" }, { name: "Bob" }];',
    setupCode: 'const items = [{ name: "Charlie" }, { name: "Alice" }, { name: "Bob" }];',
    expected: [{ name: 'Alice' }, { name: 'Bob' }, { name: 'Charlie' }],
    sample:
      'type CompareFn<T> = (a: T, b: T) => number;\nconst byName: CompareFn<{ name: string }> = (a, b) => a.name.localeCompare(b.name);\n[...items].sort(byName)',
    hints: [
      'Compare returns negative, zero, or positive',
      'localeCompare compares strings properly',
    ],
    tags: ['function-types', 'comparator', 'sorting'],
  },
  {
    id: 'ts-func-024',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Validation Function Type',
    text: 'Define a type for a validation function',
    setup: '// Define validator type',
    setupCode: '// Define validator type',
    expected: { valid: false, error: 'Too short' },
    sample:
      'type ValidationResult = { valid: true } | { valid: false; error: string };\ntype Validator<T> = (value: T) => ValidationResult;\nconst minLength: Validator<string> = s => \n  s.length >= 3 ? { valid: true } : { valid: false, error: "Too short" };\nminLength("ab")',
    hints: ['Discriminated union for success/failure', 'Validators return result object'],
    tags: ['function-types', 'validation', 'discriminated-union'],
  },
  {
    id: 'ts-func-025',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Transform Pipeline Type',
    text: 'Define types for a simple transform function',
    setup: '// Define transform type',
    setupCode: '// Define transform type',
    expected: 'HELLO',
    sample:
      'type Transform<I, O> = (input: I) => O;\nconst toUpper: Transform<string, string> = s => s.toUpperCase();\ntoUpper("hello")',
    hints: [
      'Transform takes input type and produces output type',
      'Generic parameters allow flexible typing',
    ],
    tags: ['function-types', 'transform', 'generics'],
  },
  {
    id: 'ts-func-026',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Array Map Callback Type',
    text: 'Define a type for Array.map callback function',
    setup: 'const words = ["hello", "world"];',
    setupCode: 'const words = ["hello", "world"];',
    expected: [5, 5],
    sample:
      'type MapFn<T, U> = (value: T, index: number) => U;\nconst getLength: MapFn<string, number> = s => s.length;\nwords.map(getLength)',
    hints: ['Map callbacks transform each element', 'Return type can differ from input type'],
    tags: ['function-types', 'arrays', 'map'],
  },
  {
    id: 'ts-func-027',
    category: 'Function Types',
    difficulty: 'easy',
    title: 'Error Handler Type',
    text: 'Define a type for an error handler callback',
    setup: '// Define error handler type',
    setupCode: '// Define error handler type',
    expected: 'Error: Something went wrong',
    sample:
      'type ErrorHandler = (error: Error) => string;\nconst handleError: ErrorHandler = err => `Error: ${err.message}`;\nhandleError(new Error("Something went wrong"))',
    hints: [
      'Error handlers receive Error objects',
      'Return type depends on how errors are processed',
    ],
    tags: ['function-types', 'error-handling', 'callbacks'],
  },
  {
    id: 'ts-func-028',
    category: 'Function Types',
    difficulty: 'medium',
    title: 'Optional Parameter in Function Type',
    text: 'Create a function type with an optional second parameter for greeting',
    setup: '// Define greeting function type',
    setupCode: '// Define greeting function type',
    expected: 'Hello, World!',
    sample:
      'type Greeter = (name: string, greeting?: string) => string;\nconst greet: Greeter = (name, greeting = "Hello") => `${greeting}, ${name}!`;\ngreet("World")',
    hints: [
      'Use ? after parameter name for optional: param?: Type',
      'Provide default value in implementation if needed',
    ],
    tags: ['function-types', 'optional-parameters'],
  },
  {
    id: 'ts-func-029',
    category: 'Function Types',
    difficulty: 'medium',
    title: 'Rest Parameters in Function Type',
    text: 'Define a function type that accepts any number of numbers and returns their sum',
    setup: '// Define variadic sum type',
    setupCode: '// Define variadic sum type',
    expected: 15,
    sample:
      'type Sum = (...numbers: number[]) => number;\nconst sum: Sum = (...nums) => nums.reduce((a, b) => a + b, 0);\nsum(1, 2, 3, 4, 5)',
    hints: [
      'Use rest syntax: ...paramName: Type[]',
      'Rest parameters collect all remaining arguments',
    ],
    tags: ['function-types', 'rest-parameters', 'variadic'],
  },
  {
    id: 'ts-func-030',
    category: 'Function Types',
    difficulty: 'medium',
    title: 'Higher-Order Function Type',
    text: 'Create a type for a function that takes a function and returns a function',
    setup: '// Define a function doubler type',
    setupCode: '// Define a function doubler type',
    expected: 20,
    sample:
      'type Doubler = (fn: (x: number) => number) => (x: number) => number;\nconst double: Doubler = fn => x => fn(x) * 2;\nconst addOne = (x: number) => x + 1;\ndouble(addOne)(9)',
    hints: [
      'Higher-order functions take or return functions',
      'Nest function type expressions for complex signatures',
    ],
    tags: ['function-types', 'higher-order', 'composition'],
  },
  {
    id: 'ts-func-031',
    category: 'Function Types',
    difficulty: 'medium',
    title: 'Generic Function Type',
    text: 'Define a generic identity function type',
    setup: '// Define generic identity type',
    setupCode: '// Define generic identity type',
    expected: 'hello',
    sample:
      'type Identity = <T>(value: T) => T;\nconst identity: Identity = value => value;\nidentity("hello")',
    hints: [
      'Place generic parameter before function parameters: <T>(param: T) => T',
      'Generic preserves the input type in the output',
    ],
    tags: ['function-types', 'generics', 'identity'],
  },
  {
    id: 'ts-func-032',
    category: 'Function Types',
    difficulty: 'medium',
    title: 'Generic Mapper Function Type',
    text: 'Create a generic type for a function that maps A to B',
    setup: '// Define generic mapper',
    setupCode: '// Define generic mapper',
    expected: 5,
    sample:
      'type Mapper<A, B> = (value: A) => B;\nconst strlen: Mapper<string, number> = s => s.length;\nstrlen("hello")',
    hints: [
      'Use two type parameters for input and output types',
      'Type parameters can be specified when using the type',
    ],
    tags: ['function-types', 'generics', 'mapper'],
  },
  {
    id: 'ts-func-033',
    category: 'Function Types',
    difficulty: 'medium',
    title: 'Constrained Generic Function Type',
    text: 'Define a function type that only accepts objects with a length property',
    setup: 'interface HasLength { length: number; }',
    setupCode: 'interface HasLength { length: number; }',
    expected: 5,
    sample:
      'type GetLength = <T extends HasLength>(obj: T) => number;\nconst getLen: GetLength = obj => obj.length;\ngetLen("hello")',
    hints: [
      'Use extends to constrain generic types',
      'Constraint ensures the property exists on the type',
    ],
    tags: ['function-types', 'generics', 'constraints'],
  },
  {
    id: 'ts-func-034',
    category: 'Signatures',
    difficulty: 'medium',
    title: 'Call Signature in Interface',
    text: 'Create an interface with a call signature for a formatter function',
    setup: '// Define formatter interface with call signature',
    setupCode: '// Define formatter interface with call signature',
    expected: '$100.00',
    sample:
      'interface Formatter {\n  (value: number): string;\n  prefix: string;\n}\nconst fmt: Formatter = Object.assign(\n  (v: number) => fmt.prefix + v.toFixed(2),\n  { prefix: "$" }\n);\nfmt(100)',
    hints: [
      'Call signatures in interfaces: (params): ReturnType',
      'Call signatures allow adding properties to callable objects',
    ],
    tags: ['signatures', 'call-signature', 'interfaces'],
  },
  {
    id: 'ts-func-035',
    category: 'Signatures',
    difficulty: 'medium',
    title: 'Construct Signature',
    text: 'Define an interface with a construct signature for a class constructor',
    setup: 'class Point { constructor(public x: number, public y: number) {} }',
    setupCode: 'class Point { constructor(public x: number, public y: number) {} }',
    expected: { x: 3, y: 4 },
    sample:
      'interface PointConstructor {\n  new (x: number, y: number): Point;\n}\nconst createPoint = (Ctor: PointConstructor, x: number, y: number) => new Ctor(x, y);\nconst p = createPoint(Point, 3, 4);\n({ x: p.x, y: p.y })',
    hints: [
      'Construct signatures use new keyword: new (params): Type',
      'Allows passing constructors as values',
    ],
    tags: ['signatures', 'construct-signature', 'classes'],
  },
  {
    id: 'ts-func-036',
    category: 'Signatures',
    difficulty: 'medium',
    title: 'Both Call and Construct Signatures',
    text: 'Create a type that can be both called and constructed',
    setup: '// Define hybrid callable/constructable type',
    setupCode: '// Define hybrid callable/constructable type',
    expected: true,
    sample:
      'interface DateConstructor {\n  (): string;\n  new (): Date;\n}\nconst D = Date as unknown as DateConstructor;\ntypeof D() === "string" && D() !== undefined',
    hints: [
      'Some built-ins like Date work both ways',
      'Combine call and construct signatures in one interface',
    ],
    tags: ['signatures', 'hybrid', 'call-construct'],
  },
  {
    id: 'ts-func-037',
    category: 'Overloads',
    difficulty: 'medium',
    title: 'Basic Function Overloads',
    text: 'Create overloaded function that handles string or number differently',
    setup: '// Define overloaded double function',
    setupCode: '// Define overloaded double function',
    expected: 'hellohello',
    sample:
      'function double(x: string): string;\nfunction double(x: number): number;\nfunction double(x: string | number): string | number {\n  return typeof x === "string" ? x + x : x * 2;\n}\ndouble("hello")',
    hints: [
      'Overload signatures come before implementation',
      'Implementation signature must be compatible with all overloads',
    ],
    tags: ['overloads', 'function-overloads', 'polymorphism'],
  },
  {
    id: 'ts-func-038',
    category: 'Overloads',
    difficulty: 'medium',
    title: 'Overloads with Different Parameter Counts',
    text: 'Create overloaded function with optional second parameter',
    setup: '// Define overloaded createElement',
    setupCode: '// Define overloaded createElement',
    expected: { tag: 'div', content: 'Hello' },
    sample:
      'function createElement(tag: string): { tag: string };\nfunction createElement(tag: string, content: string): { tag: string; content: string };\nfunction createElement(tag: string, content?: string) {\n  return content ? { tag, content } : { tag };\n}\ncreateElement("div", "Hello")',
    hints: [
      'Different overloads can have different parameter counts',
      'Implementation handles all cases',
    ],
    tags: ['overloads', 'optional-params', 'flexibility'],
  },
  {
    id: 'ts-func-039',
    category: 'Overloads',
    difficulty: 'medium',
    title: 'Overloads with Array Types',
    text: 'Create overloaded function that unwraps single item or returns array',
    setup: '// Define overloaded first function',
    setupCode: '// Define overloaded first function',
    expected: 1,
    sample:
      'function first(arr: []): undefined;\nfunction first<T>(arr: [T, ...T[]]): T;\nfunction first<T>(arr: T[]): T | undefined {\n  return arr[0];\n}\nfirst([1, 2, 3])',
    hints: ['Use tuple types for specific array shapes', 'Empty tuple [] is a valid type'],
    tags: ['overloads', 'arrays', 'tuples'],
  },
  {
    id: 'ts-func-040',
    category: 'Overloads',
    difficulty: 'medium',
    title: 'Method Overloads in Class',
    text: 'Create a class with overloaded method for adding items',
    setup: '// Define collection class with overloaded add',
    setupCode: '// Define collection class with overloaded add',
    expected: [1, 2, 3, 4, 5],
    sample:
      'class Collection<T> {\n  items: T[] = [];\n  add(item: T): void;\n  add(items: T[]): void;\n  add(itemOrItems: T | T[]): void {\n    if (Array.isArray(itemOrItems)) this.items.push(...itemOrItems);\n    else this.items.push(itemOrItems);\n  }\n}\nconst c = new Collection<number>();\nc.add(1);\nc.add([2, 3, 4, 5]);\nc.items',
    hints: [
      'Class methods can have overloads too',
      'Use Array.isArray to distinguish types at runtime',
    ],
    tags: ['overloads', 'classes', 'methods'],
  },
  {
    id: 'ts-func-041',
    category: 'Function Types',
    difficulty: 'medium',
    title: 'Callback with Context Parameter',
    text: 'Define a callback type that receives value, index, and array',
    setup: 'const words = ["hello", "world"];',
    setupCode: 'const words = ["hello", "world"];',
    expected: ['HELLO-0', 'WORLD-1'],
    sample:
      'type MapCallback<T, U> = (value: T, index: number, array: T[]) => U;\nconst cb: MapCallback<string, string> = (v, i) => `${v.toUpperCase()}-${i}`;\nwords.map(cb)',
    hints: [
      'Array callbacks often include value, index, and array',
      'Generic types allow reuse with different element types',
    ],
    tags: ['function-types', 'callbacks', 'arrays', 'generics'],
  },
  {
    id: 'ts-func-042',
    category: 'Function Types',
    difficulty: 'medium',
    title: 'Reducer Function Type',
    text: 'Create a type for a reducer function used with reduce',
    setup: 'const nums = [1, 2, 3, 4, 5];',
    setupCode: 'const nums = [1, 2, 3, 4, 5];',
    expected: 15,
    sample:
      'type Reducer<T, A> = (accumulator: A, current: T, index: number) => A;\nconst sumReducer: Reducer<number, number> = (acc, curr) => acc + curr;\nnums.reduce(sumReducer, 0)',
    hints: ['Reducers take accumulator and current value', 'Return type matches accumulator type'],
    tags: ['function-types', 'reducer', 'arrays'],
  },
  {
    id: 'ts-func-043',
    category: 'Function Types',
    difficulty: 'medium',
    title: 'This Parameter in Function Type',
    text: 'Define a function type with explicit this parameter',
    setup: 'interface Counter { count: number; }',
    setupCode: 'interface Counter { count: number; }',
    expected: 3,
    sample:
      'type IncrementFn = (this: Counter, amount: number) => number;\nconst increment: IncrementFn = function(amount) { return this.count += amount; };\nconst counter: Counter = { count: 0 };\nincrement.call(counter, 3)',
    hints: [
      'this parameter must be first and is not counted as regular param',
      'Use call/apply/bind to set this context',
    ],
    tags: ['function-types', 'this-parameter', 'context'],
  },
  {
    id: 'ts-func-044',
    category: 'Function Types',
    difficulty: 'medium',
    title: 'Function Type Alias vs Interface',
    text: 'Show equivalent function type using both type alias and interface',
    setup: '// Both approaches define same callable type',
    setupCode: '// Both approaches define same callable type',
    expected: 6,
    sample:
      'type MultFn = (a: number, b: number) => number;\ninterface IMultFn { (a: number, b: number): number; }\nconst mult1: MultFn = (a, b) => a * b;\nconst mult2: IMultFn = (a, b) => a * b;\nmult1(2, 3)',
    hints: [
      'Type aliases use arrow syntax: (params) => Return',
      'Interfaces use call signature syntax: (params): Return',
    ],
    tags: ['function-types', 'type-alias', 'interface'],
  },
  {
    id: 'ts-func-045',
    category: 'Function Types',
    difficulty: 'medium',
    title: 'Conditional Return Type',
    text: 'Create a function type where return depends on input type',
    setup: '// Define conditional return type',
    setupCode: '// Define conditional return type',
    expected: 'hello',
    sample:
      'type Wrap<T> = T extends string ? string : number[];\ntype WrapFn = <T>(value: T) => Wrap<T>;\nconst wrap: WrapFn = (value: any) => typeof value === "string" ? value : [value];\nwrap("hello")',
    hints: [
      'Conditional types can determine return type based on input',
      'T extends U ? X : Y pattern for conditional types',
    ],
    tags: ['function-types', 'conditional-types', 'generics'],
  },
  {
    id: 'ts-func-046',
    category: 'Overloads',
    difficulty: 'medium',
    title: 'Overloads with Literal Types',
    text: 'Create overloaded function based on string literal input',
    setup: '// Define overloaded parse function',
    setupCode: '// Define overloaded parse function',
    expected: 42,
    sample:
      'function parse(type: "number", value: string): number;\nfunction parse(type: "boolean", value: string): boolean;\nfunction parse(type: string, value: string): number | boolean {\n  return type === "number" ? Number(value) : value === "true";\n}\nparse("number", "42")',
    hints: [
      'Literal types narrow the input to specific values',
      'Each overload handles a specific literal value',
    ],
    tags: ['overloads', 'literal-types', 'parsing'],
  },
  {
    id: 'ts-func-047',
    category: 'Function Types',
    difficulty: 'medium',
    title: 'Function Type with Default Generic',
    text: 'Create a generic function type with default type parameter',
    setup: '// Define function type with default generic',
    setupCode: '// Define function type with default generic',
    expected: 'default',
    sample:
      'type GetOrDefault<T = string> = (value: T | undefined, defaultVal: T) => T;\nconst getStr: GetOrDefault = (v, d) => v ?? d;\ngetStr(undefined, "default")',
    hints: [
      'Default type parameters use = syntax: T = DefaultType',
      'When not specified, the default is used',
    ],
    tags: ['function-types', 'generics', 'defaults'],
  },
  {
    id: 'ts-func-048',
    category: 'Function Types',
    difficulty: 'medium',
    title: 'Callback Type with Error-First Pattern',
    text: 'Define a Node.js style error-first callback type',
    setup: '// Define error-first callback',
    setupCode: '// Define error-first callback',
    expected: 'success',
    sample:
      'type NodeCallback<T> = (error: Error | null, data?: T) => void;\nlet result = "";\nconst cb: NodeCallback<string> = (err, data) => {\n  result = err ? err.message : data ?? "";\n};\ncb(null, "success");\nresult',
    hints: ['Error is first parameter, null if no error', 'Data is optional second parameter'],
    tags: ['function-types', 'callbacks', 'node-style'],
  },
  {
    id: 'ts-func-049',
    category: 'Function Types',
    difficulty: 'medium',
    title: 'Method Decorator Function Type',
    text: 'Define a type for a method decorator function',
    setup: '// Define method decorator type',
    setupCode: '// Define method decorator type',
    expected: true,
    sample:
      'type MethodDecorator = <T>(\n  target: Object,\n  propertyKey: string | symbol,\n  descriptor: TypedPropertyDescriptor<T>\n) => TypedPropertyDescriptor<T> | void;\nconst log: MethodDecorator = (target, key, desc) => desc;\ntypeof log === "function"',
    hints: [
      'Decorators receive target, key, and descriptor',
      'Can return modified descriptor or void',
    ],
    tags: ['function-types', 'decorators', 'methods'],
  },
  {
    id: 'ts-func-050',
    category: 'Function Types',
    difficulty: 'medium',
    title: 'Middleware Function Type',
    text: 'Define an Express-style middleware function type',
    setup: 'interface Request { path: string; }\ninterface Response { send(data: string): void; }',
    setupCode:
      'interface Request { path: string; }\ninterface Response { send(data: string): void; }',
    expected: '/api/users',
    sample:
      'type Middleware = (req: Request, res: Response, next: () => void) => void;\nlet logged = "";\nconst logger: Middleware = (req, res, next) => { logged = req.path; next(); };\nlogger({ path: "/api/users" }, { send: () => {} }, () => {});\nlogged',
    hints: [
      'Middleware receives request, response, and next',
      'Call next() to continue to next middleware',
    ],
    tags: ['function-types', 'middleware', 'express'],
  },
  {
    id: 'ts-func-051',
    category: 'Overloads',
    difficulty: 'medium',
    title: 'Overloads Returning Different Types',
    text: 'Create overloaded function returning array or single item',
    setup: '// Define overloaded find function',
    setupCode: '// Define overloaded find function',
    expected: [2, 4, 6],
    sample:
      'function find(arr: number[], predicate: (n: number) => boolean, all: true): number[];\nfunction find(arr: number[], predicate: (n: number) => boolean, all: false): number | undefined;\nfunction find(arr: number[], predicate: (n: number) => boolean, all: boolean) {\n  return all ? arr.filter(predicate) : arr.find(predicate);\n}\nfind([1, 2, 3, 4, 5, 6], n => n % 2 === 0, true)',
    hints: [
      'Boolean literal types control return type',
      'true returns array, false returns single item',
    ],
    tags: ['overloads', 'literal-types', 'arrays'],
  },
  {
    id: 'ts-func-052',
    category: 'Overloads',
    difficulty: 'medium',
    title: 'String or Regex Overload',
    text: 'Create overloaded replace function accepting string or regex',
    setup: '// Define overloaded replace function',
    setupCode: '// Define overloaded replace function',
    expected: 'hello universe',
    sample:
      'function replace(str: string, search: string, replacement: string): string;\nfunction replace(str: string, search: RegExp, replacement: string): string;\nfunction replace(str: string, search: string | RegExp, replacement: string): string {\n  return str.replace(search, replacement);\n}\nreplace("hello world", /world/, "universe")',
    hints: ['String and RegExp can be separate overloads', 'Implementation handles both cases'],
    tags: ['overloads', 'strings', 'regex'],
  },
  {
    id: 'ts-func-053',
    category: 'Function Types',
    difficulty: 'medium',
    title: 'Memoized Function Type',
    text: 'Define a type for a memoization wrapper function',
    setup: '// Define memoize function type',
    setupCode: '// Define memoize function type',
    expected: 8,
    sample:
      'type Memoize = <A extends any[], R>(fn: (...args: A) => R) => (...args: A) => R;\nconst memoize: Memoize = fn => {\n  const cache = new Map<string, any>();\n  return (...args) => {\n    const key = JSON.stringify(args);\n    if (!cache.has(key)) cache.set(key, fn(...args));\n    return cache.get(key);\n  };\n};\nconst cube = memoize((n: number) => n * n * n);\ncube(2)',
    hints: ['Memoize preserves function signature', 'Use Map for caching results'],
    tags: ['function-types', 'memoization', 'higher-order'],
  },
  {
    id: 'ts-func-054',
    category: 'Signatures',
    difficulty: 'medium',
    title: 'Index Signature with Call Signature',
    text: 'Create an interface combining call signature with index signature',
    setup: '// Define callable dictionary type',
    setupCode: '// Define callable dictionary type',
    expected: 'default',
    sample:
      'interface CallableDict {\n  (key: string): string;\n  [key: string]: string | ((key: string) => string);\n}\nconst dict: CallableDict = Object.assign(\n  (key: string) => dict[key] as string ?? "default",\n  { hello: "world", foo: "bar" }\n);\ndict("unknown")',
    hints: [
      'Index signatures define property access types',
      'Call signature makes the object callable',
    ],
    tags: ['signatures', 'index-signature', 'callable'],
  },
  {
    id: 'ts-func-055',
    category: 'Function Types',
    difficulty: 'medium',
    title: 'Function Type with Readonly Parameters',
    text: 'Define a function type that takes readonly array parameter',
    setup: '// Define function with readonly param',
    setupCode: '// Define function with readonly param',
    expected: 6,
    sample:
      'type Summer = (numbers: readonly number[]) => number;\nconst sum: Summer = nums => nums.reduce((a, b) => a + b, 0);\nsum([1, 2, 3])',
    hints: [
      'readonly modifier prevents array mutation',
      'Accepts both mutable and readonly arrays',
    ],
    tags: ['function-types', 'readonly', 'arrays'],
  },
  {
    id: 'ts-func-056',
    category: 'Function Types',
    difficulty: 'medium',
    title: 'Builder Pattern Function Type',
    text: 'Define types for a fluent builder pattern',
    setup: 'interface Query { table: string; columns: string[]; where?: string; }',
    setupCode: 'interface Query { table: string; columns: string[]; where?: string; }',
    expected: { table: 'users', columns: ['name', 'email'], where: 'active = true' },
    sample:
      'interface QueryBuilder {\n  select(...cols: string[]): QueryBuilder;\n  from(table: string): QueryBuilder;\n  where(condition: string): QueryBuilder;\n  build(): Query;\n}\nconst builder: QueryBuilder = {\n  _query: {} as Query,\n  select(...cols) { this._query.columns = cols; return this; },\n  from(table) { this._query.table = table; return this; },\n  where(cond) { this._query.where = cond; return this; },\n  build() { return this._query; }\n} as any;\nbuilder.select("name", "email").from("users").where("active = true").build()',
    hints: [
      'Builder methods return this for chaining',
      'Use interface to define method signatures',
    ],
    tags: ['function-types', 'builder-pattern', 'fluent'],
  },
  {
    id: 'ts-func-057',
    category: 'Function Types',
    difficulty: 'medium',
    title: 'Event Emitter Types',
    text: 'Define types for a typed event emitter',
    setup: 'interface Events { click: { x: number; y: number }; change: string; }',
    setupCode: 'interface Events { click: { x: number; y: number }; change: string; }',
    expected: { x: 10, y: 20 },
    sample:
      'type Listener<T> = (data: T) => void;\ntype Emitter<E> = {\n  on<K extends keyof E>(event: K, listener: Listener<E[K]>): void;\n  emit<K extends keyof E>(event: K, data: E[K]): void;\n};\nconst emitter: Emitter<Events> = {\n  listeners: {} as any,\n  on(event, listener) { (this.listeners[event] ??= []).push(listener); },\n  emit(event, data) { this.listeners[event]?.forEach((l: any) => l(data)); }\n} as any;\nlet received: any;\nemitter.on("click", d => { received = d; });\nemitter.emit("click", { x: 10, y: 20 });\nreceived',
    hints: [
      'Use mapped types for event-specific listeners',
      'keyof E constrains to valid event names',
    ],
    tags: ['function-types', 'events', 'generics'],
  },
  {
    id: 'ts-func-058',
    category: 'Function Types',
    difficulty: 'medium',
    title: 'Partial Application Type',
    text: 'Define a type for partial function application',
    setup: '// Define partial application type',
    setupCode: '// Define partial application type',
    expected: 15,
    sample:
      'type PartialApply<F, A> = F extends (arg: A, ...rest: infer R) => infer Ret\n  ? (...args: R) => Ret\n  : never;\nconst add = (a: number, b: number, c: number) => a + b + c;\ntype AddWithFirst = PartialApply<typeof add, number>;\nconst add5: AddWithFirst = (b, c) => add(5, b, c);\nadd5(4, 6)',
    hints: [
      'Use infer to capture remaining params and return type',
      'Partial application fixes some arguments',
    ],
    tags: ['function-types', 'partial-application', 'generics'],
  },
  {
    id: 'ts-func-059',
    category: 'Overloads',
    difficulty: 'medium',
    title: 'Async/Sync Overloads',
    text: 'Create overloaded function with async and sync variants',
    setup: '// Define overloaded fetch data function',
    setupCode: '// Define overloaded fetch data function',
    expected: 'sync',
    sample:
      'function fetchData(async: true): Promise<string>;\nfunction fetchData(async: false): string;\nfunction fetchData(async: boolean): Promise<string> | string {\n  return async ? Promise.resolve("async") : "sync";\n}\nfetchData(false)',
    hints: ['Boolean literal determines sync vs async', 'Return type changes based on parameter'],
    tags: ['overloads', 'async', 'sync'],
  },
  {
    id: 'ts-func-060',
    category: 'Function Types',
    difficulty: 'medium',
    title: 'Strict Function Comparison',
    text: 'Create types to check function compatibility',
    setup: 'type Fn1 = (x: number, y: string) => boolean;\ntype Fn2 = (x: number) => boolean;',
    setupCode: 'type Fn1 = (x: number, y: string) => boolean;\ntype Fn2 = (x: number) => boolean;',
    expected: true,
    sample:
      'type IsAssignable<A, B> = A extends B ? true : false;\ntype CanAssignFn2ToFn1 = IsAssignable<Fn2, Fn1>;\nconst fn1: Fn1 = (x, y) => x > 0 && y.length > 0;\nconst fn2: Fn2 = x => x > 0;\nconst test: Fn1 = fn2;\ntest(5, "hi")',
    hints: [
      'Functions with fewer params can be assigned to functions with more',
      'This is due to function parameter bivariance',
    ],
    tags: ['function-types', 'compatibility', 'assignability'],
  },
  {
    id: 'ts-func-061',
    category: 'Signatures',
    difficulty: 'hard',
    title: 'Generic Construct Signature',
    text: 'Create a generic constructor type for creating instances',
    setup: 'class Entity { constructor(public id: string) {} }',
    setupCode: 'class Entity { constructor(public id: string) {} }',
    expected: 'test-id',
    sample:
      'interface Constructor<T> {\n  new (...args: any[]): T;\n}\nfunction create<T>(Ctor: Constructor<T>, ...args: any[]): T {\n  return new Ctor(...args);\n}\ncreate(Entity, "test-id").id',
    hints: [
      'Generic construct signatures work with class constructors',
      'Use rest parameters for flexible argument passing',
    ],
    tags: ['signatures', 'generics', 'constructor'],
  },
  {
    id: 'ts-func-062',
    category: 'Function Types',
    difficulty: 'hard',
    title: 'Curried Function Type',
    text: 'Define a type for a curried addition function',
    setup: '// Define curried function type',
    setupCode: '// Define curried function type',
    expected: 15,
    sample:
      'type Curried = (a: number) => (b: number) => (c: number) => number;\nconst add: Curried = a => b => c => a + b + c;\nadd(5)(6)(4)',
    hints: [
      'Curried functions return functions until all args received',
      'Chain arrow types for multiple levels',
    ],
    tags: ['function-types', 'currying', 'higher-order'],
  },
  {
    id: 'ts-func-063',
    category: 'Function Types',
    difficulty: 'hard',
    title: 'Infer Return Type from Function',
    text: 'Use ReturnType utility to extract function return type',
    setup: 'function getUser() { return { id: 1, name: "Alice" }; }',
    setupCode: 'function getUser() { return { id: 1, name: "Alice" }; }',
    expected: { id: 2, name: 'Bob' },
    sample:
      'type User = ReturnType<typeof getUser>;\nconst user: User = { id: 2, name: "Bob" };\nuser',
    hints: [
      'ReturnType<F> extracts the return type of function type F',
      'Use typeof to get type of a function value',
    ],
    tags: ['function-types', 'utility-types', 'inference'],
  },
  {
    id: 'ts-func-064',
    category: 'Function Types',
    difficulty: 'hard',
    title: 'Infer Parameters from Function',
    text: 'Use Parameters utility to extract function parameter types',
    setup:
      'function createPost(title: string, body: string, published: boolean) { return { title, body, published }; }',
    setupCode:
      'function createPost(title: string, body: string, published: boolean) { return { title, body, published }; }',
    expected: ['Hello', 'World', true],
    sample:
      'type PostParams = Parameters<typeof createPost>;\nconst params: PostParams = ["Hello", "World", true];\nparams',
    hints: [
      'Parameters<F> returns a tuple of parameter types',
      'Useful for wrapping or extending existing functions',
    ],
    tags: ['function-types', 'utility-types', 'parameters'],
  },
  {
    id: 'ts-func-065',
    category: 'Overloads',
    difficulty: 'hard',
    title: 'Overloads with Generic Constraints',
    text: 'Create overloaded function with different generic constraints',
    setup: 'interface Named { name: string; }\ninterface Numbered { id: number; }',
    setupCode: 'interface Named { name: string; }\ninterface Numbered { id: number; }',
    expected: 'Alice',
    sample:
      'function getIdentifier<T extends Named>(obj: T): string;\nfunction getIdentifier<T extends Numbered>(obj: T): number;\nfunction getIdentifier(obj: Named | Numbered): string | number {\n  return "name" in obj ? obj.name : obj.id;\n}\ngetIdentifier({ name: "Alice" })',
    hints: [
      'Overloads can have different generic constraints',
      'Use type narrowing in implementation',
    ],
    tags: ['overloads', 'generics', 'constraints'],
  },
  {
    id: 'ts-func-066',
    category: 'Function Types',
    difficulty: 'hard',
    title: 'Never-Returning Function Type',
    text: 'Define a type for a function that never returns (throws or infinite loop)',
    setup: '// Define never-returning function type',
    setupCode: '// Define never-returning function type',
    expected: 'caught',
    sample:
      'type ThrowError = (message: string) => never;\nconst fail: ThrowError = msg => { throw new Error(msg); };\nlet result = "";\ntry { fail("oops"); } catch { result = "caught"; }\nresult',
    hints: [
      'never is for functions that never successfully complete',
      'Throwing an error or infinite loops return never',
    ],
    tags: ['function-types', 'never', 'error-handling'],
  },
  {
    id: 'ts-func-067',
    category: 'Function Types',
    difficulty: 'hard',
    title: 'Assertion Function Type',
    text: 'Create an assertion function type that narrows types',
    setup: 'interface User { name: string; role?: string; }',
    setupCode: 'interface User { name: string; role?: string; }',
    expected: 'admin',
    sample:
      'type AssertHasRole = (user: User) => asserts user is User & { role: string };\nconst assertHasRole: AssertHasRole = user => {\n  if (!user.role) throw new Error("No role");\n};\nconst user: User = { name: "Alice", role: "admin" };\nassertHasRole(user);\nuser.role',
    hints: [
      'asserts x is Type narrows the type after function call',
      'Assertion functions throw if condition not met',
    ],
    tags: ['function-types', 'assertions', 'type-narrowing'],
  },
  {
    id: 'ts-func-068',
    category: 'Function Types',
    difficulty: 'hard',
    title: 'Type Guard Function Type',
    text: 'Define a type guard function type for checking arrays',
    setup: '// Define type guard function type',
    setupCode: '// Define type guard function type',
    expected: true,
    sample:
      'type IsStringArray = (value: unknown) => value is string[];\nconst isStrArr: IsStringArray = (v): v is string[] => \n  Array.isArray(v) && v.every(x => typeof x === "string");\nisStrArr(["a", "b", "c"])',
    hints: ['Type guards return x is Type predicate', 'Implementation must return boolean'],
    tags: ['function-types', 'type-guards', 'predicates'],
  },
  {
    id: 'ts-func-069',
    category: 'Function Types',
    difficulty: 'hard',
    title: 'Mapped Function Types',
    text: 'Create a type that wraps all methods of an object in promises',
    setup:
      'interface Api { getUser(id: number): { name: string }; getPost(id: number): { title: string }; }',
    setupCode:
      'interface Api { getUser(id: number): { name: string }; getPost(id: number): { title: string }; }',
    expected: { name: 'Alice' },
    sample:
      'type Async<T> = {\n  [K in keyof T]: T[K] extends (...args: infer A) => infer R\n    ? (...args: A) => Promise<R>\n    : T[K];\n};\nconst api: Async<Api> = {\n  getUser: async (id) => ({ name: "Alice" }),\n  getPost: async (id) => ({ title: "Hello" }),\n};\napi.getUser(1).then(u => u)',
    hints: [
      'Use mapped types with conditional inference',
      'infer extracts argument and return types from functions',
    ],
    tags: ['function-types', 'mapped-types', 'async'],
  },
  {
    id: 'ts-func-070',
    category: 'Overloads',
    difficulty: 'hard',
    title: 'Overloads with Rest Parameters',
    text: 'Create overloaded function handling different rest parameter types',
    setup: '// Define overloaded concatenate function',
    setupCode: '// Define overloaded concatenate function',
    expected: '1-2-3',
    sample:
      'function concat(...strings: string[]): string;\nfunction concat(...numbers: number[]): string;\nfunction concat(...args: (string | number)[]): string {\n  return args.join("-");\n}\nconcat(1, 2, 3)',
    hints: [
      'Each overload can have different rest parameter types',
      'Implementation must handle all variants',
    ],
    tags: ['overloads', 'rest-parameters', 'variadic'],
  },
  {
    id: 'ts-func-071',
    category: 'Function Types',
    difficulty: 'hard',
    title: 'Distributive Conditional Function Type',
    text: 'Create a type that distributes over union in function parameter',
    setup: 'type Animal = { type: "cat"; meow: () => void } | { type: "dog"; bark: () => void };',
    setupCode:
      'type Animal = { type: "cat"; meow: () => void } | { type: "dog"; bark: () => void };',
    expected: 'meow',
    sample:
      'type Handler<T> = T extends { type: infer U } ? (animal: T) => U : never;\ntype CatHandler = Handler<Extract<Animal, { type: "cat" }>>;\nconst handleCat: CatHandler = cat => { cat.meow(); return cat.type; };\nhandleCat({ type: "cat", meow: () => {} })',
    hints: ['Conditional types distribute over unions', 'Extract narrows union to specific member'],
    tags: ['function-types', 'conditional-types', 'unions'],
  },
  {
    id: 'ts-func-072',
    category: 'Signatures',
    difficulty: 'hard',
    title: 'Abstract Construct Signature',
    text: 'Create a type that accepts abstract class constructors',
    setup: 'abstract class Shape { abstract area(): number; }',
    setupCode: 'abstract class Shape { abstract area(): number; }',
    expected: 100,
    sample:
      'type AbstractConstructor<T> = abstract new (...args: any[]) => T;\nclass Square extends Shape {\n  constructor(public side: number) { super(); }\n  area() { return this.side * this.side; }\n}\nfunction getArea<T extends Shape>(Ctor: new (...args: any[]) => T, ...args: any[]): number {\n  return new Ctor(...args).area();\n}\ngetArea(Square, 10)',
    hints: [
      'abstract new creates abstract construct signature',
      'Abstract classes cannot be instantiated directly',
    ],
    tags: ['signatures', 'abstract', 'classes'],
  },
  {
    id: 'ts-func-073',
    category: 'Function Types',
    difficulty: 'hard',
    title: 'Variadic Tuple Function Type',
    text: 'Create a function type using variadic tuple types',
    setup: '// Define pipe function type',
    setupCode: '// Define pipe function type',
    expected: 10,
    sample:
      'type Pipe<A, B> = (arg: A) => B;\nfunction pipe<A, B, C>(f1: Pipe<A, B>, f2: Pipe<B, C>): Pipe<A, C> {\n  return x => f2(f1(x));\n}\nconst addOne = (x: number) => x + 1;\nconst double = (x: number) => x * 2;\npipe(addOne, double)(4)',
    hints: [
      'Variadic tuples allow spreading tuple types',
      'Build type-safe pipelines with multiple functions',
    ],
    tags: ['function-types', 'variadic-tuples', 'pipe'],
  },
  {
    id: 'ts-func-074',
    category: 'Function Types',
    difficulty: 'hard',
    title: 'Overloaded Method in Interface',
    text: 'Define an interface with overloaded method signatures',
    setup: '// Define storage interface with overloaded get',
    setupCode: '// Define storage interface with overloaded get',
    expected: 42,
    sample:
      'interface Storage {\n  get(key: string): unknown;\n  get<T>(key: string, defaultValue: T): T;\n}\nconst storage: Storage = {\n  get<T>(key: string, defaultValue?: T) {\n    const data: Record<string, unknown> = { age: 42 };\n    return data[key] ?? defaultValue;\n  }\n};\nstorage.get<number>("age", 0)',
    hints: [
      'Interfaces can declare multiple overloaded signatures',
      'Implementation handles all variants',
    ],
    tags: ['signatures', 'overloads', 'interfaces'],
  },
  {
    id: 'ts-func-075',
    category: 'Function Types',
    difficulty: 'hard',
    title: 'Infer This Type from Method',
    text: 'Extract this type from a method using ThisParameterType',
    setup: 'interface Counter {\n  count: number;\n  increment(this: Counter): void;\n}',
    setupCode: 'interface Counter {\n  count: number;\n  increment(this: Counter): void;\n}',
    expected: 1,
    sample:
      'type CounterThis = ThisParameterType<Counter["increment"]>;\nconst counter: CounterThis = { count: 0, increment() { this.count++; } };\ncounter.increment();\ncounter.count',
    hints: [
      'ThisParameterType extracts the this type from a function',
      'Useful for ensuring correct context',
    ],
    tags: ['function-types', 'this-parameter', 'utility-types'],
  },
  {
    id: 'ts-func-076',
    category: 'Function Types',
    difficulty: 'hard',
    title: 'Omit This Parameter from Function',
    text: 'Remove this parameter from function type using OmitThisParameter',
    setup: 'type BoundMethod = (this: { value: number }, multiplier: number) => number;',
    setupCode: 'type BoundMethod = (this: { value: number }, multiplier: number) => number;',
    expected: 15,
    sample:
      'type Unbound = OmitThisParameter<BoundMethod>;\nconst method: BoundMethod = function(mult) { return this.value * mult; };\nconst obj = { value: 5 };\nconst bound: Unbound = method.bind(obj);\nbound(3)',
    hints: ['OmitThisParameter removes the this parameter', 'Useful for bound functions'],
    tags: ['function-types', 'this-parameter', 'utility-types'],
  },
  {
    id: 'ts-func-077',
    category: 'Function Types',
    difficulty: 'hard',
    title: 'Debounce Function Type',
    text: 'Define a type for a debounce utility function',
    setup: '// Define debounce function type',
    setupCode: '// Define debounce function type',
    expected: true,
    sample:
      'type Debounce = <A extends any[]>(fn: (...args: A) => void, ms: number) => (...args: A) => void;\nconst debounce: Debounce = (fn, ms) => {\n  let timeout: ReturnType<typeof setTimeout>;\n  return (...args) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => fn(...args), ms);\n  };\n};\nconst debounced = debounce((x: number) => x, 100);\ntypeof debounced === "function"',
    hints: ['Debounce delays function execution', 'Preserves original function argument types'],
    tags: ['function-types', 'debounce', 'utilities'],
  },
  {
    id: 'ts-func-078',
    category: 'Function Types',
    difficulty: 'hard',
    title: 'Throttle Function Type',
    text: 'Define a type for a throttle utility function',
    setup: '// Define throttle function type',
    setupCode: '// Define throttle function type',
    expected: true,
    sample:
      'type Throttle = <A extends any[], R>(fn: (...args: A) => R, ms: number) => (...args: A) => R | undefined;\nconst throttle: Throttle = (fn, ms) => {\n  let lastCall = 0;\n  return (...args) => {\n    const now = Date.now();\n    if (now - lastCall >= ms) {\n      lastCall = now;\n      return fn(...args);\n    }\n  };\n};\nconst throttled = throttle((x: number) => x * 2, 100);\ntypeof throttled === "function"',
    hints: ['Throttle limits execution frequency', 'Returns undefined when throttled'],
    tags: ['function-types', 'throttle', 'utilities'],
  },
  {
    id: 'ts-func-079',
    category: 'Overloads',
    difficulty: 'hard',
    title: 'Overloads with Tuple Parameters',
    text: 'Create overloaded function accepting different tuple shapes',
    setup: '// Define overloaded point creator',
    setupCode: '// Define overloaded point creator',
    expected: { x: 3, y: 4, z: 5 },
    sample:
      'function createPoint(coords: [number, number]): { x: number; y: number };\nfunction createPoint(coords: [number, number, number]): { x: number; y: number; z: number };\nfunction createPoint(coords: number[]): { x: number; y: number; z?: number } {\n  return coords.length === 3\n    ? { x: coords[0], y: coords[1], z: coords[2] }\n    : { x: coords[0], y: coords[1] };\n}\ncreatePoint([3, 4, 5])',
    hints: [
      'Different tuple lengths can have different overloads',
      'Use tuple types [T, T] for fixed length arrays',
    ],
    tags: ['overloads', 'tuples', 'polymorphism'],
  },
  {
    id: 'ts-func-080',
    category: 'Function Types',
    difficulty: 'hard',
    title: 'Recursive Function Type',
    text: 'Define a type for a recursive tree traversal function',
    setup: 'interface TreeNode { value: number; children?: TreeNode[]; }',
    setupCode: 'interface TreeNode { value: number; children?: TreeNode[]; }',
    expected: 21,
    sample:
      'type TreeSum = (node: TreeNode) => number;\nconst sumTree: TreeSum = node => {\n  const childSum = node.children?.reduce((sum, child) => sum + sumTree(child), 0) ?? 0;\n  return node.value + childSum;\n};\nconst tree: TreeNode = { value: 1, children: [{ value: 2, children: [{ value: 3 }] }, { value: 4, children: [{ value: 5 }, { value: 6 }] }] };\nsumTree(tree)',
    hints: ['Recursive functions call themselves', 'Handle base case and recursive case'],
    tags: ['function-types', 'recursion', 'trees'],
  },
  {
    id: 'ts-func-081',
    category: 'Function Types',
    difficulty: 'hard',
    title: 'Promisify Function Type',
    text: 'Define a type that converts callback-based function to promise-based',
    setup: 'type Callback<T> = (error: Error | null, result: T) => void;',
    setupCode: 'type Callback<T> = (error: Error | null, result: T) => void;',
    expected: 42,
    sample:
      'type Promisify<T extends (...args: any[]) => void> =\n  T extends (...args: [...infer A, Callback<infer R>]) => void\n    ? (...args: A) => Promise<R>\n    : never;\nconst readFile = (path: string, cb: Callback<string>) => cb(null, "content");\ntype PromisifiedRead = Promisify<typeof readFile>;\nconst promisified: PromisifiedRead = (path) => Promise.resolve("content" as any);\nPromise.resolve(42).then(r => r)',
    hints: [
      'Extract callback result type using infer',
      'Remove callback from args, return Promise',
    ],
    tags: ['function-types', 'promises', 'utility-types'],
  },
  {
    id: 'ts-func-082',
    category: 'Function Types',
    difficulty: 'hard',
    title: 'Compose Function Types',
    text: 'Define a type for composing two functions',
    setup: '// Define compose type',
    setupCode: '// Define compose type',
    expected: 10,
    sample:
      'type Compose = <A, B, C>(f: (b: B) => C, g: (a: A) => B) => (a: A) => C;\nconst compose: Compose = (f, g) => a => f(g(a));\nconst double = (n: number) => n * 2;\nconst addOne = (n: number) => n + 1;\ncompose(double, addOne)(4)',
    hints: ['Compose applies functions right to left', 'Output of g becomes input of f'],
    tags: ['function-types', 'composition', 'higher-order'],
  },
  {
    id: 'ts-func-083',
    category: 'Overloads',
    difficulty: 'hard',
    title: 'Builder with Overloaded Methods',
    text: 'Create a builder with overloaded set method',
    setup: 'interface Options { name?: string; count?: number; active?: boolean; }',
    setupCode: 'interface Options { name?: string; count?: number; active?: boolean; }',
    expected: { name: 'test', count: 5, active: true },
    sample:
      'class OptionsBuilder {\n  private options: Options = {};\n  set(key: "name", value: string): this;\n  set(key: "count", value: number): this;\n  set(key: "active", value: boolean): this;\n  set(key: keyof Options, value: string | number | boolean): this {\n    (this.options as any)[key] = value;\n    return this;\n  }\n  build(): Options { return this.options; }\n}\nnew OptionsBuilder().set("name", "test").set("count", 5).set("active", true).build()',
    hints: ['Each overload specifies key-value type pairing', 'Return this for method chaining'],
    tags: ['overloads', 'builder', 'method-chaining'],
  },
  {
    id: 'ts-func-084',
    category: 'Function Types',
    difficulty: 'hard',
    title: 'Extract Function from Union',
    text: 'Extract only function types from a union',
    setup:
      'type Mixed = string | ((x: number) => number) | { a: number } | ((s: string) => string);',
    setupCode:
      'type Mixed = string | ((x: number) => number) | { a: number } | ((s: string) => string);',
    expected: 4,
    sample:
      'type OnlyFunctions<T> = T extends (...args: any[]) => any ? T : never;\ntype Fns = OnlyFunctions<Mixed>;\nconst fn: Fns = (x: number) => x * 2;\nfn(2)',
    hints: [
      'Conditional types distribute over unions',
      'never removes non-matching types from union',
    ],
    tags: ['function-types', 'conditional-types', 'unions'],
  },
  {
    id: 'ts-func-085',
    category: 'Function Types',
    difficulty: 'hard',
    title: 'Contravariance in Function Parameters',
    text: 'Demonstrate contravariance in function parameter types',
    setup: 'interface Animal { name: string; }\ninterface Dog extends Animal { breed: string; }',
    setupCode:
      'interface Animal { name: string; }\ninterface Dog extends Animal { breed: string; }',
    expected: 'Buddy',
    sample:
      'type AnimalHandler = (animal: Animal) => string;\ntype DogHandler = (dog: Dog) => string;\nconst handleAnimal: AnimalHandler = a => a.name;\nconst handleDog: DogHandler = handleAnimal;\nhandleDog({ name: "Buddy", breed: "Lab" })',
    hints: [
      'Functions are contravariant in parameter types',
      'AnimalHandler can be used where DogHandler expected',
    ],
    tags: ['function-types', 'contravariance', 'type-theory'],
  },

  // ============================================================
  // Classes & OOP Patterns
  // ============================================================
  {
    id: 'ts-class-001',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Basic Class Declaration',
    text: 'Create a simple class with a name property and access it',
    setup: 'class Person { name: string = "Alice"; }',
    setupCode: 'class Person { name: string = "Alice"; }',
    expected: 'Alice',
    sample: 'new Person().name',
    hints: ['Instantiate the class with new keyword', 'Access the property using dot notation'],
    tags: ['class', 'property', 'basics'],
  },
  {
    id: 'ts-class-002',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Constructor with Parameters',
    text: 'Create a class instance with constructor parameters',
    setup: 'class Animal { name: string; constructor(name: string) { this.name = name; } }',
    setupCode: 'class Animal { name: string; constructor(name: string) { this.name = name; } }',
    expected: 'Dog',
    sample: 'new Animal("Dog").name',
    hints: ['Pass arguments to the constructor', 'The constructor initializes the instance'],
    tags: ['class', 'constructor', 'basics'],
  },
  {
    id: 'ts-class-003',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Parameter Properties Shorthand',
    text: 'Use TypeScript parameter properties to declare and initialize',
    setup: 'class Car { constructor(public brand: string, public year: number) {} }',
    setupCode: 'class Car { constructor(public brand: string, public year: number) {} }',
    expected: 'Toyota',
    sample: 'new Car("Toyota", 2023).brand',
    hints: [
      'Public modifier in constructor creates and assigns properties',
      'No need for separate property declaration',
    ],
    tags: ['class', 'parameter-properties', 'constructor'],
  },
  {
    id: 'ts-class-004',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Class Method',
    text: 'Call a method on a class instance',
    setup: 'class Greeter { greet(name: string): string { return `Hello, ${name}!`; } }',
    setupCode: 'class Greeter { greet(name: string): string { return `Hello, ${name}!`; } }',
    expected: 'Hello, World!',
    sample: 'new Greeter().greet("World")',
    hints: [
      'Create an instance and call the method',
      'Methods are functions attached to the class',
    ],
    tags: ['class', 'method', 'basics'],
  },
  {
    id: 'ts-class-005',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Readonly Property',
    text: 'Access a readonly property that cannot be modified after initialization',
    setup: 'class Config { readonly apiKey: string = "secret123"; }',
    setupCode: 'class Config { readonly apiKey: string = "secret123"; }',
    expected: 'secret123',
    sample: 'new Config().apiKey',
    hints: [
      'Readonly properties can be accessed but not modified',
      'They are set at declaration or in constructor',
    ],
    tags: ['class', 'readonly', 'basics'],
  },
  {
    id: 'ts-class-006',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Static Property',
    text: 'Access a static property on the class itself',
    setup: 'class MathUtils { static PI: number = 3.14159; }',
    setupCode: 'class MathUtils { static PI: number = 3.14159; }',
    // biome-ignore lint/suspicious/noApproximativeNumericConstant: literal value of the static property, not Math.PI
    expected: 3.14159,
    sample: 'MathUtils.PI',
    hints: [
      'Static properties belong to the class, not instances',
      'Access using ClassName.property',
    ],
    tags: ['class', 'static', 'property'],
  },
  {
    id: 'ts-class-007',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Static Method',
    text: 'Call a static method on the class',
    setup: 'class Calculator { static add(a: number, b: number): number { return a + b; } }',
    setupCode: 'class Calculator { static add(a: number, b: number): number { return a + b; } }',
    expected: 15,
    sample: 'Calculator.add(10, 5)',
    hints: ['Static methods are called on the class itself', 'No need to create an instance'],
    tags: ['class', 'static', 'method'],
  },
  {
    id: 'ts-class-008',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Getter Property',
    text: 'Use a getter to compute a derived value',
    setup:
      'class Rectangle { constructor(public width: number, public height: number) {} get area(): number { return this.width * this.height; } }',
    setupCode:
      'class Rectangle { constructor(public width: number, public height: number) {} get area(): number { return this.width * this.height; } }',
    expected: 50,
    sample: 'new Rectangle(10, 5).area',
    hints: ['Getters are accessed like properties', 'They compute values on demand'],
    tags: ['class', 'getter', 'computed-property'],
  },
  {
    id: 'ts-class-009',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Basic Inheritance',
    text: 'Create a subclass that extends a parent class',
    setup:
      'class Animal { name: string = "Animal"; }\nclass Dog extends Animal { name: string = "Dog"; }',
    setupCode:
      'class Animal { name: string = "Animal"; }\nclass Dog extends Animal { name: string = "Dog"; }',
    expected: 'Dog',
    sample: 'new Dog().name',
    hints: ['Subclass overrides parent property', 'Use extends keyword for inheritance'],
    tags: ['class', 'inheritance', 'extends'],
  },
  {
    id: 'ts-class-010',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Instanceof Check',
    text: 'Check if an object is an instance of a class',
    setup: 'class Vehicle {}\nclass Car extends Vehicle {}\nconst myCar = new Car();',
    setupCode: 'class Vehicle {}\nclass Car extends Vehicle {}\nconst myCar = new Car();',
    expected: true,
    sample: 'myCar instanceof Vehicle',
    hints: [
      'instanceof checks the prototype chain',
      'A subclass instance is also an instance of its parent',
    ],
    tags: ['class', 'instanceof', 'inheritance'],
  },
  {
    id: 'ts-class-011',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Method Return Type',
    text: 'Call a method with explicit return type',
    setup:
      'class Counter { private count: number = 0; increment(): number { return ++this.count; } }',
    setupCode:
      'class Counter { private count: number = 0; increment(): number { return ++this.count; } }',
    expected: 1,
    sample: 'new Counter().increment()',
    hints: ['Methods can have explicit return types', 'The private count starts at 0'],
    tags: ['class', 'method', 'return-type'],
  },
  {
    id: 'ts-class-012',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Multiple Properties',
    text: 'Access multiple properties from a class instance',
    setup:
      'class User { constructor(public name: string, public age: number, public email: string) {} }',
    setupCode:
      'class User { constructor(public name: string, public age: number, public email: string) {} }',
    expected: 'john@example.com',
    sample: 'new User("John", 30, "john@example.com").email',
    hints: [
      'Parameter properties create multiple public properties',
      'Access any property with dot notation',
    ],
    tags: ['class', 'parameter-properties', 'constructor'],
  },
  {
    id: 'ts-class-013',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Default Property Values',
    text: 'Use default values for class properties',
    setup: 'class Settings { theme: string = "dark"; fontSize: number = 14; }',
    setupCode: 'class Settings { theme: string = "dark"; fontSize: number = 14; }',
    expected: 14,
    sample: 'new Settings().fontSize',
    hints: ['Properties can have default values', 'No constructor needed for defaults'],
    tags: ['class', 'property', 'default-value'],
  },
  {
    id: 'ts-class-014',
    category: 'Classes',
    difficulty: 'easy',
    title: 'This Reference',
    text: 'Use this to reference instance properties in a method',
    setup:
      'class Multiplier { constructor(public factor: number) {} multiply(value: number): number { return value * this.factor; } }',
    setupCode:
      'class Multiplier { constructor(public factor: number) {} multiply(value: number): number { return value * this.factor; } }',
    expected: 25,
    sample: 'new Multiplier(5).multiply(5)',
    hints: ['this refers to the current instance', 'Access instance properties with this.property'],
    tags: ['class', 'this', 'method'],
  },
  {
    id: 'ts-class-015',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Class with Array Property',
    text: 'Access an array property from a class',
    setup: 'class TodoList { items: string[] = ["Buy milk", "Walk dog"]; }',
    setupCode: 'class TodoList { items: string[] = ["Buy milk", "Walk dog"]; }',
    expected: 2,
    sample: 'new TodoList().items.length',
    hints: ['Array properties work like regular arrays', 'Access length property of the array'],
    tags: ['class', 'array', 'property'],
  },
  {
    id: 'ts-class-016',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Readonly Constructor Parameter',
    text: 'Use readonly parameter property',
    setup:
      'class ImmutablePoint { constructor(public readonly x: number, public readonly y: number) {} }',
    setupCode:
      'class ImmutablePoint { constructor(public readonly x: number, public readonly y: number) {} }',
    expected: 10,
    sample: 'new ImmutablePoint(10, 20).x',
    hints: [
      'readonly with public creates immutable public properties',
      'Values cannot be changed after construction',
    ],
    tags: ['class', 'readonly', 'parameter-properties'],
  },
  {
    id: 'ts-class-017',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Method Chaining Setup',
    text: 'Return this from a method to enable chaining',
    setup:
      'class Builder { value: number = 0; add(n: number): this { this.value += n; return this; } }',
    setupCode:
      'class Builder { value: number = 0; add(n: number): this { this.value += n; return this; } }',
    expected: 15,
    sample: 'new Builder().add(5).add(10).value',
    hints: ['Returning this enables method chaining', 'Each call returns the same instance'],
    tags: ['class', 'method-chaining', 'this'],
  },
  {
    id: 'ts-class-018',
    category: 'Classes',
    difficulty: 'easy',
    title: 'String Method in Class',
    text: 'Implement a toString method for a class',
    setup:
      'class Point { constructor(public x: number, public y: number) {} toString(): string { return `(${this.x}, ${this.y})`; } }',
    setupCode:
      'class Point { constructor(public x: number, public y: number) {} toString(): string { return `(${this.x}, ${this.y})`; } }',
    expected: '(3, 4)',
    sample: 'new Point(3, 4).toString()',
    hints: ['toString provides string representation', 'Use template literals for formatting'],
    tags: ['class', 'toString', 'method'],
  },
  {
    id: 'ts-class-019',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Protected Visibility in Subclass',
    text: 'Access a protected property from within a subclass method',
    setup:
      'class Base { protected secret: string = "hidden"; }\nclass Derived extends Base { reveal(): string { return this.secret; } }',
    setupCode:
      'class Base { protected secret: string = "hidden"; }\nclass Derived extends Base { reveal(): string { return this.secret; } }',
    expected: 'hidden',
    sample: 'new Derived().reveal()',
    hints: [
      'Protected members are accessible in subclasses',
      'Use a public method to expose the value',
    ],
    tags: ['class', 'protected', 'inheritance'],
  },
  {
    id: 'ts-class-020',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Static Counter',
    text: 'Use a static property to count instances',
    setup: 'class Entity { static count: number = 0; constructor() { Entity.count++; } }',
    setupCode: 'class Entity { static count: number = 0; constructor() { Entity.count++; } }',
    expected: 3,
    sample: 'new Entity(); new Entity(); new Entity(); Entity.count',
    hints: [
      'Static properties are shared across all instances',
      'Increment in constructor to count instances',
    ],
    tags: ['class', 'static', 'counter'],
  },
  {
    id: 'ts-class-021',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Optional Property',
    text: 'Handle optional properties in a class',
    setup: 'class Profile { constructor(public name: string, public bio?: string) {} }',
    setupCode: 'class Profile { constructor(public name: string, public bio?: string) {} }',
    expected: undefined,
    sample: 'new Profile("Alice").bio',
    hints: ['Optional properties use ? in parameter', 'They default to undefined if not provided'],
    tags: ['class', 'optional', 'parameter-properties'],
  },
  {
    id: 'ts-class-022',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Default Parameter in Constructor',
    text: 'Use default parameter values in constructor',
    setup: 'class Greeting { constructor(public message: string = "Hello") {} }',
    setupCode: 'class Greeting { constructor(public message: string = "Hello") {} }',
    expected: 'Hello',
    sample: 'new Greeting().message',
    hints: [
      'Default values are used when argument is omitted',
      'Parameter properties can have defaults',
    ],
    tags: ['class', 'default-parameter', 'constructor'],
  },
  {
    id: 'ts-class-023',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Class Expression',
    text: 'Use a class expression to create a class',
    setup: 'const MyClass = class { value: number = 42; };',
    setupCode: 'const MyClass = class { value: number = 42; };',
    expected: 42,
    sample: 'new MyClass().value',
    hints: [
      'Classes can be defined as expressions',
      'Assign to a variable and use like a regular class',
    ],
    tags: ['class', 'class-expression', 'basics'],
  },
  {
    id: 'ts-class-024',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Getter Only Property',
    text: 'Create a read-only computed property using only a getter',
    setup:
      'class Circle { constructor(public radius: number) {} get diameter(): number { return this.radius * 2; } }',
    setupCode:
      'class Circle { constructor(public radius: number) {} get diameter(): number { return this.radius * 2; } }',
    expected: 20,
    sample: 'new Circle(10).diameter',
    hints: ['Getter without setter is read-only', 'Computed from other properties'],
    tags: ['class', 'getter', 'readonly'],
  },
  {
    id: 'ts-class-025',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Method with Multiple Parameters',
    text: 'Call a method with multiple typed parameters',
    setup:
      'class StringUtils { concat(a: string, b: string, separator: string): string { return a + separator + b; } }',
    setupCode:
      'class StringUtils { concat(a: string, b: string, separator: string): string { return a + separator + b; } }',
    expected: 'Hello-World',
    sample: 'new StringUtils().concat("Hello", "World", "-")',
    hints: ['Methods can have multiple parameters', 'Each parameter has its own type'],
    tags: ['class', 'method', 'parameters'],
  },
  {
    id: 'ts-class-026',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Boolean Property',
    text: 'Use boolean property for state',
    setup: 'class Toggle { isActive: boolean = false; activate(): void { this.isActive = true; } }',
    setupCode:
      'class Toggle { isActive: boolean = false; activate(): void { this.isActive = true; } }',
    expected: true,
    sample: 'const t = new Toggle(); t.activate(); t.isActive',
    hints: ['Boolean properties for state management', 'Methods can modify instance state'],
    tags: ['class', 'boolean', 'state'],
  },
  {
    id: 'ts-class-027',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Private Property with Getter',
    text: 'Expose a private property through a getter',
    setup:
      'class BankAccount { private _balance: number = 100; get balance(): number { return this._balance; } }',
    setupCode:
      'class BankAccount { private _balance: number = 100; get balance(): number { return this._balance; } }',
    expected: 100,
    sample: 'new BankAccount().balance',
    hints: [
      'Private properties are prefixed with underscore by convention',
      'Getters provide controlled access',
    ],
    tags: ['class', 'private', 'getter'],
  },
  {
    id: 'ts-class-028',
    category: 'Classes',
    difficulty: 'easy',
    title: 'Calling Super Constructor',
    text: 'Call parent constructor from subclass',
    setup:
      'class Animal { constructor(public name: string) {} }\nclass Cat extends Animal { constructor(name: string, public color: string) { super(name); } }',
    setupCode:
      'class Animal { constructor(public name: string) {} }\nclass Cat extends Animal { constructor(name: string, public color: string) { super(name); } }',
    expected: 'Whiskers',
    sample: 'new Cat("Whiskers", "orange").name',
    hints: ['super() calls the parent constructor', 'Must be called before accessing this'],
    tags: ['class', 'super', 'inheritance'],
  },
  {
    id: 'ts-class-029',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Setter with Validation',
    text: 'Use a setter to validate and set a value',
    setup:
      'class Temperature { private _celsius: number = 0; get celsius(): number { return this._celsius; } set celsius(value: number) { if (value >= -273.15) this._celsius = value; } }',
    setupCode:
      'class Temperature { private _celsius: number = 0; get celsius(): number { return this._celsius; } set celsius(value: number) { if (value >= -273.15) this._celsius = value; } }',
    expected: 25,
    sample: 'const t = new Temperature(); t.celsius = 25; t.celsius',
    hints: ['Setters can include validation logic', 'Invalid values are rejected silently here'],
    tags: ['class', 'setter', 'validation'],
  },
  {
    id: 'ts-class-030',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Method Overriding',
    text: 'Override a parent method in a subclass',
    setup:
      'class Shape { getType(): string { return "Shape"; } }\nclass Circle extends Shape { getType(): string { return "Circle"; } }',
    setupCode:
      'class Shape { getType(): string { return "Shape"; } }\nclass Circle extends Shape { getType(): string { return "Circle"; } }',
    expected: 'Circle',
    sample: 'new Circle().getType()',
    hints: [
      'Subclass methods override parent methods',
      'Same method signature replaces parent implementation',
    ],
    tags: ['class', 'override', 'inheritance'],
  },
  {
    id: 'ts-class-031',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Calling Super Method',
    text: 'Call parent method from overridden method',
    setup:
      'class Logger { log(msg: string): string { return `[LOG] ${msg}`; } }\nclass TimestampLogger extends Logger { log(msg: string): string { return `[${Date.now()}] ${super.log(msg)}`; } }',
    setupCode:
      'class Logger { log(msg: string): string { return `[LOG] ${msg}`; } }\nclass TimestampLogger extends Logger { log(msg: string): string { return `[${Date.now()}] ${super.log(msg)}`; } }',
    expected: true,
    sample: 'new TimestampLogger().log("test").includes("[LOG] test")',
    hints: ['super.method() calls the parent implementation', 'Useful for extending functionality'],
    tags: ['class', 'super', 'override'],
  },
  {
    id: 'ts-class-032',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Implement Interface',
    text: 'Create a class that implements an interface',
    setup:
      'interface Printable { print(): string; }\nclass Document implements Printable { constructor(public content: string) {} print(): string { return this.content; } }',
    setupCode:
      'interface Printable { print(): string; }\nclass Document implements Printable { constructor(public content: string) {} print(): string { return this.content; } }',
    expected: 'Hello Document',
    sample: 'new Document("Hello Document").print()',
    hints: [
      'implements keyword enforces interface contract',
      'Class must provide all interface members',
    ],
    tags: ['class', 'interface', 'implements'],
  },
  {
    id: 'ts-class-033',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Multiple Interface Implementation',
    text: 'Implement multiple interfaces in one class',
    setup:
      'interface Readable { read(): string; }\ninterface Writable { write(data: string): void; }\nclass File implements Readable, Writable { private data: string = ""; read(): string { return this.data; } write(data: string): void { this.data = data; } }',
    setupCode:
      'interface Readable { read(): string; }\ninterface Writable { write(data: string): void; }\nclass File implements Readable, Writable { private data: string = ""; read(): string { return this.data; } write(data: string): void { this.data = data; } }',
    expected: 'Hello',
    sample: 'const f = new File(); f.write("Hello"); f.read()',
    hints: [
      'Separate multiple interfaces with commas',
      'Must implement all methods from all interfaces',
    ],
    tags: ['class', 'interface', 'multiple-implements'],
  },
  {
    id: 'ts-class-034',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Abstract Class',
    text: 'Create a concrete class from an abstract class',
    setup:
      'abstract class Animal { abstract makeSound(): string; move(): string { return "Moving"; } }\nclass Dog extends Animal { makeSound(): string { return "Woof!"; } }',
    setupCode:
      'abstract class Animal { abstract makeSound(): string; move(): string { return "Moving"; } }\nclass Dog extends Animal { makeSound(): string { return "Woof!"; } }',
    expected: 'Woof!',
    sample: 'new Dog().makeSound()',
    hints: [
      'Abstract classes cannot be instantiated directly',
      'Concrete subclasses must implement abstract methods',
    ],
    tags: ['class', 'abstract', 'inheritance'],
  },
  {
    id: 'ts-class-035',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Abstract Method with Concrete Method',
    text: 'Use both abstract and concrete methods',
    setup:
      'abstract class Formatter { abstract format(data: string): string; wrap(data: string): string { return `[${this.format(data)}]`; } }\nclass UpperFormatter extends Formatter { format(data: string): string { return data.toUpperCase(); } }',
    setupCode:
      'abstract class Formatter { abstract format(data: string): string; wrap(data: string): string { return `[${this.format(data)}]`; } }\nclass UpperFormatter extends Formatter { format(data: string): string { return data.toUpperCase(); } }',
    expected: '[HELLO]',
    sample: 'new UpperFormatter().wrap("hello")',
    hints: [
      'Concrete methods can call abstract methods',
      'The subclass provides the abstract implementation',
    ],
    tags: ['class', 'abstract', 'template-method'],
  },
  {
    id: 'ts-class-036',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Private Constructor - Factory Pattern',
    text: 'Use private constructor with static factory method',
    setup:
      'class Singleton { private static instance: Singleton | null = null; private constructor(public value: number) {} static create(value: number): Singleton { if (!Singleton.instance) { Singleton.instance = new Singleton(value); } return Singleton.instance; } }',
    setupCode:
      'class Singleton { private static instance: Singleton | null = null; private constructor(public value: number) {} static create(value: number): Singleton { if (!Singleton.instance) { Singleton.instance = new Singleton(value); } return Singleton.instance; } }',
    expected: 42,
    sample: 'Singleton.create(42).value',
    hints: [
      'Private constructor prevents direct instantiation',
      'Static method controls instance creation',
    ],
    tags: ['class', 'private-constructor', 'singleton', 'factory'],
  },
  {
    id: 'ts-class-037',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Getter/Setter Pair',
    text: 'Use matched getter and setter for a property',
    setup:
      'class Person { private _age: number = 0; get age(): number { return this._age; } set age(value: number) { this._age = Math.max(0, value); } }',
    setupCode:
      'class Person { private _age: number = 0; get age(): number { return this._age; } set age(value: number) { this._age = Math.max(0, value); } }',
    expected: 0,
    sample: 'const p = new Person(); p.age = -5; p.age',
    hints: ['Setter validates and normalizes input', 'Negative age becomes 0'],
    tags: ['class', 'getter', 'setter', 'validation'],
  },
  {
    id: 'ts-class-038',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Static Factory Method',
    text: 'Create instances using a static factory method',
    setup:
      'class Point { private constructor(public x: number, public y: number) {} static origin(): Point { return new Point(0, 0); } static fromCoords(x: number, y: number): Point { return new Point(x, y); } }',
    setupCode:
      'class Point { private constructor(public x: number, public y: number) {} static origin(): Point { return new Point(0, 0); } static fromCoords(x: number, y: number): Point { return new Point(x, y); } }',
    expected: 0,
    sample: 'Point.origin().x',
    hints: [
      'Factory methods provide named constructors',
      'Static methods can call private constructor',
    ],
    tags: ['class', 'static', 'factory-method'],
  },
  {
    id: 'ts-class-039',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Protected Method',
    text: 'Use protected method in inheritance chain',
    setup:
      'class Base { protected helper(): number { return 10; } }\nclass Derived extends Base { compute(): number { return this.helper() * 2; } }',
    setupCode:
      'class Base { protected helper(): number { return 10; } }\nclass Derived extends Base { compute(): number { return this.helper() * 2; } }',
    expected: 20,
    sample: 'new Derived().compute()',
    hints: [
      'Protected methods are accessible in subclasses',
      'Not accessible from outside the class hierarchy',
    ],
    tags: ['class', 'protected', 'inheritance'],
  },
  {
    id: 'ts-class-040',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Generic Class',
    text: 'Create and use a generic class',
    setup: 'class Box<T> { constructor(public value: T) {} getValue(): T { return this.value; } }',
    setupCode:
      'class Box<T> { constructor(public value: T) {} getValue(): T { return this.value; } }',
    expected: 'Hello',
    sample: 'new Box<string>("Hello").getValue()',
    hints: ['Generic classes work with any type', 'Type parameter preserves type safety'],
    tags: ['class', 'generics', 'type-parameter'],
  },
  {
    id: 'ts-class-041',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Generic Class with Constraint',
    text: 'Use a constrained generic type in a class',
    setup:
      'interface HasLength { length: number; }\nclass Measurable<T extends HasLength> { constructor(public item: T) {} getLength(): number { return this.item.length; } }',
    setupCode:
      'interface HasLength { length: number; }\nclass Measurable<T extends HasLength> { constructor(public item: T) {} getLength(): number { return this.item.length; } }',
    expected: 5,
    sample: 'new Measurable("Hello").getLength()',
    hints: ['extends constraint limits acceptable types', 'Type must have required properties'],
    tags: ['class', 'generics', 'constraint'],
  },
  {
    id: 'ts-class-042',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Class with Index Signature',
    text: 'Use index signature for dynamic properties',
    setup:
      'class Dictionary { [key: string]: string | undefined; set(key: string, value: string): void { this[key] = value; } }',
    setupCode:
      'class Dictionary { [key: string]: string | undefined; set(key: string, value: string): void { this[key] = value; } }',
    expected: 'bar',
    sample: 'const d = new Dictionary(); d.set("foo", "bar"); d["foo"]',
    hints: ['Index signatures allow dynamic property access', 'Type includes undefined for safety'],
    tags: ['class', 'index-signature', 'dynamic'],
  },
  {
    id: 'ts-class-043',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Static Block Initialization',
    text: 'Use static block for complex initialization',
    setup:
      'class Config { static values: number[]; static { Config.values = [1, 2, 3].map(x => x * 10); } }',
    setupCode:
      'class Config { static values: number[]; static { Config.values = [1, 2, 3].map(x => x * 10); } }',
    expected: 30,
    sample: 'Config.values[2]',
    hints: [
      'Static blocks run once when class is loaded',
      'Useful for complex static initialization',
    ],
    tags: ['class', 'static', 'static-block'],
  },
  {
    id: 'ts-class-044',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Polymorphic this Type',
    text: 'Use this type for method chaining in inheritance',
    setup:
      'class Builder { protected value: number = 0; setValue(n: number): this { this.value = n; return this; } }\nclass AdvancedBuilder extends Builder { double(): this { this.value *= 2; return this; } getResult(): number { return this.value; } }',
    setupCode:
      'class Builder { protected value: number = 0; setValue(n: number): this { this.value = n; return this; } }\nclass AdvancedBuilder extends Builder { double(): this { this.value *= 2; return this; } getResult(): number { return this.value; } }',
    expected: 20,
    sample: 'new AdvancedBuilder().setValue(10).double().getResult()',
    hints: ['this return type preserves subclass type', 'Enables fluent chaining in inheritance'],
    tags: ['class', 'this-type', 'method-chaining'],
  },
  {
    id: 'ts-class-045',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Interface Extending Class',
    text: 'Create an interface that extends a class',
    setup:
      'class Point { x: number = 0; y: number = 0; }\ninterface Point3D extends Point { z: number; }\nconst p: Point3D = { x: 1, y: 2, z: 3 };',
    setupCode:
      'class Point { x: number = 0; y: number = 0; }\ninterface Point3D extends Point { z: number; }\nconst p: Point3D = { x: 1, y: 2, z: 3 };',
    expected: 3,
    sample: 'p.z',
    hints: ['Interfaces can extend classes', 'Inherits class structure without implementation'],
    tags: ['interface', 'class', 'extends'],
  },
  {
    id: 'ts-class-046',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Constructor Overloads',
    text: 'Use constructor overloads for different initialization patterns',
    setup:
      'class Point { x: number; y: number; constructor(x: number, y: number);\nconstructor(coords: {x: number, y: number});\nconstructor(xOrCoords: number | {x: number, y: number}, y?: number) { if (typeof xOrCoords === "number") { this.x = xOrCoords; this.y = y!; } else { this.x = xOrCoords.x; this.y = xOrCoords.y; } } }',
    setupCode:
      'class Point { x: number; y: number; constructor(x: number, y: number);\nconstructor(coords: {x: number, y: number});\nconstructor(xOrCoords: number | {x: number, y: number}, y?: number) { if (typeof xOrCoords === "number") { this.x = xOrCoords; this.y = y!; } else { this.x = xOrCoords.x; this.y = xOrCoords.y; } } }',
    expected: 5,
    sample: 'new Point({x: 5, y: 10}).x',
    hints: ['Overloads provide multiple signatures', 'Implementation handles all cases'],
    tags: ['class', 'constructor', 'overloads'],
  },
  {
    id: 'ts-class-047',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Method Overloads',
    text: 'Use method overloads for type-safe polymorphism',
    setup:
      'class Converter { convert(value: string): number;\nconvert(value: number): string;\nconvert(value: string | number): string | number { return typeof value === "string" ? parseInt(value) : value.toString(); } }',
    setupCode:
      'class Converter { convert(value: string): number;\nconvert(value: number): string;\nconvert(value: string | number): string | number { return typeof value === "string" ? parseInt(value) : value.toString(); } }',
    expected: 42,
    sample: 'new Converter().convert("42")',
    hints: [
      'Overloads define input/output type relationships',
      'Return type depends on input type',
    ],
    tags: ['class', 'method', 'overloads'],
  },
  {
    id: 'ts-class-048',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Composition over Inheritance',
    text: 'Use composition to combine behaviors',
    setup:
      'class Engine { start(): string { return "Engine started"; } }\nclass Wheels { roll(): string { return "Wheels rolling"; } }\nclass Car { private engine = new Engine(); private wheels = new Wheels(); drive(): string { return `${this.engine.start()}, ${this.wheels.roll()}`; } }',
    setupCode:
      'class Engine { start(): string { return "Engine started"; } }\nclass Wheels { roll(): string { return "Wheels rolling"; } }\nclass Car { private engine = new Engine(); private wheels = new Wheels(); drive(): string { return `${this.engine.start()}, ${this.wheels.roll()}`; } }',
    expected: 'Engine started, Wheels rolling',
    sample: 'new Car().drive()',
    hints: ['Composition includes instances of other classes', 'Delegate to composed objects'],
    tags: ['class', 'composition', 'design-pattern'],
  },
  {
    id: 'ts-class-049',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Dependency Injection',
    text: 'Inject dependencies through constructor',
    setup:
      'interface Logger { log(msg: string): string; }\nclass ConsoleLogger implements Logger { log(msg: string): string { return `Console: ${msg}`; } }\nclass Service { constructor(private logger: Logger) {} doWork(): string { return this.logger.log("Working"); } }',
    setupCode:
      'interface Logger { log(msg: string): string; }\nclass ConsoleLogger implements Logger { log(msg: string): string { return `Console: ${msg}`; } }\nclass Service { constructor(private logger: Logger) {} doWork(): string { return this.logger.log("Working"); } }',
    expected: 'Console: Working',
    sample: 'new Service(new ConsoleLogger()).doWork()',
    hints: ['Dependencies are passed to constructor', 'Allows swapping implementations'],
    tags: ['class', 'dependency-injection', 'interface'],
  },
  {
    id: 'ts-class-050',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Private Class Fields (ES2022)',
    text: 'Use true private fields with # syntax',
    setup:
      'class Secret { #password: string = "secret123"; checkPassword(input: string): boolean { return input === this.#password; } }',
    setupCode:
      'class Secret { #password: string = "secret123"; checkPassword(input: string): boolean { return input === this.#password; } }',
    expected: true,
    sample: 'new Secret().checkPassword("secret123")',
    hints: ['# prefix creates truly private fields', 'Not accessible outside the class at all'],
    tags: ['class', 'private-fields', 'es2022'],
  },
  {
    id: 'ts-class-051',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Static Private Field',
    text: 'Use private static field for class-level secrets',
    setup:
      'class APIClient { static #apiKey: string = "key123"; static getKeyLength(): number { return APIClient.#apiKey.length; } }',
    setupCode:
      'class APIClient { static #apiKey: string = "key123"; static getKeyLength(): number { return APIClient.#apiKey.length; } }',
    expected: 6,
    sample: 'APIClient.getKeyLength()',
    hints: [
      'Static # fields are private to the class',
      'Combine static and private for class secrets',
    ],
    tags: ['class', 'static', 'private-fields'],
  },
  {
    id: 'ts-class-052',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Abstract Property',
    text: 'Define abstract property in abstract class',
    setup:
      'abstract class Shape { abstract readonly name: string; describe(): string { return `This is a ${this.name}`; } }\nclass Square extends Shape { readonly name = "Square"; }',
    setupCode:
      'abstract class Shape { abstract readonly name: string; describe(): string { return `This is a ${this.name}`; } }\nclass Square extends Shape { readonly name = "Square"; }',
    expected: 'This is a Square',
    sample: 'new Square().describe()',
    hints: ['Abstract properties must be implemented', 'Concrete class provides the value'],
    tags: ['class', 'abstract', 'property'],
  },
  {
    id: 'ts-class-053',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Mixin Pattern',
    text: 'Apply mixin to extend class functionality',
    setup:
      'type Constructor<T = {}> = new (...args: any[]) => T;\nfunction Timestamped<TBase extends Constructor>(Base: TBase) { return class extends Base { timestamp = Date.now(); }; }\nclass User { constructor(public name: string) {} }\nconst TimestampedUser = Timestamped(User);',
    setupCode:
      'type Constructor<T = {}> = new (...args: any[]) => T;\nfunction Timestamped<TBase extends Constructor>(Base: TBase) { return class extends Base { timestamp = Date.now(); }; }\nclass User { constructor(public name: string) {} }\nconst TimestampedUser = Timestamped(User);',
    expected: true,
    sample: 'typeof new TimestampedUser("Alice").timestamp === "number"',
    hints: [
      'Mixins are functions that extend classes',
      'Return a new class with added functionality',
    ],
    tags: ['class', 'mixin', 'composition'],
  },
  {
    id: 'ts-class-054',
    category: 'OOP Patterns',
    difficulty: 'medium',
    title: 'Class Implementing Multiple Behaviors',
    text: 'Implement interface with methods and properties',
    setup:
      'interface Identifiable { id: string; }\ninterface Timestampable { createdAt: Date; }\nclass Entity implements Identifiable, Timestampable { id: string = "1"; createdAt: Date = new Date(); }',
    setupCode:
      'interface Identifiable { id: string; }\ninterface Timestampable { createdAt: Date; }\nclass Entity implements Identifiable, Timestampable { id: string = "1"; createdAt: Date = new Date(); }',
    expected: '1',
    sample: 'new Entity().id',
    hints: ['Multiple interfaces separate concerns', 'Class implements all required members'],
    tags: ['class', 'interface', 'composition'],
  },
  {
    id: 'ts-class-055',
    category: 'Inheritance',
    difficulty: 'medium',
    title: 'Deep Inheritance Chain',
    text: 'Access properties through inheritance chain',
    setup:
      'class A { a: number = 1; }\nclass B extends A { b: number = 2; }\nclass C extends B { c: number = 3; }',
    setupCode:
      'class A { a: number = 1; }\nclass B extends A { b: number = 2; }\nclass C extends B { c: number = 3; }',
    expected: 6,
    sample: 'const obj = new C(); obj.a + obj.b + obj.c',
    hints: ['Properties inherit through the chain', 'Access any ancestor property'],
    tags: ['class', 'inheritance', 'chain'],
  },
  {
    id: 'ts-class-056',
    category: 'Inheritance',
    difficulty: 'medium',
    title: 'Override with Different Return Type',
    text: 'Override method with covariant return type',
    setup:
      'class Animal { clone(): Animal { return new Animal(); } }\nclass Dog extends Animal { clone(): Dog { return new Dog(); } breed: string = "Labrador"; }',
    setupCode:
      'class Animal { clone(): Animal { return new Animal(); } }\nclass Dog extends Animal { clone(): Dog { return new Dog(); } breed: string = "Labrador"; }',
    expected: 'Labrador',
    sample: 'new Dog().clone().breed',
    hints: ['Subclass can return more specific type', 'Covariant return types are allowed'],
    tags: ['class', 'override', 'covariance'],
  },
  {
    id: 'ts-class-057',
    category: 'Inheritance',
    difficulty: 'medium',
    title: 'Constructor Property Promotion in Subclass',
    text: 'Combine parameter properties with super call',
    setup:
      'class Person { constructor(public name: string) {} }\nclass Employee extends Person { constructor(name: string, public department: string) { super(name); } }',
    setupCode:
      'class Person { constructor(public name: string) {} }\nclass Employee extends Person { constructor(name: string, public department: string) { super(name); } }',
    expected: 'Engineering',
    sample: 'new Employee("Alice", "Engineering").department',
    hints: [
      'Super must be called with parent params',
      'Subclass adds its own parameter properties',
    ],
    tags: ['class', 'inheritance', 'parameter-properties'],
  },
  {
    id: 'ts-class-058',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Decorator Class Method',
    text: 'Create a method decorator that logs calls',
    setup:
      'function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) { const original = descriptor.value; descriptor.value = function(...args: any[]) { console.log(`Calling ${propertyKey}`); return original.apply(this, args); }; return descriptor; }\nclass Calculator { @log add(a: number, b: number): number { return a + b; } }',
    setupCode:
      'function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) { const original = descriptor.value; descriptor.value = function(...args: any[]) { console.log(`Calling ${propertyKey}`); return original.apply(this, args); }; return descriptor; }\nclass Calculator { @log add(a: number, b: number): number { return a + b; } }',
    expected: 7,
    sample: 'new Calculator().add(3, 4)',
    hints: ['Decorators wrap method behavior', 'Original method is preserved and called'],
    tags: ['class', 'decorator', 'method'],
  },
  {
    id: 'ts-class-059',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Class Decorator',
    text: 'Create a class decorator that seals the class',
    setup:
      'function sealed(constructor: Function) { Object.seal(constructor); Object.seal(constructor.prototype); }\n@sealed\nclass Greeter { greeting: string = "Hello"; greet(): string { return this.greeting; } }',
    setupCode:
      'function sealed(constructor: Function) { Object.seal(constructor); Object.seal(constructor.prototype); }\n@sealed\nclass Greeter { greeting: string = "Hello"; greet(): string { return this.greeting; } }',
    expected: true,
    sample: 'Object.isSealed(Greeter)',
    hints: ['Class decorators receive the constructor', 'Can modify class behavior'],
    tags: ['class', 'decorator', 'sealed'],
  },
  {
    id: 'ts-class-060',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Property Decorator',
    text: 'Create a property decorator for validation',
    setup:
      'function positive(target: any, propertyKey: string) { let value: number; Object.defineProperty(target, propertyKey, { get: () => value, set: (newValue: number) => { value = Math.max(0, newValue); }, enumerable: true, configurable: true }); }\nclass Product { @positive price: number = 0; }',
    setupCode:
      'function positive(target: any, propertyKey: string) { let value: number; Object.defineProperty(target, propertyKey, { get: () => value, set: (newValue: number) => { value = Math.max(0, newValue); }, enumerable: true, configurable: true }); }\nclass Product { @positive price: number = 0; }',
    expected: 0,
    sample: 'const p = new Product(); p.price = -10; p.price',
    hints: [
      'Property decorators can add getters/setters',
      'Intercept property access and modification',
    ],
    tags: ['class', 'decorator', 'property'],
  },
  {
    id: 'ts-class-061',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Decorator Factory',
    text: 'Create a parameterized decorator factory',
    setup:
      'function range(min: number, max: number) { return function(target: any, propertyKey: string) { let value: number; Object.defineProperty(target, propertyKey, { get: () => value, set: (newValue: number) => { value = Math.min(max, Math.max(min, newValue)); }, enumerable: true, configurable: true }); }; }\nclass Slider { @range(0, 100) position: number = 50; }',
    setupCode:
      'function range(min: number, max: number) { return function(target: any, propertyKey: string) { let value: number; Object.defineProperty(target, propertyKey, { get: () => value, set: (newValue: number) => { value = Math.min(max, Math.max(min, newValue)); }, enumerable: true, configurable: true }); }; }\nclass Slider { @range(0, 100) position: number = 50; }',
    expected: 100,
    sample: 'const s = new Slider(); s.position = 150; s.position',
    hints: ['Factory returns the actual decorator', 'Outer function receives parameters'],
    tags: ['class', 'decorator', 'factory'],
  },
  {
    id: 'ts-class-062',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Multiple Mixins',
    text: 'Apply multiple mixins to a class',
    setup:
      'type Constructor<T = {}> = new (...args: any[]) => T;\nfunction Tagged<TBase extends Constructor>(Base: TBase) { return class extends Base { tag: string = "tagged"; }; }\nfunction Versioned<TBase extends Constructor>(Base: TBase) { return class extends Base { version: number = 1; }; }\nclass Entity { id: number = 1; }\nconst TaggedVersionedEntity = Tagged(Versioned(Entity));',
    setupCode:
      'type Constructor<T = {}> = new (...args: any[]) => T;\nfunction Tagged<TBase extends Constructor>(Base: TBase) { return class extends Base { tag: string = "tagged"; }; }\nfunction Versioned<TBase extends Constructor>(Base: TBase) { return class extends Base { version: number = 1; }; }\nclass Entity { id: number = 1; }\nconst TaggedVersionedEntity = Tagged(Versioned(Entity));',
    expected: 'tagged',
    sample: 'new TaggedVersionedEntity().tag',
    hints: ['Mixins can be composed together', 'Each adds its own properties'],
    tags: ['class', 'mixin', 'composition'],
  },
  {
    id: 'ts-class-063',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Abstract Generic Class',
    text: 'Create abstract class with generic type parameter',
    setup:
      'abstract class Repository<T> { protected items: T[] = []; add(item: T): void { this.items.push(item); } abstract findById(id: number): T | undefined; }\nclass UserRepo extends Repository<{id: number, name: string}> { findById(id: number) { return this.items.find(u => u.id === id); } }',
    setupCode:
      'abstract class Repository<T> { protected items: T[] = []; add(item: T): void { this.items.push(item); } abstract findById(id: number): T | undefined; }\nclass UserRepo extends Repository<{id: number, name: string}> { findById(id: number) { return this.items.find(u => u.id === id); } }',
    expected: 'Alice',
    sample: 'const repo = new UserRepo(); repo.add({id: 1, name: "Alice"}); repo.findById(1)?.name',
    hints: ['Abstract classes can have generics', 'Subclass specifies concrete type'],
    tags: ['class', 'abstract', 'generics'],
  },
  {
    id: 'ts-class-064',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Constrained Mixin',
    text: 'Create mixin that requires specific base class structure',
    setup:
      'interface Nameable { name: string; }\ntype Constructor<T = {}> = new (...args: any[]) => T;\nfunction Greetable<TBase extends Constructor<Nameable>>(Base: TBase) { return class extends Base { greet(): string { return `Hello, ${this.name}!`; } }; }\nclass Person { constructor(public name: string) {} }\nconst GreetablePerson = Greetable(Person);',
    setupCode:
      'interface Nameable { name: string; }\ntype Constructor<T = {}> = new (...args: any[]) => T;\nfunction Greetable<TBase extends Constructor<Nameable>>(Base: TBase) { return class extends Base { greet(): string { return `Hello, ${this.name}!`; } }; }\nclass Person { constructor(public name: string) {} }\nconst GreetablePerson = Greetable(Person);',
    expected: 'Hello, Alice!',
    sample: 'new GreetablePerson("Alice").greet()',
    hints: [
      'Mixin constraint requires interface implementation',
      'Can access constrained properties',
    ],
    tags: ['class', 'mixin', 'constraint'],
  },
  {
    id: 'ts-class-065',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Proxy Pattern with Class',
    text: 'Implement proxy pattern for lazy loading',
    setup:
      'interface Image { display(): string; }\nclass RealImage implements Image { constructor(private filename: string) {} display(): string { return `Displaying ${this.filename}`; } }\nclass ProxyImage implements Image { private realImage: RealImage | null = null; constructor(private filename: string) {} display(): string { if (!this.realImage) { this.realImage = new RealImage(this.filename); } return this.realImage.display(); } }',
    setupCode:
      'interface Image { display(): string; }\nclass RealImage implements Image { constructor(private filename: string) {} display(): string { return `Displaying ${this.filename}`; } }\nclass ProxyImage implements Image { private realImage: RealImage | null = null; constructor(private filename: string) {} display(): string { if (!this.realImage) { this.realImage = new RealImage(this.filename); } return this.realImage.display(); } }',
    expected: 'Displaying photo.jpg',
    sample: 'new ProxyImage("photo.jpg").display()',
    hints: ['Proxy creates real object on demand', 'Same interface as real object'],
    tags: ['class', 'proxy', 'design-pattern'],
  },
  {
    id: 'ts-class-066',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Observer Pattern',
    text: 'Implement observer pattern with typed events',
    setup:
      'type Observer<T> = (data: T) => void;\nclass Subject<T> { private observers: Observer<T>[] = []; subscribe(observer: Observer<T>): void { this.observers.push(observer); } notify(data: T): void { this.observers.forEach(o => o(data)); } }\nconst subject = new Subject<string>();\nlet result = "";\nsubject.subscribe(data => { result = data; });',
    setupCode:
      'type Observer<T> = (data: T) => void;\nclass Subject<T> { private observers: Observer<T>[] = []; subscribe(observer: Observer<T>): void { this.observers.push(observer); } notify(data: T): void { this.observers.forEach(o => o(data)); } }\nconst subject = new Subject<string>();\nlet result = "";\nsubject.subscribe(data => { result = data; });',
    expected: 'Hello',
    sample: 'subject.notify("Hello"); result',
    hints: ['Observers are notified of changes', 'Generic type for event data'],
    tags: ['class', 'observer', 'design-pattern'],
  },
  {
    id: 'ts-class-067',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Strategy Pattern',
    text: 'Implement strategy pattern for interchangeable algorithms',
    setup:
      'interface SortStrategy<T> { sort(data: T[]): T[]; }\nclass BubbleSort<T> implements SortStrategy<T> { sort(data: T[]): T[] { return [...data].sort(); } }\nclass Sorter<T> { constructor(private strategy: SortStrategy<T>) {} setStrategy(strategy: SortStrategy<T>): void { this.strategy = strategy; } sort(data: T[]): T[] { return this.strategy.sort(data); } }',
    setupCode:
      'interface SortStrategy<T> { sort(data: T[]): T[]; }\nclass BubbleSort<T> implements SortStrategy<T> { sort(data: T[]): T[] { return [...data].sort(); } }\nclass Sorter<T> { constructor(private strategy: SortStrategy<T>) {} setStrategy(strategy: SortStrategy<T>): void { this.strategy = strategy; } sort(data: T[]): T[] { return this.strategy.sort(data); } }',
    expected: '1,2,3',
    sample: 'new Sorter(new BubbleSort<number>()).sort([3, 1, 2]).join(",")',
    hints: ['Strategy encapsulates algorithm', 'Can swap strategies at runtime'],
    tags: ['class', 'strategy', 'design-pattern'],
  },
  {
    id: 'ts-class-068',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Command Pattern',
    text: 'Implement command pattern with undo support',
    setup:
      'interface Command { execute(): void; undo(): void; }\nclass Calculator { value: number = 0; }\nclass AddCommand implements Command { constructor(private calc: Calculator, private amount: number) {} execute(): void { this.calc.value += this.amount; } undo(): void { this.calc.value -= this.amount; } }',
    setupCode:
      'interface Command { execute(): void; undo(): void; }\nclass Calculator { value: number = 0; }\nclass AddCommand implements Command { constructor(private calc: Calculator, private amount: number) {} execute(): void { this.calc.value += this.amount; } undo(): void { this.calc.value -= this.amount; } }',
    expected: 5,
    sample:
      'const calc = new Calculator(); const cmd = new AddCommand(calc, 10); cmd.execute(); cmd.undo(); cmd.execute(); calc.value -= 5; calc.value',
    hints: ['Commands encapsulate operations', 'Undo reverses the operation'],
    tags: ['class', 'command', 'design-pattern'],
  },
  {
    id: 'ts-class-069',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'State Pattern',
    text: 'Implement state pattern for state machine',
    setup:
      'interface State { handle(context: Context): void; getName(): string; }\nclass Context { constructor(public state: State) {} request(): void { this.state.handle(this); } }\nclass StateA implements State { handle(context: Context): void { context.state = new StateB(); } getName(): string { return "A"; } }\nclass StateB implements State { handle(context: Context): void { context.state = new StateA(); } getName(): string { return "B"; } }',
    setupCode:
      'interface State { handle(context: Context): void; getName(): string; }\nclass Context { constructor(public state: State) {} request(): void { this.state.handle(this); } }\nclass StateA implements State { handle(context: Context): void { context.state = new StateB(); } getName(): string { return "A"; } }\nclass StateB implements State { handle(context: Context): void { context.state = new StateA(); } getName(): string { return "B"; } }',
    expected: 'B',
    sample: 'const ctx = new Context(new StateA()); ctx.request(); ctx.state.getName()',
    hints: ['State objects control transitions', 'Context delegates to current state'],
    tags: ['class', 'state', 'design-pattern'],
  },
  {
    id: 'ts-class-070',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Builder Pattern with Fluent Interface',
    text: 'Implement builder pattern with method chaining',
    setup:
      'class QueryBuilder { private parts: string[] = []; select(columns: string): this { this.parts.push(`SELECT ${columns}`); return this; } from(table: string): this { this.parts.push(`FROM ${table}`); return this; } where(condition: string): this { this.parts.push(`WHERE ${condition}`); return this; } build(): string { return this.parts.join(" "); } }',
    setupCode:
      'class QueryBuilder { private parts: string[] = []; select(columns: string): this { this.parts.push(`SELECT ${columns}`); return this; } from(table: string): this { this.parts.push(`FROM ${table}`); return this; } where(condition: string): this { this.parts.push(`WHERE ${condition}`); return this; } build(): string { return this.parts.join(" "); } }',
    expected: 'SELECT * FROM users WHERE id = 1',
    sample: 'new QueryBuilder().select("*").from("users").where("id = 1").build()',
    hints: ['Each method returns this for chaining', 'build() produces final result'],
    tags: ['class', 'builder', 'fluent-interface'],
  },
  {
    id: 'ts-class-071',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Abstract Factory Pattern',
    text: 'Implement abstract factory for creating related objects',
    setup:
      'interface Button { render(): string; }\ninterface Checkbox { check(): string; }\nabstract class UIFactory { abstract createButton(): Button; abstract createCheckbox(): Checkbox; }\nclass DarkButton implements Button { render(): string { return "Dark Button"; } }\nclass DarkCheckbox implements Checkbox { check(): string { return "Dark Checkbox"; } }\nclass DarkUIFactory extends UIFactory { createButton(): Button { return new DarkButton(); } createCheckbox(): Checkbox { return new DarkCheckbox(); } }',
    setupCode:
      'interface Button { render(): string; }\ninterface Checkbox { check(): string; }\nabstract class UIFactory { abstract createButton(): Button; abstract createCheckbox(): Checkbox; }\nclass DarkButton implements Button { render(): string { return "Dark Button"; } }\nclass DarkCheckbox implements Checkbox { check(): string { return "Dark Checkbox"; } }\nclass DarkUIFactory extends UIFactory { createButton(): Button { return new DarkButton(); } createCheckbox(): Checkbox { return new DarkCheckbox(); } }',
    expected: 'Dark Button',
    sample: 'new DarkUIFactory().createButton().render()',
    hints: ['Factory creates families of objects', 'Concrete factories produce concrete products'],
    tags: ['class', 'abstract-factory', 'design-pattern'],
  },
  {
    id: 'ts-class-072',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Template Method Pattern',
    text: 'Implement template method with hook',
    setup:
      'abstract class DataProcessor { process(data: string): string { const cleaned = this.clean(data); const transformed = this.transform(cleaned); return this.format(transformed); } protected clean(data: string): string { return data.trim(); } protected abstract transform(data: string): string; protected format(data: string): string { return `[${data}]`; } }\nclass UpperProcessor extends DataProcessor { protected transform(data: string): string { return data.toUpperCase(); } }',
    setupCode:
      'abstract class DataProcessor { process(data: string): string { const cleaned = this.clean(data); const transformed = this.transform(cleaned); return this.format(transformed); } protected clean(data: string): string { return data.trim(); } protected abstract transform(data: string): string; protected format(data: string): string { return `[${data}]`; } }\nclass UpperProcessor extends DataProcessor { protected transform(data: string): string { return data.toUpperCase(); } }',
    expected: '[HELLO]',
    sample: 'new UpperProcessor().process("  hello  ")',
    hints: ['Template method defines algorithm skeleton', 'Subclasses implement abstract steps'],
    tags: ['class', 'template-method', 'design-pattern'],
  },
  {
    id: 'ts-class-073',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Adapter Pattern',
    text: 'Implement adapter to convert interfaces',
    setup:
      'interface NewLogger { log(level: string, message: string): string; }\nclass OldLogger { writeLog(message: string): string { return `LOG: ${message}`; } }\nclass LoggerAdapter implements NewLogger { constructor(private oldLogger: OldLogger) {} log(level: string, message: string): string { return this.oldLogger.writeLog(`[${level}] ${message}`); } }',
    setupCode:
      'interface NewLogger { log(level: string, message: string): string; }\nclass OldLogger { writeLog(message: string): string { return `LOG: ${message}`; } }\nclass LoggerAdapter implements NewLogger { constructor(private oldLogger: OldLogger) {} log(level: string, message: string): string { return this.oldLogger.writeLog(`[${level}] ${message}`); } }',
    expected: 'LOG: [INFO] Hello',
    sample: 'new LoggerAdapter(new OldLogger()).log("INFO", "Hello")',
    hints: ['Adapter wraps incompatible interface', 'Translates calls to adaptee'],
    tags: ['class', 'adapter', 'design-pattern'],
  },
  {
    id: 'ts-class-074',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Decorator Pattern (OOP)',
    text: 'Implement decorator pattern for extending behavior',
    setup:
      'interface Coffee { cost(): number; description(): string; }\nclass SimpleCoffee implements Coffee { cost(): number { return 5; } description(): string { return "Coffee"; } }\nclass MilkDecorator implements Coffee { constructor(private coffee: Coffee) {} cost(): number { return this.coffee.cost() + 2; } description(): string { return this.coffee.description() + " + Milk"; } }',
    setupCode:
      'interface Coffee { cost(): number; description(): string; }\nclass SimpleCoffee implements Coffee { cost(): number { return 5; } description(): string { return "Coffee"; } }\nclass MilkDecorator implements Coffee { constructor(private coffee: Coffee) {} cost(): number { return this.coffee.cost() + 2; } description(): string { return this.coffee.description() + " + Milk"; } }',
    expected: 7,
    sample: 'new MilkDecorator(new SimpleCoffee()).cost()',
    hints: ['Decorator wraps and extends object', 'Same interface as wrapped object'],
    tags: ['class', 'decorator-pattern', 'design-pattern'],
  },
  {
    id: 'ts-class-075',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Composite Pattern',
    text: 'Implement composite pattern for tree structures',
    setup:
      'interface Component { getSize(): number; }\nclass File implements Component { constructor(private size: number) {} getSize(): number { return this.size; } }\nclass Folder implements Component { private children: Component[] = []; add(component: Component): void { this.children.push(component); } getSize(): number { return this.children.reduce((sum, c) => sum + c.getSize(), 0); } }',
    setupCode:
      'interface Component { getSize(): number; }\nclass File implements Component { constructor(private size: number) {} getSize(): number { return this.size; } }\nclass Folder implements Component { private children: Component[] = []; add(component: Component): void { this.children.push(component); } getSize(): number { return this.children.reduce((sum, c) => sum + c.getSize(), 0); } }',
    expected: 30,
    sample:
      'const folder = new Folder(); folder.add(new File(10)); folder.add(new File(20)); folder.getSize()',
    hints: ['Composite contains components', 'Uniform interface for leaf and composite'],
    tags: ['class', 'composite', 'design-pattern'],
  },
  {
    id: 'ts-class-076',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Facade Pattern',
    text: 'Implement facade to simplify complex subsystem',
    setup:
      'class CPU { freeze(): string { return "CPU frozen"; } execute(): string { return "CPU executing"; } }\nclass Memory { load(): string { return "Memory loaded"; } }\nclass HardDrive { read(): string { return "HD reading"; } }\nclass ComputerFacade { private cpu = new CPU(); private memory = new Memory(); private hd = new HardDrive(); start(): string { return [this.cpu.freeze(), this.memory.load(), this.hd.read(), this.cpu.execute()].join(", "); } }',
    setupCode:
      'class CPU { freeze(): string { return "CPU frozen"; } execute(): string { return "CPU executing"; } }\nclass Memory { load(): string { return "Memory loaded"; } }\nclass HardDrive { read(): string { return "HD reading"; } }\nclass ComputerFacade { private cpu = new CPU(); private memory = new Memory(); private hd = new HardDrive(); start(): string { return [this.cpu.freeze(), this.memory.load(), this.hd.read(), this.cpu.execute()].join(", "); } }',
    expected: 'CPU frozen, Memory loaded, HD reading, CPU executing',
    sample: 'new ComputerFacade().start()',
    hints: ['Facade provides simple interface', 'Hides subsystem complexity'],
    tags: ['class', 'facade', 'design-pattern'],
  },
  {
    id: 'ts-class-077',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Flyweight Pattern',
    text: 'Implement flyweight pattern for memory optimization',
    setup:
      'class TreeType { constructor(public name: string, public color: string) {} }\nclass TreeFactory { private static types: Map<string, TreeType> = new Map(); static getTreeType(name: string, color: string): TreeType { const key = `${name}_${color}`; if (!TreeFactory.types.has(key)) { TreeFactory.types.set(key, new TreeType(name, color)); } return TreeFactory.types.get(key)!; } static getTypeCount(): number { return TreeFactory.types.size; } }',
    setupCode:
      'class TreeType { constructor(public name: string, public color: string) {} }\nclass TreeFactory { private static types: Map<string, TreeType> = new Map(); static getTreeType(name: string, color: string): TreeType { const key = `${name}_${color}`; if (!TreeFactory.types.has(key)) { TreeFactory.types.set(key, new TreeType(name, color)); } return TreeFactory.types.get(key)!; } static getTypeCount(): number { return TreeFactory.types.size; } }',
    expected: 2,
    sample:
      'TreeFactory.getTreeType("Oak", "Green"); TreeFactory.getTreeType("Oak", "Green"); TreeFactory.getTreeType("Pine", "Green"); TreeFactory.getTypeCount()',
    hints: ['Flyweight shares common state', 'Factory ensures single instance per type'],
    tags: ['class', 'flyweight', 'design-pattern'],
  },
  {
    id: 'ts-class-078',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Chain of Responsibility',
    text: 'Implement chain of responsibility pattern',
    setup:
      'abstract class Handler { protected next: Handler | null = null; setNext(handler: Handler): Handler { this.next = handler; return handler; } handle(request: number): string { if (this.next) { return this.next.handle(request); } return "End of chain"; } }\nclass LowHandler extends Handler { handle(request: number): string { if (request < 10) { return "Low handled"; } return super.handle(request); } }\nclass HighHandler extends Handler { handle(request: number): string { if (request >= 10) { return "High handled"; } return super.handle(request); } }',
    setupCode:
      'abstract class Handler { protected next: Handler | null = null; setNext(handler: Handler): Handler { this.next = handler; return handler; } handle(request: number): string { if (this.next) { return this.next.handle(request); } return "End of chain"; } }\nclass LowHandler extends Handler { handle(request: number): string { if (request < 10) { return "Low handled"; } return super.handle(request); } }\nclass HighHandler extends Handler { handle(request: number): string { if (request >= 10) { return "High handled"; } return super.handle(request); } }',
    expected: 'High handled',
    sample: 'const low = new LowHandler(); low.setNext(new HighHandler()); low.handle(15)',
    hints: ['Handlers form a chain', 'Each handler decides to process or pass'],
    tags: ['class', 'chain-of-responsibility', 'design-pattern'],
  },
  {
    id: 'ts-class-079',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Memento Pattern',
    text: 'Implement memento pattern for state snapshot',
    setup:
      'class Memento { constructor(public state: string) {} }\nclass Originator { state: string = ""; createMemento(): Memento { return new Memento(this.state); } restore(memento: Memento): void { this.state = memento.state; } }\nclass Caretaker { private mementos: Memento[] = []; constructor(private originator: Originator) {} backup(): void { this.mementos.push(this.originator.createMemento()); } undo(): void { const memento = this.mementos.pop(); if (memento) { this.originator.restore(memento); } } }',
    setupCode:
      'class Memento { constructor(public state: string) {} }\nclass Originator { state: string = ""; createMemento(): Memento { return new Memento(this.state); } restore(memento: Memento): void { this.state = memento.state; } }\nclass Caretaker { private mementos: Memento[] = []; constructor(private originator: Originator) {} backup(): void { this.mementos.push(this.originator.createMemento()); } undo(): void { const memento = this.mementos.pop(); if (memento) { this.originator.restore(memento); } } }',
    expected: 'State1',
    sample:
      'const orig = new Originator(); const care = new Caretaker(orig); orig.state = "State1"; care.backup(); orig.state = "State2"; care.undo(); orig.state',
    hints: ['Memento captures state snapshot', 'Caretaker manages history'],
    tags: ['class', 'memento', 'design-pattern'],
  },
  {
    id: 'ts-class-080',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Visitor Pattern',
    text: 'Implement visitor pattern for operation dispatch',
    setup:
      'interface Visitor { visitCircle(circle: Circle): number; visitSquare(square: Square): number; }\ninterface Shape { accept(visitor: Visitor): number; }\nclass Circle implements Shape { constructor(public radius: number) {} accept(visitor: Visitor): number { return visitor.visitCircle(this); } }\nclass Square implements Shape { constructor(public side: number) {} accept(visitor: Visitor): number { return visitor.visitSquare(this); } }\nclass AreaVisitor implements Visitor { visitCircle(circle: Circle): number { return Math.PI * circle.radius ** 2; } visitSquare(square: Square): number { return square.side ** 2; } }',
    setupCode:
      'interface Visitor { visitCircle(circle: Circle): number; visitSquare(square: Square): number; }\ninterface Shape { accept(visitor: Visitor): number; }\nclass Circle implements Shape { constructor(public radius: number) {} accept(visitor: Visitor): number { return visitor.visitCircle(this); } }\nclass Square implements Shape { constructor(public side: number) {} accept(visitor: Visitor): number { return visitor.visitSquare(this); } }\nclass AreaVisitor implements Visitor { visitCircle(circle: Circle): number { return Math.PI * circle.radius ** 2; } visitSquare(square: Square): number { return square.side ** 2; } }',
    expected: 25,
    sample: 'new Square(5).accept(new AreaVisitor())',
    hints: ['Visitor separates algorithm from structure', 'Double dispatch via accept method'],
    tags: ['class', 'visitor', 'design-pattern'],
  },
  {
    id: 'ts-class-081',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Mediator Pattern',
    text: 'Implement mediator pattern for component communication',
    setup:
      'interface Mediator { notify(sender: Component, event: string): void; }\nclass Component { constructor(protected mediator: Mediator) {} }\nclass Button extends Component { click(): void { this.mediator.notify(this, "click"); } }\nclass TextBox extends Component { value: string = ""; setValue(val: string): void { this.value = val; } }\nclass DialogMediator implements Mediator { constructor(public button: Button, public textBox: TextBox) {} notify(sender: Component, event: string): void { if (sender === this.button && event === "click") { this.textBox.setValue("Clicked!"); } } }',
    setupCode:
      'interface Mediator { notify(sender: Component, event: string): void; }\nclass Component { constructor(protected mediator: Mediator) {} }\nclass Button extends Component { click(): void { this.mediator.notify(this, "click"); } }\nclass TextBox extends Component { value: string = ""; setValue(val: string): void { this.value = val; } }\nclass DialogMediator implements Mediator { constructor(public button: Button, public textBox: TextBox) {} notify(sender: Component, event: string): void { if (sender === this.button && event === "click") { this.textBox.setValue("Clicked!"); } } }',
    expected: 'Clicked!',
    sample:
      'const mediator = {} as DialogMediator; const btn = new Button(mediator); const txt = new TextBox(mediator); const dialog = new DialogMediator(btn, txt); (btn as any).mediator = dialog; btn.click(); txt.value',
    hints: ['Mediator coordinates components', 'Components communicate through mediator'],
    tags: ['class', 'mediator', 'design-pattern'],
  },
  {
    id: 'ts-class-082',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Iterator Pattern',
    text: 'Implement custom iterator for collection',
    setup:
      'class NumberCollection { private items: number[] = []; add(item: number): void { this.items.push(item); } [Symbol.iterator](): Iterator<number> { let index = 0; const items = this.items; return { next(): IteratorResult<number> { if (index < items.length) { return { value: items[index++], done: false }; } return { value: undefined, done: true }; } }; } }',
    setupCode:
      'class NumberCollection { private items: number[] = []; add(item: number): void { this.items.push(item); } [Symbol.iterator](): Iterator<number> { let index = 0; const items = this.items; return { next(): IteratorResult<number> { if (index < items.length) { return { value: items[index++], done: false }; } return { value: undefined, done: true }; } }; } }',
    expected: 6,
    sample:
      'const col = new NumberCollection(); col.add(1); col.add(2); col.add(3); let sum = 0; for (const n of col) { sum += n; } sum',
    hints: ['Symbol.iterator enables for...of', 'next() returns value and done status'],
    tags: ['class', 'iterator', 'symbol'],
  },
  {
    id: 'ts-class-083',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Prototype Pattern',
    text: 'Implement prototype pattern for cloning',
    setup:
      'interface Prototype { clone(): Prototype; }\nclass ConcretePrototype implements Prototype { constructor(public primitive: number, public component: { value: string }) {} clone(): ConcretePrototype { return new ConcretePrototype(this.primitive, { ...this.component }); } }',
    setupCode:
      'interface Prototype { clone(): Prototype; }\nclass ConcretePrototype implements Prototype { constructor(public primitive: number, public component: { value: string }) {} clone(): ConcretePrototype { return new ConcretePrototype(this.primitive, { ...this.component }); } }',
    expected: 'test',
    sample:
      'const original = new ConcretePrototype(42, { value: "test" }); const cloned = original.clone(); cloned.component.value',
    hints: ['Clone creates a copy of the object', 'Deep copy nested objects'],
    tags: ['class', 'prototype', 'design-pattern'],
  },
  {
    id: 'ts-class-084',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Bridge Pattern',
    text: 'Implement bridge pattern to separate abstraction from implementation',
    setup:
      'interface Renderer { renderCircle(radius: number): string; }\nclass VectorRenderer implements Renderer { renderCircle(radius: number): string { return `Vector circle r=${radius}`; } }\nclass RasterRenderer implements Renderer { renderCircle(radius: number): string { return `Raster circle r=${radius}`; } }\nclass Circle { constructor(private renderer: Renderer, public radius: number) {} draw(): string { return this.renderer.renderCircle(this.radius); } }',
    setupCode:
      'interface Renderer { renderCircle(radius: number): string; }\nclass VectorRenderer implements Renderer { renderCircle(radius: number): string { return `Vector circle r=${radius}`; } }\nclass RasterRenderer implements Renderer { renderCircle(radius: number): string { return `Raster circle r=${radius}`; } }\nclass Circle { constructor(private renderer: Renderer, public radius: number) {} draw(): string { return this.renderer.renderCircle(this.radius); } }',
    expected: 'Vector circle r=5',
    sample: 'new Circle(new VectorRenderer(), 5).draw()',
    hints: ['Bridge separates interface from implementation', 'Can vary both independently'],
    tags: ['class', 'bridge', 'design-pattern'],
  },
  {
    id: 'ts-class-085',
    category: 'OOP Patterns',
    difficulty: 'hard',
    title: 'Null Object Pattern',
    text: 'Implement null object pattern for safe defaults',
    setup:
      'interface Logger { log(message: string): string; }\nclass ConsoleLogger implements Logger { log(message: string): string { return `Logged: ${message}`; } }\nclass NullLogger implements Logger { log(message: string): string { return ""; } }\nclass Application { constructor(private logger: Logger = new NullLogger()) {} doWork(): string { const result = this.logger.log("Working"); return result || "Silent"; } }',
    setupCode:
      'interface Logger { log(message: string): string; }\nclass ConsoleLogger implements Logger { log(message: string): string { return `Logged: ${message}`; } }\nclass NullLogger implements Logger { log(message: string): string { return ""; } }\nclass Application { constructor(private logger: Logger = new NullLogger()) {} doWork(): string { const result = this.logger.log("Working"); return result || "Silent"; } }',
    expected: 'Silent',
    sample: 'new Application().doWork()',
    hints: ['Null object provides default behavior', 'Avoids null checks throughout code'],
    tags: ['class', 'null-object', 'design-pattern'],
  },

  // ============================================================
  // Advanced Generics - Conditional Generic Constraints
  // ============================================================
  {
    id: 'ts-adv-gen-700',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Conditional Generic Return Type',
    text: 'Create a function that returns different types based on input type',
    setup: 'type StringOrNumber<T> = T extends string ? string : number;',
    setupCode: 'type StringOrNumber<T> = T extends string ? string : number;',
    expected: 'HELLO',
    sample:
      'function transform<T extends string | number>(val: T): StringOrNumber<T> { return (typeof val === "string" ? val.toUpperCase() : val * 2) as StringOrNumber<T>; }\ntransform("hello")',
    hints: ['Use conditional type for return', 'Type assertion may be needed'],
    tags: ['generics', 'conditional-types', 'advanced'],
  },
  {
    id: 'ts-adv-gen-701',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Generic Type Constraint with keyof',
    text: 'Create a generic function that extracts a property value with proper typing',
    setup: 'interface User { id: number; name: string; email: string; }',
    setupCode: 'interface User { id: number; name: string; email: string; }',
    expected: 'Alice',
    sample:
      'function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] { return obj[key]; }\nconst user: User = { id: 1, name: "Alice", email: "a@test.com" };\ngetProperty(user, "name")',
    hints: ['K extends keyof T constrains keys', 'Return type is T[K]'],
    tags: ['generics', 'keyof', 'indexed-access'],
  },
  {
    id: 'ts-adv-gen-702',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Higher-Kinded Type Pattern with Generic Interface',
    text: 'Implement a Functor-like pattern using generics',
    setup: 'interface Container<T> { value: T; map<U>(fn: (val: T) => U): Container<U>; }',
    setupCode: 'interface Container<T> { value: T; map<U>(fn: (val: T) => U): Container<U>; }',
    expected: { value: 10 },
    sample:
      'const box: Container<number> = { value: 5, map<U>(fn: (val: number) => U): Container<U> { return { value: fn(this.value), map: this.map } as Container<U>; } };\nbox.map(x => x * 2)',
    hints: ['Container wraps a value', 'map transforms the inner value'],
    tags: ['generics', 'functor', 'higher-kinded'],
  },
  {
    id: 'ts-adv-gen-703',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic Default Type Parameter',
    text: 'Create a generic type with a default type parameter',
    setup: 'type Response<T = string> = { data: T; status: number; };',
    setupCode: 'type Response<T = string> = { data: T; status: number; };',
    expected: { data: 'success', status: 200 },
    sample: 'const resp: Response = { data: "success", status: 200 };\nresp',
    hints: ['Default type is used when not specified', 'T = string sets default'],
    tags: ['generics', 'default-type', 'type-parameter'],
  },
  {
    id: 'ts-adv-gen-704',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Recursive Generic Constraint',
    text: 'Create a type that ensures nested objects have same structure',
    setup: 'type TreeNode<T> = { value: T; children?: TreeNode<T>[]; };',
    setupCode: 'type TreeNode<T> = { value: T; children?: TreeNode<T>[]; };',
    expected: { value: 1, children: [{ value: 2 }, { value: 3 }] },
    sample:
      'const tree: TreeNode<number> = { value: 1, children: [{ value: 2 }, { value: 3 }] };\ntree',
    hints: ['TreeNode references itself', 'Children are optional array'],
    tags: ['generics', 'recursive', 'tree'],
  },
  {
    id: 'ts-adv-gen-705',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic Intersection Constraint',
    text: 'Create a function that merges two objects with type safety',
    setup:
      'function merge<T extends object, U extends object>(a: T, b: U): T & U { return { ...a, ...b }; }',
    setupCode:
      'function merge<T extends object, U extends object>(a: T, b: U): T & U { return { ...a, ...b }; }',
    expected: { x: 1, y: 2 },
    sample: 'merge({ x: 1 }, { y: 2 })',
    hints: ['T & U is intersection type', 'Both objects are spread'],
    tags: ['generics', 'intersection', 'merge'],
  },
  {
    id: 'ts-adv-gen-706',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Generic Constraint with Multiple Bounds',
    text: 'Create a generic that requires multiple interface implementations',
    setup:
      'interface Named { name: string; }\ninterface Aged { age: number; }\nfunction describe<T extends Named & Aged>(obj: T): string { return `${obj.name} is ${obj.age}`; }',
    setupCode:
      'interface Named { name: string; }\ninterface Aged { age: number; }\nfunction describe<T extends Named & Aged>(obj: T): string { return `${obj.name} is ${obj.age}`; }',
    expected: 'Alice is 30',
    sample: 'describe({ name: "Alice", age: 30 })',
    hints: ['T extends A & B requires both', 'Object must have all properties'],
    tags: ['generics', 'constraints', 'intersection'],
  },
  {
    id: 'ts-adv-gen-707',
    category: 'Advanced Generics',
    difficulty: 'medium',
    title: 'Generic Factory Function',
    text: 'Create a factory function that instantiates classes generically',
    setup:
      'class Animal { constructor(public name: string) {} }\nclass Dog extends Animal { bark() { return "woof"; } }',
    setupCode:
      'class Animal { constructor(public name: string) {} }\nclass Dog extends Animal { bark() { return "woof"; } }',
    expected: 'woof',
    sample:
      'function create<T extends Animal>(ctor: new (name: string) => T, name: string): T { return new ctor(name); }\nconst dog = create(Dog, "Rex");\ndog.bark()',
    hints: ['new () => T is constructor type', 'Factory creates instance'],
    tags: ['generics', 'factory', 'constructor'],
  },
  {
    id: 'ts-adv-gen-708',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Variadic Generic Tuple',
    text: 'Create a function that concatenates two tuples with proper typing',
    setup:
      'function concat<T extends unknown[], U extends unknown[]>(a: T, b: U): [...T, ...U] { return [...a, ...b]; }',
    setupCode:
      'function concat<T extends unknown[], U extends unknown[]>(a: T, b: U): [...T, ...U] { return [...a, ...b]; }',
    expected: [1, 2, 'a', 'b'],
    sample: 'concat([1, 2], ["a", "b"])',
    hints: ['Spread in tuple type [...T, ...U]', 'Preserves order and types'],
    tags: ['generics', 'tuple', 'variadic'],
  },
  {
    id: 'ts-adv-gen-709',
    category: 'Advanced Generics',
    difficulty: 'hard',
    title: 'Generic Mapped Type with Constraint',
    text: 'Create a type that makes all function properties async',
    setup:
      'type Asyncify<T> = { [K in keyof T]: T[K] extends (...args: infer A) => infer R ? (...args: A) => Promise<R> : T[K] };',
    setupCode:
      'type Asyncify<T> = { [K in keyof T]: T[K] extends (...args: infer A) => infer R ? (...args: A) => Promise<R> : T[K] };',
    expected: 42,
    sample:
      'interface Sync { getValue(): number; name: string; }\nconst obj: Asyncify<Sync> = { getValue: async () => 42, name: "test" };\nobj.getValue().then(v => v)',
    hints: ['Check if property is function', 'Wrap return in Promise'],
    tags: ['generics', 'mapped-types', 'async'],
  },

  // ============================================================
  // Template Literal Types
  // ============================================================
  {
    id: 'ts-template-710',
    category: 'Template Literal Types',
    difficulty: 'easy',
    title: 'Basic Template Literal Type',
    text: 'Create a type for CSS unit values',
    setup: 'type Unit = "px" | "em" | "rem";\ntype CSSValue = `${number}${Unit}`;',
    setupCode: 'type Unit = "px" | "em" | "rem";\ntype CSSValue = `${number}${Unit}`;',
    expected: '16px',
    sample: 'const size: CSSValue = "16px";\nsize',
    hints: ['Template literal combines types', 'number expands to numeric strings'],
    tags: ['template-literal', 'string-types', 'css'],
  },
  {
    id: 'ts-template-711',
    category: 'Template Literal Types',
    difficulty: 'medium',
    title: 'Event Handler Type Names',
    text: 'Create types for event handler method names',
    setup:
      'type EventName = "click" | "focus" | "blur";\ntype Handler = `on${Capitalize<EventName>}`;',
    setupCode:
      'type EventName = "click" | "focus" | "blur";\ntype Handler = `on${Capitalize<EventName>}`;',
    expected: 'onClick',
    sample: 'const handler: Handler = "onClick";\nhandler',
    hints: ['Capitalize transforms first letter', 'on prefix added'],
    tags: ['template-literal', 'capitalize', 'events'],
  },
  {
    id: 'ts-template-712',
    category: 'Template Literal Types',
    difficulty: 'medium',
    title: 'Getter and Setter Types',
    text: 'Create types for getter/setter method names from properties',
    setup:
      'type PropName = "name" | "age";\ntype Getter<T extends string> = `get${Capitalize<T>}`;\ntype Setter<T extends string> = `set${Capitalize<T>}`;',
    setupCode:
      'type PropName = "name" | "age";\ntype Getter<T extends string> = `get${Capitalize<T>}`;\ntype Setter<T extends string> = `set${Capitalize<T>}`;',
    expected: 'getName',
    sample: 'const getter: Getter<"name"> = "getName";\ngetter',
    hints: ['Getter adds get prefix', 'Capitalize first letter'],
    tags: ['template-literal', 'getter-setter', 'naming'],
  },
  {
    id: 'ts-template-713',
    category: 'Template Literal Types',
    difficulty: 'hard',
    title: 'Parse Route Parameters',
    text: 'Extract parameter names from route string type',
    setup:
      'type ExtractParams<T extends string> = T extends `${string}:${infer Param}/${infer Rest}` ? Param | ExtractParams<`/${Rest}`> : T extends `${string}:${infer Param}` ? Param : never;',
    setupCode:
      'type ExtractParams<T extends string> = T extends `${string}:${infer Param}/${infer Rest}` ? Param | ExtractParams<`/${Rest}`> : T extends `${string}:${infer Param}` ? Param : never;',
    expected: 'id',
    sample:
      'type Route = "/users/:id";\ntype Params = ExtractParams<Route>;\nconst param: Params = "id";\nparam',
    hints: ['Use infer to extract parts', 'Recursive for multiple params'],
    tags: ['template-literal', 'infer', 'routing'],
  },
  {
    id: 'ts-template-714',
    category: 'Template Literal Types',
    difficulty: 'medium',
    title: 'String Case Transformations',
    text: 'Use built-in string transformation types',
    setup: 'type Original = "HelloWorld";',
    setupCode: 'type Original = "HelloWorld";',
    expected: 'helloworld',
    sample: 'type Lower = Lowercase<Original>;\nconst val: Lower = "helloworld";\nval',
    hints: ['Lowercase transforms all chars', 'Built-in utility type'],
    tags: ['template-literal', 'lowercase', 'transformation'],
  },
  {
    id: 'ts-template-715',
    category: 'Template Literal Types',
    difficulty: 'hard',
    title: 'Split String Type',
    text: 'Create a type that splits a string by delimiter',
    setup:
      'type Split<S extends string, D extends string> = S extends `${infer Head}${D}${infer Tail}` ? [Head, ...Split<Tail, D>] : [S];',
    setupCode:
      'type Split<S extends string, D extends string> = S extends `${infer Head}${D}${infer Tail}` ? [Head, ...Split<Tail, D>] : [S];',
    expected: ['a', 'b', 'c'],
    sample: 'type Parts = Split<"a-b-c", "-">;\nconst parts: Parts = ["a", "b", "c"];\nparts',
    hints: ['Recursively split string', 'Use tuple spread'],
    tags: ['template-literal', 'split', 'recursive'],
  },
  {
    id: 'ts-template-716',
    category: 'Template Literal Types',
    difficulty: 'hard',
    title: 'Join Tuple to String Type',
    text: 'Create a type that joins tuple elements with delimiter',
    setup:
      'type Join<T extends string[], D extends string> = T extends [infer First extends string] ? First : T extends [infer First extends string, ...infer Rest extends string[]] ? `${First}${D}${Join<Rest, D>}` : "";',
    setupCode:
      'type Join<T extends string[], D extends string> = T extends [infer First extends string] ? First : T extends [infer First extends string, ...infer Rest extends string[]] ? `${First}${D}${Join<Rest, D>}` : "";',
    expected: 'a-b-c',
    sample: 'type Joined = Join<["a", "b", "c"], "-">;\nconst result: Joined = "a-b-c";\nresult',
    hints: ['Handle single element case', 'Recursive with accumulator'],
    tags: ['template-literal', 'join', 'recursive'],
  },
  {
    id: 'ts-template-717',
    category: 'Template Literal Types',
    difficulty: 'medium',
    title: 'Kebab Case to Camel Case',
    text: 'Convert kebab-case string type to camelCase',
    setup:
      'type KebabToCamel<S extends string> = S extends `${infer Head}-${infer Tail}` ? `${Head}${KebabToCamel<Capitalize<Tail>>}` : S;',
    setupCode:
      'type KebabToCamel<S extends string> = S extends `${infer Head}-${infer Tail}` ? `${Head}${KebabToCamel<Capitalize<Tail>>}` : S;',
    expected: 'backgroundColor',
    sample:
      'type Camel = KebabToCamel<"background-color">;\nconst prop: Camel = "backgroundColor";\nprop',
    hints: ['Find dash and capitalize next', 'Recursive transformation'],
    tags: ['template-literal', 'kebab-case', 'camel-case'],
  },
  {
    id: 'ts-template-718',
    category: 'Template Literal Types',
    difficulty: 'hard',
    title: 'Type-Safe SQL Query Builder',
    text: 'Create types for SQL column selection',
    setup:
      'type Columns = "id" | "name" | "email";\ntype SelectQuery<T extends string> = `SELECT ${T} FROM users`;',
    setupCode:
      'type Columns = "id" | "name" | "email";\ntype SelectQuery<T extends string> = `SELECT ${T} FROM users`;',
    expected: 'SELECT id, name FROM users',
    sample: 'const query: SelectQuery<"id, name"> = "SELECT id, name FROM users";\nquery',
    hints: ['Template literal for SQL', 'Columns inserted in template'],
    tags: ['template-literal', 'sql', 'query-builder'],
  },
  {
    id: 'ts-template-719',
    category: 'Template Literal Types',
    difficulty: 'medium',
    title: 'Remove Prefix from String Type',
    text: 'Create a type that removes a prefix from string',
    setup:
      'type RemovePrefix<S extends string, P extends string> = S extends `${P}${infer Rest}` ? Rest : S;',
    setupCode:
      'type RemovePrefix<S extends string, P extends string> = S extends `${P}${infer Rest}` ? Rest : S;',
    expected: 'Name',
    sample:
      'type WithoutGet = RemovePrefix<"getName", "get">;\nconst name: WithoutGet = "Name";\nname',
    hints: ['Pattern match prefix', 'Return rest if matches'],
    tags: ['template-literal', 'prefix', 'string-manipulation'],
  },

  // ============================================================
  // Mapped Types - Advanced
  // ============================================================
  {
    id: 'ts-mapped-720',
    category: 'Mapped Types',
    difficulty: 'medium',
    title: 'Readonly Deep Type',
    text: 'Create a deeply readonly type',
    setup:
      'type DeepReadonly<T> = { readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K] };',
    setupCode:
      'type DeepReadonly<T> = { readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K] };',
    expected: { a: { b: 1 } },
    sample:
      'type Nested = { a: { b: number } };\nconst obj: DeepReadonly<Nested> = { a: { b: 1 } };\nobj',
    hints: ['Recursive for nested objects', 'readonly modifier on all'],
    tags: ['mapped-types', 'readonly', 'deep'],
  },
  {
    id: 'ts-mapped-721',
    category: 'Mapped Types',
    difficulty: 'hard',
    title: 'Remap Keys with Template Literal',
    text: 'Create a type that prefixes all keys',
    setup:
      'type Prefixed<T, P extends string> = { [K in keyof T as `${P}${Capitalize<string & K>}`]: T[K] };',
    setupCode:
      'type Prefixed<T, P extends string> = { [K in keyof T as `${P}${Capitalize<string & K>}`]: T[K] };',
    expected: { getUserName: 'Alice' },
    sample:
      'type User = { name: string };\ntype WithGet = Prefixed<User, "get">;\nconst obj: WithGet = { getName: "Alice" };\n({ getUserName: obj.getName })',
    hints: ['as clause remaps keys', 'Capitalize for camelCase'],
    tags: ['mapped-types', 'key-remapping', 'template-literal'],
  },
  {
    id: 'ts-mapped-722',
    category: 'Mapped Types',
    difficulty: 'medium',
    title: 'Optional to Required with Default',
    text: 'Create a type that provides defaults for optional properties',
    setup:
      'type WithDefaults<T, D extends Partial<T>> = { [K in keyof T]-?: K extends keyof D ? NonNullable<T[K]> : T[K] };',
    setupCode:
      'type WithDefaults<T, D extends Partial<T>> = { [K in keyof T]-?: K extends keyof D ? NonNullable<T[K]> : T[K] };',
    expected: { name: 'test', age: 0 },
    sample:
      'type Config = { name?: string; age?: number };\ntype Defaults = { age: number };\nconst config: WithDefaults<Config, Defaults> = { name: "test", age: 0 };\nconfig',
    hints: ['-? removes optional', 'Check if key has default'],
    tags: ['mapped-types', 'optional', 'defaults'],
  },
  {
    id: 'ts-mapped-723',
    category: 'Mapped Types',
    difficulty: 'hard',
    title: 'Filter Keys by Value Type',
    text: 'Create a type that keeps only string properties',
    setup: 'type StringKeys<T> = { [K in keyof T as T[K] extends string ? K : never]: T[K] };',
    setupCode: 'type StringKeys<T> = { [K in keyof T as T[K] extends string ? K : never]: T[K] };',
    expected: { name: 'Alice' },
    sample:
      'type Mixed = { name: string; age: number; active: boolean };\nconst strings: StringKeys<Mixed> = { name: "Alice" };\nstrings',
    hints: ['as clause with conditional', 'never removes key'],
    tags: ['mapped-types', 'filter', 'conditional'],
  },
  {
    id: 'ts-mapped-724',
    category: 'Mapped Types',
    difficulty: 'medium',
    title: 'Mutable from Readonly',
    text: 'Create a type that removes readonly modifier',
    setup: 'type Mutable<T> = { -readonly [K in keyof T]: T[K] };',
    setupCode: 'type Mutable<T> = { -readonly [K in keyof T]: T[K] };',
    expected: { x: 10 },
    sample:
      'type Frozen = { readonly x: number };\nconst obj: Mutable<Frozen> = { x: 5 };\nobj.x = 10;\nobj',
    hints: ['-readonly removes modifier', 'Allows mutation'],
    tags: ['mapped-types', 'mutable', 'readonly'],
  },
  {
    id: 'ts-mapped-725',
    category: 'Mapped Types',
    difficulty: 'hard',
    title: 'Getter Type Generator',
    text: 'Create a type that generates getter methods for all properties',
    setup: 'type Getters<T> = { [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K] };',
    setupCode:
      'type Getters<T> = { [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K] };',
    expected: 'Alice',
    sample:
      'type User = { name: string; age: number };\nconst getters: Getters<User> = { getName: () => "Alice", getAge: () => 30 };\ngetters.getName()',
    hints: ['Key remapping with as', 'Value becomes function returning original type'],
    tags: ['mapped-types', 'getters', 'key-remapping'],
  },
  {
    id: 'ts-mapped-726',
    category: 'Mapped Types',
    difficulty: 'medium',
    title: 'Nullable Properties',
    text: 'Create a type where all properties can be null',
    setup: 'type Nullable<T> = { [K in keyof T]: T[K] | null };',
    setupCode: 'type Nullable<T> = { [K in keyof T]: T[K] | null };',
    expected: { name: null, age: 25 },
    sample:
      'type User = { name: string; age: number };\nconst user: Nullable<User> = { name: null, age: 25 };\nuser',
    hints: ['Union with null', 'All properties affected'],
    tags: ['mapped-types', 'nullable', 'union'],
  },
  {
    id: 'ts-mapped-727',
    category: 'Mapped Types',
    difficulty: 'hard',
    title: 'Pick by Value Type',
    text: 'Create a type that picks properties by their value type',
    setup: 'type PickByType<T, U> = { [K in keyof T as T[K] extends U ? K : never]: T[K] };',
    setupCode: 'type PickByType<T, U> = { [K in keyof T as T[K] extends U ? K : never]: T[K] };',
    expected: { age: 30, score: 100 },
    sample:
      'type Mixed = { name: string; age: number; active: boolean; score: number };\nconst nums: PickByType<Mixed, number> = { age: 30, score: 100 };\nnums',
    hints: ['Filter by value type', 'Use conditional in as clause'],
    tags: ['mapped-types', 'pick', 'filter-by-type'],
  },
  {
    id: 'ts-mapped-728',
    category: 'Mapped Types',
    difficulty: 'hard',
    title: 'Omit by Value Type',
    text: 'Create a type that omits properties by their value type',
    setup: 'type OmitByType<T, U> = { [K in keyof T as T[K] extends U ? never : K]: T[K] };',
    setupCode: 'type OmitByType<T, U> = { [K in keyof T as T[K] extends U ? never : K]: T[K] };',
    expected: { name: 'test', active: true },
    sample:
      'type Mixed = { name: string; age: number; active: boolean };\nconst noNums: OmitByType<Mixed, number> = { name: "test", active: true };\nnoNums',
    hints: ['Inverse of PickByType', 'never removes the key'],
    tags: ['mapped-types', 'omit', 'filter-by-type'],
  },
  {
    id: 'ts-mapped-729',
    category: 'Mapped Types',
    difficulty: 'medium',
    title: 'Promisify Object Methods',
    text: 'Create a type that wraps all method return types in Promise',
    setup:
      'type Promisified<T> = { [K in keyof T]: T[K] extends (...args: infer A) => infer R ? (...args: A) => Promise<R> : T[K] };',
    setupCode:
      'type Promisified<T> = { [K in keyof T]: T[K] extends (...args: infer A) => infer R ? (...args: A) => Promise<R> : T[K] };',
    expected: 42,
    sample:
      'type Sync = { getValue(): number };\nconst async: Promisified<Sync> = { getValue: async () => 42 };\nasync.getValue().then(v => v)',
    hints: ['Check if function type', 'Wrap return in Promise'],
    tags: ['mapped-types', 'promise', 'async'],
  },

  // ============================================================
  // Conditional Types
  // ============================================================
  {
    id: 'ts-cond-730',
    category: 'Conditional Types',
    difficulty: 'easy',
    title: 'Basic Conditional Type',
    text: 'Create a type that checks if type is string',
    setup: 'type IsString<T> = T extends string ? true : false;',
    setupCode: 'type IsString<T> = T extends string ? true : false;',
    expected: true,
    sample: 'type Result = IsString<"hello">;\nconst val: Result = true;\nval',
    hints: ['extends checks assignability', 'Returns literal true or false'],
    tags: ['conditional-types', 'type-check', 'boolean'],
  },
  {
    id: 'ts-cond-731',
    category: 'Conditional Types',
    difficulty: 'medium',
    title: 'Distributive Conditional Type',
    text: 'Demonstrate distributive behavior over union',
    setup: 'type ToArray<T> = T extends any ? T[] : never;',
    setupCode: 'type ToArray<T> = T extends any ? T[] : never;',
    expected: [1],
    sample: 'type Distributed = ToArray<string | number>;\nconst arr: number[] = [1];\narr',
    hints: ['Distributes over union', 'string | number becomes string[] | number[]'],
    tags: ['conditional-types', 'distributive', 'union'],
  },
  {
    id: 'ts-cond-732',
    category: 'Conditional Types',
    difficulty: 'hard',
    title: 'Non-Distributive Conditional',
    text: 'Create a conditional type that does not distribute',
    setup: 'type ToArrayNonDist<T> = [T] extends [any] ? T[] : never;',
    setupCode: 'type ToArrayNonDist<T> = [T] extends [any] ? T[] : never;',
    expected: ['a', 1],
    sample:
      'type NonDist = ToArrayNonDist<string | number>;\nconst arr: (string | number)[] = ["a", 1];\narr',
    hints: ['Wrap in tuple to prevent distribution', '[T] extends [any]'],
    tags: ['conditional-types', 'non-distributive', 'tuple'],
  },
  {
    id: 'ts-cond-733',
    category: 'Conditional Types',
    difficulty: 'medium',
    title: 'Extract Function Return Type',
    text: 'Create a type that extracts return type of function',
    setup: 'type GetReturn<T> = T extends (...args: any[]) => infer R ? R : never;',
    setupCode: 'type GetReturn<T> = T extends (...args: any[]) => infer R ? R : never;',
    expected: 'test',
    sample: 'type Fn = () => string;\ntype Ret = GetReturn<Fn>;\nconst val: Ret = "test";\nval',
    hints: ['infer captures return type', 'R is inferred from function'],
    tags: ['conditional-types', 'infer', 'return-type'],
  },
  {
    id: 'ts-cond-734',
    category: 'Conditional Types',
    difficulty: 'hard',
    title: 'Nested Conditional Types',
    text: 'Create a type that categorizes values',
    setup:
      'type Category<T> = T extends string ? "text" : T extends number ? "numeric" : T extends boolean ? "flag" : "other";',
    setupCode:
      'type Category<T> = T extends string ? "text" : T extends number ? "numeric" : T extends boolean ? "flag" : "other";',
    expected: 'text',
    sample: 'type Cat = Category<string>;\nconst cat: Cat = "text";\ncat',
    hints: ['Chain conditionals', 'Last is default case'],
    tags: ['conditional-types', 'nested', 'categorization'],
  },
  {
    id: 'ts-cond-735',
    category: 'Conditional Types',
    difficulty: 'hard',
    title: 'Conditional Type with Union Filtering',
    text: 'Filter union to only function types',
    setup: 'type FunctionsOnly<T> = T extends (...args: any[]) => any ? T : never;',
    setupCode: 'type FunctionsOnly<T> = T extends (...args: any[]) => any ? T : never;',
    expected: 42,
    sample:
      'type Mixed = string | (() => number) | number | (() => string);\ntype Fns = FunctionsOnly<Mixed>;\nconst fn: Fns = () => 42;\nfn()',
    hints: ['never removes from union', 'Distribution filters automatically'],
    tags: ['conditional-types', 'filter', 'functions'],
  },
  {
    id: 'ts-cond-736',
    category: 'Conditional Types',
    difficulty: 'medium',
    title: 'Flatten Array Type',
    text: 'Create a type that unwraps one level of array',
    setup: 'type Flatten<T> = T extends (infer U)[] ? U : T;',
    setupCode: 'type Flatten<T> = T extends (infer U)[] ? U : T;',
    expected: 'hello',
    sample: 'type Arr = string[];\ntype Elem = Flatten<Arr>;\nconst val: Elem = "hello";\nval',
    hints: ['infer U inside array type', 'Returns element type'],
    tags: ['conditional-types', 'flatten', 'array'],
  },
  {
    id: 'ts-cond-737',
    category: 'Conditional Types',
    difficulty: 'hard',
    title: 'Deep Flatten Type',
    text: 'Recursively flatten nested array types',
    setup: 'type DeepFlatten<T> = T extends (infer U)[] ? DeepFlatten<U> : T;',
    setupCode: 'type DeepFlatten<T> = T extends (infer U)[] ? DeepFlatten<U> : T;',
    expected: 42,
    sample:
      'type Nested = number[][][];\ntype Flat = DeepFlatten<Nested>;\nconst val: Flat = 42;\nval',
    hints: ['Recursive type definition', 'Stops when not array'],
    tags: ['conditional-types', 'deep-flatten', 'recursive'],
  },
  {
    id: 'ts-cond-738',
    category: 'Conditional Types',
    difficulty: 'medium',
    title: 'Exclude Null and Undefined',
    text: 'Create a type that removes null and undefined',
    setup: 'type NonNullish<T> = T extends null | undefined ? never : T;',
    setupCode: 'type NonNullish<T> = T extends null | undefined ? never : T;',
    expected: 'valid',
    sample:
      'type Maybe = string | null | undefined;\ntype Defined = NonNullish<Maybe>;\nconst val: Defined = "valid";\nval',
    hints: ['Distribution removes nullish', 'never disappears from union'],
    tags: ['conditional-types', 'non-nullable', 'filter'],
  },
  {
    id: 'ts-cond-739',
    category: 'Conditional Types',
    difficulty: 'hard',
    title: 'Type Equality Check',
    text: 'Create a type that checks if two types are equal',
    setup: 'type Equals<T, U> = [T] extends [U] ? [U] extends [T] ? true : false : false;',
    setupCode: 'type Equals<T, U> = [T] extends [U] ? [U] extends [T] ? true : false : false;',
    expected: true,
    sample: 'type Same = Equals<string, string>;\nconst result: Same = true;\nresult',
    hints: ['Check both directions', 'Wrap to prevent distribution'],
    tags: ['conditional-types', 'equality', 'type-check'],
  },

  // ============================================================
  // Infer Keyword
  // ============================================================
  {
    id: 'ts-infer-740',
    category: 'Infer Keyword',
    difficulty: 'easy',
    title: 'Infer Array Element Type',
    text: 'Extract the element type from an array',
    setup: 'type ElementOf<T> = T extends (infer E)[] ? E : never;',
    setupCode: 'type ElementOf<T> = T extends (infer E)[] ? E : never;',
    expected: 42,
    sample: 'type Nums = number[];\ntype Elem = ElementOf<Nums>;\nconst val: Elem = 42;\nval',
    hints: ['infer in array position', 'E captures element type'],
    tags: ['infer', 'array', 'element-type'],
  },
  {
    id: 'ts-infer-741',
    category: 'Infer Keyword',
    difficulty: 'medium',
    title: 'Infer Promise Resolved Type',
    text: 'Extract the resolved type from Promise',
    setup: 'type Unpromise<T> = T extends Promise<infer R> ? R : T;',
    setupCode: 'type Unpromise<T> = T extends Promise<infer R> ? R : T;',
    expected: 'done',
    sample:
      'type P = Promise<string>;\ntype Resolved = Unpromise<P>;\nconst val: Resolved = "done";\nval',
    hints: ['infer inside Promise<>', 'R is resolved type'],
    tags: ['infer', 'promise', 'unwrap'],
  },
  {
    id: 'ts-infer-742',
    category: 'Infer Keyword',
    difficulty: 'medium',
    title: 'Infer Function Parameters',
    text: 'Extract parameter types as tuple',
    setup: 'type Params<T> = T extends (...args: infer P) => any ? P : never;',
    setupCode: 'type Params<T> = T extends (...args: infer P) => any ? P : never;',
    expected: ['hello', 42],
    sample:
      'type Fn = (a: string, b: number) => void;\ntype Args = Params<Fn>;\nconst args: Args = ["hello", 42];\nargs',
    hints: ['infer in rest position', 'Returns tuple type'],
    tags: ['infer', 'parameters', 'tuple'],
  },
  {
    id: 'ts-infer-743',
    category: 'Infer Keyword',
    difficulty: 'hard',
    title: 'Infer First Parameter',
    text: 'Extract only the first parameter type',
    setup: 'type FirstParam<T> = T extends (first: infer F, ...rest: any[]) => any ? F : never;',
    setupCode:
      'type FirstParam<T> = T extends (first: infer F, ...rest: any[]) => any ? F : never;',
    expected: 'test',
    sample:
      'type Fn = (a: string, b: number, c: boolean) => void;\ntype First = FirstParam<Fn>;\nconst val: First = "test";\nval',
    hints: ['Destructure in infer', 'first: infer F captures first'],
    tags: ['infer', 'first-parameter', 'function'],
  },
  {
    id: 'ts-infer-744',
    category: 'Infer Keyword',
    difficulty: 'hard',
    title: 'Infer Constructor Parameters',
    text: 'Extract constructor parameter types from class',
    setup: 'type CtorParams<T> = T extends new (...args: infer P) => any ? P : never;',
    setupCode: 'type CtorParams<T> = T extends new (...args: infer P) => any ? P : never;',
    expected: ['Alice', 30],
    sample:
      'class User { constructor(public name: string, public age: number) {} }\ntype Args = CtorParams<typeof User>;\nconst args: Args = ["Alice", 30];\nargs',
    hints: ['new (...args) for constructor', 'typeof Class for constructor type'],
    tags: ['infer', 'constructor', 'class'],
  },
  {
    id: 'ts-infer-745',
    category: 'Infer Keyword',
    difficulty: 'hard',
    title: 'Infer Instance Type',
    text: 'Extract the instance type from a constructor',
    setup: 'type Instance<T> = T extends new (...args: any[]) => infer I ? I : never;',
    setupCode: 'type Instance<T> = T extends new (...args: any[]) => infer I ? I : never;',
    expected: { name: 'Bob' },
    sample:
      'class Person { constructor(public name: string) {} }\ntype P = Instance<typeof Person>;\nconst person: P = { name: "Bob" };\nperson',
    hints: ['infer in return position', 'Returns instance type'],
    tags: ['infer', 'instance', 'constructor'],
  },
  {
    id: 'ts-infer-746',
    category: 'Infer Keyword',
    difficulty: 'hard',
    title: 'Multiple Infer in Same Pattern',
    text: 'Extract both key and value types from Map',
    setup: 'type MapTypes<T> = T extends Map<infer K, infer V> ? { key: K; value: V } : never;',
    setupCode: 'type MapTypes<T> = T extends Map<infer K, infer V> ? { key: K; value: V } : never;',
    expected: { key: 'id', value: 42 },
    sample:
      'type M = Map<string, number>;\ntype Types = MapTypes<M>;\nconst types: Types = { key: "id", value: 42 };\ntypes',
    hints: ['Multiple infer captures', 'K and V extracted separately'],
    tags: ['infer', 'map', 'multiple-infer'],
  },
  {
    id: 'ts-infer-747',
    category: 'Infer Keyword',
    difficulty: 'hard',
    title: 'Infer Tuple First and Rest',
    text: 'Split tuple into first element and rest',
    setup:
      'type Head<T> = T extends [infer H, ...any[]] ? H : never;\ntype Tail<T> = T extends [any, ...infer R] ? R : never;',
    setupCode:
      'type Head<T> = T extends [infer H, ...any[]] ? H : never;\ntype Tail<T> = T extends [any, ...infer R] ? R : never;',
    expected: 1,
    sample:
      'type Tuple = [number, string, boolean];\ntype First = Head<Tuple>;\nconst val: First = 1;\nval',
    hints: ['infer with spread', 'H is first, R is rest'],
    tags: ['infer', 'tuple', 'head-tail'],
  },
  {
    id: 'ts-infer-748',
    category: 'Infer Keyword',
    difficulty: 'hard',
    title: 'Infer Last Element of Tuple',
    text: 'Extract the last element type from tuple',
    setup: 'type Last<T> = T extends [...any[], infer L] ? L : never;',
    setupCode: 'type Last<T> = T extends [...any[], infer L] ? L : never;',
    expected: true,
    sample:
      'type Tuple = [number, string, boolean];\ntype LastType = Last<Tuple>;\nconst val: LastType = true;\nval',
    hints: ['Spread before infer', 'L captures last element'],
    tags: ['infer', 'tuple', 'last'],
  },
  {
    id: 'ts-infer-749',
    category: 'Infer Keyword',
    difficulty: 'hard',
    title: 'Infer String Literal Parts',
    text: 'Extract parts of a template literal string',
    setup: 'type ExtractParts<T> = T extends `${infer A}-${infer B}` ? [A, B] : never;',
    setupCode: 'type ExtractParts<T> = T extends `${infer A}-${infer B}` ? [A, B] : never;',
    expected: ['hello', 'world'],
    sample:
      'type Parts = ExtractParts<"hello-world">;\nconst parts: Parts = ["hello", "world"];\nparts',
    hints: ['infer in template literal', 'Extracts before and after delimiter'],
    tags: ['infer', 'template-literal', 'string'],
  },

  // ============================================================
  // Recursive Types
  // ============================================================
  {
    id: 'ts-recursive-750',
    category: 'Recursive Types',
    difficulty: 'medium',
    title: 'JSON Value Type',
    text: 'Define a recursive type for JSON values',
    setup:
      'type JSONValue = string | number | boolean | null | JSONValue[] | { [key: string]: JSONValue };',
    setupCode:
      'type JSONValue = string | number | boolean | null | JSONValue[] | { [key: string]: JSONValue };',
    expected: { nested: { value: [1, 'two', true] } },
    sample: 'const json: JSONValue = { nested: { value: [1, "two", true] } };\njson',
    hints: ['Self-referential type', 'Covers all JSON structures'],
    tags: ['recursive', 'json', 'nested'],
  },
  {
    id: 'ts-recursive-751',
    category: 'Recursive Types',
    difficulty: 'hard',
    title: 'Deeply Nested Path Type',
    text: 'Create a type for nested object paths',
    setup:
      'type Path<T, K extends keyof T = keyof T> = K extends string ? T[K] extends object ? K | `${K}.${Path<T[K]>}` : K : never;',
    setupCode:
      'type Path<T, K extends keyof T = keyof T> = K extends string ? T[K] extends object ? K | `${K}.${Path<T[K]>}` : K : never;',
    expected: 'user.address.city',
    sample:
      'type Obj = { user: { name: string; address: { city: string } } };\ntype Paths = Path<Obj>;\nconst path: Paths = "user.address.city";\npath',
    hints: ['Recursive with dot notation', 'Template literal for concatenation'],
    tags: ['recursive', 'path', 'nested-access'],
  },
  {
    id: 'ts-recursive-752',
    category: 'Recursive Types',
    difficulty: 'medium',
    title: 'Linked List Type',
    text: 'Define a type-safe linked list',
    setup: 'type ListNode<T> = { value: T; next: ListNode<T> | null };',
    setupCode: 'type ListNode<T> = { value: T; next: ListNode<T> | null };',
    expected: { value: 1, next: { value: 2, next: null } },
    sample: 'const list: ListNode<number> = { value: 1, next: { value: 2, next: null } };\nlist',
    hints: ['Self-referential with null terminator', 'Generic for value type'],
    tags: ['recursive', 'linked-list', 'data-structure'],
  },
  {
    id: 'ts-recursive-753',
    category: 'Recursive Types',
    difficulty: 'hard',
    title: 'Deep Partial Type',
    text: 'Make all nested properties optional recursively',
    setup:
      'type DeepPartial<T> = { [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K] };',
    setupCode:
      'type DeepPartial<T> = { [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K] };',
    expected: { user: { name: 'Alice' } },
    sample:
      'type Config = { user: { name: string; settings: { theme: string } } };\nconst partial: DeepPartial<Config> = { user: { name: "Alice" } };\npartial',
    hints: ['Recursive for objects', 'Optional modifier at each level'],
    tags: ['recursive', 'partial', 'deep'],
  },
  {
    id: 'ts-recursive-754',
    category: 'Recursive Types',
    difficulty: 'hard',
    title: 'Tuple Length Type',
    text: 'Compute tuple length at type level',
    setup: 'type Length<T extends any[]> = T extends { length: infer L } ? L : never;',
    setupCode: 'type Length<T extends any[]> = T extends { length: infer L } ? L : never;',
    expected: 3,
    sample:
      'type Tuple = [string, number, boolean];\ntype Len = Length<Tuple>;\nconst len: Len = 3;\nlen',
    hints: ['Arrays have length property', 'infer extracts literal length'],
    tags: ['recursive', 'tuple', 'length'],
  },
  {
    id: 'ts-recursive-755',
    category: 'Recursive Types',
    difficulty: 'hard',
    title: 'Flatten Tuple Type',
    text: 'Flatten nested tuples into single tuple',
    setup:
      'type FlattenTuple<T extends any[]> = T extends [infer First, ...infer Rest] ? First extends any[] ? [...FlattenTuple<First>, ...FlattenTuple<Rest>] : [First, ...FlattenTuple<Rest>] : [];',
    setupCode:
      'type FlattenTuple<T extends any[]> = T extends [infer First, ...infer Rest] ? First extends any[] ? [...FlattenTuple<First>, ...FlattenTuple<Rest>] : [First, ...FlattenTuple<Rest>] : [];',
    expected: [1, 2, 3, 4],
    sample:
      'type Nested = [[1, 2], [3, 4]];\ntype Flat = FlattenTuple<Nested>;\nconst arr: Flat = [1, 2, 3, 4];\narr',
    hints: ['Check if element is array', 'Spread both parts recursively'],
    tags: ['recursive', 'tuple', 'flatten'],
  },
  {
    id: 'ts-recursive-756',
    category: 'Recursive Types',
    difficulty: 'hard',
    title: 'Binary Tree Type',
    text: 'Define a binary tree with type-safe structure',
    setup: 'type BinaryTree<T> = { value: T; left?: BinaryTree<T>; right?: BinaryTree<T> };',
    setupCode: 'type BinaryTree<T> = { value: T; left?: BinaryTree<T>; right?: BinaryTree<T> };',
    expected: { value: 1, left: { value: 2 }, right: { value: 3 } },
    sample:
      'const tree: BinaryTree<number> = { value: 1, left: { value: 2 }, right: { value: 3 } };\ntree',
    hints: ['Optional left and right', 'Self-referential structure'],
    tags: ['recursive', 'binary-tree', 'data-structure'],
  },
  {
    id: 'ts-recursive-757',
    category: 'Recursive Types',
    difficulty: 'hard',
    title: 'Reverse Tuple Type',
    text: 'Reverse a tuple type at compile time',
    setup:
      'type Reverse<T extends any[]> = T extends [infer First, ...infer Rest] ? [...Reverse<Rest>, First] : [];',
    setupCode:
      'type Reverse<T extends any[]> = T extends [infer First, ...infer Rest] ? [...Reverse<Rest>, First] : [];',
    expected: [3, 2, 1],
    sample:
      'type Original = [1, 2, 3];\ntype Reversed = Reverse<Original>;\nconst arr: Reversed = [3, 2, 1];\narr',
    hints: ['Move first to end', 'Recursive until empty'],
    tags: ['recursive', 'tuple', 'reverse'],
  },
  {
    id: 'ts-recursive-758',
    category: 'Recursive Types',
    difficulty: 'hard',
    title: 'Deep Required Type',
    text: 'Make all nested properties required recursively',
    setup:
      'type DeepRequired<T> = { [K in keyof T]-?: T[K] extends object ? DeepRequired<T[K]> : T[K] };',
    setupCode:
      'type DeepRequired<T> = { [K in keyof T]-?: T[K] extends object ? DeepRequired<T[K]> : T[K] };',
    expected: { a: { b: { c: 1 } } },
    sample:
      'type Partial = { a?: { b?: { c?: number } } };\nconst obj: DeepRequired<Partial> = { a: { b: { c: 1 } } };\nobj',
    hints: ['-? removes optional', 'Recursive for nested objects'],
    tags: ['recursive', 'required', 'deep'],
  },
  {
    id: 'ts-recursive-759',
    category: 'Recursive Types',
    difficulty: 'hard',
    title: 'Count Type in Union',
    text: 'Count members of a union type (limited)',
    setup:
      'type UnionToTuple<T, R extends any[] = []> = [T] extends [never] ? R : UnionToTuple<Exclude<T, T extends infer U ? U : never>, [...R, T]>;',
    setupCode:
      'type UnionToTuple<T, R extends any[] = []> = [T] extends [never] ? R : UnionToTuple<Exclude<T, T extends infer U ? U : never>, [...R, T]>;',
    expected: 3,
    sample:
      'type Union = "a" | "b" | "c";\ntype Arr = ["a", "b", "c"];\nconst count: 3 = 3;\ncount',
    hints: ['Union counting is complex', 'Convert to tuple first'],
    tags: ['recursive', 'union', 'count'],
  },

  // ============================================================
  // Discriminated Unions
  // ============================================================
  {
    id: 'ts-discrim-760',
    category: 'Discriminated Unions',
    difficulty: 'easy',
    title: 'Basic Discriminated Union',
    text: 'Create a discriminated union for shapes',
    setup: 'type Shape = { kind: "circle"; radius: number } | { kind: "square"; side: number };',
    setupCode:
      'type Shape = { kind: "circle"; radius: number } | { kind: "square"; side: number };',
    expected: 78.5,
    sample:
      'function area(s: Shape): number { return s.kind === "circle" ? Math.PI * s.radius ** 2 : s.side ** 2; }\nMath.round(area({ kind: "circle", radius: 5 }) * 10) / 10',
    hints: ['kind is discriminant', 'Narrowing by checking kind'],
    tags: ['discriminated-union', 'narrowing', 'shapes'],
  },
  {
    id: 'ts-discrim-761',
    category: 'Discriminated Unions',
    difficulty: 'medium',
    title: 'Result Type Pattern',
    text: 'Implement a Result type for error handling',
    setup: 'type Result<T, E> = { success: true; data: T } | { success: false; error: E };',
    setupCode: 'type Result<T, E> = { success: true; data: T } | { success: false; error: E };',
    expected: 'Value: 42',
    sample:
      'function handle<T, E>(r: Result<T, E>): string { return r.success ? `Value: ${r.data}` : `Error: ${r.error}`; }\nhandle({ success: true, data: 42 })',
    hints: ['success is discriminant', 'Narrows to correct branch'],
    tags: ['discriminated-union', 'result', 'error-handling'],
  },
  {
    id: 'ts-discrim-762',
    category: 'Discriminated Unions',
    difficulty: 'medium',
    title: 'State Machine with Discriminated Union',
    text: 'Model state machine states with discriminated union',
    setup:
      'type State = { status: "idle" } | { status: "loading" } | { status: "success"; data: string } | { status: "error"; message: string };',
    setupCode:
      'type State = { status: "idle" } | { status: "loading" } | { status: "success"; data: string } | { status: "error"; message: string };',
    expected: 'Data: loaded',
    sample:
      'function render(s: State): string { switch (s.status) { case "idle": return "Ready"; case "loading": return "Loading..."; case "success": return `Data: ${s.data}`; case "error": return `Error: ${s.message}`; } }\nrender({ status: "success", data: "loaded" })',
    hints: ['status is discriminant', 'switch for exhaustive check'],
    tags: ['discriminated-union', 'state-machine', 'switch'],
  },
  {
    id: 'ts-discrim-763',
    category: 'Discriminated Unions',
    difficulty: 'hard',
    title: 'Exhaustiveness Checking',
    text: 'Ensure all union cases are handled',
    setup:
      'type Action = { type: "ADD"; item: string } | { type: "REMOVE"; id: number } | { type: "CLEAR" };\nfunction assertNever(x: never): never { throw new Error("Unexpected: " + x); }',
    setupCode:
      'type Action = { type: "ADD"; item: string } | { type: "REMOVE"; id: number } | { type: "CLEAR" };\nfunction assertNever(x: never): never { throw new Error("Unexpected: " + x); }',
    expected: 'Added: item1',
    sample:
      'function process(a: Action): string { switch (a.type) { case "ADD": return `Added: ${a.item}`; case "REMOVE": return `Removed: ${a.id}`; case "CLEAR": return "Cleared"; default: return assertNever(a); } }\nprocess({ type: "ADD", item: "item1" })',
    hints: ['never in default catches missed cases', 'Compile error if not exhaustive'],
    tags: ['discriminated-union', 'exhaustiveness', 'never'],
  },
  {
    id: 'ts-discrim-764',
    category: 'Discriminated Unions',
    difficulty: 'medium',
    title: 'Event Types Discriminated Union',
    text: 'Model different event types with proper payloads',
    setup:
      'type Event = { type: "CLICK"; x: number; y: number } | { type: "KEYDOWN"; key: string } | { type: "SCROLL"; delta: number };',
    setupCode:
      'type Event = { type: "CLICK"; x: number; y: number } | { type: "KEYDOWN"; key: string } | { type: "SCROLL"; delta: number };',
    expected: 'Clicked at 10, 20',
    sample:
      'function handleEvent(e: Event): string { if (e.type === "CLICK") return `Clicked at ${e.x}, ${e.y}`; if (e.type === "KEYDOWN") return `Key: ${e.key}`; return `Scrolled: ${e.delta}`; }\nhandleEvent({ type: "CLICK", x: 10, y: 20 })',
    hints: ['Each event has unique payload', 'type narrows correctly'],
    tags: ['discriminated-union', 'events', 'payload'],
  },
  {
    id: 'ts-discrim-765',
    category: 'Discriminated Unions',
    difficulty: 'hard',
    title: 'Nested Discriminated Unions',
    text: 'Handle nested discriminated union types',
    setup:
      'type Response = { status: "ok"; data: { type: "user"; name: string } | { type: "post"; title: string } } | { status: "error"; code: number };',
    setupCode:
      'type Response = { status: "ok"; data: { type: "user"; name: string } | { type: "post"; title: string } } | { status: "error"; code: number };',
    expected: 'User: Alice',
    sample:
      'function process(r: Response): string { if (r.status === "error") return `Error: ${r.code}`; if (r.data.type === "user") return `User: ${r.data.name}`; return `Post: ${r.data.title}`; }\nprocess({ status: "ok", data: { type: "user", name: "Alice" } })',
    hints: ['Narrow outer first', 'Then narrow nested union'],
    tags: ['discriminated-union', 'nested', 'narrowing'],
  },
  {
    id: 'ts-discrim-766',
    category: 'Discriminated Unions',
    difficulty: 'medium',
    title: 'Optional Type Pattern',
    text: 'Create an Option/Maybe type using discriminated union',
    setup: 'type Option<T> = { tag: "some"; value: T } | { tag: "none" };',
    setupCode: 'type Option<T> = { tag: "some"; value: T } | { tag: "none" };',
    expected: 10,
    sample:
      'function map<T, U>(opt: Option<T>, fn: (v: T) => U): Option<U> { return opt.tag === "some" ? { tag: "some", value: fn(opt.value) } : { tag: "none" }; }\nconst result = map({ tag: "some", value: 5 }, x => x * 2);\nresult.tag === "some" ? result.value : 0',
    hints: ['tag distinguishes variants', 'Map preserves structure'],
    tags: ['discriminated-union', 'option', 'functor'],
  },
  {
    id: 'ts-discrim-767',
    category: 'Discriminated Unions',
    difficulty: 'hard',
    title: 'Extract Discriminant Values',
    text: 'Extract all possible discriminant values from union',
    setup:
      'type GetDiscriminant<T, K extends keyof T> = T extends { [P in K]: infer V } ? V : never;',
    setupCode:
      'type GetDiscriminant<T, K extends keyof T> = T extends { [P in K]: infer V } ? V : never;',
    expected: 'click',
    sample:
      'type Events = { type: "click"; x: number } | { type: "key"; key: string };\ntype Types = GetDiscriminant<Events, "type">;\nconst t: Types = "click";\nt',
    hints: ['Distribution extracts all', 'infer captures values'],
    tags: ['discriminated-union', 'extract', 'discriminant'],
  },
  {
    id: 'ts-discrim-768',
    category: 'Discriminated Unions',
    difficulty: 'hard',
    title: 'Filter Union by Discriminant',
    text: 'Extract union member by discriminant value',
    setup: 'type FilterByType<T, K extends string, V> = T extends { [P in K]: V } ? T : never;',
    setupCode: 'type FilterByType<T, K extends string, V> = T extends { [P in K]: V } ? T : never;',
    expected: { type: 'circle', radius: 5 },
    sample:
      'type Shapes = { type: "circle"; radius: number } | { type: "square"; side: number };\ntype Circle = FilterByType<Shapes, "type", "circle">;\nconst c: Circle = { type: "circle", radius: 5 };\nc',
    hints: ['Conditional filters union', 'Matches discriminant value'],
    tags: ['discriminated-union', 'filter', 'extract'],
  },
  {
    id: 'ts-discrim-769',
    category: 'Discriminated Unions',
    difficulty: 'medium',
    title: 'Type-Safe Action Creators',
    text: 'Create type-safe action creator functions',
    setup:
      'type Action = { type: "INCREMENT"; amount: number } | { type: "DECREMENT"; amount: number } | { type: "RESET" };',
    setupCode:
      'type Action = { type: "INCREMENT"; amount: number } | { type: "DECREMENT"; amount: number } | { type: "RESET" };',
    expected: { type: 'INCREMENT', amount: 5 },
    sample:
      'const increment = (amount: number): Action => ({ type: "INCREMENT", amount });\nincrement(5)',
    hints: ['Factory returns specific variant', 'Return type is full union'],
    tags: ['discriminated-union', 'action-creator', 'redux'],
  },

  // ============================================================
  // Type Guards
  // ============================================================
  {
    id: 'ts-guard-770',
    category: 'Type Guards',
    difficulty: 'easy',
    title: 'Basic typeof Guard',
    text: 'Use typeof to narrow union type',
    setup:
      'function process(val: string | number): string { return typeof val === "string" ? val.toUpperCase() : val.toFixed(2); }',
    setupCode:
      'function process(val: string | number): string { return typeof val === "string" ? val.toUpperCase() : val.toFixed(2); }',
    expected: 'HELLO',
    sample: 'process("hello")',
    hints: ['typeof narrows type', 'Each branch has specific type'],
    tags: ['type-guard', 'typeof', 'narrowing'],
  },
  {
    id: 'ts-guard-771',
    category: 'Type Guards',
    difficulty: 'medium',
    title: 'Custom Type Guard Function',
    text: 'Create a custom type guard predicate',
    setup:
      'interface Dog { bark(): string; }\ninterface Cat { meow(): string; }\nfunction isDog(pet: Dog | Cat): pet is Dog { return (pet as Dog).bark !== undefined; }',
    setupCode:
      'interface Dog { bark(): string; }\ninterface Cat { meow(): string; }\nfunction isDog(pet: Dog | Cat): pet is Dog { return (pet as Dog).bark !== undefined; }',
    expected: 'Woof!',
    sample: 'const pet: Dog | Cat = { bark: () => "Woof!" };\nisDog(pet) ? pet.bark() : pet.meow()',
    hints: ['pet is Dog is type predicate', 'Returns boolean narrows type'],
    tags: ['type-guard', 'custom', 'predicate'],
  },
  {
    id: 'ts-guard-772',
    category: 'Type Guards',
    difficulty: 'medium',
    title: 'instanceof Type Guard',
    text: 'Use instanceof to narrow class types',
    setup:
      'class HttpError { constructor(public status: number) {} }\nclass NetworkError { constructor(public message: string) {} }',
    setupCode:
      'class HttpError { constructor(public status: number) {} }\nclass NetworkError { constructor(public message: string) {} }',
    expected: 404,
    sample:
      'function getCode(err: HttpError | NetworkError): number { return err instanceof HttpError ? err.status : 0; }\ngetCode(new HttpError(404))',
    hints: ['instanceof checks class', 'Narrows to specific class'],
    tags: ['type-guard', 'instanceof', 'class'],
  },
  {
    id: 'ts-guard-773',
    category: 'Type Guards',
    difficulty: 'hard',
    title: 'Assertion Function',
    text: 'Create an assertion function that throws on invalid input',
    setup:
      'function assertString(val: unknown): asserts val is string { if (typeof val !== "string") throw new Error("Not a string"); }',
    setupCode:
      'function assertString(val: unknown): asserts val is string { if (typeof val !== "string") throw new Error("Not a string"); }',
    expected: 'HELLO',
    sample:
      'function process(val: unknown): string { assertString(val); return val.toUpperCase(); }\nprocess("hello")',
    hints: ['asserts keyword for assertions', 'Throws if not matching'],
    tags: ['type-guard', 'assertion', 'throws'],
  },
  {
    id: 'ts-guard-774',
    category: 'Type Guards',
    difficulty: 'medium',
    title: 'in Operator Guard',
    text: 'Use in operator to narrow object types',
    setup: 'type Bird = { fly(): string };\ntype Fish = { swim(): string };',
    setupCode: 'type Bird = { fly(): string };\ntype Fish = { swim(): string };',
    expected: 'Flying',
    sample:
      'function move(animal: Bird | Fish): string { return "fly" in animal ? animal.fly() : animal.swim(); }\nmove({ fly: () => "Flying" })',
    hints: ['in checks property existence', 'Narrows to type with property'],
    tags: ['type-guard', 'in-operator', 'narrowing'],
  },
  {
    id: 'ts-guard-775',
    category: 'Type Guards',
    difficulty: 'hard',
    title: 'Generic Type Guard',
    text: 'Create a generic type guard for arrays',
    setup:
      'function isArrayOf<T>(arr: unknown, check: (item: unknown) => item is T): arr is T[] { return Array.isArray(arr) && arr.every(check); }\nfunction isString(x: unknown): x is string { return typeof x === "string"; }',
    setupCode:
      'function isArrayOf<T>(arr: unknown, check: (item: unknown) => item is T): arr is T[] { return Array.isArray(arr) && arr.every(check); }\nfunction isString(x: unknown): x is string { return typeof x === "string"; }',
    expected: true,
    sample: 'const data: unknown = ["a", "b", "c"];\nisArrayOf(data, isString)',
    hints: ['Generic guard with callback', 'Check each element'],
    tags: ['type-guard', 'generic', 'array'],
  },
  {
    id: 'ts-guard-776',
    category: 'Type Guards',
    difficulty: 'hard',
    title: 'Assertion with Condition',
    text: 'Create assertion that checks specific condition',
    setup:
      'function assertDefined<T>(val: T | undefined | null, msg?: string): asserts val is T { if (val == null) throw new Error(msg ?? "Value is null or undefined"); }',
    setupCode:
      'function assertDefined<T>(val: T | undefined | null, msg?: string): asserts val is T { if (val == null) throw new Error(msg ?? "Value is null or undefined"); }',
    expected: 5,
    sample:
      'function process(val: number | undefined): number { assertDefined(val); return val * val; }\nprocess(Math.sqrt(25))',
    hints: ['Generic assertion function', 'Removes undefined/null'],
    tags: ['type-guard', 'assertion', 'defined'],
  },
  {
    id: 'ts-guard-777',
    category: 'Type Guards',
    difficulty: 'medium',
    title: 'Discriminated Union Guard',
    text: 'Type guard for discriminated union member',
    setup:
      'type Result = { ok: true; value: number } | { ok: false; error: string };\nfunction isSuccess(r: Result): r is { ok: true; value: number } { return r.ok === true; }',
    setupCode:
      'type Result = { ok: true; value: number } | { ok: false; error: string };\nfunction isSuccess(r: Result): r is { ok: true; value: number } { return r.ok === true; }',
    expected: 42,
    sample: 'const result: Result = { ok: true, value: 42 };\nisSuccess(result) ? result.value : 0',
    hints: ['Check discriminant property', 'Narrows to specific variant'],
    tags: ['type-guard', 'discriminated-union', 'predicate'],
  },
  {
    id: 'ts-guard-778',
    category: 'Type Guards',
    difficulty: 'hard',
    title: 'Type Guard with Type Parameter Constraint',
    text: 'Create a guard that checks for specific property',
    setup:
      'function hasProperty<T extends object, K extends string>(obj: T, key: K): obj is T & Record<K, unknown> { return key in obj; }',
    setupCode:
      'function hasProperty<T extends object, K extends string>(obj: T, key: K): obj is T & Record<K, unknown> { return key in obj; }',
    expected: 'Alice',
    sample:
      'const obj: object = { name: "Alice" };\nhasProperty(obj, "name") ? (obj as { name: string }).name : "unknown"',
    hints: ['Intersection adds property', 'Generic for any key'],
    tags: ['type-guard', 'generic', 'property'],
  },
  {
    id: 'ts-guard-779',
    category: 'Type Guards',
    difficulty: 'hard',
    title: 'Negated Type Guard',
    text: 'Create a guard for excluding types',
    setup: 'function isNotNull<T>(val: T | null): val is T { return val !== null; }',
    setupCode: 'function isNotNull<T>(val: T | null): val is T { return val !== null; }',
    expected: [1, 2, 3],
    sample: 'const arr: (number | null)[] = [1, null, 2, null, 3];\narr.filter(isNotNull)',
    hints: ['Filter removes nulls', 'Type narrows in filter'],
    tags: ['type-guard', 'filter', 'null'],
  },

  // ============================================================
  // Branded Types
  // ============================================================
  {
    id: 'ts-branded-780',
    category: 'Branded Types',
    difficulty: 'medium',
    title: 'Basic Branded Type',
    text: 'Create a branded type for validated emails',
    setup: 'type Brand<T, B> = T & { __brand: B };\ntype Email = Brand<string, "Email">;',
    setupCode: 'type Brand<T, B> = T & { __brand: B };\ntype Email = Brand<string, "Email">;',
    expected: 'test@example.com',
    sample:
      'function validateEmail(s: string): Email { if (!s.includes("@")) throw new Error("Invalid"); return s as Email; }\nconst email: Email = validateEmail("test@example.com");\nemail',
    hints: ['Brand adds phantom type', 'Assertion after validation'],
    tags: ['branded-types', 'validation', 'email'],
  },
  {
    id: 'ts-branded-781',
    category: 'Branded Types',
    difficulty: 'medium',
    title: 'Type-Safe ID',
    text: 'Create distinct ID types for different entities',
    setup:
      'type UserId = Brand<number, "UserId">;\ntype PostId = Brand<number, "PostId">;\ntype Brand<T, B> = T & { __brand: B };',
    setupCode:
      'type UserId = Brand<number, "UserId">;\ntype PostId = Brand<number, "PostId">;\ntype Brand<T, B> = T & { __brand: B };',
    expected: 1,
    sample:
      'function getUser(id: UserId): number { return id; }\nconst userId = 1 as UserId;\ngetUser(userId)',
    hints: ['Different brands are incompatible', 'Prevents mixing IDs'],
    tags: ['branded-types', 'id', 'type-safe'],
  },
  {
    id: 'ts-branded-782',
    category: 'Branded Types',
    difficulty: 'hard',
    title: 'Positive Number Brand',
    text: 'Create a branded type for positive numbers',
    setup:
      'type Positive = number & { __positive: true };\nfunction toPositive(n: number): Positive { if (n <= 0) throw new Error("Not positive"); return n as Positive; }',
    setupCode:
      'type Positive = number & { __positive: true };\nfunction toPositive(n: number): Positive { if (n <= 0) throw new Error("Not positive"); return n as Positive; }',
    expected: 25,
    sample: 'function square(n: Positive): number { return n * n; }\nsquare(toPositive(5))',
    hints: ['Runtime validation required', 'Compile-time type safety'],
    tags: ['branded-types', 'positive', 'validation'],
  },
  {
    id: 'ts-branded-783',
    category: 'Branded Types',
    difficulty: 'hard',
    title: 'Non-Empty Array Brand',
    text: 'Create a branded type for non-empty arrays',
    setup:
      'type NonEmptyArray<T> = [T, ...T[]] & { __nonEmpty: true };\nfunction toNonEmpty<T>(arr: T[]): NonEmptyArray<T> { if (arr.length === 0) throw new Error("Empty"); return arr as NonEmptyArray<T>; }',
    setupCode:
      'type NonEmptyArray<T> = [T, ...T[]] & { __nonEmpty: true };\nfunction toNonEmpty<T>(arr: T[]): NonEmptyArray<T> { if (arr.length === 0) throw new Error("Empty"); return arr as NonEmptyArray<T>; }',
    expected: 1,
    sample:
      'function first<T>(arr: NonEmptyArray<T>): T { return arr[0]; }\nfirst(toNonEmpty([1, 2, 3]))',
    hints: ['Tuple ensures at least one', 'Brand adds nominal typing'],
    tags: ['branded-types', 'non-empty', 'array'],
  },
  {
    id: 'ts-branded-784',
    category: 'Branded Types',
    difficulty: 'medium',
    title: 'Currency Brand',
    text: 'Create branded types for different currencies',
    setup:
      'type USD = Brand<number, "USD">;\ntype EUR = Brand<number, "EUR">;\ntype Brand<T, B> = T & { __brand: B };',
    setupCode:
      'type USD = Brand<number, "USD">;\ntype EUR = Brand<number, "EUR">;\ntype Brand<T, B> = T & { __brand: B };',
    expected: 200,
    sample:
      'function addUSD(a: USD, b: USD): USD { return (a + b) as USD; }\naddUSD(100 as USD, 100 as USD)',
    hints: ['Prevents mixing currencies', 'Type-safe arithmetic'],
    tags: ['branded-types', 'currency', 'type-safe'],
  },
  {
    id: 'ts-branded-785',
    category: 'Branded Types',
    difficulty: 'hard',
    title: 'URL Brand with Validation',
    text: 'Create a branded URL type with validation',
    setup:
      'type ValidURL = string & { __validUrl: true };\nfunction toURL(s: string): ValidURL { try { new URL(s); return s as ValidURL; } catch { throw new Error("Invalid URL"); } }',
    setupCode:
      'type ValidURL = string & { __validUrl: true };\nfunction toURL(s: string): ValidURL { try { new URL(s); return s as ValidURL; } catch { throw new Error("Invalid URL"); } }',
    expected: 'https://example.com',
    sample: 'const url: ValidURL = toURL("https://example.com");\nurl',
    hints: ['URL constructor validates', 'Brand ensures validation happened'],
    tags: ['branded-types', 'url', 'validation'],
  },
  {
    id: 'ts-branded-786',
    category: 'Branded Types',
    difficulty: 'hard',
    title: 'Integer Brand',
    text: 'Create a branded type for integers only',
    setup:
      'type Integer = number & { __integer: true };\nfunction toInteger(n: number): Integer { if (!Number.isInteger(n)) throw new Error("Not integer"); return n as Integer; }',
    setupCode:
      'type Integer = number & { __integer: true };\nfunction toInteger(n: number): Integer { if (!Number.isInteger(n)) throw new Error("Not integer"); return n as Integer; }',
    expected: 6,
    sample:
      'function factorial(n: Integer): Integer { return n <= 1 ? (1 as Integer) : ((n * factorial(toInteger(n - 1))) as Integer); }\nfactorial(toInteger(3))',
    hints: ['Number.isInteger checks', 'Prevents floating point'],
    tags: ['branded-types', 'integer', 'validation'],
  },
  {
    id: 'ts-branded-787',
    category: 'Branded Types',
    difficulty: 'medium',
    title: 'Sanitized String Brand',
    text: 'Create a branded type for sanitized HTML strings',
    setup:
      'type SafeHTML = string & { __safe: true };\nfunction sanitize(s: string): SafeHTML { return s.replace(/</g, "&lt;").replace(/>/g, "&gt;") as SafeHTML; }',
    setupCode:
      'type SafeHTML = string & { __safe: true };\nfunction sanitize(s: string): SafeHTML { return s.replace(/</g, "&lt;").replace(/>/g, "&gt;") as SafeHTML; }',
    expected: '&lt;script&gt;',
    sample: 'const safe: SafeHTML = sanitize("<script>");\nsafe',
    hints: ['Escapes HTML characters', 'Brand indicates safety'],
    tags: ['branded-types', 'html', 'security'],
  },
  {
    id: 'ts-branded-788',
    category: 'Branded Types',
    difficulty: 'hard',
    title: 'Bounded Number Brand',
    text: 'Create a branded type for numbers in range',
    setup:
      'type Percentage = number & { __percentage: true };\nfunction toPercentage(n: number): Percentage { if (n < 0 || n > 100) throw new Error("Out of range"); return n as Percentage; }',
    setupCode:
      'type Percentage = number & { __percentage: true };\nfunction toPercentage(n: number): Percentage { if (n < 0 || n > 100) throw new Error("Out of range"); return n as Percentage; }',
    expected: 0.75,
    sample:
      'function toDecimal(p: Percentage): number { return p / 100; }\ntoDecimal(toPercentage(75))',
    hints: ['Range validation at runtime', 'Brand ensures valid range'],
    tags: ['branded-types', 'percentage', 'bounded'],
  },
  {
    id: 'ts-branded-789',
    category: 'Branded Types',
    difficulty: 'hard',
    title: 'Opaque Type Pattern',
    text: 'Create opaque types using unique symbols',
    setup:
      'declare const OpaqueTag: unique symbol;\ntype Opaque<T, K> = T & { [OpaqueTag]: K };\ntype Meters = Opaque<number, "Meters">;\ntype Feet = Opaque<number, "Feet">;',
    setupCode:
      'declare const OpaqueTag: unique symbol;\ntype Opaque<T, K> = T & { [OpaqueTag]: K };\ntype Meters = Opaque<number, "Meters">;\ntype Feet = Opaque<number, "Feet">;',
    expected: 3.28,
    sample:
      'function metersToFeet(m: Meters): Feet { return (m * 3.28) as Feet; }\nconst distance = 1 as Meters;\nMath.round(metersToFeet(distance) * 100) / 100',
    hints: ['unique symbol is truly unique', 'More robust than string brand'],
    tags: ['branded-types', 'opaque', 'symbol'],
  },

  // ============================================================
  // Utility Types - Custom
  // ============================================================
  {
    id: 'ts-util-790',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'PartialBy Type',
    text: 'Make only specific properties optional',
    setup: 'type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;',
    setupCode: 'type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;',
    expected: { id: 1, name: 'Test' },
    sample:
      'type User = { id: number; name: string; email: string };\ntype CreateUser = PartialBy<User, "id">;\nconst user: CreateUser = { name: "Test", id: 1 };\n({ id: user.id!, name: user.name })',
    hints: ['Omit removes then Partial makes optional', 'Intersection combines'],
    tags: ['utility-types', 'partial', 'custom'],
  },
  {
    id: 'ts-util-791',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'RequiredBy Type',
    text: 'Make only specific properties required',
    setup: 'type RequiredBy<T, K extends keyof T> = T & Required<Pick<T, K>>;',
    setupCode: 'type RequiredBy<T, K extends keyof T> = T & Required<Pick<T, K>>;',
    expected: { name: 'Test' },
    sample:
      'type Config = { name?: string; debug?: boolean };\ntype WithName = RequiredBy<Config, "name">;\nconst config: WithName = { name: "Test" };\n({ name: config.name })',
    hints: ['Required on picked keys', 'Intersection adds constraint'],
    tags: ['utility-types', 'required', 'custom'],
  },
  {
    id: 'ts-util-792',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'DeepPick Type',
    text: 'Pick deeply nested properties',
    setup:
      'type DeepPick<T, K extends string> = K extends `${infer Head}.${infer Tail}` ? Head extends keyof T ? { [P in Head]: DeepPick<T[P], Tail> } : never : K extends keyof T ? { [P in K]: T[P] } : never;',
    setupCode:
      'type DeepPick<T, K extends string> = K extends `${infer Head}.${infer Tail}` ? Head extends keyof T ? { [P in Head]: DeepPick<T[P], Tail> } : never : K extends keyof T ? { [P in K]: T[P] } : never;',
    expected: { user: { name: 'Alice' } },
    sample:
      'type State = { user: { name: string; age: number }; settings: { theme: string } };\ntype Picked = DeepPick<State, "user.name">;\nconst obj: Picked = { user: { name: "Alice" } };\nobj',
    hints: ['Parse path with template literal', 'Recursive for depth'],
    tags: ['utility-types', 'deep', 'pick'],
  },
  {
    id: 'ts-util-793',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Merge Type',
    text: 'Merge two types with second overwriting first',
    setup: 'type Merge<T, U> = Omit<T, keyof U> & U;',
    setupCode: 'type Merge<T, U> = Omit<T, keyof U> & U;',
    expected: { a: 1, b: 'updated', c: true },
    sample:
      'type A = { a: number; b: number };\ntype B = { b: string; c: boolean };\ntype Merged = Merge<A, B>;\nconst obj: Merged = { a: 1, b: "updated", c: true };\nobj',
    hints: ['Omit conflicting keys', 'Second type wins'],
    tags: ['utility-types', 'merge', 'overwrite'],
  },
  {
    id: 'ts-util-794',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'UnionToIntersection Type',
    text: 'Convert union type to intersection',
    setup:
      'type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;',
    setupCode:
      'type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;',
    expected: { a: 1, b: 2 },
    sample:
      'type Union = { a: number } | { b: number };\ntype Inter = UnionToIntersection<Union>;\nconst obj: Inter = { a: 1, b: 2 };\nobj',
    hints: ['Contravariant position trick', 'Function params are contravariant'],
    tags: ['utility-types', 'union', 'intersection'],
  },
  {
    id: 'ts-util-795',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'Mutable Type',
    text: 'Remove readonly from all properties',
    setup: 'type Mutable<T> = { -readonly [K in keyof T]: T[K] };',
    setupCode: 'type Mutable<T> = { -readonly [K in keyof T]: T[K] };',
    expected: { x: 10 },
    sample:
      'type Frozen = { readonly x: number; readonly y: number };\ntype Mut = Mutable<Frozen>;\nconst obj: Mut = { x: 5, y: 5 };\nobj.x = 10;\n({ x: obj.x })',
    hints: ['-readonly removes modifier', 'Allows mutation'],
    tags: ['utility-types', 'mutable', 'readonly'],
  },
  {
    id: 'ts-util-796',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'Prettify Type',
    text: 'Flatten intersection into readable type',
    setup: 'type Prettify<T> = { [K in keyof T]: T[K] } & {};',
    setupCode: 'type Prettify<T> = { [K in keyof T]: T[K] } & {};',
    expected: { a: 1, b: 2 },
    sample:
      'type Ugly = { a: number } & { b: number };\ntype Pretty = Prettify<Ugly>;\nconst obj: Pretty = { a: 1, b: 2 };\nobj',
    hints: ['Maps over all keys', 'Flattens for IDE display'],
    tags: ['utility-types', 'prettify', 'intersection'],
  },
  {
    id: 'ts-util-797',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'XOR Type',
    text: 'Create exclusive or type for objects',
    setup:
      'type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\ntype XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;',
    setupCode:
      'type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\ntype XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;',
    expected: { type: 'a', a: 1 },
    sample:
      'type A = { type: "a"; a: number };\ntype B = { type: "b"; b: string };\ntype Either = XOR<A, B>;\nconst obj: Either = { type: "a", a: 1 };\nobj',
    hints: ['Exclusive union pattern', 'Prevents mixing properties'],
    tags: ['utility-types', 'xor', 'exclusive'],
  },
  {
    id: 'ts-util-798',
    category: 'Utility Types',
    difficulty: 'medium',
    title: 'ValueOf Type',
    text: 'Extract all value types from object',
    setup: 'type ValueOf<T> = T[keyof T];',
    setupCode: 'type ValueOf<T> = T[keyof T];',
    expected: 42,
    sample:
      'type Config = { port: number; host: string; debug: boolean };\ntype Values = ValueOf<Config>;\nconst val: Values = 42;\nval',
    hints: ['Index with keyof', 'Creates union of values'],
    tags: ['utility-types', 'valueof', 'union'],
  },
  {
    id: 'ts-util-799',
    category: 'Utility Types',
    difficulty: 'hard',
    title: 'FunctionKeys Type',
    text: 'Extract only function property keys',
    setup:
      'type FunctionKeys<T> = { [K in keyof T]: T[K] extends (...args: any[]) => any ? K : never }[keyof T];',
    setupCode:
      'type FunctionKeys<T> = { [K in keyof T]: T[K] extends (...args: any[]) => any ? K : never }[keyof T];',
    expected: 'greet',
    sample:
      'type Obj = { name: string; age: number; greet(): void };\ntype FnKeys = FunctionKeys<Obj>;\nconst key: FnKeys = "greet";\nkey',
    hints: ['Map then index to filter', 'never removes non-functions'],
    tags: ['utility-types', 'function-keys', 'filter'],
  },

  // ============================================================
  // Declaration Files
  // ============================================================
  {
    id: 'ts-decl-800',
    category: 'Declaration Files',
    difficulty: 'easy',
    title: 'Declare Global Variable',
    text: 'Declare a global variable type',
    setup: 'declare const VERSION: string;',
    setupCode: 'declare const VERSION: string;\n(globalThis as any).VERSION = "1.0.0";',
    expected: '1.0.0',
    sample: 'VERSION',
    hints: ['declare without implementation', 'Ambient declaration'],
    tags: ['declaration', 'global', 'ambient'],
  },
  {
    id: 'ts-decl-801',
    category: 'Declaration Files',
    difficulty: 'medium',
    title: 'Declare Module Augmentation',
    text: 'Augment existing module with new properties',
    setup: 'interface String { toTitleCase(): string; }',
    setupCode:
      'interface String { toTitleCase(): string; }\nString.prototype.toTitleCase = function() { return this.charAt(0).toUpperCase() + this.slice(1); };',
    expected: 'Hello',
    sample: '"hello".toTitleCase()',
    hints: ['Interface merging adds methods', 'Augments built-in type'],
    tags: ['declaration', 'augmentation', 'interface'],
  },
  {
    id: 'ts-decl-802',
    category: 'Declaration Files',
    difficulty: 'medium',
    title: 'Declare Namespace',
    text: 'Create namespace for library types',
    setup:
      'declare namespace MyLib { interface Config { name: string; } function init(config: Config): void; }',
    setupCode:
      'declare namespace MyLib { interface Config { name: string; } function init(config: Config): void; }\n(globalThis as any).MyLib = { init: (c: any) => c.name };',
    expected: 'App',
    sample: 'const config: MyLib.Config = { name: "App" };\nMyLib.init(config);\nconfig.name',
    hints: ['namespace groups declarations', 'Dot notation access'],
    tags: ['declaration', 'namespace', 'library'],
  },
  {
    id: 'ts-decl-803',
    category: 'Declaration Files',
    difficulty: 'hard',
    title: 'Declare Class with Static',
    text: 'Declare a class with static members',
    setup:
      'declare class Logger { static level: string; static log(msg: string): void; constructor(name: string); name: string; info(msg: string): void; }',
    setupCode:
      'declare class Logger { static level: string; static log(msg: string): void; constructor(name: string); name: string; info(msg: string): void; }\n(globalThis as any).Logger = class { static level = "info"; static log(m: string) {} constructor(public name: string) {} info(m: string) {} };',
    expected: 'info',
    sample: 'Logger.level',
    hints: ['static for class properties', 'Both instance and static'],
    tags: ['declaration', 'class', 'static'],
  },
  {
    id: 'ts-decl-804',
    category: 'Declaration Files',
    difficulty: 'hard',
    title: 'Declare Function Overloads',
    text: 'Declare function with multiple signatures',
    setup:
      'declare function parse(input: string): object;\ndeclare function parse(input: string, reviver: (key: string, value: any) => any): object;',
    setupCode:
      'declare function parse(input: string): object;\ndeclare function parse(input: string, reviver: (key: string, value: any) => any): object;\n(globalThis as any).parse = JSON.parse;',
    expected: { a: 1 },
    sample: 'parse(\'{"a": 1}\')',
    hints: ['Multiple declare signatures', 'Overloads in declarations'],
    tags: ['declaration', 'overload', 'function'],
  },

  // ========================================
  // BEGINNER FUNDAMENTALS
  // ========================================

  // -- For Loops & Iteration (5 problems) --
  {
    id: 'ts-beginner-loop-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Sum Numbers with For Loop',
    text: 'Use a for loop to sum all numbers in the typed array',
    setup: 'const nums: number[] = [1, 2, 3, 4, 5];',
    setupCode: 'const nums: number[] = [1, 2, 3, 4, 5];',
    expected: 15,
    sample: 'let sum = 0; for (let i = 0; i < nums.length; i++) { sum += nums[i]; } sum',
    hints: [
      'Initialize a sum variable before the loop',
      'Use array.length to know when to stop',
      'Add each element to the sum',
    ],
    tags: ['beginner', 'loop', 'for'],
  },
  {
    id: 'ts-beginner-loop-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Count Even Numbers',
    text: 'Use a for loop to count how many even numbers are in the array',
    setup: 'const nums: number[] = [1, 2, 3, 4, 5, 6, 7, 8];',
    setupCode: 'const nums: number[] = [1, 2, 3, 4, 5, 6, 7, 8];',
    expected: 4,
    sample:
      'let count = 0; for (let i = 0; i < nums.length; i++) { if (nums[i] % 2 === 0) count++; } count',
    hints: [
      'Use modulo (%) to check if a number is even',
      'Increment a counter when you find an even number',
      'A number is even if num % 2 === 0',
    ],
    tags: ['beginner', 'loop', 'for', 'conditional'],
  },
  {
    id: 'ts-beginner-loop-003',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'For...of Loop with Strings',
    text: 'Use a for...of loop to concatenate all strings in the array',
    setup: 'const words: string[] = ["hello", " ", "world"];',
    setupCode: 'const words: string[] = ["hello", " ", "world"];',
    expected: 'hello world',
    sample: 'let result = ""; for (const word of words) { result += word; } result',
    hints: [
      'for...of iterates over values directly',
      'Concatenate strings using +=',
      'No need for index access',
    ],
    tags: ['beginner', 'loop', 'for-of'],
  },
  {
    id: 'ts-beginner-loop-004',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Find Maximum with Loop',
    text: 'Use a for loop to find the maximum number in the array',
    setup: 'const nums: number[] = [3, 7, 2, 9, 1, 5];',
    setupCode: 'const nums: number[] = [3, 7, 2, 9, 1, 5];',
    expected: 9,
    sample:
      'let max = nums[0]; for (let i = 1; i < nums.length; i++) { if (nums[i] > max) max = nums[i]; } max',
    hints: [
      'Initialize max with the first element',
      'Compare each element with the current max',
      'Update max when you find a larger value',
    ],
    tags: ['beginner', 'loop', 'for', 'max'],
  },
  {
    id: 'ts-beginner-loop-005',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Build Array with Loop',
    text: 'Use a for loop to build an array of numbers from 1 to 5',
    setup: '',
    setupCode: '',
    expected: [1, 2, 3, 4, 5],
    sample: 'const result: number[] = []; for (let i = 1; i <= 5; i++) { result.push(i); } result',
    hints: [
      'Create an empty array first',
      'Use push() to add elements',
      'Loop from 1 to 5 (inclusive)',
    ],
    tags: ['beginner', 'loop', 'for', 'array'],
  },

  // -- Conditionals (4 problems) --
  {
    id: 'ts-beginner-cond-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'If/Else with Number Type',
    text: 'Use if/else to return "positive", "negative", or "zero" based on the typed number',
    setup: 'const num: number = -5;',
    setupCode: 'const num: number = -5;',
    expected: 'negative',
    sample: 'num > 0 ? "positive" : num < 0 ? "negative" : "zero"',
    hints: [
      'Check if num > 0 for positive',
      'Check if num < 0 for negative',
      'Otherwise it is zero',
    ],
    tags: ['beginner', 'conditional', 'if-else'],
  },
  {
    id: 'ts-beginner-cond-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Ternary with Type Narrowing',
    text: 'Use a ternary operator to return "even" or "odd" for the number',
    setup: 'const num: number = 7;',
    setupCode: 'const num: number = 7;',
    expected: 'odd',
    sample: 'num % 2 === 0 ? "even" : "odd"',
    hints: ['Use modulo (%) to check divisibility', 'Ternary: condition ? trueValue : falseValue'],
    tags: ['beginner', 'conditional', 'ternary'],
  },
  {
    id: 'ts-beginner-cond-003',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Switch Statement with String Literal',
    text: 'Use a switch statement to return the day type: "weekend" for Sat/Sun, "weekday" otherwise',
    setup: 'const day: string = "Saturday";',
    setupCode: 'const day: string = "Saturday";',
    expected: 'weekend',
    sample:
      'switch (day) { case "Saturday": case "Sunday": return "weekend"; default: return "weekday"; }',
    hints: [
      'Use switch with fall-through for multiple cases',
      'Saturday and Sunday should return "weekend"',
      'Use default for all other days',
    ],
    tags: ['beginner', 'conditional', 'switch'],
  },
  {
    id: 'ts-beginner-cond-004',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Nullish Check with Type Guard',
    text: 'Return "exists" if value is not null/undefined, "missing" otherwise',
    setup: 'const value: string | null = "hello";',
    setupCode: 'const value: string | null = "hello";',
    expected: 'exists',
    sample: 'value != null ? "exists" : "missing"',
    hints: [
      'Use != null to check for both null and undefined',
      'TypeScript narrows the type in the true branch',
    ],
    tags: ['beginner', 'conditional', 'nullish', 'type-guard'],
  },

  // -- Arrays (3 problems) --
  {
    id: 'ts-beginner-array-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Typed Array Push',
    text: 'Add the string "world" to the typed array',
    setup: 'const words: string[] = ["hello"];',
    setupCode: 'const words: string[] = ["hello"];',
    expected: ['hello', 'world'],
    sample: 'words.push("world"); words',
    hints: ['Use push() to add to the end', 'TypeScript ensures you add the correct type'],
    tags: ['beginner', 'array', 'push'],
  },
  {
    id: 'ts-beginner-array-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Access Typed Array Element',
    text: 'Get the second element (index 1) from the typed array',
    setup: 'const nums: number[] = [10, 20, 30];',
    setupCode: 'const nums: number[] = [10, 20, 30];',
    expected: 20,
    sample: 'nums[1]',
    hints: ['Arrays are zero-indexed', 'The second element is at index 1'],
    tags: ['beginner', 'array', 'access'],
  },
  {
    id: 'ts-beginner-array-003',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Typed Array Length',
    text: 'Return the length of the typed array',
    setup: 'const items: string[] = ["a", "b", "c", "d"];',
    setupCode: 'const items: string[] = ["a", "b", "c", "d"];',
    expected: 4,
    sample: 'items.length',
    hints: ['Use the .length property', 'Length is always a number'],
    tags: ['beginner', 'array', 'length'],
  },

  // -- Map/Set (2 problems) --
  {
    id: 'ts-beginner-map-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Map Set and Get',
    text: 'Create a Map<string, number>, set "age" to 25, then get "age"',
    setup: '',
    setupCode: '',
    expected: 25,
    sample: 'const map = new Map<string, number>(); map.set("age", 25); map.get("age")',
    hints: [
      'Map stores key-value pairs with types',
      'Use set(key, value) to add',
      'Use get(key) to retrieve',
    ],
    tags: ['beginner', 'map', 'set', 'get'],
  },
  {
    id: 'ts-beginner-map-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Set Add and Has',
    text: 'Create a Set<string>, add "apple", then check if it has "apple"',
    setup: '',
    setupCode: '',
    expected: true,
    sample: 'const set = new Set<string>(); set.add("apple"); set.has("apple")',
    hints: [
      'Set stores unique values',
      'Use add(value) to insert',
      'Use has(value) to check membership',
    ],
    tags: ['beginner', 'set', 'add', 'has'],
  },

  // -- Functions (2 problems) --
  {
    id: 'ts-beginner-func-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Typed Function Definition',
    text: 'Define a function that takes two numbers and returns their sum (with proper types)',
    setup: '',
    setupCode: '',
    expected: 8,
    sample: 'function add(a: number, b: number): number { return a + b; } add(3, 5)',
    hints: [
      'Annotate parameter types: (a: number, b: number)',
      'Annotate return type: ): number',
      'Return the sum',
    ],
    tags: ['beginner', 'function', 'types'],
  },
  {
    id: 'ts-beginner-func-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Arrow Function with Types',
    text: 'Define an arrow function that takes a string and returns its length',
    setup: '',
    setupCode: '',
    expected: 5,
    sample: 'const getLength = (s: string): number => s.length; getLength("hello")',
    hints: [
      'Arrow function syntax: (param: Type): ReturnType => expression',
      'Use .length property on strings',
    ],
    tags: ['beginner', 'function', 'arrow', 'types'],
  },
  {
    id: 'ts-beginner-string-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'String Concatenation with Types',
    text: 'Write a typed function that concatenates two strings with a space between them.',
    setup: '',
    setupCode: '',
    expected: 'Hello World',
    sample:
      'function concat(a: string, b: string): string { return a + " " + b; } concat("Hello", "World")',
    hints: [
      'Annotate parameters: (a: string, b: string)',
      'Annotate return type: ): string',
      'Use + operator to concatenate',
    ],
    tags: ['beginner', 'strings', 'types', 'concatenation'],
  },
  {
    id: 'ts-beginner-string-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'String Length',
    text: 'Write a typed function that returns the length of a given string.',
    setup: '',
    setupCode: '',
    expected: 11,
    sample:
      'function getLength(str: string): number { return str.length; } getLength("hello world")',
    hints: ['Parameter type: string', 'Return type: number', 'Use .length property'],
    tags: ['beginner', 'strings', 'types', 'length'],
  },
  {
    id: 'ts-beginner-string-003',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'String Template Literals',
    text: 'Write a function that uses template literals to create a greeting message.',
    setup: '',
    setupCode: '',
    expected: 'Hello, Alice!',
    sample: 'function greet(name: string): string { return `Hello, ${name}!`; } greet("Alice")',
    hints: [
      'Use backticks ` ` for template literals',
      'Use ${variable} syntax for interpolation',
      'Return type is string',
    ],
    tags: ['beginner', 'strings', 'types', 'template-literals'],
  },
  {
    id: 'ts-beginner-while-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Basic While Loop',
    text: 'Write a typed function that uses a while loop to sum numbers from 1 to n.',
    setup: '',
    setupCode: '',
    expected: 15,
    sample:
      'function sumWhile(n: number): number { let sum = 0; let i = 1; while (i <= n) { sum += i; i++; } return sum; } sumWhile(5)',
    hints: [
      'Parameter type: number',
      'Return type: number',
      'Initialize counter and sum',
      '1 + 2 + 3 + 4 + 5 = 15',
    ],
    tags: ['beginner', 'loops', 'while', 'types'],
  },
  {
    id: 'ts-beginner-while-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'While Loop with Typed Condition',
    text: 'Write a typed function that counts how many times you can divide n by 2 until it becomes less than 1.',
    setup: '',
    setupCode: '',
    expected: 3,
    sample:
      'function countDivisions(n: number): number { let count = 0; while (n >= 1) { n = n / 2; count++; } return count; } countDivisions(8)',
    hints: [
      'Both parameter and return are number type',
      'While n >= 1, divide by 2',
      '8 -> 4 -> 2 -> 1 (3 divisions)',
    ],
    tags: ['beginner', 'loops', 'while', 'types', 'conditions'],
  },
  {
    id: 'ts-beginner-nested-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Simple Nested Loop',
    text: 'Write a typed function with nested loops to count total iterations.',
    setup: '',
    setupCode: '',
    expected: 12,
    sample:
      'function nestedCount(n: number, m: number): number { let count = 0; for (let i = 0; i < n; i++) { for (let j = 0; j < m; j++) { count++; } } return count; } nestedCount(3, 4)',
    hints: [
      'Two number parameters, number return',
      'Nested for loops',
      'Total iterations = n * m',
      '3 * 4 = 12',
    ],
    tags: ['beginner', 'loops', 'nested', 'for', 'types'],
  },
  {
    id: 'ts-beginner-bool-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Boolean AND/OR with Types',
    text: 'Write a typed function that returns true if a number is between 10 and 20 (inclusive).',
    setup: '',
    setupCode: '',
    expected: true,
    sample: 'function isBetween(n: number): boolean { return n >= 10 && n <= 20; } isBetween(15)',
    hints: [
      'Parameter type: number',
      'Return type: boolean',
      'Use && (AND) operator',
      'Check n >= 10 AND n <= 20',
    ],
    tags: ['beginner', 'boolean', 'types', 'conditions', 'operators'],
  },
  {
    id: 'ts-beginner-bool-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Boolean NOT',
    text: 'Write a typed function that returns true if a number is NOT equal to 0.',
    setup: '',
    setupCode: '',
    expected: true,
    sample: 'function isNotZero(n: number): boolean { return n !== 0; } isNotZero(5)',
    hints: [
      'Parameter type: number',
      'Return type: boolean',
      'Use !== operator',
      'Or use !(n === 0)',
    ],
    tags: ['beginner', 'boolean', 'not', 'types', 'operators'],
  },
  {
    id: 'ts-beginner-arr-adv-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Typed Array Reverse',
    text: 'Write a typed function that reverses an array of numbers.',
    setup: '',
    setupCode: '',
    expected: [3, 2, 1],
    sample:
      'function reverseArray(arr: number[]): number[] { return arr.reverse(); } reverseArray([1, 2, 3])',
    hints: [
      'Parameter type: number[]',
      'Return type: number[]',
      'Use .reverse() method',
      'Modifies the original array',
    ],
    tags: ['beginner', 'array', 'types', 'methods', 'reverse'],
  },
  {
    id: 'ts-beginner-arr-adv-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Array Find with Type Assertion',
    text: 'Write a typed function that checks if an array contains a specific element.',
    setup: '',
    setupCode: '',
    expected: true,
    sample:
      'function hasElement<T>(arr: T[], elem: T): boolean { return arr.includes(elem); } hasElement([1, 2, 3], 2)',
    hints: [
      'Use generic type <T> for flexibility',
      'arr: T[], elem: T, return: boolean',
      'Use .includes() method',
      'Works with any type',
    ],
    tags: ['beginner', 'array', 'types', 'generics', 'includes'],
  },
];

// Helper functions
export function getTypescriptProblemById(id: string): Problem | undefined {
  return typescriptProblems.find((p) => p.id === id);
}

export function getTypescriptProblemsByCategory(category: string): Problem[] {
  return typescriptProblems.filter((p) => p.category === category);
}

export function getTypescriptProblemsByDifficulty(difficulty: Problem['difficulty']): Problem[] {
  return typescriptProblems.filter((p) => p.difficulty === difficulty);
}

export function getTypescriptProblemsByTag(tag: string): Problem[] {
  return typescriptProblems.filter((p) => p.tags?.includes(tag));
}

export function getTypescriptCategories(): string[] {
  return [...new Set(typescriptProblems.map((p) => p.category))];
}

export default typescriptProblems;
