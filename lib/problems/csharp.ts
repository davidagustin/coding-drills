import type { Problem } from '../types';

/**
 * C# coding drill problems
 * Covers: List<T> Methods, LINQ Methods, String Methods, Array Methods
 */

export const csharpProblems: Problem[] = [
  // ============================================================
  // Modern C# Features
  // ============================================================
  {
    id: 'csharp-range-slice-1',
    category: 'Modern C# Features',
    difficulty: 'easy',
    title: 'Slice Array with Range Operator',
    text: 'Get the last 3 elements of the array using the range operator (..)',
    setup: 'int[] numbers = { 1, 2, 3, 4, 5, 6 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 4, 5, 6 };',
    expected: '{ 4, 5, 6 }',
    sample: 'numbers[^3..]',
    hints: [
      '^n means n elements from the end',
      'Range operator (..) creates a slice without copying',
    ],
    tags: ['modern', 'range', 'index', 'c#8'],
  },
  {
    id: 'csharp-range-middle-1',
    category: 'Modern C# Features',
    difficulty: 'medium',
    title: 'Extract Middle Elements with Range',
    text: 'Get elements from index 1 to 4 (exclusive) using the range operator',
    setup: 'int[] numbers = { 10, 20, 30, 40, 50 };',
    setupCode: 'int[] numbers = { 10, 20, 30, 40, 50 };',
    expected: '{ 20, 30, 40 }',
    sample: 'numbers[1..4]',
    hints: ['Range is inclusive at start, exclusive at end', 'Similar to Python slicing syntax'],
    tags: ['modern', 'range', 'slice', 'c#8'],
  },
  {
    id: 'csharp-null-coalescing-1',
    category: 'Modern C# Features',
    difficulty: 'easy',
    title: 'Null Coalescing Operator',
    text: 'Return the name or "Unknown" if null using the null-coalescing operator (??)',
    setup: 'string? name = null;',
    setupCode: 'string? name = null;',
    expected: '"Unknown"',
    sample: 'name ?? "Unknown"',
    hints: [
      '?? returns the left operand if not null, otherwise the right',
      'Works with nullable value types and reference types',
    ],
    tags: ['modern', 'null', 'coalescing', 'nullable'],
  },
  {
    id: 'csharp-null-coalescing-assign-1',
    category: 'Modern C# Features',
    difficulty: 'medium',
    title: 'Null Coalescing Assignment',
    text: 'Assign "Default" to name only if it is null using ??=',
    setup: 'string? name = null;',
    setupCode: 'string? name = null;',
    expected: 'name = "Default"',
    sample: 'name ??= "Default";',
    hints: ['??= assigns only if the variable is null', 'Introduced in C# 8.0'],
    tags: ['modern', 'null', 'assignment', 'c#8'],
  },
  {
    id: 'csharp-pattern-is-1',
    category: 'Modern C# Features',
    difficulty: 'medium',
    title: 'Pattern Matching with is',
    text: 'Check if the object is a non-null string with length > 5 using pattern matching',
    setup: 'object? value = "Hello World";',
    setupCode: 'object? value = "Hello World";',
    expected: 'true',
    sample: 'value is string s && s.Length > 5',
    hints: [
      'Pattern matching with is can declare a variable',
      'The variable is only in scope when the pattern matches',
    ],
    tags: ['modern', 'pattern', 'is', 'c#7'],
  },
  {
    id: 'csharp-switch-expression-1',
    category: 'Modern C# Features',
    difficulty: 'medium',
    title: 'Switch Expression',
    text: 'Convert day number (1-7) to day name using a switch expression',
    setup: 'int day = 3;',
    setupCode: 'int day = 3;',
    expected: '"Wednesday"',
    sample:
      'day switch { 1 => "Monday", 2 => "Tuesday", 3 => "Wednesday", 4 => "Thursday", 5 => "Friday", 6 => "Saturday", 7 => "Sunday", _ => "Invalid" }',
    hints: [
      'Switch expressions use => instead of case/break',
      'Use _ for the default/discard pattern',
    ],
    tags: ['modern', 'switch', 'expression', 'c#8'],
  },
  {
    id: 'csharp-string-interpolation-1',
    category: 'Modern C# Features',
    difficulty: 'easy',
    title: 'String Interpolation',
    text: 'Create a greeting message using string interpolation',
    setup: 'string name = "Alice";\nint age = 30;',
    setupCode: 'string name = "Alice";\nint age = 30;',
    expected: '"Hello, Alice! You are 30 years old."',
    sample: '$"Hello, {name}! You are {age} years old."',
    hints: ['String interpolation uses $ prefix', 'Expressions inside {} are evaluated at runtime'],
    tags: ['modern', 'string', 'interpolation', 'c#6'],
  },
  {
    id: 'csharp-raw-string-1',
    category: 'Modern C# Features',
    difficulty: 'medium',
    title: 'Raw String Literals',
    text: 'Create a JSON string using raw string literals (triple quotes)',
    setup: 'string name = "test";',
    setupCode: 'string name = "test";',
    expected: '{"name": "test"}',
    sample: '$$"""{"name": "{{name}}"}"""',
    hints: [
      'Raw strings start and end with """',
      'Use $$ with {{ }} for interpolation in raw strings',
      'Introduced in C# 11',
    ],
    tags: ['modern', 'string', 'raw', 'c#11'],
  },

  // ============================================================
  // List<T> Methods
  // ============================================================
  {
    id: 'csharp-list-add-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Add Element to List',
    text: 'Add the value 42 to the end of the list using Add()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    expected: '{ 1, 2, 3, 42 }',
    sample: 'numbers.Add(42);',
    hints: [
      'Add() appends a single element to the end of the list',
      'Add() modifies the list in-place and returns void',
    ],
    tags: ['list', 'add', 'collections'],
  },
  {
    id: 'csharp-list-addrange-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Add Multiple Elements',
    text: 'Add the elements { 4, 5, 6 } to the list using AddRange()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    expected: '{ 1, 2, 3, 4, 5, 6 }',
    sample: 'numbers.AddRange(new[] { 4, 5, 6 });',
    hints: ['AddRange() adds all elements from a collection to the end of the list'],
    tags: ['list', 'addrange', 'collections'],
  },
  {
    id: 'csharp-list-remove-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Remove Element by Value',
    text: 'Remove the first occurrence of the value 3 using Remove()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 3 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 3 };',
    expected: '{ 1, 2, 4, 3 }',
    sample: 'numbers.Remove(3);',
    hints: ['Remove() removes the first occurrence and returns true if found'],
    tags: ['list', 'remove', 'collections'],
  },
  {
    id: 'csharp-list-removeat-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Remove Element by Index',
    text: 'Remove the element at index 2 using RemoveAt()',
    setup: 'List<int> numbers = new List<int> { 10, 20, 30, 40 };',
    setupCode: 'List<int> numbers = new List<int> { 10, 20, 30, 40 };',
    expected: '{ 10, 20, 40 }',
    sample: 'numbers.RemoveAt(2);',
    hints: ['RemoveAt() removes the element at the specified index'],
    tags: ['list', 'removeat', 'collections'],
  },
  {
    id: 'csharp-list-removeall-1',
    category: 'List Methods',
    difficulty: 'medium',
    title: 'Remove All Matching Elements',
    text: 'Remove all even numbers from the list using RemoveAll()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };',
    expected: '{ 1, 3, 5 }',
    sample: 'numbers.RemoveAll(x => x % 2 == 0);',
    hints: ['RemoveAll() takes a Predicate<T> and removes all matching elements'],
    tags: ['list', 'removeall', 'lambda', 'collections'],
  },
  {
    id: 'csharp-list-contains-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Check if List Contains Element',
    text: 'Check if the list contains the value 3 using Contains()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    expected: 'true',
    sample: 'numbers.Contains(3)',
    hints: ['Contains() returns true if the element exists in the list'],
    tags: ['list', 'contains', 'collections'],
  },
  {
    id: 'csharp-list-indexof-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Find Index of Element',
    text: 'Find the index of the value 30 using IndexOf()',
    setup: 'List<int> numbers = new List<int> { 10, 20, 30, 40 };',
    setupCode: 'List<int> numbers = new List<int> { 10, 20, 30, 40 };',
    expected: '2',
    sample: 'numbers.IndexOf(30)',
    hints: ['IndexOf() returns -1 if the element is not found'],
    tags: ['list', 'indexof', 'collections'],
  },
  {
    id: 'csharp-list-count-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Get List Count',
    text: 'Get the number of elements in the list using the Count property',
    setup: 'List<string> names = new List<string> { "Alice", "Bob", "Charlie" };',
    setupCode: 'List<string> names = new List<string> { "Alice", "Bob", "Charlie" };',
    expected: '3',
    sample: 'names.Count',
    hints: ['Count is a property, not a method, so no parentheses needed'],
    tags: ['list', 'count', 'collections'],
  },
  {
    id: 'csharp-list-sort-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Sort List in Ascending Order',
    text: 'Sort the list in ascending order using Sort()',
    setup: 'List<int> numbers = new List<int> { 5, 2, 8, 1, 9 };',
    setupCode: 'List<int> numbers = new List<int> { 5, 2, 8, 1, 9 };',
    expected: '{ 1, 2, 5, 8, 9 }',
    sample: 'numbers.Sort();',
    hints: ['Sort() sorts the list in-place in ascending order by default'],
    tags: ['list', 'sort', 'collections'],
  },
  {
    id: 'csharp-list-reverse-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Reverse List Order',
    text: 'Reverse the order of elements in the list using Reverse()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    expected: '{ 5, 4, 3, 2, 1 }',
    sample: 'numbers.Reverse();',
    hints: ['Reverse() reverses the list in-place'],
    tags: ['list', 'reverse', 'collections'],
  },
  {
    id: 'csharp-list-toarray-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Convert List to Array',
    text: 'Convert the list to an array using ToArray()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    expected: 'int[] { 1, 2, 3 }',
    sample: 'int[] arr = numbers.ToArray();',
    hints: ['ToArray() creates a new array containing all list elements'],
    tags: ['list', 'toarray', 'collections'],
  },
  {
    id: 'csharp-list-insert-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Insert Element at Index',
    text: 'Insert the value 99 at index 1 using Insert()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    expected: '{ 1, 99, 2, 3 }',
    sample: 'numbers.Insert(1, 99);',
    hints: [
      'Insert() adds an element at the specified index',
      'Existing elements shift to make room',
    ],
    tags: ['list', 'insert', 'collections'],
  },
  {
    id: 'csharp-list-clear-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Clear All Elements',
    text: 'Remove all elements from the list using Clear()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    expected: '{ } (empty list with Count = 0)',
    sample: 'numbers.Clear();',
    hints: [
      'Clear() removes all elements but keeps the list object',
      'Count becomes 0, but Capacity may remain',
    ],
    tags: ['list', 'clear', 'collections'],
  },
  {
    id: 'csharp-list-find-1',
    category: 'List Methods',
    difficulty: 'medium',
    title: 'Find First Matching Element',
    text: 'Find the first number greater than 15 using Find()',
    setup: 'List<int> numbers = new List<int> { 5, 10, 20, 25, 30 };',
    setupCode: 'List<int> numbers = new List<int> { 5, 10, 20, 25, 30 };',
    expected: '20',
    sample: 'numbers.Find(x => x > 15)',
    hints: [
      'Find() returns default(T) if no match is found',
      'For reference types, default is null',
    ],
    tags: ['list', 'find', 'predicate', 'collections'],
  },
  {
    id: 'csharp-list-findall-1',
    category: 'List Methods',
    difficulty: 'medium',
    title: 'Find All Matching Elements in List',
    text: 'Find all numbers greater than 15 using FindAll()',
    setup: 'List<int> numbers = new List<int> { 5, 10, 20, 25, 30 };',
    setupCode: 'List<int> numbers = new List<int> { 5, 10, 20, 25, 30 };',
    expected: '{ 20, 25, 30 }',
    sample: 'numbers.FindAll(x => x > 15)',
    hints: [
      'FindAll() returns a new List<T> with matching elements',
      'Returns empty list if no matches',
    ],
    tags: ['list', 'findall', 'predicate', 'collections'],
  },
  {
    id: 'csharp-list-exists-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Check if Element Exists in List',
    text: 'Check if any number is negative using Exists()',
    setup: 'List<int> numbers = new List<int> { 5, -3, 10, 8 };',
    setupCode: 'List<int> numbers = new List<int> { 5, -3, 10, 8 };',
    expected: 'true',
    sample: 'numbers.Exists(x => x < 0)',
    hints: [
      'Exists() is similar to LINQ Any() but is a List<T> method',
      'Returns true if any element matches the predicate',
    ],
    tags: ['list', 'exists', 'predicate', 'collections'],
  },
  {
    id: 'csharp-list-trueforall-1',
    category: 'List Methods',
    difficulty: 'medium',
    title: 'Check if All Elements Match',
    text: 'Check if all numbers are positive using TrueForAll()',
    setup: 'List<int> numbers = new List<int> { 1, 5, 10, 8 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 5, 10, 8 };',
    expected: 'true',
    sample: 'numbers.TrueForAll(x => x > 0)',
    hints: [
      'TrueForAll() is similar to LINQ All() but is a List<T> method',
      'Returns true if all elements match the predicate',
    ],
    tags: ['list', 'trueforall', 'predicate', 'collections'],
  },

  // ============================================================
  // Dictionary Methods
  // ============================================================
  {
    id: 'csharp-dict-add-1',
    category: 'Dictionary Methods',
    difficulty: 'easy',
    title: 'Add Key-Value Pair',
    text: 'Add a new entry with key "grape" and value 4 using Add()',
    setup:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    setupCode:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    expected: '{ apple: 1, banana: 2, grape: 4 }',
    sample: 'fruits.Add("grape", 4);',
    hints: [
      'Add() throws ArgumentException if key already exists',
      'Use indexer fruits["key"] = value to add or update',
    ],
    tags: ['dictionary', 'add', 'collections'],
  },
  {
    id: 'csharp-dict-trygetvalue-1',
    category: 'Dictionary Methods',
    difficulty: 'medium',
    title: 'Safely Get Value with TryGetValue',
    text: 'Try to get the value for key "banana" using TryGetValue()',
    setup:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    setupCode:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    expected: 'true and out value = 2',
    sample: 'fruits.TryGetValue("banana", out int value)',
    hints: [
      'TryGetValue() returns bool and sets out parameter',
      'Avoids KeyNotFoundException when key might not exist',
    ],
    tags: ['dictionary', 'trygetvalue', 'collections'],
  },
  {
    id: 'csharp-dict-containskey-1',
    category: 'Dictionary Methods',
    difficulty: 'easy',
    title: 'Check if Key Exists',
    text: 'Check if the dictionary contains the key "banana" using ContainsKey()',
    setup:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    setupCode:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    expected: 'true',
    sample: 'fruits.ContainsKey("banana")',
    hints: [
      'ContainsKey() is O(1) average time complexity',
      'Prefer TryGetValue() if you also need the value',
    ],
    tags: ['dictionary', 'containskey', 'collections'],
  },
  {
    id: 'csharp-dict-containsvalue-1',
    category: 'Dictionary Methods',
    difficulty: 'easy',
    title: 'Check if Value Exists',
    text: 'Check if the dictionary contains the value 2 using ContainsValue()',
    setup:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    setupCode:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    expected: 'true',
    sample: 'fruits.ContainsValue(2)',
    hints: [
      'ContainsValue() is O(n) as it must scan all values',
      'Consider using a reverse lookup dictionary if needed frequently',
    ],
    tags: ['dictionary', 'containsvalue', 'collections'],
  },
  {
    id: 'csharp-dict-remove-1',
    category: 'Dictionary Methods',
    difficulty: 'easy',
    title: 'Remove Key-Value Pair',
    text: 'Remove the entry with key "apple" using Remove()',
    setup:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    setupCode:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    expected: '{ banana: 2 }',
    sample: 'fruits.Remove("apple");',
    hints: [
      'Remove() returns true if key was found and removed',
      'Use Remove(key, out value) to also get the removed value',
    ],
    tags: ['dictionary', 'remove', 'collections'],
  },
  {
    id: 'csharp-dict-keys-1',
    category: 'Dictionary Methods',
    difficulty: 'easy',
    title: 'Get All Keys',
    text: 'Get all keys from the dictionary using the Keys property',
    setup:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    setupCode:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    expected: '{ "apple", "banana" }',
    sample: 'fruits.Keys',
    hints: [
      'Keys returns KeyCollection which implements IEnumerable<TKey>',
      'Use .ToList() or .ToArray() if you need a concrete collection',
    ],
    tags: ['dictionary', 'keys', 'collections'],
  },
  {
    id: 'csharp-dict-values-1',
    category: 'Dictionary Methods',
    difficulty: 'easy',
    title: 'Get All Values',
    text: 'Get all values from the dictionary using the Values property',
    setup:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    setupCode:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    expected: '{ 1, 2 }',
    sample: 'fruits.Values',
    hints: [
      'Values returns ValueCollection which implements IEnumerable<TValue>',
      'Use .ToList() or .ToArray() if you need a concrete collection',
    ],
    tags: ['dictionary', 'values', 'collections'],
  },
  {
    id: 'csharp-dict-getvalueordefault-1',
    category: 'Dictionary Methods',
    difficulty: 'medium',
    title: 'Get Value or Default',
    text: 'Get the value for "cherry" or 0 if not found using GetValueOrDefault()',
    setup:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    setupCode:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    expected: '0',
    sample: 'fruits.GetValueOrDefault("cherry")',
    hints: [
      'GetValueOrDefault() returns default(TValue) if key not found',
      'Can also specify a custom default: GetValueOrDefault("cherry", -1)',
    ],
    tags: ['dictionary', 'getvalueordefault', 'collections'],
  },

  // ============================================================
  // LINQ Methods
  // ============================================================
  {
    id: 'csharp-linq-where-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Filter with Where()',
    text: 'Filter the list to only include numbers greater than 5 using Where()',
    setup: 'List<int> numbers = new List<int> { 3, 7, 2, 9, 4, 8 };',
    setupCode: 'List<int> numbers = new List<int> { 3, 7, 2, 9, 4, 8 };',
    expected: '{ 7, 9, 8 }',
    sample: 'numbers.Where(x => x > 5)',
    hints: [
      'Where() filters elements based on a predicate',
      'Remember to add .ToList() if you need a List<T>',
    ],
    tags: ['linq', 'where', 'filter'],
  },
  {
    id: 'csharp-linq-select-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Transform with Select()',
    text: 'Double each number in the list using Select()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4 };',
    expected: '{ 2, 4, 6, 8 }',
    sample: 'numbers.Select(x => x * 2)',
    hints: ['Select() transforms each element using the provided function'],
    tags: ['linq', 'select', 'projection'],
  },
  {
    id: 'csharp-linq-orderby-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Sort with OrderBy()',
    text: 'Sort the list in ascending order using OrderBy()',
    setup: 'List<int> numbers = new List<int> { 5, 2, 8, 1, 9 };',
    setupCode: 'List<int> numbers = new List<int> { 5, 2, 8, 1, 9 };',
    expected: '{ 1, 2, 5, 8, 9 }',
    sample: 'numbers.OrderBy(x => x)',
    hints: ['OrderBy() returns a new sorted sequence', 'The lambda specifies the sort key'],
    tags: ['linq', 'orderby', 'sorting'],
  },
  {
    id: 'csharp-linq-orderbydesc-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Sort Descending with OrderByDescending()',
    text: 'Sort the list in descending order using OrderByDescending()',
    setup: 'List<int> numbers = new List<int> { 5, 2, 8, 1, 9 };',
    setupCode: 'List<int> numbers = new List<int> { 5, 2, 8, 1, 9 };',
    expected: '{ 9, 8, 5, 2, 1 }',
    sample: 'numbers.OrderByDescending(x => x)',
    hints: ['OrderByDescending() sorts in descending order'],
    tags: ['linq', 'orderbydescending', 'sorting'],
  },
  {
    id: 'csharp-linq-first-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Get First Element with First()',
    text: 'Get the first element of the list using First()',
    setup: 'List<int> numbers = new List<int> { 10, 20, 30 };',
    setupCode: 'List<int> numbers = new List<int> { 10, 20, 30 };',
    expected: '10',
    sample: 'numbers.First()',
    hints: [
      'First() throws an exception if the sequence is empty',
      'Use FirstOrDefault() for safe access',
    ],
    tags: ['linq', 'first', 'element'],
  },
  {
    id: 'csharp-linq-firstordefault-1',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'Get First Element Safely',
    text: 'Get the first even number, or 0 if none exist, using FirstOrDefault()',
    setup: 'List<int> numbers = new List<int> { 1, 3, 5, 7 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 3, 5, 7 };',
    expected: '0',
    sample: 'numbers.FirstOrDefault(x => x % 2 == 0)',
    hints: ['FirstOrDefault() returns default(T) if no match is found', 'default(int) is 0'],
    tags: ['linq', 'firstordefault', 'element'],
  },
  {
    id: 'csharp-linq-any-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Check if Any Element Matches',
    text: 'Check if any number is greater than 10 using Any()',
    setup: 'List<int> numbers = new List<int> { 5, 8, 12, 3 };',
    setupCode: 'List<int> numbers = new List<int> { 5, 8, 12, 3 };',
    expected: 'true',
    sample: 'numbers.Any(x => x > 10)',
    hints: [
      'Any() with a predicate checks if at least one element matches',
      'Any() without arguments checks if the sequence is non-empty',
    ],
    tags: ['linq', 'any', 'predicate'],
  },
  {
    id: 'csharp-linq-all-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Check if All Elements Match',
    text: 'Check if all numbers are positive using All()',
    setup: 'List<int> numbers = new List<int> { 1, 5, 3, 8 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 5, 3, 8 };',
    expected: 'true',
    sample: 'numbers.All(x => x > 0)',
    hints: ['All() returns true if every element satisfies the predicate'],
    tags: ['linq', 'all', 'predicate'],
  },
  {
    id: 'csharp-linq-count-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Count Elements with LINQ',
    text: 'Count how many numbers are even using Count()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };',
    expected: '3',
    sample: 'numbers.Count(x => x % 2 == 0)',
    hints: [
      'Count() with a predicate counts matching elements',
      'Count() without arguments returns total count',
    ],
    tags: ['linq', 'count', 'aggregate'],
  },
  {
    id: 'csharp-linq-sum-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Calculate Sum with Sum()',
    text: 'Calculate the sum of all numbers using Sum()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    expected: '15',
    sample: 'numbers.Sum()',
    hints: ['Sum() adds all elements in the sequence'],
    tags: ['linq', 'sum', 'aggregate'],
  },
  {
    id: 'csharp-linq-average-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Calculate Average',
    text: 'Calculate the average of all numbers using Average()',
    setup: 'List<int> numbers = new List<int> { 2, 4, 6, 8, 10 };',
    setupCode: 'List<int> numbers = new List<int> { 2, 4, 6, 8, 10 };',
    expected: '6.0',
    sample: 'numbers.Average()',
    hints: ['Average() returns a double'],
    tags: ['linq', 'average', 'aggregate'],
  },
  {
    id: 'csharp-linq-max-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Find Maximum Value',
    text: 'Find the maximum value using Max()',
    setup: 'List<int> numbers = new List<int> { 3, 7, 2, 9, 4 };',
    setupCode: 'List<int> numbers = new List<int> { 3, 7, 2, 9, 4 };',
    expected: '9',
    sample: 'numbers.Max()',
    hints: ['Max() throws an exception if the sequence is empty'],
    tags: ['linq', 'max', 'aggregate'],
  },
  {
    id: 'csharp-linq-min-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Find Minimum Value',
    text: 'Find the minimum value using Min()',
    setup: 'List<int> numbers = new List<int> { 3, 7, 2, 9, 4 };',
    setupCode: 'List<int> numbers = new List<int> { 3, 7, 2, 9, 4 };',
    expected: '2',
    sample: 'numbers.Min()',
    hints: ['Min() throws an exception if the sequence is empty'],
    tags: ['linq', 'min', 'aggregate'],
  },
  {
    id: 'csharp-linq-distinct-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Remove Duplicates with Distinct()',
    text: 'Remove duplicate values using Distinct()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 2, 3, 3, 3, 4 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 2, 3, 3, 3, 4 };',
    expected: '{ 1, 2, 3, 4 }',
    sample: 'numbers.Distinct()',
    hints: ['Distinct() returns a sequence with unique elements'],
    tags: ['linq', 'distinct', 'set'],
  },
  {
    id: 'csharp-linq-take-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Take First N Elements',
    text: 'Get the first 3 elements using Take()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };',
    expected: '{ 1, 2, 3 }',
    sample: 'numbers.Take(3)',
    hints: ['Take() returns the first n elements'],
    tags: ['linq', 'take', 'partition'],
  },
  {
    id: 'csharp-linq-skip-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Skip First N Elements',
    text: 'Skip the first 2 elements using Skip()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    expected: '{ 3, 4, 5 }',
    sample: 'numbers.Skip(2)',
    hints: ['Skip() bypasses the first n elements'],
    tags: ['linq', 'skip', 'partition'],
  },
  {
    id: 'csharp-linq-groupby-1',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'Group Elements with GroupBy()',
    text: 'Group numbers by whether they are even or odd using GroupBy()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };',
    expected: 'IEnumerable<IGrouping<bool, int>> with Key=false: {1,3,5} and Key=true: {2,4,6}',
    sample: 'numbers.GroupBy(x => x % 2 == 0)',
    hints: [
      'GroupBy() returns IEnumerable<IGrouping<TKey, TElement>>',
      'Access the key with group.Key and iterate elements with foreach',
      'Consider using ToDictionary() or ToLookup() for direct key access',
    ],
    tags: ['linq', 'groupby', 'grouping'],
  },
  {
    id: 'csharp-linq-aggregate-1',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'Custom Aggregation with Aggregate()',
    text: 'Calculate the product of all numbers using Aggregate()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4 };',
    expected: '24',
    sample: 'numbers.Aggregate((acc, x) => acc * x)',
    hints: [
      'Aggregate() applies a function cumulatively',
      'The accumulator starts with the first element',
    ],
    tags: ['linq', 'aggregate', 'reduce'],
  },
  {
    id: 'csharp-linq-aggregate-seed-1',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'Aggregate with Seed Value',
    text: 'Concatenate all names with a prefix of "Names:" using Aggregate()',
    setup: 'List<string> names = new List<string> { "Alice", "Bob", "Charlie" };',
    setupCode: 'List<string> names = new List<string> { "Alice", "Bob", "Charlie" };',
    expected: '"Names: Alice Bob Charlie"',
    sample: 'names.Aggregate("Names:", (acc, name) => acc + " " + name)',
    hints: [
      'Aggregate with a seed starts accumulation from that value',
      'The seed becomes the initial accumulator value',
    ],
    tags: ['linq', 'aggregate', 'reduce'],
  },

  // ============================================================
  // String Methods
  // ============================================================
  {
    id: 'csharp-string-length-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Get String Length',
    text: 'Get the length of the string using the Length property',
    setup: 'string text = "Hello, World!";',
    setupCode: 'string text = "Hello, World!";',
    expected: '13',
    sample: 'text.Length',
    hints: ['Length is a property, not a method'],
    tags: ['string', 'length'],
  },
  {
    id: 'csharp-string-substring-1',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Extract Substring',
    text: 'Extract "World" from the string using Substring()',
    setup: 'string text = "Hello, World!";',
    setupCode: 'string text = "Hello, World!";',
    expected: '"World"',
    sample: 'text.Substring(7, 5)',
    hints: ['Substring(startIndex, length) extracts a portion of the string'],
    tags: ['string', 'substring'],
  },
  {
    id: 'csharp-string-indexof-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Find Substring Position',
    text: 'Find the position of "World" in the string using IndexOf()',
    setup: 'string text = "Hello, World!";',
    setupCode: 'string text = "Hello, World!";',
    expected: '7',
    sample: 'text.IndexOf("World")',
    hints: ['IndexOf() returns -1 if the substring is not found'],
    tags: ['string', 'indexof'],
  },
  {
    id: 'csharp-string-contains-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Check if String Contains Substring',
    text: 'Check if the string contains "World" using Contains()',
    setup: 'string text = "Hello, World!";',
    setupCode: 'string text = "Hello, World!";',
    expected: 'true',
    sample: 'text.Contains("World")',
    hints: ['Contains() is case-sensitive by default'],
    tags: ['string', 'contains'],
  },
  {
    id: 'csharp-string-split-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Split String into Array',
    text: 'Split the string by commas using Split()',
    setup: 'string text = "apple,banana,cherry";',
    setupCode: 'string text = "apple,banana,cherry";',
    expected: '["apple", "banana", "cherry"]',
    sample: "text.Split(',')",
    hints: ['Split() returns a string array', 'Use char literals with single quotes'],
    tags: ['string', 'split'],
  },
  {
    id: 'csharp-string-join-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Join Array into String',
    text: 'Join the array elements with " - " separator using String.Join()',
    setup: 'string[] fruits = { "apple", "banana", "cherry" };',
    setupCode: 'string[] fruits = { "apple", "banana", "cherry" };',
    expected: '"apple - banana - cherry"',
    sample: 'string.Join(" - ", fruits)',
    hints: ['String.Join() is a static method'],
    tags: ['string', 'join'],
  },
  {
    id: 'csharp-string-toupper-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Convert to Uppercase',
    text: 'Convert the string to uppercase using ToUpper()',
    setup: 'string text = "Hello, World!";',
    setupCode: 'string text = "Hello, World!";',
    expected: '"HELLO, WORLD!"',
    sample: 'text.ToUpper()',
    hints: ['ToUpper() returns a new string; strings are immutable'],
    tags: ['string', 'toupper', 'case'],
  },
  {
    id: 'csharp-string-tolower-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Convert to Lowercase',
    text: 'Convert the string to lowercase using ToLower()',
    setup: 'string text = "Hello, World!";',
    setupCode: 'string text = "Hello, World!";',
    expected: '"hello, world!"',
    sample: 'text.ToLower()',
    hints: ['ToLower() returns a new string; strings are immutable'],
    tags: ['string', 'tolower', 'case'],
  },
  {
    id: 'csharp-string-trim-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Trim Whitespace',
    text: 'Remove leading and trailing whitespace using Trim()',
    setup: 'string text = "  Hello, World!  ";',
    setupCode: 'string text = "  Hello, World!  ";',
    expected: '"Hello, World!"',
    sample: 'text.Trim()',
    hints: [
      'Trim() removes whitespace from both ends',
      'Use TrimStart() or TrimEnd() for one side only',
    ],
    tags: ['string', 'trim'],
  },
  {
    id: 'csharp-string-replace-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Replace Substring',
    text: 'Replace "World" with "C#" using Replace()',
    setup: 'string text = "Hello, World!";',
    setupCode: 'string text = "Hello, World!";',
    expected: '"Hello, C#!"',
    sample: 'text.Replace("World", "C#")',
    hints: ['Replace() replaces all occurrences'],
    tags: ['string', 'replace'],
  },
  {
    id: 'csharp-string-startswith-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Check if String Starts With',
    text: 'Check if the string starts with "Hello" using StartsWith()',
    setup: 'string text = "Hello, World!";',
    setupCode: 'string text = "Hello, World!";',
    expected: 'true',
    sample: 'text.StartsWith("Hello")',
    hints: ['StartsWith() is case-sensitive by default'],
    tags: ['string', 'startswith'],
  },
  {
    id: 'csharp-string-endswith-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Check if String Ends With',
    text: 'Check if the string ends with "!" using EndsWith()',
    setup: 'string text = "Hello, World!";',
    setupCode: 'string text = "Hello, World!";',
    expected: 'true',
    sample: 'text.EndsWith("!")',
    hints: ['EndsWith() is case-sensitive by default'],
    tags: ['string', 'endswith'],
  },

  // ============================================================
  // Array Methods
  // ============================================================
  {
    id: 'csharp-array-sort-1',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Sort Array with Array.Sort()',
    text: 'Sort the array in ascending order using Array.Sort()',
    setup: 'int[] numbers = { 5, 2, 8, 1, 9 };',
    setupCode: 'int[] numbers = { 5, 2, 8, 1, 9 };',
    expected: '{ 1, 2, 5, 8, 9 }',
    sample: 'Array.Sort(numbers);',
    hints: ['Array.Sort() modifies the array in-place'],
    tags: ['array', 'sort'],
  },
  {
    id: 'csharp-array-reverse-1',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Reverse Array with Array.Reverse()',
    text: 'Reverse the order of elements using Array.Reverse()',
    setup: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    expected: '{ 5, 4, 3, 2, 1 }',
    sample: 'Array.Reverse(numbers);',
    hints: ['Array.Reverse() modifies the array in-place'],
    tags: ['array', 'reverse'],
  },
  {
    id: 'csharp-array-indexof-1',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Find Index in Array',
    text: 'Find the index of the value 30 using Array.IndexOf()',
    setup: 'int[] numbers = { 10, 20, 30, 40, 50 };',
    setupCode: 'int[] numbers = { 10, 20, 30, 40, 50 };',
    expected: '2',
    sample: 'Array.IndexOf(numbers, 30)',
    hints: ['Array.IndexOf() returns -1 if the element is not found'],
    tags: ['array', 'indexof'],
  },
  {
    id: 'csharp-array-exists-1',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Check if Element Exists with Array.Exists()',
    text: 'Check if any element is greater than 40 using Array.Exists()',
    setup: 'int[] numbers = { 10, 20, 30, 45, 50 };',
    setupCode: 'int[] numbers = { 10, 20, 30, 45, 50 };',
    expected: 'true',
    sample: 'Array.Exists(numbers, x => x > 40)',
    hints: ['Array.Exists() takes a Predicate<T>'],
    tags: ['array', 'exists', 'predicate'],
  },
  {
    id: 'csharp-array-find-1',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Find Element with Array.Find()',
    text: 'Find the first element greater than 25 using Array.Find()',
    setup: 'int[] numbers = { 10, 20, 30, 40, 50 };',
    setupCode: 'int[] numbers = { 10, 20, 30, 40, 50 };',
    expected: '30',
    sample: 'Array.Find(numbers, x => x > 25)',
    hints: ['Array.Find() returns default(T) if no match is found'],
    tags: ['array', 'find', 'predicate'],
  },
  {
    id: 'csharp-array-findall-1',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Find All Matching Elements',
    text: 'Find all elements greater than 25 using Array.FindAll()',
    setup: 'int[] numbers = { 10, 20, 30, 40, 50 };',
    setupCode: 'int[] numbers = { 10, 20, 30, 40, 50 };',
    expected: '{ 30, 40, 50 }',
    sample: 'Array.FindAll(numbers, x => x > 25)',
    hints: ['Array.FindAll() returns an array of all matching elements'],
    tags: ['array', 'findall', 'predicate'],
  },
  {
    id: 'csharp-array-copy-1',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Copy Array Elements',
    text: 'Copy the first 3 elements to a new array using Array.Copy()',
    setup: 'int[] source = { 1, 2, 3, 4, 5 };\nint[] dest = new int[3];',
    setupCode: 'int[] source = { 1, 2, 3, 4, 5 };\nint[] dest = new int[3];',
    expected: 'dest = { 1, 2, 3 }',
    sample: 'Array.Copy(source, dest, 3);',
    hints: ['Array.Copy() copies elements from source to destination'],
    tags: ['array', 'copy'],
  },
  {
    id: 'csharp-array-resize-1',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Resize Array',
    text: 'Resize the array to hold 5 elements using Array.Resize()',
    setup: 'int[] numbers = { 1, 2, 3 };',
    setupCode: 'int[] numbers = { 1, 2, 3 };',
    expected: '{ 1, 2, 3, 0, 0 }',
    sample: 'Array.Resize(ref numbers, 5);',
    hints: ['Array.Resize() requires ref keyword', 'New elements are initialized to default(T)'],
    tags: ['array', 'resize'],
  },

  // ============================================================
  // Additional LINQ Methods
  // ============================================================
  {
    id: 'cs-linq-selectmany-1',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'Flatten Nested Collections with SelectMany()',
    text: 'Flatten the list of lists into a single list using SelectMany()',
    setup: 'List<List<int>> nested = new List<List<int>> { new List<int> { 1, 2 }, new List<int> { 3, 4 }, new List<int> { 5 } };',
    setupCode:
      'List<List<int>> nested = new List<List<int>> { new List<int> { 1, 2 }, new List<int> { 3, 4 }, new List<int> { 5 } };',
    expected: '{ 1, 2, 3, 4, 5 }',
    sample: 'nested.SelectMany(x => x)',
    hints: [
      'SelectMany() flattens nested collections into one sequence',
      'It projects each element to a sequence and flattens the result',
    ],
    validPatterns: [
      /nested\.SelectMany\s*\(\s*\w+\s*=>\s*\w+\s*\)/,
      /\.SelectMany\(/,
    ],
    tags: ['linq', 'selectmany', 'flatten', 'projection'],
  },
  {
    id: 'cs-linq-selectmany-2',
    category: 'LINQ Methods',
    difficulty: 'hard',
    title: 'SelectMany with Index and Projection',
    text: 'Flatten words and pair each character with its word index using SelectMany with index',
    setup: 'string[] words = { "Hi", "Bye" };',
    setupCode: 'string[] words = { "Hi", "Bye" };',
    expected: '{ (0, H), (0, i), (1, B), (1, y), (1, e) }',
    sample: 'words.SelectMany((word, idx) => word.Select(c => (idx, c)))',
    hints: [
      'SelectMany has an overload that provides the index of the source element',
      'You can combine it with Select to create tuples',
    ],
    validPatterns: [
      /\.SelectMany\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>/,
      /SelectMany.*Select/,
    ],
    tags: ['linq', 'selectmany', 'index', 'advanced'],
  },
  {
    id: 'cs-linq-groupby-key-1',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'GroupBy with Key Selector and Count',
    text: 'Group words by their first letter and count how many in each group',
    setup: 'List<string> words = new List<string> { "apple", "apricot", "banana", "blueberry", "cherry" };',
    setupCode:
      'List<string> words = new List<string> { "apple", "apricot", "banana", "blueberry", "cherry" };',
    expected: '{ (a, 2), (b, 2), (c, 1) }',
    sample: 'words.GroupBy(w => w[0]).Select(g => (g.Key, g.Count()))',
    hints: [
      'GroupBy returns IGrouping<TKey, TElement> with a Key property',
      'Use Select to project each group into a result',
    ],
    validPatterns: [
      /\.GroupBy\s*\(.*\[0\].*\)/,
      /GroupBy.*\.Select.*Count\(/,
    ],
    tags: ['linq', 'groupby', 'count', 'projection'],
  },
  {
    id: 'cs-linq-aggregate-string-1',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'Build CSV String with Aggregate',
    text: 'Create a comma-separated string from the list using Aggregate()',
    setup: 'List<string> items = new List<string> { "one", "two", "three" };',
    setupCode: 'List<string> items = new List<string> { "one", "two", "three" };',
    expected: '"one,two,three"',
    sample: 'items.Aggregate((acc, x) => acc + "," + x)',
    hints: [
      'Aggregate without a seed uses the first element as the initial accumulator',
      'Consider String.Join for this common scenario',
    ],
    validPatterns: [
      /\.Aggregate\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>.*\+.*,.*\+/,
      /Aggregate.*\+\s*","\s*\+/,
    ],
    tags: ['linq', 'aggregate', 'string', 'reduce'],
  },
  {
    id: 'cs-linq-orderby-thenby-1',
    category: 'LINQ Methods',
    difficulty: 'hard',
    title: 'Multi-Level Sorting with OrderBy and ThenBy',
    text: 'Sort people by age ascending, then by name descending',
    setup: 'var people = new[] { ("Alice", 30), ("Bob", 25), ("Charlie", 30), ("Diana", 25) };',
    setupCode:
      'var people = new[] { ("Alice", 30), ("Bob", 25), ("Charlie", 30), ("Diana", 25) };',
    expected: '{ (Diana, 25), (Bob, 25), (Charlie, 30), (Alice, 30) }',
    sample: 'people.OrderBy(p => p.Item2).ThenByDescending(p => p.Item1)',
    hints: [
      'Use ThenBy or ThenByDescending for secondary sort criteria',
      'OrderBy must come before ThenBy',
    ],
    validPatterns: [
      /\.OrderBy\s*\(.*\)\.ThenByDescending\s*\(/,
      /OrderBy.*ThenByDescending/,
    ],
    tags: ['linq', 'orderby', 'thenby', 'sorting', 'advanced'],
  },
  {
    id: 'cs-linq-where-index-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Filter with Where Using Index',
    text: 'Get elements at even indices using Where with index parameter',
    setup: 'List<string> items = new List<string> { "a", "b", "c", "d", "e" };',
    setupCode: 'List<string> items = new List<string> { "a", "b", "c", "d", "e" };',
    expected: '{ "a", "c", "e" }',
    sample: 'items.Where((item, index) => index % 2 == 0)',
    hints: [
      'Where has an overload that provides the index as a second parameter',
      'The index starts at 0',
    ],
    validPatterns: [
      /\.Where\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>.*%\s*2/,
      /Where.*index.*%.*2.*==.*0/,
    ],
    tags: ['linq', 'where', 'index', 'filter'],
  },

  // ============================================================
  // Additional String Methods
  // ============================================================
  {
    id: 'cs-string-format-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Format String with Placeholders',
    text: 'Create a formatted string "Name: Alice, Age: 30" using String.Format()',
    setup: 'string name = "Alice";\nint age = 30;',
    setupCode: 'string name = "Alice";\nint age = 30;',
    expected: '"Name: Alice, Age: 30"',
    sample: 'string.Format("Name: {0}, Age: {1}", name, age)',
    hints: [
      'String.Format uses {0}, {1}, etc. as placeholders',
      'Consider using string interpolation ($"") for simpler cases',
    ],
    validPatterns: [
      /string\.Format\s*\(\s*".*\{0\}.*\{1\}.*"/,
      /String\.Format/,
    ],
    tags: ['string', 'format', 'formatting'],
  },
  {
    id: 'cs-string-format-number-1',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Format Number with Thousands Separator',
    text: 'Format the number with thousands separator and 2 decimal places using String.Format()',
    setup: 'double amount = 1234567.891;',
    setupCode: 'double amount = 1234567.891;',
    expected: '"1,234,567.89"',
    sample: 'string.Format("{0:N2}", amount)',
    hints: [
      'N2 format specifier adds thousands separator and 2 decimal places',
      'C2 would add currency symbol',
    ],
    validPatterns: [
      /string\.Format\s*\(\s*"\{0:N2\}"/,
      /:N2\}/,
      /\.ToString\s*\(\s*"N2"\s*\)/,
    ],
    tags: ['string', 'format', 'number', 'formatting'],
  },
  {
    id: 'cs-string-padleft-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Pad String on Left',
    text: 'Pad the string to 10 characters with zeros on the left using PadLeft()',
    setup: 'string code = "42";',
    setupCode: 'string code = "42";',
    expected: '"0000000042"',
    sample: "code.PadLeft(10, '0')",
    hints: [
      'PadLeft adds padding characters to the left until the total length is reached',
      'If the string is already >= the specified length, no padding is added',
    ],
    validPatterns: [
      /\.PadLeft\s*\(\s*10\s*,\s*'0'\s*\)/,
      /PadLeft\s*\(\s*10/,
    ],
    tags: ['string', 'padleft', 'formatting'],
  },
  {
    id: 'cs-string-padright-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Pad String on Right',
    text: 'Pad the string to 15 characters with dots on the right using PadRight()',
    setup: 'string label = "Total";',
    setupCode: 'string label = "Total";',
    expected: '"Total.........."',
    sample: "label.PadRight(15, '.')",
    hints: [
      'PadRight adds padding characters to the right until the total length is reached',
      'Useful for creating aligned output',
    ],
    validPatterns: [
      /\.PadRight\s*\(\s*15\s*,\s*'\.\'\s*\)/,
      /PadRight\s*\(\s*15/,
    ],
    tags: ['string', 'padright', 'formatting'],
  },
  {
    id: 'cs-string-trimstart-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Trim Leading Characters',
    text: 'Remove leading zeros from the string using TrimStart()',
    setup: 'string code = "000123";',
    setupCode: 'string code = "000123";',
    expected: '"123"',
    sample: "code.TrimStart('0')",
    hints: [
      'TrimStart removes specified characters from the beginning',
      'Without arguments, it removes whitespace',
    ],
    validPatterns: [
      /\.TrimStart\s*\(\s*'0'\s*\)/,
      /TrimStart.*0/,
    ],
    tags: ['string', 'trimstart', 'trim'],
  },
  {
    id: 'cs-string-trimend-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Trim Trailing Characters',
    text: 'Remove trailing exclamation marks from the string using TrimEnd()',
    setup: 'string text = "Hello!!!";',
    setupCode: 'string text = "Hello!!!";',
    expected: '"Hello"',
    sample: "text.TrimEnd('!')",
    hints: [
      'TrimEnd removes specified characters from the end',
      'Without arguments, it removes whitespace',
    ],
    validPatterns: [
      /\.TrimEnd\s*\(\s*'!'\s*\)/,
      /TrimEnd.*!/,
    ],
    tags: ['string', 'trimend', 'trim'],
  },
  {
    id: 'cs-string-join-format-1',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Join with Custom Separator',
    text: 'Join the integers with " | " separator, converting each to string',
    setup: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    expected: '"1 | 2 | 3 | 4 | 5"',
    sample: 'string.Join(" | ", numbers)',
    hints: [
      'String.Join automatically converts elements to strings',
      'Works with any IEnumerable',
    ],
    validPatterns: [
      /string\.Join\s*\(\s*"\s*\|\s*"/,
      /String\.Join.*\|/,
    ],
    tags: ['string', 'join', 'formatting'],
  },

  // ============================================================
  // Additional List Methods
  // ============================================================
  {
    id: 'cs-list-convertall-1',
    category: 'List Methods',
    difficulty: 'medium',
    title: 'Convert All Elements with ConvertAll()',
    text: 'Convert all integers to their string representations using ConvertAll()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    expected: '{ "1", "2", "3", "4", "5" }',
    sample: 'numbers.ConvertAll(x => x.ToString())',
    hints: [
      'ConvertAll is a List<T> method similar to Select but returns List<TOutput>',
      'More efficient than Select().ToList() for lists',
    ],
    validPatterns: [
      /\.ConvertAll\s*\(.*\.ToString\s*\(\s*\)\s*\)/,
      /ConvertAll.*ToString/,
    ],
    tags: ['list', 'convertall', 'conversion', 'collections'],
  },
  {
    id: 'cs-list-findindex-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Find Index with Predicate',
    text: 'Find the index of the first number greater than 20 using FindIndex()',
    setup: 'List<int> numbers = new List<int> { 5, 15, 25, 35, 45 };',
    setupCode: 'List<int> numbers = new List<int> { 5, 15, 25, 35, 45 };',
    expected: '2',
    sample: 'numbers.FindIndex(x => x > 20)',
    hints: [
      'FindIndex returns -1 if no element matches the predicate',
      'Different from IndexOf which searches for a specific value',
    ],
    validPatterns: [
      /\.FindIndex\s*\(\s*\w+\s*=>\s*\w+\s*>\s*20\s*\)/,
      /FindIndex.*>.*20/,
    ],
    tags: ['list', 'findindex', 'predicate', 'collections'],
  },
  {
    id: 'cs-list-findlast-1',
    category: 'List Methods',
    difficulty: 'hard',
    title: 'Find Last Matching Element',
    text: 'Find the last even number using FindLast()',
    setup: 'List<int> numbers = new List<int> { 2, 5, 8, 11, 14, 17 };',
    setupCode: 'List<int> numbers = new List<int> { 2, 5, 8, 11, 14, 17 };',
    expected: '14',
    sample: 'numbers.FindLast(x => x % 2 == 0)',
    hints: [
      'FindLast searches from the end of the list',
      'Returns default(T) if no match is found',
    ],
    validPatterns: [
      /\.FindLast\s*\(\s*\w+\s*=>\s*\w+\s*%\s*2\s*==\s*0\s*\)/,
      /FindLast.*%.*2.*==.*0/,
    ],
    tags: ['list', 'findlast', 'predicate', 'collections'],
  },
  {
    id: 'cs-list-binarysearch-1',
    category: 'List Methods',
    difficulty: 'hard',
    title: 'Binary Search in Sorted List',
    text: 'Find the index of value 30 using BinarySearch() (list is already sorted)',
    setup: 'List<int> numbers = new List<int> { 10, 20, 30, 40, 50 };',
    setupCode: 'List<int> numbers = new List<int> { 10, 20, 30, 40, 50 };',
    expected: '2',
    sample: 'numbers.BinarySearch(30)',
    hints: [
      'BinarySearch requires the list to be sorted',
      'Returns bitwise complement of next larger element index if not found',
    ],
    validPatterns: [
      /\.BinarySearch\s*\(\s*30\s*\)/,
      /BinarySearch\(30\)/,
    ],
    tags: ['list', 'binarysearch', 'search', 'collections'],
  },

  // ============================================================
  // Additional Dictionary Methods
  // ============================================================
  {
    id: 'cs-dict-tryadd-1',
    category: 'Dictionary Methods',
    difficulty: 'easy',
    title: 'Add if Key Does Not Exist with TryAdd()',
    text: 'Add "cherry" with value 3 only if the key does not exist using TryAdd()',
    setup: 'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    setupCode:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    expected: 'true (and fruits now has cherry: 3)',
    sample: 'fruits.TryAdd("cherry", 3)',
    hints: [
      'TryAdd returns true if added, false if key already exists',
      'Safer than Add which throws if key exists',
    ],
    validPatterns: [
      /\.TryAdd\s*\(\s*"cherry"\s*,\s*3\s*\)/,
      /TryAdd.*cherry.*3/,
    ],
    tags: ['dictionary', 'tryadd', 'collections'],
  },
  {
    id: 'cs-dict-getvalueordefault-custom-1',
    category: 'Dictionary Methods',
    difficulty: 'medium',
    title: 'Get Value with Custom Default',
    text: 'Get the value for "mango" or -1 if not found using GetValueOrDefault with custom default',
    setup: 'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    setupCode:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    expected: '-1',
    sample: 'fruits.GetValueOrDefault("mango", -1)',
    hints: [
      'GetValueOrDefault accepts an optional second parameter for custom default',
      'More concise than TryGetValue for simple cases',
    ],
    validPatterns: [
      /\.GetValueOrDefault\s*\(\s*"mango"\s*,\s*-1\s*\)/,
      /GetValueOrDefault.*mango.*-1/,
    ],
    tags: ['dictionary', 'getvalueordefault', 'collections'],
  },
  {
    id: 'cs-dict-trygetvalue-pattern-1',
    category: 'Dictionary Methods',
    difficulty: 'medium',
    title: 'TryGetValue with Pattern Matching',
    text: 'Get the value for "apple" and use it if found, otherwise use 0, using TryGetValue with pattern',
    setup: 'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 5, ["banana"] = 3 };',
    setupCode:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 5, ["banana"] = 3 };',
    expected: '5',
    sample: 'fruits.TryGetValue("apple", out var value) ? value : 0',
    hints: [
      'TryGetValue can be combined with ternary operator',
      'The out variable is in scope for the entire expression',
    ],
    validPatterns: [
      /\.TryGetValue\s*\(\s*"apple"\s*,\s*out\s+(var\s+)?\w+\s*\)\s*\?/,
      /TryGetValue.*\?.*:/,
    ],
    tags: ['dictionary', 'trygetvalue', 'pattern', 'collections'],
  },

  // ============================================================
  // Nullable Handling
  // ============================================================
  {
    id: 'cs-nullable-conditional-1',
    category: 'Nullable Handling',
    difficulty: 'easy',
    title: 'Null-Conditional Member Access',
    text: 'Get the length of the string if not null, otherwise null, using ?. operator',
    setup: 'string? text = "Hello";',
    setupCode: 'string? text = "Hello";',
    expected: '5',
    sample: 'text?.Length',
    hints: [
      '?. returns null if the left operand is null',
      'The result type is nullable (int? in this case)',
    ],
    validPatterns: [
      /text\?\.Length/,
      /\?\.Length/,
    ],
    tags: ['nullable', 'conditional', 'null-safe'],
  },
  {
    id: 'cs-nullable-coalesce-chain-1',
    category: 'Nullable Handling',
    difficulty: 'medium',
    title: 'Chain Null Coalescing Operators',
    text: 'Return the first non-null value from first, second, or "default" using ?? chaining',
    setup: 'string? first = null;\nstring? second = null;',
    setupCode: 'string? first = null;\nstring? second = null;',
    expected: '"default"',
    sample: 'first ?? second ?? "default"',
    hints: [
      '?? operators can be chained for multiple fallbacks',
      'Evaluation is left-to-right and short-circuits on first non-null',
    ],
    validPatterns: [
      /first\s*\?\?\s*second\s*\?\?\s*"default"/,
      /\?\?.*\?\?/,
    ],
    tags: ['nullable', 'coalesce', 'chain'],
  },
  {
    id: 'cs-nullable-assign-1',
    category: 'Nullable Handling',
    difficulty: 'easy',
    title: 'Null Coalescing Assignment',
    text: 'Initialize the list only if it is null using ??= operator',
    setup: 'List<int>? numbers = null;',
    setupCode: 'List<int>? numbers = null;',
    expected: 'numbers is now an empty list',
    sample: 'numbers ??= new List<int>();',
    hints: [
      '??= only assigns if the variable is null',
      'Useful for lazy initialization',
    ],
    validPatterns: [
      /numbers\s*\?\?=\s*new\s+List<int>\s*\(\s*\)/,
      /\?\?=\s*new\s+List/,
    ],
    tags: ['nullable', 'assignment', 'coalesce'],
  },
  {
    id: 'cs-nullable-conditional-method-1',
    category: 'Nullable Handling',
    difficulty: 'medium',
    title: 'Null-Conditional Method Call',
    text: 'Call ToUpper() on the string only if not null using ?. operator',
    setup: 'string? name = "alice";',
    setupCode: 'string? name = "alice";',
    expected: '"ALICE"',
    sample: 'name?.ToUpper()',
    hints: [
      '?. can be used before method calls',
      'The entire expression returns null if the object is null',
    ],
    validPatterns: [
      /name\?\.ToUpper\s*\(\s*\)/,
      /\?\.ToUpper\(/,
    ],
    tags: ['nullable', 'conditional', 'method'],
  },
  {
    id: 'cs-nullable-chain-access-1',
    category: 'Nullable Handling',
    difficulty: 'hard',
    title: 'Chain Null-Conditional with Coalescing',
    text: 'Get the first character uppercase of name, or "?" if null or empty',
    setup: 'string? name = null;',
    setupCode: 'string? name = null;',
    expected: '"?"',
    sample: 'name?.FirstOrDefault().ToString()?.ToUpper() ?? "?"',
    hints: [
      'Combine ?. and ?? for safe navigation with defaults',
      'FirstOrDefault() returns default char for empty strings',
    ],
    validPatterns: [
      /\?\..*\?\..*\?\?/,
      /FirstOrDefault.*\?\?/,
    ],
    tags: ['nullable', 'conditional', 'coalesce', 'chain', 'advanced'],
  },

  // ============================================================
  // Advanced LINQ Operations
  // ============================================================

  // --- EASY (8 problems) ---
  {
    id: 'cs-linq-query-basic-1',
    category: 'Advanced LINQ',
    difficulty: 'easy',
    title: 'Query Syntax: Basic Where and Select',
    text: 'Filter even numbers and square them using LINQ query syntax instead of method syntax',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };',
    expected: '{ 4, 16, 36, 64, 100 }',
    sample: 'from n in numbers where n % 2 == 0 select n * n',
    hints: [
      'Query syntax starts with "from" and ends with "select"',
      'The "where" clause filters elements before projection',
      'Query syntax is translated to method syntax at compile time',
    ],
    validPatterns: [/from\s+\w+\s+in\s+\w+\s+where.*select/i],
    tags: ['linq', 'query-syntax', 'where', 'select', 'advanced'],
  },
  {
    id: 'cs-linq-selectmany-flatten-1',
    category: 'Advanced LINQ',
    difficulty: 'easy',
    title: 'Flatten Nested Arrays with SelectMany',
    text: 'Flatten the jagged array into a single sequence using SelectMany()',
    setup: 'int[][] jagged = new int[][] { new[] { 1, 2 }, new[] { 3, 4, 5 }, new[] { 6 } };',
    setupCode: 'int[][] jagged = new int[][] { new[] { 1, 2 }, new[] { 3, 4, 5 }, new[] { 6 } };',
    expected: '{ 1, 2, 3, 4, 5, 6 }',
    sample: 'jagged.SelectMany(arr => arr)',
    hints: [
      'SelectMany flattens nested collections into a single sequence',
      'The lambda returns the inner collection to flatten',
      'Equivalent to flatMap in functional programming',
    ],
    validPatterns: [/\.SelectMany\s*\(\s*\w+\s*=>\s*\w+\s*\)/i],
    tags: ['linq', 'selectmany', 'flatten', 'advanced'],
  },
  {
    id: 'cs-linq-zip-combine-1',
    category: 'Advanced LINQ',
    difficulty: 'easy',
    title: 'Combine Sequences with Zip',
    text: 'Pair products with their prices using Zip()',
    setup: 'string[] products = { "Apple", "Banana", "Cherry" };\ndecimal[] prices = { 1.50m, 0.75m, 2.00m };',
    setupCode: 'string[] products = { "Apple", "Banana", "Cherry" };\ndecimal[] prices = { 1.50m, 0.75m, 2.00m };',
    expected: '{ "Apple: $1.50", "Banana: $0.75", "Cherry: $2.00" }',
    sample: 'products.Zip(prices, (p, price) => $"{p}: ${price}")',
    hints: [
      'Zip combines two sequences element by element',
      'Result length equals the shorter sequence',
      'The lambda receives one element from each sequence',
    ],
    validPatterns: [/\.Zip\s*\(\s*\w+\s*,\s*\(/i],
    tags: ['linq', 'zip', 'combine', 'advanced'],
  },
  {
    id: 'cs-linq-oftype-filter-1',
    category: 'Advanced LINQ',
    difficulty: 'easy',
    title: 'Filter by Type with OfType',
    text: 'Extract only integers from the mixed collection using OfType<T>()',
    setup: 'object[] mixed = { 1, "hello", 2.5, 3, "world", 4, true };',
    setupCode: 'object[] mixed = { 1, "hello", 2.5, 3, "world", 4, true };',
    expected: '{ 1, 3, 4 }',
    sample: 'mixed.OfType<int>()',
    hints: [
      'OfType<T>() filters and casts elements to the specified type',
      'Elements that cannot be cast are silently excluded',
      'Safer than Cast<T>() which throws on incompatible types',
    ],
    validPatterns: [/\.OfType\s*<\s*int\s*>\s*\(\s*\)/i],
    tags: ['linq', 'oftype', 'type-filtering', 'advanced'],
  },
  {
    id: 'cs-linq-cast-convert-1',
    category: 'Advanced LINQ',
    difficulty: 'easy',
    title: 'Cast Non-Generic Collection',
    text: 'Convert ArrayList to IEnumerable<string> using Cast<T>()',
    setup: 'System.Collections.ArrayList list = new System.Collections.ArrayList { "a", "b", "c" };',
    setupCode: 'System.Collections.ArrayList list = new System.Collections.ArrayList { "a", "b", "c" };',
    expected: 'IEnumerable<string> { "a", "b", "c" }',
    sample: 'list.Cast<string>()',
    hints: [
      'Cast<T>() converts IEnumerable to IEnumerable<T>',
      'Throws InvalidCastException if any element cannot be cast',
      'Required for using LINQ on non-generic collections',
    ],
    validPatterns: [/\.Cast\s*<\s*string\s*>\s*\(\s*\)/i],
    tags: ['linq', 'cast', 'type-conversion', 'advanced'],
  },
  {
    id: 'cs-linq-deferred-tolist-1',
    category: 'Advanced LINQ',
    difficulty: 'easy',
    title: 'Immediate Execution with ToList',
    text: 'Force immediate execution of the LINQ query using ToList()',
    setup: 'IEnumerable<int> query = Enumerable.Range(1, 5).Where(x => x % 2 == 1);',
    setupCode: 'IEnumerable<int> query = Enumerable.Range(1, 5).Where(x => x % 2 == 1);',
    expected: 'List<int> { 1, 3, 5 }',
    sample: 'query.ToList()',
    hints: [
      'LINQ queries use deferred execution by default',
      'ToList() forces immediate enumeration and caches results',
      'ToArray() and ToDictionary() also force immediate execution',
    ],
    validPatterns: [/\.ToList\s*\(\s*\)/i],
    tags: ['linq', 'deferred-execution', 'immediate-execution', 'advanced'],
  },
  {
    id: 'cs-linq-concat-union-1',
    category: 'Advanced LINQ',
    difficulty: 'easy',
    title: 'Concatenate vs Union',
    text: 'Combine two arrays preserving all elements (including duplicates) using Concat()',
    setup: 'int[] first = { 1, 2, 3 };\nint[] second = { 2, 3, 4 };',
    setupCode: 'int[] first = { 1, 2, 3 };\nint[] second = { 2, 3, 4 };',
    expected: '{ 1, 2, 3, 2, 3, 4 }',
    sample: 'first.Concat(second)',
    hints: [
      'Concat() preserves all elements including duplicates',
      'Union() removes duplicates from the combined result',
      'Both use deferred execution',
    ],
    validPatterns: [/\.Concat\s*\(\s*\w+\s*\)/i],
    tags: ['linq', 'concat', 'union', 'combine', 'advanced'],
  },
  {
    id: 'cs-linq-defaultifempty-1',
    category: 'Advanced LINQ',
    difficulty: 'easy',
    title: 'Handle Empty Sequences with DefaultIfEmpty',
    text: 'Return a default value of 0 if the filtered sequence is empty',
    setup: 'List<int> numbers = new List<int> { 2, 4, 6, 8 };',
    setupCode: 'List<int> numbers = new List<int> { 2, 4, 6, 8 };',
    expected: '{ 0 }',
    sample: 'numbers.Where(x => x > 10).DefaultIfEmpty(0)',
    hints: [
      'DefaultIfEmpty() returns a sequence with one default element if source is empty',
      'Without argument, uses default(T)',
      'Essential for left outer joins in LINQ',
    ],
    validPatterns: [/\.DefaultIfEmpty\s*\(\s*0\s*\)/i],
    tags: ['linq', 'defaultifempty', 'empty-handling', 'advanced'],
  },

  // --- MEDIUM (12 problems) ---
  {
    id: 'cs-linq-groupby-projection-1',
    category: 'Advanced LINQ',
    difficulty: 'medium',
    title: 'GroupBy with Element Projection',
    text: 'Group students by grade and project to a summary with grade, count, and names',
    setup: 'var students = new[] { new { Name = "Alice", Grade = "A" }, new { Name = "Bob", Grade = "B" }, new { Name = "Carol", Grade = "A" }, new { Name = "Dave", Grade = "B" }, new { Name = "Eve", Grade = "A" } };',
    setupCode: 'var students = new[] { new { Name = "Alice", Grade = "A" }, new { Name = "Bob", Grade = "B" }, new { Name = "Carol", Grade = "A" }, new { Name = "Dave", Grade = "B" }, new { Name = "Eve", Grade = "A" } };',
    expected: '{ { Grade = "A", Count = 3, Names = "Alice, Carol, Eve" }, { Grade = "B", Count = 2, Names = "Bob, Dave" } }',
    sample: 'students.GroupBy(s => s.Grade).Select(g => new { Grade = g.Key, Count = g.Count(), Names = string.Join(", ", g.Select(s => s.Name)) })',
    hints: [
      'GroupBy returns IEnumerable<IGrouping<TKey, TElement>>',
      'Use g.Key to access the grouping key',
      'Apply aggregates and projections in Select',
    ],
    validPatterns: [/\.GroupBy\s*\(.*\)\.Select\s*\(.*g\.Key.*g\.Count\(\)/i],
    tags: ['linq', 'groupby', 'projection', 'aggregate', 'advanced'],
  },
  {
    id: 'cs-linq-groupby-having-1',
    category: 'Advanced LINQ',
    difficulty: 'medium',
    title: 'GroupBy with Having Equivalent',
    text: 'Group orders by customer and filter to only customers with more than 2 orders',
    setup: 'var orders = new[] { new { CustomerId = 1, Amount = 100 }, new { CustomerId = 2, Amount = 50 }, new { CustomerId = 1, Amount = 200 }, new { CustomerId = 1, Amount = 150 }, new { CustomerId = 2, Amount = 75 } };',
    setupCode: 'var orders = new[] { new { CustomerId = 1, Amount = 100 }, new { CustomerId = 2, Amount = 50 }, new { CustomerId = 1, Amount = 200 }, new { CustomerId = 1, Amount = 150 }, new { CustomerId = 2, Amount = 75 } };',
    expected: '{ { CustomerId = 1, OrderCount = 3, Total = 450 } }',
    sample: 'orders.GroupBy(o => o.CustomerId).Where(g => g.Count() > 2).Select(g => new { CustomerId = g.Key, OrderCount = g.Count(), Total = g.Sum(o => o.Amount) })',
    hints: [
      'Use Where after GroupBy for HAVING equivalent',
      'The Where predicate receives IGrouping<TKey, TElement>',
      'Can apply aggregates inside Where condition',
    ],
    validPatterns: [/\.GroupBy\s*\(.*\)\.Where\s*\(.*\.Count\(\).*\)\.Select/i],
    tags: ['linq', 'groupby', 'where', 'having', 'advanced'],
  },
  {
    id: 'cs-linq-join-inner-1',
    category: 'Advanced LINQ',
    difficulty: 'medium',
    title: 'Inner Join with Method Syntax',
    text: 'Join orders to customers by CustomerId to get customer names with order amounts',
    setup: 'var customers = new[] { new { Id = 1, Name = "Alice" }, new { Id = 2, Name = "Bob" } };\nvar orders = new[] { new { CustomerId = 1, Amount = 100m }, new { CustomerId = 2, Amount = 200m }, new { CustomerId = 1, Amount = 150m } };',
    setupCode: 'var customers = new[] { new { Id = 1, Name = "Alice" }, new { Id = 2, Name = "Bob" } };\nvar orders = new[] { new { CustomerId = 1, Amount = 100m }, new { CustomerId = 2, Amount = 200m }, new { CustomerId = 1, Amount = 150m } };',
    expected: '{ { Customer = "Alice", Amount = 100 }, { Customer = "Alice", Amount = 150 }, { Customer = "Bob", Amount = 200 } }',
    sample: 'orders.Join(customers, o => o.CustomerId, c => c.Id, (o, c) => new { Customer = c.Name, o.Amount })',
    hints: [
      'Join takes: inner sequence, outer key selector, inner key selector, result selector',
      'Only matching pairs are included (inner join)',
      'Key selectors must produce comparable values',
    ],
    validPatterns: [/\.Join\s*\(\s*\w+\s*,.*=>.*,.*=>.*,\s*\(/i],
    tags: ['linq', 'join', 'inner-join', 'advanced'],
  },
  {
    id: 'cs-linq-groupjoin-1',
    category: 'Advanced LINQ',
    difficulty: 'medium',
    title: 'Group Join for Hierarchical Data',
    text: 'Use GroupJoin to get each category with its list of products',
    setup: 'var categories = new[] { new { Id = 1, Name = "Fruit" }, new { Id = 2, Name = "Dairy" } };\nvar products = new[] { new { Name = "Apple", CatId = 1 }, new { Name = "Milk", CatId = 2 }, new { Name = "Banana", CatId = 1 } };',
    setupCode: 'var categories = new[] { new { Id = 1, Name = "Fruit" }, new { Id = 2, Name = "Dairy" } };\nvar products = new[] { new { Name = "Apple", CatId = 1 }, new { Name = "Milk", CatId = 2 }, new { Name = "Banana", CatId = 1 } };',
    expected: '{ { Category = "Fruit", Products = ["Apple", "Banana"] }, { Category = "Dairy", Products = ["Milk"] } }',
    sample: 'categories.GroupJoin(products, c => c.Id, p => p.CatId, (c, prods) => new { Category = c.Name, Products = prods.Select(p => p.Name).ToList() })',
    hints: [
      'GroupJoin groups inner elements by the outer key',
      'Returns all outer elements even without matches',
      'prods is IEnumerable<TInner> for each outer element',
    ],
    validPatterns: [/\.GroupJoin\s*\(\s*\w+\s*,.*,.*,\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>/i],
    tags: ['linq', 'groupjoin', 'hierarchical', 'advanced'],
  },
  {
    id: 'cs-linq-aggregate-custom-1',
    category: 'Advanced LINQ',
    difficulty: 'medium',
    title: 'Custom Aggregation: Find Longest Word',
    text: 'Use Aggregate to find the longest string in the list',
    setup: 'List<string> words = new List<string> { "cat", "elephant", "dog", "hippopotamus" };',
    setupCode: 'List<string> words = new List<string> { "cat", "elephant", "dog", "hippopotamus" };',
    expected: '"hippopotamus"',
    sample: 'words.Aggregate((longest, current) => current.Length > longest.Length ? current : longest)',
    hints: [
      'Aggregate applies a function cumulatively to the sequence',
      'Without seed, first element becomes initial accumulator',
      'Return the new accumulator value from the function',
    ],
    validPatterns: [/\.Aggregate\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>.*\.Length/i],
    tags: ['linq', 'aggregate', 'custom-reduction', 'advanced'],
  },
  {
    id: 'cs-linq-selectmany-crossjoin-1',
    category: 'Advanced LINQ',
    difficulty: 'medium',
    title: 'Cross Join with SelectMany',
    text: 'Generate all combinations of colors and sizes using SelectMany',
    setup: 'string[] colors = { "Red", "Blue" };\nstring[] sizes = { "S", "M", "L" };',
    setupCode: 'string[] colors = { "Red", "Blue" };\nstring[] sizes = { "S", "M", "L" };',
    expected: '{ "Red-S", "Red-M", "Red-L", "Blue-S", "Blue-M", "Blue-L" }',
    sample: 'colors.SelectMany(c => sizes.Select(s => $"{c}-{s}"))',
    hints: [
      'SelectMany can create a cross join (Cartesian product)',
      'Each color maps to all sizes',
      'Result count = colors.Length * sizes.Length',
    ],
    validPatterns: [/\.SelectMany\s*\(\s*\w+\s*=>\s*\w+\.Select/i],
    tags: ['linq', 'selectmany', 'cross-join', 'advanced'],
  },
  {
    id: 'cs-linq-query-join-1',
    category: 'Advanced LINQ',
    difficulty: 'medium',
    title: 'Query Syntax: Join with into',
    text: 'Rewrite the join using LINQ query syntax with the join keyword',
    setup: 'var authors = new[] { new { Id = 1, Name = "Alice" }, new { Id = 2, Name = "Bob" } };\nvar books = new[] { new { Title = "C# Basics", AuthorId = 1 }, new { Title = "Advanced C#", AuthorId = 1 }, new { Title = "Python 101", AuthorId = 2 } };',
    setupCode: 'var authors = new[] { new { Id = 1, Name = "Alice" }, new { Id = 2, Name = "Bob" } };\nvar books = new[] { new { Title = "C# Basics", AuthorId = 1 }, new { Title = "Advanced C#", AuthorId = 1 }, new { Title = "Python 101", AuthorId = 2 } };',
    expected: '{ { Author = "Alice", Title = "C# Basics" }, { Author = "Alice", Title = "Advanced C#" }, { Author = "Bob", Title = "Python 101" } }',
    sample: 'from a in authors join b in books on a.Id equals b.AuthorId select new { Author = a.Name, b.Title }',
    hints: [
      'Query syntax uses "join ... on ... equals ..."',
      'The equals keyword is required (not ==)',
      'Query syntax joins are more readable for complex queries',
    ],
    validPatterns: [/from\s+\w+\s+in\s+\w+\s+join\s+\w+\s+in\s+\w+\s+on\s+.*equals/i],
    tags: ['linq', 'query-syntax', 'join', 'advanced'],
  },
  {
    id: 'cs-linq-query-groupby-1',
    category: 'Advanced LINQ',
    difficulty: 'medium',
    title: 'Query Syntax: Group By with into',
    text: 'Group numbers by their tens digit using query syntax with group ... by ... into',
    setup: 'int[] numbers = { 5, 15, 25, 12, 32, 45, 48 };',
    setupCode: 'int[] numbers = { 5, 15, 25, 12, 32, 45, 48 };',
    expected: '{ { Tens = 0, Numbers = [5] }, { Tens = 1, Numbers = [15, 12] }, { Tens = 2, Numbers = [25] }, { Tens = 3, Numbers = [32] }, { Tens = 4, Numbers = [45, 48] } }',
    sample: 'from n in numbers group n by n / 10 into g select new { Tens = g.Key, Numbers = g.ToList() }',
    hints: [
      'Use "group ... by ... into ..." for query continuation',
      'The "into" keyword creates a new range variable for the group',
      'Can continue the query with select or additional clauses',
    ],
    validPatterns: [/from\s+\w+\s+in\s+\w+\s+group\s+\w+\s+by.*into\s+\w+\s+select/i],
    tags: ['linq', 'query-syntax', 'groupby', 'advanced'],
  },
  {
    id: 'cs-linq-let-clause-1',
    category: 'Advanced LINQ',
    difficulty: 'medium',
    title: 'Query Syntax: Let Clause for Computed Values',
    text: 'Use let clause to compute total price and filter expensive items',
    setup: 'var items = new[] { new { Name = "A", Qty = 2, Price = 10m }, new { Name = "B", Qty = 5, Price = 3m }, new { Name = "C", Qty = 1, Price = 50m } };',
    setupCode: 'var items = new[] { new { Name = "A", Qty = 2, Price = 10m }, new { Name = "B", Qty = 5, Price = 3m }, new { Name = "C", Qty = 1, Price = 50m } };',
    expected: '{ { Name = "A", Total = 20 }, { Name = "C", Total = 50 } }',
    sample: 'from i in items let total = i.Qty * i.Price where total >= 20 select new { i.Name, Total = total }',
    hints: [
      'The let clause introduces a computed range variable',
      'Avoids recalculating the expression multiple times',
      'Variable is available in subsequent clauses',
    ],
    validPatterns: [/from\s+\w+\s+in\s+\w+\s+let\s+\w+\s*=.*where.*select/i],
    tags: ['linq', 'query-syntax', 'let', 'advanced'],
  },
  {
    id: 'cs-linq-zip-multiple-1',
    category: 'Advanced LINQ',
    difficulty: 'medium',
    title: 'Zip Multiple Sequences',
    text: 'Combine three arrays (ids, names, scores) using chained Zip calls',
    setup: 'int[] ids = { 1, 2, 3 };\nstring[] names = { "Alice", "Bob", "Carol" };\nint[] scores = { 95, 87, 92 };',
    setupCode: 'int[] ids = { 1, 2, 3 };\nstring[] names = { "Alice", "Bob", "Carol" };\nint[] scores = { 95, 87, 92 };',
    expected: '{ { Id = 1, Name = "Alice", Score = 95 }, { Id = 2, Name = "Bob", Score = 87 }, { Id = 3, Name = "Carol", Score = 92 } }',
    sample: 'ids.Zip(names, (id, name) => new { Id = id, Name = name }).Zip(scores, (x, score) => new { x.Id, x.Name, Score = score })',
    hints: [
      'Chain Zip calls for more than two sequences',
      'First Zip creates intermediate result',
      'Second Zip combines with third sequence',
    ],
    validPatterns: [/\.Zip\s*\(.*\)\.Zip\s*\(/i],
    tags: ['linq', 'zip', 'multiple-sequences', 'advanced'],
  },
  {
    id: 'cs-linq-tolookup-1',
    category: 'Advanced LINQ',
    difficulty: 'medium',
    title: 'Create Lookup with ToLookup',
    text: 'Create a lookup of words grouped by their length',
    setup: 'string[] words = { "cat", "dog", "elephant", "ant", "bird", "fish" };',
    setupCode: 'string[] words = { "cat", "dog", "elephant", "ant", "bird", "fish" };',
    expected: 'ILookup with [3] = { cat, dog, ant }, [8] = { elephant }, [4] = { bird, fish }',
    sample: 'words.ToLookup(w => w.Length)',
    hints: [
      'ToLookup creates an immutable dictionary-like structure',
      'Executes immediately (unlike GroupBy)',
      'Access with lookup[key] which never throws',
    ],
    validPatterns: [/\.ToLookup\s*\(\s*\w+\s*=>\s*\w+\.Length\s*\)/i],
    tags: ['linq', 'tolookup', 'grouping', 'immediate-execution', 'advanced'],
  },
  {
    id: 'cs-linq-except-intersect-1',
    category: 'Advanced LINQ',
    difficulty: 'medium',
    title: 'Set Operations: Except and Intersect',
    text: 'Find numbers in the first list that are not in the second using Except()',
    setup: 'int[] available = { 1, 2, 3, 4, 5, 6, 7, 8 };\nint[] taken = { 2, 4, 6 };',
    setupCode: 'int[] available = { 1, 2, 3, 4, 5, 6, 7, 8 };\nint[] taken = { 2, 4, 6 };',
    expected: '{ 1, 3, 5, 7, 8 }',
    sample: 'available.Except(taken)',
    hints: [
      'Except returns elements in first but not in second',
      'Intersect returns common elements',
      'Both automatically remove duplicates',
    ],
    validPatterns: [/\.Except\s*\(\s*\w+\s*\)/i],
    tags: ['linq', 'except', 'set-operations', 'advanced'],
  },

  // --- HARD (5 problems) ---
  {
    id: 'cs-linq-complex-groupby-1',
    category: 'Advanced LINQ',
    difficulty: 'hard',
    title: 'Multi-Level GroupBy with Composite Key',
    text: 'Group transactions by year and month, calculate count and total per group',
    setup: 'var transactions = new[] { new { Date = new DateTime(2024, 1, 15), Amount = 100m }, new { Date = new DateTime(2024, 1, 20), Amount = 150m }, new { Date = new DateTime(2024, 2, 10), Amount = 200m }, new { Date = new DateTime(2024, 2, 25), Amount = 75m }, new { Date = new DateTime(2024, 1, 5), Amount = 50m } };',
    setupCode: 'var transactions = new[] { new { Date = new DateTime(2024, 1, 15), Amount = 100m }, new { Date = new DateTime(2024, 1, 20), Amount = 150m }, new { Date = new DateTime(2024, 2, 10), Amount = 200m }, new { Date = new DateTime(2024, 2, 25), Amount = 75m }, new { Date = new DateTime(2024, 1, 5), Amount = 50m } };',
    expected: '{ { Year = 2024, Month = 1, Count = 3, Total = 300 }, { Year = 2024, Month = 2, Count = 2, Total = 275 } }',
    sample: 'transactions.GroupBy(t => new { t.Date.Year, t.Date.Month }).Select(g => new { g.Key.Year, g.Key.Month, Count = g.Count(), Total = g.Sum(t => t.Amount) })',
    hints: [
      'Use anonymous type for composite grouping key',
      'Access key parts with g.Key.PropertyName',
      'Combine multiple aggregates in the projection',
    ],
    validPatterns: [/\.GroupBy\s*\(\s*\w+\s*=>\s*new\s*\{.*Year.*Month.*\}\s*\)\.Select/i],
    tags: ['linq', 'groupby', 'composite-key', 'aggregate', 'advanced'],
  },
  {
    id: 'cs-linq-left-outer-join-1',
    category: 'Advanced LINQ',
    difficulty: 'hard',
    title: 'Left Outer Join Pattern',
    text: 'Perform left outer join to get all employees with their department (or "Unassigned" if null)',
    setup: 'var employees = new[] { new { Name = "Alice", DeptId = (int?)1 }, new { Name = "Bob", DeptId = (int?)null }, new { Name = "Carol", DeptId = (int?)2 } };\nvar departments = new[] { new { Id = 1, Name = "Engineering" }, new { Id = 2, Name = "Marketing" } };',
    setupCode: 'var employees = new[] { new { Name = "Alice", DeptId = (int?)1 }, new { Name = "Bob", DeptId = (int?)null }, new { Name = "Carol", DeptId = (int?)2 } };\nvar departments = new[] { new { Id = 1, Name = "Engineering" }, new { Id = 2, Name = "Marketing" } };',
    expected: '{ { Employee = "Alice", Dept = "Engineering" }, { Employee = "Bob", Dept = "Unassigned" }, { Employee = "Carol", Dept = "Marketing" } }',
    sample: 'employees.GroupJoin(departments, e => e.DeptId, d => (int?)d.Id, (e, depts) => new { e, depts }).SelectMany(x => x.depts.DefaultIfEmpty(), (x, d) => new { Employee = x.e.Name, Dept = d?.Name ?? "Unassigned" })',
    hints: [
      'Left outer join = GroupJoin + SelectMany + DefaultIfEmpty',
      'DefaultIfEmpty ensures unmatched rows are included',
      'Handle null with ?. and ?? operators',
    ],
    validPatterns: [/\.GroupJoin\s*\(.*\)\.SelectMany\s*\(.*\.DefaultIfEmpty\s*\(\s*\)/i],
    tags: ['linq', 'left-outer-join', 'groupjoin', 'selectmany', 'advanced'],
  },
  {
    id: 'cs-linq-nested-from-1',
    category: 'Advanced LINQ',
    difficulty: 'hard',
    title: 'Query Syntax: Nested From for Combinations',
    text: 'Use multiple from clauses to find all pairs of numbers that sum to 100',
    setup: 'int[] numbers = { 10, 20, 30, 40, 50, 60, 70, 80, 90 };',
    setupCode: 'int[] numbers = { 10, 20, 30, 40, 50, 60, 70, 80, 90 };',
    expected: '{ (10, 90), (20, 80), (30, 70), (40, 60) }',
    sample: 'from a in numbers from b in numbers where a < b && a + b == 100 select (a, b)',
    hints: [
      'Multiple from clauses create a cross join',
      'Use a < b to avoid duplicate pairs',
      'Filter with where after the cross join',
    ],
    validPatterns: [/from\s+\w+\s+in\s+\w+\s+from\s+\w+\s+in\s+\w+\s+where.*<.*&&.*\+.*==\s*100/i],
    tags: ['linq', 'query-syntax', 'nested-from', 'cross-join', 'advanced'],
  },
  {
    id: 'cs-linq-aggregate-seed-result-1',
    category: 'Advanced LINQ',
    difficulty: 'hard',
    title: 'Aggregate with Seed and Result Selector',
    text: 'Count word frequencies and format as "word:count" string sorted by count descending',
    setup: 'string[] words = { "apple", "banana", "apple", "cherry", "banana", "apple" };',
    setupCode: 'string[] words = { "apple", "banana", "apple", "cherry", "banana", "apple" };',
    expected: '"apple:3, banana:2, cherry:1"',
    sample: 'words.Aggregate(new Dictionary<string, int>(), (dict, word) => { dict[word] = dict.GetValueOrDefault(word) + 1; return dict; }, dict => string.Join(", ", dict.OrderByDescending(kv => kv.Value).Select(kv => $"{kv.Key}:{kv.Value}")))',
    hints: [
      'Aggregate overload: seed, accumulator function, result selector',
      'Seed is the initial accumulator (empty dictionary)',
      'Result selector transforms final accumulator to output',
    ],
    validPatterns: [/\.Aggregate\s*\(\s*new\s+Dictionary.*,\s*\(.*\)\s*=>\s*\{.*\},\s*\w+\s*=>/i],
    tags: ['linq', 'aggregate', 'seed', 'result-selector', 'advanced'],
  },
  {
    id: 'cs-linq-deferred-pitfall-1',
    category: 'Advanced LINQ',
    difficulty: 'hard',
    title: 'Deferred Execution Pitfall',
    text: 'Demonstrate the deferred execution pitfall: the list is modified before the query is enumerated',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3 };\nvar evens = numbers.Where(x => x % 2 == 0);',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3 };\nvar evens = numbers.Where(x => x % 2 == 0);',
    expected: 'After numbers.Add(4): evens.ToList() returns { 2, 4 }',
    sample: 'numbers.Add(4); var result = evens.ToList();',
    hints: [
      'LINQ queries capture the source reference, not a snapshot',
      'The query executes when enumerated, seeing current state',
      'Use ToList() immediately to capture a snapshot if needed',
      'This behavior can cause unexpected results in loops',
    ],
    validPatterns: [/numbers\.Add\s*\(\s*4\s*\).*evens\.(ToList|ToArray)\s*\(\s*\)/i],
    tags: ['linq', 'deferred-execution', 'pitfall', 'advanced'],
  },

  // ============================================================
  // String Operations - Interpolation, StringBuilder, Span, Regex
  // ============================================================
  {
    id: 'cs-str-interpolation-format-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'String Interpolation with Formatting',
    text: 'Format the price as currency with 2 decimal places using string interpolation',
    setup: 'decimal price = 49.99m;',
    setupCode: 'decimal price = 49.99m;',
    expected: '"Price: $49.99"',
    sample: '$"Price: {price:C2}"',
    hints: [
      'Use :C2 format specifier for currency with 2 decimal places',
      'Format specifiers go after the colon inside the braces',
    ],
    validPatterns: [
      /\$".*\{price:C2?\}"/i,
      /\{price:C\d?\}/i,
    ],
    tags: ['string', 'interpolation', 'format', 'currency'],
  },
  {
    id: 'cs-str-interpolation-align-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'String Interpolation with Alignment',
    text: 'Create a right-aligned string with the name padded to 10 characters',
    setup: 'string name = "Alice";',
    setupCode: 'string name = "Alice";',
    expected: '"Name:      Alice"',
    sample: '$"Name: {name,10}"',
    hints: [
      'Use comma followed by width for alignment',
      'Positive width right-aligns, negative left-aligns',
    ],
    validPatterns: [
      /\$".*\{name,10\}"/i,
      /\{name,\d+\}/i,
    ],
    tags: ['string', 'interpolation', 'alignment', 'format'],
  },
  {
    id: 'cs-str-interpolation-datetime-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Format DateTime in Interpolation',
    text: 'Format the date as "yyyy-MM-dd" using string interpolation',
    setup: 'DateTime date = new DateTime(2024, 12, 25);',
    setupCode: 'DateTime date = new DateTime(2024, 12, 25);',
    expected: '"Date: 2024-12-25"',
    sample: '$"Date: {date:yyyy-MM-dd}"',
    hints: [
      'DateTime format strings can be used directly in interpolation',
      'yyyy = 4-digit year, MM = 2-digit month, dd = 2-digit day',
    ],
    validPatterns: [
      /\$".*\{date:yyyy-MM-dd\}"/i,
      /\{date:yyyy-MM-dd\}/i,
    ],
    tags: ['string', 'interpolation', 'datetime', 'format'],
  },
  {
    id: 'cs-str-interpolation-expression-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Expression in String Interpolation',
    text: 'Calculate and display the area of a rectangle using interpolation with an expression',
    setup: 'int width = 5;\nint height = 3;',
    setupCode: 'int width = 5;\nint height = 3;',
    expected: '"Area: 15"',
    sample: '$"Area: {width * height}"',
    hints: [
      'Any valid C# expression can be used inside interpolation braces',
      'Complex expressions may need parentheses for clarity',
    ],
    validPatterns: [
      /\$".*\{width\s*\*\s*height\}"/i,
      /\{width.*\*.*height\}/i,
    ],
    tags: ['string', 'interpolation', 'expression'],
  },
  {
    id: 'cs-str-interpolation-ternary-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Ternary Expression in Interpolation',
    text: 'Display "Pass" or "Fail" based on score >= 60 using string interpolation',
    setup: 'int score = 75;',
    setupCode: 'int score = 75;',
    expected: '"Result: Pass"',
    sample: '$"Result: {(score >= 60 ? "Pass" : "Fail")}"',
    hints: [
      'Wrap ternary expressions in parentheses inside interpolation',
      'String literals inside need to be properly escaped or use different quotes',
    ],
    validPatterns: [
      /\$".*\{\(score\s*>=\s*60\s*\?/i,
      /score.*>=.*60.*\?.*Pass.*:.*Fail/i,
    ],
    tags: ['string', 'interpolation', 'ternary', 'conditional'],
  },
  {
    id: 'cs-str-stringbuilder-basic-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Basic StringBuilder Append',
    text: 'Build the string "Hello World!" using StringBuilder Append methods',
    setup: 'using System.Text;\nvar sb = new StringBuilder();',
    setupCode: 'using System.Text;\nvar sb = new StringBuilder();',
    expected: '"Hello World!"',
    sample: 'sb.Append("Hello").Append(" ").Append("World!");',
    hints: [
      'Append returns the StringBuilder for method chaining',
      'StringBuilder is mutable and more efficient for multiple concatenations',
    ],
    validPatterns: [
      /sb\.Append\("Hello"\).*\.Append\(" "\).*\.Append\("World!"\)/i,
      /sb\.Append.*\.Append.*\.Append/i,
    ],
    tags: ['string', 'stringbuilder', 'append', 'performance'],
  },
  {
    id: 'cs-str-stringbuilder-appendline-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'StringBuilder with AppendLine',
    text: 'Create a multi-line string with "Line 1" and "Line 2" using AppendLine',
    setup: 'using System.Text;\nvar sb = new StringBuilder();',
    setupCode: 'using System.Text;\nvar sb = new StringBuilder();',
    expected: '"Line 1\\nLine 2\\n"',
    sample: 'sb.AppendLine("Line 1").AppendLine("Line 2");',
    hints: [
      'AppendLine adds the text plus a newline character',
      'Use Environment.NewLine for platform-specific line endings',
    ],
    validPatterns: [
      /sb\.AppendLine\("Line 1"\).*\.AppendLine\("Line 2"\)/i,
      /AppendLine.*AppendLine/i,
    ],
    tags: ['string', 'stringbuilder', 'appendline', 'multiline'],
  },
  {
    id: 'cs-str-stringbuilder-insert-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'StringBuilder Insert',
    text: 'Insert "Beautiful " at index 6 in the StringBuilder containing "Hello World!"',
    setup: 'using System.Text;\nvar sb = new StringBuilder("Hello World!");',
    setupCode: 'using System.Text;\nvar sb = new StringBuilder("Hello World!");',
    expected: '"Hello Beautiful World!"',
    sample: 'sb.Insert(6, "Beautiful ");',
    hints: [
      'Insert takes an index and the value to insert',
      'Existing content shifts to the right',
    ],
    validPatterns: [
      /sb\.Insert\(6,\s*"Beautiful "\)/i,
      /\.Insert\(6/i,
    ],
    tags: ['string', 'stringbuilder', 'insert'],
  },
  {
    id: 'cs-str-stringbuilder-replace-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'StringBuilder Replace',
    text: 'Replace all occurrences of "old" with "new" using StringBuilder Replace',
    setup: 'using System.Text;\nvar sb = new StringBuilder("old value and old data");',
    setupCode: 'using System.Text;\nvar sb = new StringBuilder("old value and old data");',
    expected: '"new value and new data"',
    sample: 'sb.Replace("old", "new");',
    hints: [
      'Replace modifies the StringBuilder in-place',
      'Replaces all occurrences, not just the first',
    ],
    validPatterns: [
      /sb\.Replace\("old",\s*"new"\)/i,
      /\.Replace\("old"/i,
    ],
    tags: ['string', 'stringbuilder', 'replace'],
  },
  {
    id: 'cs-str-stringbuilder-format-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'StringBuilder with AppendFormat',
    text: 'Append formatted text "Name: Alice, Age: 30" using AppendFormat',
    setup: 'using System.Text;\nvar sb = new StringBuilder();\nstring name = "Alice";\nint age = 30;',
    setupCode: 'using System.Text;\nvar sb = new StringBuilder();\nstring name = "Alice";\nint age = 30;',
    expected: '"Name: Alice, Age: 30"',
    sample: 'sb.AppendFormat("Name: {0}, Age: {1}", name, age);',
    hints: [
      'AppendFormat uses the same format syntax as String.Format',
      'Placeholders are {0}, {1}, etc.',
    ],
    validPatterns: [
      /sb\.AppendFormat\(".*\{0\}.*\{1\}"/i,
      /\.AppendFormat\(/i,
    ],
    tags: ['string', 'stringbuilder', 'format', 'appendformat'],
  },
  {
    id: 'cs-str-span-slice-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Span<char> Slice from String',
    text: 'Extract "World" from the string as a ReadOnlySpan<char> using AsSpan and Slice',
    setup: 'string text = "Hello World!";',
    setupCode: 'string text = "Hello World!";',
    expected: 'ReadOnlySpan<char> containing "World"',
    sample: 'text.AsSpan().Slice(6, 5)',
    hints: [
      'AsSpan() creates a span view without copying',
      'Slice(start, length) extracts a portion',
    ],
    validPatterns: [
      /text\.AsSpan\(\)\.Slice\(6,\s*5\)/i,
      /\.AsSpan\(\).*\.Slice\(/i,
    ],
    tags: ['string', 'span', 'slice', 'performance'],
  },
  {
    id: 'cs-str-span-range-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Span<char> with Range Operator',
    text: 'Get the last 6 characters of the string as a ReadOnlySpan<char> using range syntax',
    setup: 'string text = "Hello World!";',
    setupCode: 'string text = "Hello World!";',
    expected: 'ReadOnlySpan<char> containing "World!"',
    sample: 'text.AsSpan()[^6..]',
    hints: [
      'Range operator works with spans',
      '^6.. means from 6th-from-end to end',
    ],
    validPatterns: [
      /text\.AsSpan\(\)\[\^6\.\.\.?\]/i,
      /\.AsSpan\(\)\[\^\d+\.\./i,
    ],
    tags: ['string', 'span', 'range', 'index'],
  },
  {
    id: 'cs-str-span-stackalloc-1',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Span<char> with stackalloc',
    text: 'Create a char buffer on the stack and copy the reversed string into it',
    setup: 'string text = "Hello";',
    setupCode: 'string text = "Hello";',
    expected: 'Span<char> containing "olleH"',
    sample: 'Span<char> buffer = stackalloc char[text.Length];\ntext.AsSpan().CopyTo(buffer);\nbuffer.Reverse();',
    hints: [
      'stackalloc allocates memory on the stack (fast, no GC)',
      'CopyTo copies span contents to another span',
      'Reverse() reverses the span in-place',
    ],
    validPatterns: [
      /stackalloc\s+char\[/i,
      /\.CopyTo\(.*\).*\.Reverse\(/i,
    ],
    tags: ['string', 'span', 'stackalloc', 'performance', 'advanced'],
  },
  {
    id: 'cs-str-regex-match-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Basic Regex Match',
    text: 'Check if the string contains a valid email pattern using Regex.IsMatch',
    setup: 'using System.Text.RegularExpressions;\nstring email = "user@example.com";',
    setupCode: 'using System.Text.RegularExpressions;\nstring email = "user@example.com";',
    expected: 'true',
    sample: 'Regex.IsMatch(email, @"^[\\w.-]+@[\\w.-]+\\.\\w+$")',
    hints: [
      'Use @ for verbatim strings to avoid double escaping',
      'IsMatch returns true if any match is found',
    ],
    validPatterns: [
      /Regex\.IsMatch\(email/i,
      /Regex\.IsMatch.*@/i,
    ],
    tags: ['string', 'regex', 'match', 'validation'],
  },
  {
    id: 'cs-str-regex-replace-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Regex Replace',
    text: 'Replace all digits in the string with "#" using Regex.Replace',
    setup: 'using System.Text.RegularExpressions;\nstring text = "Phone: 123-456-7890";',
    setupCode: 'using System.Text.RegularExpressions;\nstring text = "Phone: 123-456-7890";',
    expected: '"Phone: ###-###-####"',
    sample: 'Regex.Replace(text, @"\\d", "#")',
    hints: [
      '\\d matches any digit',
      'Replace replaces all matches by default',
    ],
    validPatterns: [
      /Regex\.Replace\(text,\s*@?"\\d"/i,
      /Regex\.Replace.*\\d.*#/i,
    ],
    tags: ['string', 'regex', 'replace'],
  },
  {
    id: 'cs-str-regex-groups-1',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Regex Capture Groups',
    text: 'Extract the area code from a phone number using named capture groups',
    setup: 'using System.Text.RegularExpressions;\nstring phone = "(555) 123-4567";',
    setupCode: 'using System.Text.RegularExpressions;\nstring phone = "(555) 123-4567";',
    expected: '"555"',
    sample: 'Regex.Match(phone, @"\\((?<area>\\d{3})\\)").Groups["area"].Value',
    hints: [
      'Named groups use (?<name>pattern) syntax',
      'Access captured value via Groups["name"].Value',
    ],
    validPatterns: [
      /Regex\.Match.*\(\?<\w+>.*Groups\["\w+"\]/i,
      /\(\?<area>/i,
    ],
    tags: ['string', 'regex', 'groups', 'capture', 'advanced'],
  },
  {
    id: 'cs-str-regex-split-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Regex Split',
    text: 'Split the string by any whitespace characters (spaces, tabs, newlines)',
    setup: 'using System.Text.RegularExpressions;\nstring text = "one  two\\tthree\\nfour";',
    setupCode: 'using System.Text.RegularExpressions;\nstring text = "one  two\\tthree\\nfour";',
    expected: '["one", "two", "three", "four"]',
    sample: 'Regex.Split(text, @"\\s+")',
    hints: [
      '\\s matches any whitespace character',
      '+ means one or more occurrences',
    ],
    validPatterns: [
      /Regex\.Split\(text,\s*@?"\\s\+"/i,
      /Regex\.Split.*\\s\+/i,
    ],
    tags: ['string', 'regex', 'split', 'whitespace'],
  },
  {
    id: 'cs-str-comparison-ordinal-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Ordinal String Comparison',
    text: 'Compare two strings using case-insensitive ordinal comparison',
    setup: 'string a = "Hello";\nstring b = "HELLO";',
    setupCode: 'string a = "Hello";\nstring b = "HELLO";',
    expected: 'true',
    sample: 'string.Equals(a, b, StringComparison.OrdinalIgnoreCase)',
    hints: [
      'OrdinalIgnoreCase is fastest for case-insensitive comparison',
      'Ordinal comparison uses byte-by-byte comparison',
    ],
    validPatterns: [
      /string\.Equals\(a,\s*b,\s*StringComparison\.OrdinalIgnoreCase\)/i,
      /StringComparison\.OrdinalIgnoreCase/i,
    ],
    tags: ['string', 'comparison', 'ordinal', 'case-insensitive'],
  },
  {
    id: 'cs-str-comparison-culture-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Culture-Aware String Comparison',
    text: 'Compare strings using current culture rules (for proper linguistic sorting)',
    setup: 'string a = "cafe";\nstring b = "CAFE";',
    setupCode: 'string a = "cafe";\nstring b = "CAFE";',
    expected: 'true',
    sample: 'string.Equals(a, b, StringComparison.CurrentCultureIgnoreCase)',
    hints: [
      'CurrentCulture uses linguistic rules of the current thread culture',
      'Use for user-facing text comparison',
    ],
    validPatterns: [
      /StringComparison\.CurrentCultureIgnoreCase/i,
      /string\.Equals.*CurrentCultureIgnoreCase/i,
    ],
    tags: ['string', 'comparison', 'culture', 'localization'],
  },
  {
    id: 'cs-str-comparison-invariant-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Invariant Culture Comparison',
    text: 'Compare strings using invariant culture for consistent cross-culture behavior',
    setup: 'string a = "strasse";\nstring b = "STRASSE";',
    setupCode: 'string a = "strasse";\nstring b = "STRASSE";',
    expected: 'true',
    sample: 'string.Compare(a, b, StringComparison.InvariantCultureIgnoreCase) == 0',
    hints: [
      'InvariantCulture provides consistent behavior across cultures',
      'Use for data that will be stored or compared across systems',
    ],
    validPatterns: [
      /StringComparison\.InvariantCultureIgnoreCase/i,
      /string\.Compare.*InvariantCultureIgnoreCase/i,
    ],
    tags: ['string', 'comparison', 'invariant', 'culture'],
  },
  {
    id: 'cs-str-split-options-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Split with StringSplitOptions',
    text: 'Split the string and remove empty entries',
    setup: 'string text = "one,,two,,,three";',
    setupCode: 'string text = "one,,two,,,three";',
    expected: '["one", "two", "three"]',
    sample: "text.Split(',', StringSplitOptions.RemoveEmptyEntries)",
    hints: [
      'StringSplitOptions.RemoveEmptyEntries removes empty strings from result',
      'Can combine with TrimEntries in .NET 5+',
    ],
    validPatterns: [
      /text\.Split\(',.*StringSplitOptions\.RemoveEmptyEntries/i,
      /StringSplitOptions\.RemoveEmptyEntries/i,
    ],
    tags: ['string', 'split', 'options'],
  },
  {
    id: 'cs-str-split-trim-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Split with Trim Entries',
    text: 'Split the string, remove empty entries, and trim whitespace from each',
    setup: 'string text = " one , two , three ";',
    setupCode: 'string text = " one , two , three ";',
    expected: '["one", "two", "three"]',
    sample: "text.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)",
    hints: [
      'TrimEntries trims whitespace from each result (requires .NET 5+)',
      'Use | to combine multiple options',
    ],
    validPatterns: [
      /StringSplitOptions\.RemoveEmptyEntries\s*\|\s*StringSplitOptions\.TrimEntries/i,
      /TrimEntries/i,
    ],
    tags: ['string', 'split', 'trim', 'options'],
  },
  {
    id: 'cs-str-format-provider-1',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Format with CultureInfo',
    text: 'Format the number using German culture (uses comma as decimal separator)',
    setup: 'using System.Globalization;\ndouble value = 1234.56;',
    setupCode: 'using System.Globalization;\ndouble value = 1234.56;',
    expected: '"1.234,56"',
    sample: 'value.ToString("N2", CultureInfo.GetCultureInfo("de-DE"))',
    hints: [
      'CultureInfo determines number and date formatting',
      'German uses . for thousands and , for decimals',
    ],
    validPatterns: [
      /\.ToString\("N2",\s*CultureInfo\.GetCultureInfo\("de-DE"\)\)/i,
      /CultureInfo.*de-DE/i,
    ],
    tags: ['string', 'format', 'culture', 'localization', 'advanced'],
  },
  {
    id: 'cs-str-format-composite-1',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Composite Format with Multiple Specifiers',
    text: 'Format a table row with left-aligned name (15 chars) and right-aligned price (10 chars, currency)',
    setup: 'string name = "Widget";\ndecimal price = 29.99m;',
    setupCode: 'string name = "Widget";\ndecimal price = 29.99m;',
    expected: '"Widget             $29.99"',
    sample: 'string.Format("{0,-15}{1,10:C}", name, price)',
    hints: [
      'Negative width left-aligns, positive right-aligns',
      'Combine alignment and format: {index,alignment:format}',
    ],
    validPatterns: [
      /string\.Format\("\{0,-15\}\{1,10:C\}"/i,
      /\{\d+,-?\d+:C\}/i,
    ],
    tags: ['string', 'format', 'alignment', 'composite', 'advanced'],
  },
  {
    id: 'cs-str-join-linq-1',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Join with LINQ Transformation',
    text: 'Create a comma-separated list of squared values',
    setup: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    expected: '"1, 4, 9, 16, 25"',
    sample: 'string.Join(", ", numbers.Select(n => n * n))',
    hints: [
      'String.Join works with any IEnumerable',
      'Combine with LINQ Select for transformation',
    ],
    validPatterns: [
      /string\.Join\(".*",\s*numbers\.Select\(.*\*/i,
      /Join.*Select.*\*/i,
    ],
    tags: ['string', 'join', 'linq', 'transform', 'advanced'],
  },
];

export default csharpProblems;
