import type { Problem } from '../types';

/**
 * C# coding drill problems
 * Covers: List<T> Methods, LINQ Methods, String Methods, Array Methods
 */

export const csharpProblems: Problem[] = [
  // ============================================================
  // Modern C# Features
  // ============================================================
  {
    id: 'csharp-range-slice-1',
    category: 'Modern C# Features',
    difficulty: 'easy',
    title: 'Slice Array with Range Operator',
    text: 'Get the last 3 elements of the array using the range operator (..)',
    setup: 'int[] numbers = { 1, 2, 3, 4, 5, 6 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 4, 5, 6 };',
    expected: '{ 4, 5, 6 }',
    sample: 'numbers[^3..]',
    hints: [
      '^n means n elements from the end',
      'Range operator (..) creates a slice without copying',
    ],
    tags: ['modern', 'range', 'index', 'c#8'],
  },
  {
    id: 'csharp-range-middle-1',
    category: 'Modern C# Features',
    difficulty: 'medium',
    title: 'Extract Middle Elements with Range',
    text: 'Get elements from index 1 to 4 (exclusive) using the range operator',
    setup: 'int[] numbers = { 10, 20, 30, 40, 50 };',
    setupCode: 'int[] numbers = { 10, 20, 30, 40, 50 };',
    expected: '{ 20, 30, 40 }',
    sample: 'numbers[1..4]',
    hints: ['Range is inclusive at start, exclusive at end', 'Similar to Python slicing syntax'],
    tags: ['modern', 'range', 'slice', 'c#8'],
  },
  {
    id: 'csharp-null-coalescing-1',
    category: 'Modern C# Features',
    difficulty: 'easy',
    title: 'Null Coalescing Operator',
    text: 'Return the name or "Unknown" if null using the null-coalescing operator (??)',
    setup: 'string? name = null;',
    setupCode: 'string? name = null;',
    expected: '"Unknown"',
    sample: 'name ?? "Unknown"',
    hints: [
      '?? returns the left operand if not null, otherwise the right',
      'Works with nullable value types and reference types',
    ],
    tags: ['modern', 'null', 'coalescing', 'nullable'],
  },
  {
    id: 'csharp-null-coalescing-assign-1',
    category: 'Modern C# Features',
    difficulty: 'medium',
    title: 'Null Coalescing Assignment',
    text: 'Assign "Default" to name only if it is null using ??=',
    setup: 'string? name = null;',
    setupCode: 'string? name = null;',
    expected: 'name = "Default"',
    sample: 'name ??= "Default";',
    hints: ['??= assigns only if the variable is null', 'Introduced in C# 8.0'],
    tags: ['modern', 'null', 'assignment', 'c#8'],
  },
  {
    id: 'csharp-pattern-is-1',
    category: 'Modern C# Features',
    difficulty: 'medium',
    title: 'Pattern Matching with is',
    text: 'Check if the object is a non-null string with length > 5 using pattern matching',
    setup: 'object? value = "Hello World";',
    setupCode: 'object? value = "Hello World";',
    expected: 'true',
    sample: 'value is string s && s.Length > 5',
    hints: [
      'Pattern matching with is can declare a variable',
      'The variable is only in scope when the pattern matches',
    ],
    tags: ['modern', 'pattern', 'is', 'c#7'],
  },
  {
    id: 'csharp-switch-expression-1',
    category: 'Modern C# Features',
    difficulty: 'medium',
    title: 'Switch Expression',
    text: 'Convert day number (1-7) to day name using a switch expression',
    setup: 'int day = 3;',
    setupCode: 'int day = 3;',
    expected: '"Wednesday"',
    sample:
      'day switch { 1 => "Monday", 2 => "Tuesday", 3 => "Wednesday", 4 => "Thursday", 5 => "Friday", 6 => "Saturday", 7 => "Sunday", _ => "Invalid" }',
    hints: [
      'Switch expressions use => instead of case/break',
      'Use _ for the default/discard pattern',
    ],
    tags: ['modern', 'switch', 'expression', 'c#8'],
  },
  {
    id: 'csharp-string-interpolation-1',
    category: 'Modern C# Features',
    difficulty: 'easy',
    title: 'String Interpolation',
    text: 'Create a greeting message using string interpolation',
    setup: 'string name = "Alice";\nint age = 30;',
    setupCode: 'string name = "Alice";\nint age = 30;',
    expected: '"Hello, Alice! You are 30 years old."',
    sample: '$"Hello, {name}! You are {age} years old."',
    hints: ['String interpolation uses $ prefix', 'Expressions inside {} are evaluated at runtime'],
    tags: ['modern', 'string', 'interpolation', 'c#6'],
  },
  {
    id: 'csharp-raw-string-1',
    category: 'Modern C# Features',
    difficulty: 'medium',
    title: 'Raw String Literals',
    text: 'Create a JSON string using raw string literals (triple quotes)',
    setup: 'string name = "test";',
    setupCode: 'string name = "test";',
    expected: '{"name": "test"}',
    sample: '$$"""{"name": "{{name}}"}"""',
    hints: [
      'Raw strings start and end with """',
      'Use $$ with {{ }} for interpolation in raw strings',
      'Introduced in C# 11',
    ],
    tags: ['modern', 'string', 'raw', 'c#11'],
  },

  // ============================================================
  // List<T> Methods
  // ============================================================
  {
    id: 'csharp-list-add-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Add Element to List',
    text: 'Add the value 42 to the end of the list using Add()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    expected: '{ 1, 2, 3, 42 }',
    sample: 'numbers.Add(42);',
    hints: [
      'Add() appends a single element to the end of the list',
      'Add() modifies the list in-place and returns void',
    ],
    tags: ['list', 'add', 'collections'],
  },
  {
    id: 'csharp-list-addrange-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Add Multiple Elements',
    text: 'Add the elements { 4, 5, 6 } to the list using AddRange()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    expected: '{ 1, 2, 3, 4, 5, 6 }',
    sample: 'numbers.AddRange(new[] { 4, 5, 6 });',
    hints: ['AddRange() adds all elements from a collection to the end of the list'],
    tags: ['list', 'addrange', 'collections'],
  },
  {
    id: 'csharp-list-remove-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Remove Element by Value',
    text: 'Remove the first occurrence of the value 3 using Remove()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 3 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 3 };',
    expected: '{ 1, 2, 4, 3 }',
    sample: 'numbers.Remove(3);',
    hints: ['Remove() removes the first occurrence and returns true if found'],
    tags: ['list', 'remove', 'collections'],
  },
  {
    id: 'csharp-list-removeat-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Remove Element by Index',
    text: 'Remove the element at index 2 using RemoveAt()',
    setup: 'List<int> numbers = new List<int> { 10, 20, 30, 40 };',
    setupCode: 'List<int> numbers = new List<int> { 10, 20, 30, 40 };',
    expected: '{ 10, 20, 40 }',
    sample: 'numbers.RemoveAt(2);',
    hints: ['RemoveAt() removes the element at the specified index'],
    tags: ['list', 'removeat', 'collections'],
  },
  {
    id: 'csharp-list-removeall-1',
    category: 'List Methods',
    difficulty: 'medium',
    title: 'Remove All Matching Elements',
    text: 'Remove all even numbers from the list using RemoveAll()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };',
    expected: '{ 1, 3, 5 }',
    sample: 'numbers.RemoveAll(x => x % 2 == 0);',
    hints: ['RemoveAll() takes a Predicate<T> and removes all matching elements'],
    tags: ['list', 'removeall', 'lambda', 'collections'],
  },
  {
    id: 'csharp-list-contains-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Check if List Contains Element',
    text: 'Check if the list contains the value 3 using Contains()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    expected: 'true',
    sample: 'numbers.Contains(3)',
    hints: ['Contains() returns true if the element exists in the list'],
    tags: ['list', 'contains', 'collections'],
  },
  {
    id: 'csharp-list-indexof-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Find Index of Element',
    text: 'Find the index of the value 30 using IndexOf()',
    setup: 'List<int> numbers = new List<int> { 10, 20, 30, 40 };',
    setupCode: 'List<int> numbers = new List<int> { 10, 20, 30, 40 };',
    expected: '2',
    sample: 'numbers.IndexOf(30)',
    hints: ['IndexOf() returns -1 if the element is not found'],
    tags: ['list', 'indexof', 'collections'],
  },
  {
    id: 'csharp-list-count-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Get List Count',
    text: 'Get the number of elements in the list using the Count property',
    setup: 'List<string> names = new List<string> { "Alice", "Bob", "Charlie" };',
    setupCode: 'List<string> names = new List<string> { "Alice", "Bob", "Charlie" };',
    expected: '3',
    sample: 'names.Count',
    hints: ['Count is a property, not a method, so no parentheses needed'],
    tags: ['list', 'count', 'collections'],
  },
  {
    id: 'csharp-list-sort-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Sort List in Ascending Order',
    text: 'Sort the list in ascending order using Sort()',
    setup: 'List<int> numbers = new List<int> { 5, 2, 8, 1, 9 };',
    setupCode: 'List<int> numbers = new List<int> { 5, 2, 8, 1, 9 };',
    expected: '{ 1, 2, 5, 8, 9 }',
    sample: 'numbers.Sort();',
    hints: ['Sort() sorts the list in-place in ascending order by default'],
    tags: ['list', 'sort', 'collections'],
  },
  {
    id: 'csharp-list-reverse-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Reverse List Order',
    text: 'Reverse the order of elements in the list using Reverse()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    expected: '{ 5, 4, 3, 2, 1 }',
    sample: 'numbers.Reverse();',
    hints: ['Reverse() reverses the list in-place'],
    tags: ['list', 'reverse', 'collections'],
  },
  {
    id: 'csharp-list-toarray-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Convert List to Array',
    text: 'Convert the list to an array using ToArray()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    expected: 'int[] { 1, 2, 3 }',
    sample: 'int[] arr = numbers.ToArray();',
    hints: ['ToArray() creates a new array containing all list elements'],
    tags: ['list', 'toarray', 'collections'],
  },
  {
    id: 'csharp-list-insert-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Insert Element at Index',
    text: 'Insert the value 99 at index 1 using Insert()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    expected: '{ 1, 99, 2, 3 }',
    sample: 'numbers.Insert(1, 99);',
    hints: [
      'Insert() adds an element at the specified index',
      'Existing elements shift to make room',
    ],
    tags: ['list', 'insert', 'collections'],
  },
  {
    id: 'csharp-list-clear-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Clear All Elements',
    text: 'Remove all elements from the list using Clear()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    expected: '{ } (empty list with Count = 0)',
    sample: 'numbers.Clear();',
    hints: [
      'Clear() removes all elements but keeps the list object',
      'Count becomes 0, but Capacity may remain',
    ],
    tags: ['list', 'clear', 'collections'],
  },
  {
    id: 'csharp-list-find-1',
    category: 'List Methods',
    difficulty: 'medium',
    title: 'Find First Matching Element',
    text: 'Find the first number greater than 15 using Find()',
    setup: 'List<int> numbers = new List<int> { 5, 10, 20, 25, 30 };',
    setupCode: 'List<int> numbers = new List<int> { 5, 10, 20, 25, 30 };',
    expected: '20',
    sample: 'numbers.Find(x => x > 15)',
    hints: [
      'Find() returns default(T) if no match is found',
      'For reference types, default is null',
    ],
    tags: ['list', 'find', 'predicate', 'collections'],
  },
  {
    id: 'csharp-list-findall-1',
    category: 'List Methods',
    difficulty: 'medium',
    title: 'Find All Matching Elements in List',
    text: 'Find all numbers greater than 15 using FindAll()',
    setup: 'List<int> numbers = new List<int> { 5, 10, 20, 25, 30 };',
    setupCode: 'List<int> numbers = new List<int> { 5, 10, 20, 25, 30 };',
    expected: '{ 20, 25, 30 }',
    sample: 'numbers.FindAll(x => x > 15)',
    hints: [
      'FindAll() returns a new List<T> with matching elements',
      'Returns empty list if no matches',
    ],
    tags: ['list', 'findall', 'predicate', 'collections'],
  },
  {
    id: 'csharp-list-exists-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Check if Element Exists in List',
    text: 'Check if any number is negative using Exists()',
    setup: 'List<int> numbers = new List<int> { 5, -3, 10, 8 };',
    setupCode: 'List<int> numbers = new List<int> { 5, -3, 10, 8 };',
    expected: 'true',
    sample: 'numbers.Exists(x => x < 0)',
    hints: [
      'Exists() is similar to LINQ Any() but is a List<T> method',
      'Returns true if any element matches the predicate',
    ],
    tags: ['list', 'exists', 'predicate', 'collections'],
  },
  {
    id: 'csharp-list-trueforall-1',
    category: 'List Methods',
    difficulty: 'medium',
    title: 'Check if All Elements Match',
    text: 'Check if all numbers are positive using TrueForAll()',
    setup: 'List<int> numbers = new List<int> { 1, 5, 10, 8 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 5, 10, 8 };',
    expected: 'true',
    sample: 'numbers.TrueForAll(x => x > 0)',
    hints: [
      'TrueForAll() is similar to LINQ All() but is a List<T> method',
      'Returns true if all elements match the predicate',
    ],
    tags: ['list', 'trueforall', 'predicate', 'collections'],
  },

  // ============================================================
  // Dictionary Methods
  // ============================================================
  {
    id: 'csharp-dict-add-1',
    category: 'Dictionary Methods',
    difficulty: 'easy',
    title: 'Add Key-Value Pair',
    text: 'Add a new entry with key "grape" and value 4 using Add()',
    setup:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    setupCode:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    expected: '{ apple: 1, banana: 2, grape: 4 }',
    sample: 'fruits.Add("grape", 4);',
    hints: [
      'Add() throws ArgumentException if key already exists',
      'Use indexer fruits["key"] = value to add or update',
    ],
    tags: ['dictionary', 'add', 'collections'],
  },
  {
    id: 'csharp-dict-trygetvalue-1',
    category: 'Dictionary Methods',
    difficulty: 'medium',
    title: 'Safely Get Value with TryGetValue',
    text: 'Try to get the value for key "banana" using TryGetValue()',
    setup:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    setupCode:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    expected: 'true and out value = 2',
    sample: 'fruits.TryGetValue("banana", out int value)',
    hints: [
      'TryGetValue() returns bool and sets out parameter',
      'Avoids KeyNotFoundException when key might not exist',
    ],
    tags: ['dictionary', 'trygetvalue', 'collections'],
  },
  {
    id: 'csharp-dict-containskey-1',
    category: 'Dictionary Methods',
    difficulty: 'easy',
    title: 'Check if Key Exists',
    text: 'Check if the dictionary contains the key "banana" using ContainsKey()',
    setup:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    setupCode:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    expected: 'true',
    sample: 'fruits.ContainsKey("banana")',
    hints: [
      'ContainsKey() is O(1) average time complexity',
      'Prefer TryGetValue() if you also need the value',
    ],
    tags: ['dictionary', 'containskey', 'collections'],
  },
  {
    id: 'csharp-dict-containsvalue-1',
    category: 'Dictionary Methods',
    difficulty: 'easy',
    title: 'Check if Value Exists',
    text: 'Check if the dictionary contains the value 2 using ContainsValue()',
    setup:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    setupCode:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    expected: 'true',
    sample: 'fruits.ContainsValue(2)',
    hints: [
      'ContainsValue() is O(n) as it must scan all values',
      'Consider using a reverse lookup dictionary if needed frequently',
    ],
    tags: ['dictionary', 'containsvalue', 'collections'],
  },
  {
    id: 'csharp-dict-remove-1',
    category: 'Dictionary Methods',
    difficulty: 'easy',
    title: 'Remove Key-Value Pair',
    text: 'Remove the entry with key "apple" using Remove()',
    setup:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    setupCode:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    expected: '{ banana: 2 }',
    sample: 'fruits.Remove("apple");',
    hints: [
      'Remove() returns true if key was found and removed',
      'Use Remove(key, out value) to also get the removed value',
    ],
    tags: ['dictionary', 'remove', 'collections'],
  },
  {
    id: 'csharp-dict-keys-1',
    category: 'Dictionary Methods',
    difficulty: 'easy',
    title: 'Get All Keys',
    text: 'Get all keys from the dictionary using the Keys property',
    setup:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    setupCode:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    expected: '{ "apple", "banana" }',
    sample: 'fruits.Keys',
    hints: [
      'Keys returns KeyCollection which implements IEnumerable<TKey>',
      'Use .ToList() or .ToArray() if you need a concrete collection',
    ],
    tags: ['dictionary', 'keys', 'collections'],
  },
  {
    id: 'csharp-dict-values-1',
    category: 'Dictionary Methods',
    difficulty: 'easy',
    title: 'Get All Values',
    text: 'Get all values from the dictionary using the Values property',
    setup:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    setupCode:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    expected: '{ 1, 2 }',
    sample: 'fruits.Values',
    hints: [
      'Values returns ValueCollection which implements IEnumerable<TValue>',
      'Use .ToList() or .ToArray() if you need a concrete collection',
    ],
    tags: ['dictionary', 'values', 'collections'],
  },
  {
    id: 'csharp-dict-getvalueordefault-1',
    category: 'Dictionary Methods',
    difficulty: 'medium',
    title: 'Get Value or Default',
    text: 'Get the value for "cherry" or 0 if not found using GetValueOrDefault()',
    setup:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    setupCode:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    expected: '0',
    sample: 'fruits.GetValueOrDefault("cherry")',
    hints: [
      'GetValueOrDefault() returns default(TValue) if key not found',
      'Can also specify a custom default: GetValueOrDefault("cherry", -1)',
    ],
    tags: ['dictionary', 'getvalueordefault', 'collections'],
  },

  // ============================================================
  // LINQ Methods
  // ============================================================
  {
    id: 'csharp-linq-where-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Filter with Where()',
    text: 'Filter the list to only include numbers greater than 5 using Where()',
    setup: 'List<int> numbers = new List<int> { 3, 7, 2, 9, 4, 8 };',
    setupCode: 'List<int> numbers = new List<int> { 3, 7, 2, 9, 4, 8 };',
    expected: '{ 7, 9, 8 }',
    sample: 'numbers.Where(x => x > 5)',
    hints: [
      'Where() filters elements based on a predicate',
      'Remember to add .ToList() if you need a List<T>',
    ],
    tags: ['linq', 'where', 'filter'],
  },
  {
    id: 'csharp-linq-select-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Transform with Select()',
    text: 'Double each number in the list using Select()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4 };',
    expected: '{ 2, 4, 6, 8 }',
    sample: 'numbers.Select(x => x * 2)',
    hints: ['Select() transforms each element using the provided function'],
    tags: ['linq', 'select', 'projection'],
  },
  {
    id: 'csharp-linq-orderby-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Sort with OrderBy()',
    text: 'Sort the list in ascending order using OrderBy()',
    setup: 'List<int> numbers = new List<int> { 5, 2, 8, 1, 9 };',
    setupCode: 'List<int> numbers = new List<int> { 5, 2, 8, 1, 9 };',
    expected: '{ 1, 2, 5, 8, 9 }',
    sample: 'numbers.OrderBy(x => x)',
    hints: ['OrderBy() returns a new sorted sequence', 'The lambda specifies the sort key'],
    tags: ['linq', 'orderby', 'sorting'],
  },
  {
    id: 'csharp-linq-orderbydesc-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Sort Descending with OrderByDescending()',
    text: 'Sort the list in descending order using OrderByDescending()',
    setup: 'List<int> numbers = new List<int> { 5, 2, 8, 1, 9 };',
    setupCode: 'List<int> numbers = new List<int> { 5, 2, 8, 1, 9 };',
    expected: '{ 9, 8, 5, 2, 1 }',
    sample: 'numbers.OrderByDescending(x => x)',
    hints: ['OrderByDescending() sorts in descending order'],
    tags: ['linq', 'orderbydescending', 'sorting'],
  },
  {
    id: 'csharp-linq-first-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Get First Element with First()',
    text: 'Get the first element of the list using First()',
    setup: 'List<int> numbers = new List<int> { 10, 20, 30 };',
    setupCode: 'List<int> numbers = new List<int> { 10, 20, 30 };',
    expected: '10',
    sample: 'numbers.First()',
    hints: [
      'First() throws an exception if the sequence is empty',
      'Use FirstOrDefault() for safe access',
    ],
    tags: ['linq', 'first', 'element'],
  },
  {
    id: 'csharp-linq-firstordefault-1',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'Get First Element Safely',
    text: 'Get the first even number, or 0 if none exist, using FirstOrDefault()',
    setup: 'List<int> numbers = new List<int> { 1, 3, 5, 7 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 3, 5, 7 };',
    expected: '0',
    sample: 'numbers.FirstOrDefault(x => x % 2 == 0)',
    hints: ['FirstOrDefault() returns default(T) if no match is found', 'default(int) is 0'],
    tags: ['linq', 'firstordefault', 'element'],
  },
  {
    id: 'csharp-linq-any-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Check if Any Element Matches',
    text: 'Check if any number is greater than 10 using Any()',
    setup: 'List<int> numbers = new List<int> { 5, 8, 12, 3 };',
    setupCode: 'List<int> numbers = new List<int> { 5, 8, 12, 3 };',
    expected: 'true',
    sample: 'numbers.Any(x => x > 10)',
    hints: [
      'Any() with a predicate checks if at least one element matches',
      'Any() without arguments checks if the sequence is non-empty',
    ],
    tags: ['linq', 'any', 'predicate'],
  },
  {
    id: 'csharp-linq-all-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Check if All Elements Match',
    text: 'Check if all numbers are positive using All()',
    setup: 'List<int> numbers = new List<int> { 1, 5, 3, 8 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 5, 3, 8 };',
    expected: 'true',
    sample: 'numbers.All(x => x > 0)',
    hints: ['All() returns true if every element satisfies the predicate'],
    tags: ['linq', 'all', 'predicate'],
  },
  {
    id: 'csharp-linq-count-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Count Elements with LINQ',
    text: 'Count how many numbers are even using Count()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };',
    expected: '3',
    sample: 'numbers.Count(x => x % 2 == 0)',
    hints: [
      'Count() with a predicate counts matching elements',
      'Count() without arguments returns total count',
    ],
    tags: ['linq', 'count', 'aggregate'],
  },
  {
    id: 'csharp-linq-sum-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Calculate Sum with Sum()',
    text: 'Calculate the sum of all numbers using Sum()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    expected: '15',
    sample: 'numbers.Sum()',
    hints: ['Sum() adds all elements in the sequence'],
    tags: ['linq', 'sum', 'aggregate'],
  },
  {
    id: 'csharp-linq-average-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Calculate Average',
    text: 'Calculate the average of all numbers using Average()',
    setup: 'List<int> numbers = new List<int> { 2, 4, 6, 8, 10 };',
    setupCode: 'List<int> numbers = new List<int> { 2, 4, 6, 8, 10 };',
    expected: '6.0',
    sample: 'numbers.Average()',
    hints: ['Average() returns a double'],
    tags: ['linq', 'average', 'aggregate'],
  },
  {
    id: 'csharp-linq-max-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Find Maximum Value',
    text: 'Find the maximum value using Max()',
    setup: 'List<int> numbers = new List<int> { 3, 7, 2, 9, 4 };',
    setupCode: 'List<int> numbers = new List<int> { 3, 7, 2, 9, 4 };',
    expected: '9',
    sample: 'numbers.Max()',
    hints: ['Max() throws an exception if the sequence is empty'],
    tags: ['linq', 'max', 'aggregate'],
  },
  {
    id: 'csharp-linq-min-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Find Minimum Value',
    text: 'Find the minimum value using Min()',
    setup: 'List<int> numbers = new List<int> { 3, 7, 2, 9, 4 };',
    setupCode: 'List<int> numbers = new List<int> { 3, 7, 2, 9, 4 };',
    expected: '2',
    sample: 'numbers.Min()',
    hints: ['Min() throws an exception if the sequence is empty'],
    tags: ['linq', 'min', 'aggregate'],
  },
  {
    id: 'csharp-linq-distinct-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Remove Duplicates with Distinct()',
    text: 'Remove duplicate values using Distinct()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 2, 3, 3, 3, 4 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 2, 3, 3, 3, 4 };',
    expected: '{ 1, 2, 3, 4 }',
    sample: 'numbers.Distinct()',
    hints: ['Distinct() returns a sequence with unique elements'],
    tags: ['linq', 'distinct', 'set'],
  },
  {
    id: 'csharp-linq-take-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Take First N Elements',
    text: 'Get the first 3 elements using Take()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };',
    expected: '{ 1, 2, 3 }',
    sample: 'numbers.Take(3)',
    hints: ['Take() returns the first n elements'],
    tags: ['linq', 'take', 'partition'],
  },
  {
    id: 'csharp-linq-skip-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Skip First N Elements',
    text: 'Skip the first 2 elements using Skip()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    expected: '{ 3, 4, 5 }',
    sample: 'numbers.Skip(2)',
    hints: ['Skip() bypasses the first n elements'],
    tags: ['linq', 'skip', 'partition'],
  },
  {
    id: 'csharp-linq-groupby-1',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'Group Elements with GroupBy()',
    text: 'Group numbers by whether they are even or odd using GroupBy()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };',
    expected: 'IEnumerable<IGrouping<bool, int>> with Key=false: {1,3,5} and Key=true: {2,4,6}',
    sample: 'numbers.GroupBy(x => x % 2 == 0)',
    hints: [
      'GroupBy() returns IEnumerable<IGrouping<TKey, TElement>>',
      'Access the key with group.Key and iterate elements with foreach',
      'Consider using ToDictionary() or ToLookup() for direct key access',
    ],
    tags: ['linq', 'groupby', 'grouping'],
  },
  {
    id: 'csharp-linq-aggregate-1',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'Custom Aggregation with Aggregate()',
    text: 'Calculate the product of all numbers using Aggregate()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4 };',
    expected: '24',
    sample: 'numbers.Aggregate((acc, x) => acc * x)',
    hints: [
      'Aggregate() applies a function cumulatively',
      'The accumulator starts with the first element',
    ],
    tags: ['linq', 'aggregate', 'reduce'],
  },
  {
    id: 'csharp-linq-aggregate-seed-1',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'Aggregate with Seed Value',
    text: 'Concatenate all names with a prefix of "Names:" using Aggregate()',
    setup: 'List<string> names = new List<string> { "Alice", "Bob", "Charlie" };',
    setupCode: 'List<string> names = new List<string> { "Alice", "Bob", "Charlie" };',
    expected: '"Names: Alice Bob Charlie"',
    sample: 'names.Aggregate("Names:", (acc, name) => acc + " " + name)',
    hints: [
      'Aggregate with a seed starts accumulation from that value',
      'The seed becomes the initial accumulator value',
    ],
    tags: ['linq', 'aggregate', 'reduce'],
  },

  // ============================================================
  // String Methods
  // ============================================================
  {
    id: 'csharp-string-length-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Get String Length',
    text: 'Get the length of the string using the Length property',
    setup: 'string text = "Hello, World!";',
    setupCode: 'string text = "Hello, World!";',
    expected: '13',
    sample: 'text.Length',
    hints: ['Length is a property, not a method'],
    tags: ['string', 'length'],
  },
  {
    id: 'csharp-string-substring-1',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Extract Substring',
    text: 'Extract "World" from the string using Substring()',
    setup: 'string text = "Hello, World!";',
    setupCode: 'string text = "Hello, World!";',
    expected: '"World"',
    sample: 'text.Substring(7, 5)',
    hints: ['Substring(startIndex, length) extracts a portion of the string'],
    tags: ['string', 'substring'],
  },
  {
    id: 'csharp-string-indexof-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Find Substring Position',
    text: 'Find the position of "World" in the string using IndexOf()',
    setup: 'string text = "Hello, World!";',
    setupCode: 'string text = "Hello, World!";',
    expected: '7',
    sample: 'text.IndexOf("World")',
    hints: ['IndexOf() returns -1 if the substring is not found'],
    tags: ['string', 'indexof'],
  },
  {
    id: 'csharp-string-contains-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Check if String Contains Substring',
    text: 'Check if the string contains "World" using Contains()',
    setup: 'string text = "Hello, World!";',
    setupCode: 'string text = "Hello, World!";',
    expected: 'true',
    sample: 'text.Contains("World")',
    hints: ['Contains() is case-sensitive by default'],
    tags: ['string', 'contains'],
  },
  {
    id: 'csharp-string-split-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Split String into Array',
    text: 'Split the string by commas using Split()',
    setup: 'string text = "apple,banana,cherry";',
    setupCode: 'string text = "apple,banana,cherry";',
    expected: '["apple", "banana", "cherry"]',
    sample: "text.Split(',')",
    hints: ['Split() returns a string array', 'Use char literals with single quotes'],
    tags: ['string', 'split'],
  },
  {
    id: 'csharp-string-join-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Join Array into String',
    text: 'Join the array elements with " - " separator using String.Join()',
    setup: 'string[] fruits = { "apple", "banana", "cherry" };',
    setupCode: 'string[] fruits = { "apple", "banana", "cherry" };',
    expected: '"apple - banana - cherry"',
    sample: 'string.Join(" - ", fruits)',
    hints: ['String.Join() is a static method'],
    tags: ['string', 'join'],
  },
  {
    id: 'csharp-string-toupper-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Convert to Uppercase',
    text: 'Convert the string to uppercase using ToUpper()',
    setup: 'string text = "Hello, World!";',
    setupCode: 'string text = "Hello, World!";',
    expected: '"HELLO, WORLD!"',
    sample: 'text.ToUpper()',
    hints: ['ToUpper() returns a new string; strings are immutable'],
    tags: ['string', 'toupper', 'case'],
  },
  {
    id: 'csharp-string-tolower-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Convert to Lowercase',
    text: 'Convert the string to lowercase using ToLower()',
    setup: 'string text = "Hello, World!";',
    setupCode: 'string text = "Hello, World!";',
    expected: '"hello, world!"',
    sample: 'text.ToLower()',
    hints: ['ToLower() returns a new string; strings are immutable'],
    tags: ['string', 'tolower', 'case'],
  },
  {
    id: 'csharp-string-trim-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Trim Whitespace',
    text: 'Remove leading and trailing whitespace using Trim()',
    setup: 'string text = "  Hello, World!  ";',
    setupCode: 'string text = "  Hello, World!  ";',
    expected: '"Hello, World!"',
    sample: 'text.Trim()',
    hints: [
      'Trim() removes whitespace from both ends',
      'Use TrimStart() or TrimEnd() for one side only',
    ],
    tags: ['string', 'trim'],
  },
  {
    id: 'csharp-string-replace-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Replace Substring',
    text: 'Replace "World" with "C#" using Replace()',
    setup: 'string text = "Hello, World!";',
    setupCode: 'string text = "Hello, World!";',
    expected: '"Hello, C#!"',
    sample: 'text.Replace("World", "C#")',
    hints: ['Replace() replaces all occurrences'],
    tags: ['string', 'replace'],
  },
  {
    id: 'csharp-string-startswith-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Check if String Starts With',
    text: 'Check if the string starts with "Hello" using StartsWith()',
    setup: 'string text = "Hello, World!";',
    setupCode: 'string text = "Hello, World!";',
    expected: 'true',
    sample: 'text.StartsWith("Hello")',
    hints: ['StartsWith() is case-sensitive by default'],
    tags: ['string', 'startswith'],
  },
  {
    id: 'csharp-string-endswith-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Check if String Ends With',
    text: 'Check if the string ends with "!" using EndsWith()',
    setup: 'string text = "Hello, World!";',
    setupCode: 'string text = "Hello, World!";',
    expected: 'true',
    sample: 'text.EndsWith("!")',
    hints: ['EndsWith() is case-sensitive by default'],
    tags: ['string', 'endswith'],
  },

  // ============================================================
  // Array Methods
  // ============================================================
  {
    id: 'csharp-array-sort-1',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Sort Array with Array.Sort()',
    text: 'Sort the array in ascending order using Array.Sort()',
    setup: 'int[] numbers = { 5, 2, 8, 1, 9 };',
    setupCode: 'int[] numbers = { 5, 2, 8, 1, 9 };',
    expected: '{ 1, 2, 5, 8, 9 }',
    sample: 'Array.Sort(numbers);',
    hints: ['Array.Sort() modifies the array in-place'],
    tags: ['array', 'sort'],
  },
  {
    id: 'csharp-array-reverse-1',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Reverse Array with Array.Reverse()',
    text: 'Reverse the order of elements using Array.Reverse()',
    setup: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    expected: '{ 5, 4, 3, 2, 1 }',
    sample: 'Array.Reverse(numbers);',
    hints: ['Array.Reverse() modifies the array in-place'],
    tags: ['array', 'reverse'],
  },
  {
    id: 'csharp-array-indexof-1',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Find Index in Array',
    text: 'Find the index of the value 30 using Array.IndexOf()',
    setup: 'int[] numbers = { 10, 20, 30, 40, 50 };',
    setupCode: 'int[] numbers = { 10, 20, 30, 40, 50 };',
    expected: '2',
    sample: 'Array.IndexOf(numbers, 30)',
    hints: ['Array.IndexOf() returns -1 if the element is not found'],
    tags: ['array', 'indexof'],
  },
  {
    id: 'csharp-array-exists-1',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Check if Element Exists with Array.Exists()',
    text: 'Check if any element is greater than 40 using Array.Exists()',
    setup: 'int[] numbers = { 10, 20, 30, 45, 50 };',
    setupCode: 'int[] numbers = { 10, 20, 30, 45, 50 };',
    expected: 'true',
    sample: 'Array.Exists(numbers, x => x > 40)',
    hints: ['Array.Exists() takes a Predicate<T>'],
    tags: ['array', 'exists', 'predicate'],
  },
  {
    id: 'csharp-array-find-1',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Find Element with Array.Find()',
    text: 'Find the first element greater than 25 using Array.Find()',
    setup: 'int[] numbers = { 10, 20, 30, 40, 50 };',
    setupCode: 'int[] numbers = { 10, 20, 30, 40, 50 };',
    expected: '30',
    sample: 'Array.Find(numbers, x => x > 25)',
    hints: ['Array.Find() returns default(T) if no match is found'],
    tags: ['array', 'find', 'predicate'],
  },
  {
    id: 'csharp-array-findall-1',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Find All Matching Elements',
    text: 'Find all elements greater than 25 using Array.FindAll()',
    setup: 'int[] numbers = { 10, 20, 30, 40, 50 };',
    setupCode: 'int[] numbers = { 10, 20, 30, 40, 50 };',
    expected: '{ 30, 40, 50 }',
    sample: 'Array.FindAll(numbers, x => x > 25)',
    hints: ['Array.FindAll() returns an array of all matching elements'],
    tags: ['array', 'findall', 'predicate'],
  },
  {
    id: 'csharp-array-copy-1',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Copy Array Elements',
    text: 'Copy the first 3 elements to a new array using Array.Copy()',
    setup: 'int[] source = { 1, 2, 3, 4, 5 };\nint[] dest = new int[3];',
    setupCode: 'int[] source = { 1, 2, 3, 4, 5 };\nint[] dest = new int[3];',
    expected: 'dest = { 1, 2, 3 }',
    sample: 'Array.Copy(source, dest, 3);',
    hints: ['Array.Copy() copies elements from source to destination'],
    tags: ['array', 'copy'],
  },
  {
    id: 'csharp-array-resize-1',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Resize Array',
    text: 'Resize the array to hold 5 elements using Array.Resize()',
    setup: 'int[] numbers = { 1, 2, 3 };',
    setupCode: 'int[] numbers = { 1, 2, 3 };',
    expected: '{ 1, 2, 3, 0, 0 }',
    sample: 'Array.Resize(ref numbers, 5);',
    hints: ['Array.Resize() requires ref keyword', 'New elements are initialized to default(T)'],
    tags: ['array', 'resize'],
  },

  // ============================================================
  // Additional LINQ Methods
  // ============================================================
  {
    id: 'cs-linq-selectmany-1',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'Flatten Nested Collections with SelectMany()',
    text: 'Flatten the list of lists into a single list using SelectMany()',
    setup:
      'List<List<int>> nested = new List<List<int>> { new List<int> { 1, 2 }, new List<int> { 3, 4 }, new List<int> { 5 } };',
    setupCode:
      'List<List<int>> nested = new List<List<int>> { new List<int> { 1, 2 }, new List<int> { 3, 4 }, new List<int> { 5 } };',
    expected: '{ 1, 2, 3, 4, 5 }',
    sample: 'nested.SelectMany(x => x)',
    hints: [
      'SelectMany() flattens nested collections into one sequence',
      'It projects each element to a sequence and flattens the result',
    ],
    validPatterns: [/nested\.SelectMany\s*\(\s*\w+\s*=>\s*\w+\s*\)/, /\.SelectMany\(/],
    tags: ['linq', 'selectmany', 'flatten', 'projection'],
  },
  {
    id: 'cs-linq-selectmany-2',
    category: 'LINQ Methods',
    difficulty: 'hard',
    title: 'SelectMany with Index and Projection',
    text: 'Flatten words and pair each character with its word index using SelectMany with index',
    setup: 'string[] words = { "Hi", "Bye" };',
    setupCode: 'string[] words = { "Hi", "Bye" };',
    expected: '{ (0, H), (0, i), (1, B), (1, y), (1, e) }',
    sample: 'words.SelectMany((word, idx) => word.Select(c => (idx, c)))',
    hints: [
      'SelectMany has an overload that provides the index of the source element',
      'You can combine it with Select to create tuples',
    ],
    validPatterns: [/\.SelectMany\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>/, /SelectMany.*Select/],
    tags: ['linq', 'selectmany', 'index', 'advanced'],
  },
  {
    id: 'cs-linq-groupby-key-1',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'GroupBy with Key Selector and Count',
    text: 'Group words by their first letter and count how many in each group',
    setup:
      'List<string> words = new List<string> { "apple", "apricot", "banana", "blueberry", "cherry" };',
    setupCode:
      'List<string> words = new List<string> { "apple", "apricot", "banana", "blueberry", "cherry" };',
    expected: '{ (a, 2), (b, 2), (c, 1) }',
    sample: 'words.GroupBy(w => w[0]).Select(g => (g.Key, g.Count()))',
    hints: [
      'GroupBy returns IGrouping<TKey, TElement> with a Key property',
      'Use Select to project each group into a result',
    ],
    validPatterns: [/\.GroupBy\s*\(.*\[0\].*\)/, /GroupBy.*\.Select.*Count\(/],
    tags: ['linq', 'groupby', 'count', 'projection'],
  },
  {
    id: 'cs-linq-aggregate-string-1',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'Build CSV String with Aggregate',
    text: 'Create a comma-separated string from the list using Aggregate()',
    setup: 'List<string> items = new List<string> { "one", "two", "three" };',
    setupCode: 'List<string> items = new List<string> { "one", "two", "three" };',
    expected: '"one,two,three"',
    sample: 'items.Aggregate((acc, x) => acc + "," + x)',
    hints: [
      'Aggregate without a seed uses the first element as the initial accumulator',
      'Consider String.Join for this common scenario',
    ],
    validPatterns: [
      /\.Aggregate\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>.*\+.*,.*\+/,
      /Aggregate.*\+\s*","\s*\+/,
    ],
    tags: ['linq', 'aggregate', 'string', 'reduce'],
  },
  {
    id: 'cs-linq-orderby-thenby-1',
    category: 'LINQ Methods',
    difficulty: 'hard',
    title: 'Multi-Level Sorting with OrderBy and ThenBy',
    text: 'Sort people by age ascending, then by name descending',
    setup: 'var people = new[] { ("Alice", 30), ("Bob", 25), ("Charlie", 30), ("Diana", 25) };',
    setupCode: 'var people = new[] { ("Alice", 30), ("Bob", 25), ("Charlie", 30), ("Diana", 25) };',
    expected: '{ (Diana, 25), (Bob, 25), (Charlie, 30), (Alice, 30) }',
    sample: 'people.OrderBy(p => p.Item2).ThenByDescending(p => p.Item1)',
    hints: [
      'Use ThenBy or ThenByDescending for secondary sort criteria',
      'OrderBy must come before ThenBy',
    ],
    validPatterns: [/\.OrderBy\s*\(.*\)\.ThenByDescending\s*\(/, /OrderBy.*ThenByDescending/],
    tags: ['linq', 'orderby', 'thenby', 'sorting', 'advanced'],
  },
  {
    id: 'cs-linq-where-index-1',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Filter with Where Using Index',
    text: 'Get elements at even indices using Where with index parameter',
    setup: 'List<string> items = new List<string> { "a", "b", "c", "d", "e" };',
    setupCode: 'List<string> items = new List<string> { "a", "b", "c", "d", "e" };',
    expected: '{ "a", "c", "e" }',
    sample: 'items.Where((item, index) => index % 2 == 0)',
    hints: [
      'Where has an overload that provides the index as a second parameter',
      'The index starts at 0',
    ],
    validPatterns: [
      /\.Where\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>.*%\s*2/,
      /Where.*index.*%.*2.*==.*0/,
    ],
    tags: ['linq', 'where', 'index', 'filter'],
  },

  // ============================================================
  // Additional String Methods
  // ============================================================
  {
    id: 'cs-string-format-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Format String with Placeholders',
    text: 'Create a formatted string "Name: Alice, Age: 30" using String.Format()',
    setup: 'string name = "Alice";\nint age = 30;',
    setupCode: 'string name = "Alice";\nint age = 30;',
    expected: '"Name: Alice, Age: 30"',
    sample: 'string.Format("Name: {0}, Age: {1}", name, age)',
    hints: [
      'String.Format uses {0}, {1}, etc. as placeholders',
      'Consider using string interpolation ($"") for simpler cases',
    ],
    validPatterns: [/string\.Format\s*\(\s*".*\{0\}.*\{1\}.*"/, /String\.Format/],
    tags: ['string', 'format', 'formatting'],
  },
  {
    id: 'cs-string-format-number-1',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Format Number with Thousands Separator',
    text: 'Format the number with thousands separator and 2 decimal places using String.Format()',
    setup: 'double amount = 1234567.891;',
    setupCode: 'double amount = 1234567.891;',
    expected: '"1,234,567.89"',
    sample: 'string.Format("{0:N2}", amount)',
    hints: [
      'N2 format specifier adds thousands separator and 2 decimal places',
      'C2 would add currency symbol',
    ],
    validPatterns: [/string\.Format\s*\(\s*"\{0:N2\}"/, /:N2\}/, /\.ToString\s*\(\s*"N2"\s*\)/],
    tags: ['string', 'format', 'number', 'formatting'],
  },
  {
    id: 'cs-string-padleft-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Pad String on Left',
    text: 'Pad the string to 10 characters with zeros on the left using PadLeft()',
    setup: 'string code = "42";',
    setupCode: 'string code = "42";',
    expected: '"0000000042"',
    sample: "code.PadLeft(10, '0')",
    hints: [
      'PadLeft adds padding characters to the left until the total length is reached',
      'If the string is already >= the specified length, no padding is added',
    ],
    validPatterns: [/\.PadLeft\s*\(\s*10\s*,\s*'0'\s*\)/, /PadLeft\s*\(\s*10/],
    tags: ['string', 'padleft', 'formatting'],
  },
  {
    id: 'cs-string-padright-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Pad String on Right',
    text: 'Pad the string to 15 characters with dots on the right using PadRight()',
    setup: 'string label = "Total";',
    setupCode: 'string label = "Total";',
    expected: '"Total.........."',
    sample: "label.PadRight(15, '.')",
    hints: [
      'PadRight adds padding characters to the right until the total length is reached',
      'Useful for creating aligned output',
    ],
    validPatterns: [/\.PadRight\s*\(\s*15\s*,\s*'\.'\s*\)/, /PadRight\s*\(\s*15/],
    tags: ['string', 'padright', 'formatting'],
  },
  {
    id: 'cs-string-trimstart-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Trim Leading Characters',
    text: 'Remove leading zeros from the string using TrimStart()',
    setup: 'string code = "000123";',
    setupCode: 'string code = "000123";',
    expected: '"123"',
    sample: "code.TrimStart('0')",
    hints: [
      'TrimStart removes specified characters from the beginning',
      'Without arguments, it removes whitespace',
    ],
    validPatterns: [/\.TrimStart\s*\(\s*'0'\s*\)/, /TrimStart.*0/],
    tags: ['string', 'trimstart', 'trim'],
  },
  {
    id: 'cs-string-trimend-1',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Trim Trailing Characters',
    text: 'Remove trailing exclamation marks from the string using TrimEnd()',
    setup: 'string text = "Hello!!!";',
    setupCode: 'string text = "Hello!!!";',
    expected: '"Hello"',
    sample: "text.TrimEnd('!')",
    hints: [
      'TrimEnd removes specified characters from the end',
      'Without arguments, it removes whitespace',
    ],
    validPatterns: [/\.TrimEnd\s*\(\s*'!'\s*\)/, /TrimEnd.*!/],
    tags: ['string', 'trimend', 'trim'],
  },
  {
    id: 'cs-string-join-format-1',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Join with Custom Separator',
    text: 'Join the integers with " | " separator, converting each to string',
    setup: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    expected: '"1 | 2 | 3 | 4 | 5"',
    sample: 'string.Join(" | ", numbers)',
    hints: ['String.Join automatically converts elements to strings', 'Works with any IEnumerable'],
    validPatterns: [/string\.Join\s*\(\s*"\s*\|\s*"/, /String\.Join.*\|/],
    tags: ['string', 'join', 'formatting'],
  },

  // ============================================================
  // Additional List Methods
  // ============================================================
  {
    id: 'cs-list-convertall-1',
    category: 'List Methods',
    difficulty: 'medium',
    title: 'Convert All Elements with ConvertAll()',
    text: 'Convert all integers to their string representations using ConvertAll()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    expected: '{ "1", "2", "3", "4", "5" }',
    sample: 'numbers.ConvertAll(x => x.ToString())',
    hints: [
      'ConvertAll is a List<T> method similar to Select but returns List<TOutput>',
      'More efficient than Select().ToList() for lists',
    ],
    validPatterns: [/\.ConvertAll\s*\(.*\.ToString\s*\(\s*\)\s*\)/, /ConvertAll.*ToString/],
    tags: ['list', 'convertall', 'conversion', 'collections'],
  },
  {
    id: 'cs-list-findindex-1',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Find Index with Predicate',
    text: 'Find the index of the first number greater than 20 using FindIndex()',
    setup: 'List<int> numbers = new List<int> { 5, 15, 25, 35, 45 };',
    setupCode: 'List<int> numbers = new List<int> { 5, 15, 25, 35, 45 };',
    expected: '2',
    sample: 'numbers.FindIndex(x => x > 20)',
    hints: [
      'FindIndex returns -1 if no element matches the predicate',
      'Different from IndexOf which searches for a specific value',
    ],
    validPatterns: [/\.FindIndex\s*\(\s*\w+\s*=>\s*\w+\s*>\s*20\s*\)/, /FindIndex.*>.*20/],
    tags: ['list', 'findindex', 'predicate', 'collections'],
  },
  {
    id: 'cs-list-findlast-1',
    category: 'List Methods',
    difficulty: 'hard',
    title: 'Find Last Matching Element',
    text: 'Find the last even number using FindLast()',
    setup: 'List<int> numbers = new List<int> { 2, 5, 8, 11, 14, 17 };',
    setupCode: 'List<int> numbers = new List<int> { 2, 5, 8, 11, 14, 17 };',
    expected: '14',
    sample: 'numbers.FindLast(x => x % 2 == 0)',
    hints: [
      'FindLast searches from the end of the list',
      'Returns default(T) if no match is found',
    ],
    validPatterns: [
      /\.FindLast\s*\(\s*\w+\s*=>\s*\w+\s*%\s*2\s*==\s*0\s*\)/,
      /FindLast.*%.*2.*==.*0/,
    ],
    tags: ['list', 'findlast', 'predicate', 'collections'],
  },
  {
    id: 'cs-list-binarysearch-1',
    category: 'List Methods',
    difficulty: 'hard',
    title: 'Binary Search in Sorted List',
    text: 'Find the index of value 30 using BinarySearch() (list is already sorted)',
    setup: 'List<int> numbers = new List<int> { 10, 20, 30, 40, 50 };',
    setupCode: 'List<int> numbers = new List<int> { 10, 20, 30, 40, 50 };',
    expected: '2',
    sample: 'numbers.BinarySearch(30)',
    hints: [
      'BinarySearch requires the list to be sorted',
      'Returns bitwise complement of next larger element index if not found',
    ],
    validPatterns: [/\.BinarySearch\s*\(\s*30\s*\)/, /BinarySearch\(30\)/],
    tags: ['list', 'binarysearch', 'search', 'collections'],
  },

  // ============================================================
  // Additional Dictionary Methods
  // ============================================================
  {
    id: 'cs-dict-tryadd-1',
    category: 'Dictionary Methods',
    difficulty: 'easy',
    title: 'Add if Key Does Not Exist with TryAdd()',
    text: 'Add "cherry" with value 3 only if the key does not exist using TryAdd()',
    setup:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    setupCode:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    expected: 'true (and fruits now has cherry: 3)',
    sample: 'fruits.TryAdd("cherry", 3)',
    hints: [
      'TryAdd returns true if added, false if key already exists',
      'Safer than Add which throws if key exists',
    ],
    validPatterns: [/\.TryAdd\s*\(\s*"cherry"\s*,\s*3\s*\)/, /TryAdd.*cherry.*3/],
    tags: ['dictionary', 'tryadd', 'collections'],
  },
  {
    id: 'cs-dict-getvalueordefault-custom-1',
    category: 'Dictionary Methods',
    difficulty: 'medium',
    title: 'Get Value with Custom Default',
    text: 'Get the value for "mango" or -1 if not found using GetValueOrDefault with custom default',
    setup:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    setupCode:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 1, ["banana"] = 2 };',
    expected: '-1',
    sample: 'fruits.GetValueOrDefault("mango", -1)',
    hints: [
      'GetValueOrDefault accepts an optional second parameter for custom default',
      'More concise than TryGetValue for simple cases',
    ],
    validPatterns: [
      /\.GetValueOrDefault\s*\(\s*"mango"\s*,\s*-1\s*\)/,
      /GetValueOrDefault.*mango.*-1/,
    ],
    tags: ['dictionary', 'getvalueordefault', 'collections'],
  },
  {
    id: 'cs-dict-trygetvalue-pattern-1',
    category: 'Dictionary Methods',
    difficulty: 'medium',
    title: 'TryGetValue with Pattern Matching',
    text: 'Get the value for "apple" and use it if found, otherwise use 0, using TryGetValue with pattern',
    setup:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 5, ["banana"] = 3 };',
    setupCode:
      'Dictionary<string, int> fruits = new Dictionary<string, int> { ["apple"] = 5, ["banana"] = 3 };',
    expected: '5',
    sample: 'fruits.TryGetValue("apple", out var value) ? value : 0',
    hints: [
      'TryGetValue can be combined with ternary operator',
      'The out variable is in scope for the entire expression',
    ],
    validPatterns: [
      /\.TryGetValue\s*\(\s*"apple"\s*,\s*out\s+(var\s+)?\w+\s*\)\s*\?/,
      /TryGetValue.*\?.*:/,
    ],
    tags: ['dictionary', 'trygetvalue', 'pattern', 'collections'],
  },

  // ============================================================
  // Nullable Handling
  // ============================================================
  {
    id: 'cs-nullable-conditional-1',
    category: 'Nullable Handling',
    difficulty: 'easy',
    title: 'Null-Conditional Member Access',
    text: 'Get the length of the string if not null, otherwise null, using ?. operator',
    setup: 'string? text = "Hello";',
    setupCode: 'string? text = "Hello";',
    expected: '5',
    sample: 'text?.Length',
    hints: [
      '?. returns null if the left operand is null',
      'The result type is nullable (int? in this case)',
    ],
    validPatterns: [/text\?\.Length/, /\?\.Length/],
    tags: ['nullable', 'conditional', 'null-safe'],
  },
  {
    id: 'cs-nullable-coalesce-chain-1',
    category: 'Nullable Handling',
    difficulty: 'medium',
    title: 'Chain Null Coalescing Operators',
    text: 'Return the first non-null value from first, second, or "default" using ?? chaining',
    setup: 'string? first = null;\nstring? second = null;',
    setupCode: 'string? first = null;\nstring? second = null;',
    expected: '"default"',
    sample: 'first ?? second ?? "default"',
    hints: [
      '?? operators can be chained for multiple fallbacks',
      'Evaluation is left-to-right and short-circuits on first non-null',
    ],
    validPatterns: [/first\s*\?\?\s*second\s*\?\?\s*"default"/, /\?\?.*\?\?/],
    tags: ['nullable', 'coalesce', 'chain'],
  },
  {
    id: 'cs-nullable-assign-1',
    category: 'Nullable Handling',
    difficulty: 'easy',
    title: 'Null Coalescing Assignment',
    text: 'Initialize the list only if it is null using ??= operator',
    setup: 'List<int>? numbers = null;',
    setupCode: 'List<int>? numbers = null;',
    expected: 'numbers is now an empty list',
    sample: 'numbers ??= new List<int>();',
    hints: ['??= only assigns if the variable is null', 'Useful for lazy initialization'],
    validPatterns: [/numbers\s*\?\?=\s*new\s+List<int>\s*\(\s*\)/, /\?\?=\s*new\s+List/],
    tags: ['nullable', 'assignment', 'coalesce'],
  },
  {
    id: 'cs-nullable-conditional-method-1',
    category: 'Nullable Handling',
    difficulty: 'medium',
    title: 'Null-Conditional Method Call',
    text: 'Call ToUpper() on the string only if not null using ?. operator',
    setup: 'string? name = "alice";',
    setupCode: 'string? name = "alice";',
    expected: '"ALICE"',
    sample: 'name?.ToUpper()',
    hints: [
      '?. can be used before method calls',
      'The entire expression returns null if the object is null',
    ],
    validPatterns: [/name\?\.ToUpper\s*\(\s*\)/, /\?\.ToUpper\(/],
    tags: ['nullable', 'conditional', 'method'],
  },
  {
    id: 'cs-nullable-chain-access-1',
    category: 'Nullable Handling',
    difficulty: 'hard',
    title: 'Chain Null-Conditional with Coalescing',
    text: 'Get the first character uppercase of name, or "?" if null or empty',
    setup: 'string? name = null;',
    setupCode: 'string? name = null;',
    expected: '"?"',
    sample: 'name?.FirstOrDefault().ToString()?.ToUpper() ?? "?"',
    hints: [
      'Combine ?. and ?? for safe navigation with defaults',
      'FirstOrDefault() returns default char for empty strings',
    ],
    validPatterns: [/\?\..*\?\..*\?\?/, /FirstOrDefault.*\?\?/],
    tags: ['nullable', 'conditional', 'coalesce', 'chain', 'advanced'],
  },

  // ============================================================
  // Advanced LINQ Operations
  // ============================================================

  // --- EASY (8 problems) ---
  {
    id: 'cs-linq-query-basic-1',
    category: 'Advanced LINQ',
    difficulty: 'easy',
    title: 'Query Syntax: Basic Where and Select',
    text: 'Filter even numbers and square them using LINQ query syntax instead of method syntax',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };',
    expected: '{ 4, 16, 36, 64, 100 }',
    sample: 'from n in numbers where n % 2 == 0 select n * n',
    hints: [
      'Query syntax starts with "from" and ends with "select"',
      'The "where" clause filters elements before projection',
      'Query syntax is translated to method syntax at compile time',
    ],
    validPatterns: [/from\s+\w+\s+in\s+\w+\s+where.*select/i],
    tags: ['linq', 'query-syntax', 'where', 'select', 'advanced'],
  },
  {
    id: 'cs-linq-selectmany-flatten-1',
    category: 'Advanced LINQ',
    difficulty: 'easy',
    title: 'Flatten Nested Arrays with SelectMany',
    text: 'Flatten the jagged array into a single sequence using SelectMany()',
    setup: 'int[][] jagged = new int[][] { new[] { 1, 2 }, new[] { 3, 4, 5 }, new[] { 6 } };',
    setupCode: 'int[][] jagged = new int[][] { new[] { 1, 2 }, new[] { 3, 4, 5 }, new[] { 6 } };',
    expected: '{ 1, 2, 3, 4, 5, 6 }',
    sample: 'jagged.SelectMany(arr => arr)',
    hints: [
      'SelectMany flattens nested collections into a single sequence',
      'The lambda returns the inner collection to flatten',
      'Equivalent to flatMap in functional programming',
    ],
    validPatterns: [/\.SelectMany\s*\(\s*\w+\s*=>\s*\w+\s*\)/i],
    tags: ['linq', 'selectmany', 'flatten', 'advanced'],
  },
  {
    id: 'cs-linq-zip-combine-1',
    category: 'Advanced LINQ',
    difficulty: 'easy',
    title: 'Combine Sequences with Zip',
    text: 'Pair products with their prices using Zip()',
    setup:
      'string[] products = { "Apple", "Banana", "Cherry" };\ndecimal[] prices = { 1.50m, 0.75m, 2.00m };',
    setupCode:
      'string[] products = { "Apple", "Banana", "Cherry" };\ndecimal[] prices = { 1.50m, 0.75m, 2.00m };',
    expected: '{ "Apple: $1.50", "Banana: $0.75", "Cherry: $2.00" }',
    sample: 'products.Zip(prices, (p, price) => $"{p}: ${price}")',
    hints: [
      'Zip combines two sequences element by element',
      'Result length equals the shorter sequence',
      'The lambda receives one element from each sequence',
    ],
    validPatterns: [/\.Zip\s*\(\s*\w+\s*,\s*\(/i],
    tags: ['linq', 'zip', 'combine', 'advanced'],
  },
  {
    id: 'cs-linq-oftype-filter-1',
    category: 'Advanced LINQ',
    difficulty: 'easy',
    title: 'Filter by Type with OfType',
    text: 'Extract only integers from the mixed collection using OfType<T>()',
    setup: 'object[] mixed = { 1, "hello", 2.5, 3, "world", 4, true };',
    setupCode: 'object[] mixed = { 1, "hello", 2.5, 3, "world", 4, true };',
    expected: '{ 1, 3, 4 }',
    sample: 'mixed.OfType<int>()',
    hints: [
      'OfType<T>() filters and casts elements to the specified type',
      'Elements that cannot be cast are silently excluded',
      'Safer than Cast<T>() which throws on incompatible types',
    ],
    validPatterns: [/\.OfType\s*<\s*int\s*>\s*\(\s*\)/i],
    tags: ['linq', 'oftype', 'type-filtering', 'advanced'],
  },
  {
    id: 'cs-linq-cast-convert-1',
    category: 'Advanced LINQ',
    difficulty: 'easy',
    title: 'Cast Non-Generic Collection',
    text: 'Convert ArrayList to IEnumerable<string> using Cast<T>()',
    setup:
      'System.Collections.ArrayList list = new System.Collections.ArrayList { "a", "b", "c" };',
    setupCode:
      'System.Collections.ArrayList list = new System.Collections.ArrayList { "a", "b", "c" };',
    expected: 'IEnumerable<string> { "a", "b", "c" }',
    sample: 'list.Cast<string>()',
    hints: [
      'Cast<T>() converts IEnumerable to IEnumerable<T>',
      'Throws InvalidCastException if any element cannot be cast',
      'Required for using LINQ on non-generic collections',
    ],
    validPatterns: [/\.Cast\s*<\s*string\s*>\s*\(\s*\)/i],
    tags: ['linq', 'cast', 'type-conversion', 'advanced'],
  },
  {
    id: 'cs-linq-deferred-tolist-1',
    category: 'Advanced LINQ',
    difficulty: 'easy',
    title: 'Immediate Execution with ToList',
    text: 'Force immediate execution of the LINQ query using ToList()',
    setup: 'IEnumerable<int> query = Enumerable.Range(1, 5).Where(x => x % 2 == 1);',
    setupCode: 'IEnumerable<int> query = Enumerable.Range(1, 5).Where(x => x % 2 == 1);',
    expected: 'List<int> { 1, 3, 5 }',
    sample: 'query.ToList()',
    hints: [
      'LINQ queries use deferred execution by default',
      'ToList() forces immediate enumeration and caches results',
      'ToArray() and ToDictionary() also force immediate execution',
    ],
    validPatterns: [/\.ToList\s*\(\s*\)/i],
    tags: ['linq', 'deferred-execution', 'immediate-execution', 'advanced'],
  },
  {
    id: 'cs-linq-concat-union-1',
    category: 'Advanced LINQ',
    difficulty: 'easy',
    title: 'Concatenate vs Union',
    text: 'Combine two arrays preserving all elements (including duplicates) using Concat()',
    setup: 'int[] first = { 1, 2, 3 };\nint[] second = { 2, 3, 4 };',
    setupCode: 'int[] first = { 1, 2, 3 };\nint[] second = { 2, 3, 4 };',
    expected: '{ 1, 2, 3, 2, 3, 4 }',
    sample: 'first.Concat(second)',
    hints: [
      'Concat() preserves all elements including duplicates',
      'Union() removes duplicates from the combined result',
      'Both use deferred execution',
    ],
    validPatterns: [/\.Concat\s*\(\s*\w+\s*\)/i],
    tags: ['linq', 'concat', 'union', 'combine', 'advanced'],
  },
  {
    id: 'cs-linq-defaultifempty-1',
    category: 'Advanced LINQ',
    difficulty: 'easy',
    title: 'Handle Empty Sequences with DefaultIfEmpty',
    text: 'Return a default value of 0 if the filtered sequence is empty',
    setup: 'List<int> numbers = new List<int> { 2, 4, 6, 8 };',
    setupCode: 'List<int> numbers = new List<int> { 2, 4, 6, 8 };',
    expected: '{ 0 }',
    sample: 'numbers.Where(x => x > 10).DefaultIfEmpty(0)',
    hints: [
      'DefaultIfEmpty() returns a sequence with one default element if source is empty',
      'Without argument, uses default(T)',
      'Essential for left outer joins in LINQ',
    ],
    validPatterns: [/\.DefaultIfEmpty\s*\(\s*0\s*\)/i],
    tags: ['linq', 'defaultifempty', 'empty-handling', 'advanced'],
  },

  // --- MEDIUM (12 problems) ---
  {
    id: 'cs-linq-groupby-projection-1',
    category: 'Advanced LINQ',
    difficulty: 'medium',
    title: 'GroupBy with Element Projection',
    text: 'Group students by grade and project to a summary with grade, count, and names',
    setup:
      'var students = new[] { new { Name = "Alice", Grade = "A" }, new { Name = "Bob", Grade = "B" }, new { Name = "Carol", Grade = "A" }, new { Name = "Dave", Grade = "B" }, new { Name = "Eve", Grade = "A" } };',
    setupCode:
      'var students = new[] { new { Name = "Alice", Grade = "A" }, new { Name = "Bob", Grade = "B" }, new { Name = "Carol", Grade = "A" }, new { Name = "Dave", Grade = "B" }, new { Name = "Eve", Grade = "A" } };',
    expected:
      '{ { Grade = "A", Count = 3, Names = "Alice, Carol, Eve" }, { Grade = "B", Count = 2, Names = "Bob, Dave" } }',
    sample:
      'students.GroupBy(s => s.Grade).Select(g => new { Grade = g.Key, Count = g.Count(), Names = string.Join(", ", g.Select(s => s.Name)) })',
    hints: [
      'GroupBy returns IEnumerable<IGrouping<TKey, TElement>>',
      'Use g.Key to access the grouping key',
      'Apply aggregates and projections in Select',
    ],
    validPatterns: [/\.GroupBy\s*\(.*\)\.Select\s*\(.*g\.Key.*g\.Count\(\)/i],
    tags: ['linq', 'groupby', 'projection', 'aggregate', 'advanced'],
  },
  {
    id: 'cs-linq-groupby-having-1',
    category: 'Advanced LINQ',
    difficulty: 'medium',
    title: 'GroupBy with Having Equivalent',
    text: 'Group orders by customer and filter to only customers with more than 2 orders',
    setup:
      'var orders = new[] { new { CustomerId = 1, Amount = 100 }, new { CustomerId = 2, Amount = 50 }, new { CustomerId = 1, Amount = 200 }, new { CustomerId = 1, Amount = 150 }, new { CustomerId = 2, Amount = 75 } };',
    setupCode:
      'var orders = new[] { new { CustomerId = 1, Amount = 100 }, new { CustomerId = 2, Amount = 50 }, new { CustomerId = 1, Amount = 200 }, new { CustomerId = 1, Amount = 150 }, new { CustomerId = 2, Amount = 75 } };',
    expected: '{ { CustomerId = 1, OrderCount = 3, Total = 450 } }',
    sample:
      'orders.GroupBy(o => o.CustomerId).Where(g => g.Count() > 2).Select(g => new { CustomerId = g.Key, OrderCount = g.Count(), Total = g.Sum(o => o.Amount) })',
    hints: [
      'Use Where after GroupBy for HAVING equivalent',
      'The Where predicate receives IGrouping<TKey, TElement>',
      'Can apply aggregates inside Where condition',
    ],
    validPatterns: [/\.GroupBy\s*\(.*\)\.Where\s*\(.*\.Count\(\).*\)\.Select/i],
    tags: ['linq', 'groupby', 'where', 'having', 'advanced'],
  },
  {
    id: 'cs-linq-join-inner-1',
    category: 'Advanced LINQ',
    difficulty: 'medium',
    title: 'Inner Join with Method Syntax',
    text: 'Join orders to customers by CustomerId to get customer names with order amounts',
    setup:
      'var customers = new[] { new { Id = 1, Name = "Alice" }, new { Id = 2, Name = "Bob" } };\nvar orders = new[] { new { CustomerId = 1, Amount = 100m }, new { CustomerId = 2, Amount = 200m }, new { CustomerId = 1, Amount = 150m } };',
    setupCode:
      'var customers = new[] { new { Id = 1, Name = "Alice" }, new { Id = 2, Name = "Bob" } };\nvar orders = new[] { new { CustomerId = 1, Amount = 100m }, new { CustomerId = 2, Amount = 200m }, new { CustomerId = 1, Amount = 150m } };',
    expected:
      '{ { Customer = "Alice", Amount = 100 }, { Customer = "Alice", Amount = 150 }, { Customer = "Bob", Amount = 200 } }',
    sample:
      'orders.Join(customers, o => o.CustomerId, c => c.Id, (o, c) => new { Customer = c.Name, o.Amount })',
    hints: [
      'Join takes: inner sequence, outer key selector, inner key selector, result selector',
      'Only matching pairs are included (inner join)',
      'Key selectors must produce comparable values',
    ],
    validPatterns: [/\.Join\s*\(\s*\w+\s*,.*=>.*,.*=>.*,\s*\(/i],
    tags: ['linq', 'join', 'inner-join', 'advanced'],
  },
  {
    id: 'cs-linq-groupjoin-1',
    category: 'Advanced LINQ',
    difficulty: 'medium',
    title: 'Group Join for Hierarchical Data',
    text: 'Use GroupJoin to get each category with its list of products',
    setup:
      'var categories = new[] { new { Id = 1, Name = "Fruit" }, new { Id = 2, Name = "Dairy" } };\nvar products = new[] { new { Name = "Apple", CatId = 1 }, new { Name = "Milk", CatId = 2 }, new { Name = "Banana", CatId = 1 } };',
    setupCode:
      'var categories = new[] { new { Id = 1, Name = "Fruit" }, new { Id = 2, Name = "Dairy" } };\nvar products = new[] { new { Name = "Apple", CatId = 1 }, new { Name = "Milk", CatId = 2 }, new { Name = "Banana", CatId = 1 } };',
    expected:
      '{ { Category = "Fruit", Products = ["Apple", "Banana"] }, { Category = "Dairy", Products = ["Milk"] } }',
    sample:
      'categories.GroupJoin(products, c => c.Id, p => p.CatId, (c, prods) => new { Category = c.Name, Products = prods.Select(p => p.Name).ToList() })',
    hints: [
      'GroupJoin groups inner elements by the outer key',
      'Returns all outer elements even without matches',
      'prods is IEnumerable<TInner> for each outer element',
    ],
    validPatterns: [/\.GroupJoin\s*\(\s*\w+\s*,.*,.*,\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>/i],
    tags: ['linq', 'groupjoin', 'hierarchical', 'advanced'],
  },
  {
    id: 'cs-linq-aggregate-custom-1',
    category: 'Advanced LINQ',
    difficulty: 'medium',
    title: 'Custom Aggregation: Find Longest Word',
    text: 'Use Aggregate to find the longest string in the list',
    setup: 'List<string> words = new List<string> { "cat", "elephant", "dog", "hippopotamus" };',
    setupCode:
      'List<string> words = new List<string> { "cat", "elephant", "dog", "hippopotamus" };',
    expected: '"hippopotamus"',
    sample:
      'words.Aggregate((longest, current) => current.Length > longest.Length ? current : longest)',
    hints: [
      'Aggregate applies a function cumulatively to the sequence',
      'Without seed, first element becomes initial accumulator',
      'Return the new accumulator value from the function',
    ],
    validPatterns: [/\.Aggregate\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>.*\.Length/i],
    tags: ['linq', 'aggregate', 'custom-reduction', 'advanced'],
  },
  {
    id: 'cs-linq-selectmany-crossjoin-1',
    category: 'Advanced LINQ',
    difficulty: 'medium',
    title: 'Cross Join with SelectMany',
    text: 'Generate all combinations of colors and sizes using SelectMany',
    setup: 'string[] colors = { "Red", "Blue" };\nstring[] sizes = { "S", "M", "L" };',
    setupCode: 'string[] colors = { "Red", "Blue" };\nstring[] sizes = { "S", "M", "L" };',
    expected: '{ "Red-S", "Red-M", "Red-L", "Blue-S", "Blue-M", "Blue-L" }',
    sample: 'colors.SelectMany(c => sizes.Select(s => $"{c}-{s}"))',
    hints: [
      'SelectMany can create a cross join (Cartesian product)',
      'Each color maps to all sizes',
      'Result count = colors.Length * sizes.Length',
    ],
    validPatterns: [/\.SelectMany\s*\(\s*\w+\s*=>\s*\w+\.Select/i],
    tags: ['linq', 'selectmany', 'cross-join', 'advanced'],
  },
  {
    id: 'cs-linq-query-join-1',
    category: 'Advanced LINQ',
    difficulty: 'medium',
    title: 'Query Syntax: Join with into',
    text: 'Rewrite the join using LINQ query syntax with the join keyword',
    setup:
      'var authors = new[] { new { Id = 1, Name = "Alice" }, new { Id = 2, Name = "Bob" } };\nvar books = new[] { new { Title = "C# Basics", AuthorId = 1 }, new { Title = "Advanced C#", AuthorId = 1 }, new { Title = "Python 101", AuthorId = 2 } };',
    setupCode:
      'var authors = new[] { new { Id = 1, Name = "Alice" }, new { Id = 2, Name = "Bob" } };\nvar books = new[] { new { Title = "C# Basics", AuthorId = 1 }, new { Title = "Advanced C#", AuthorId = 1 }, new { Title = "Python 101", AuthorId = 2 } };',
    expected:
      '{ { Author = "Alice", Title = "C# Basics" }, { Author = "Alice", Title = "Advanced C#" }, { Author = "Bob", Title = "Python 101" } }',
    sample:
      'from a in authors join b in books on a.Id equals b.AuthorId select new { Author = a.Name, b.Title }',
    hints: [
      'Query syntax uses "join ... on ... equals ..."',
      'The equals keyword is required (not ==)',
      'Query syntax joins are more readable for complex queries',
    ],
    validPatterns: [/from\s+\w+\s+in\s+\w+\s+join\s+\w+\s+in\s+\w+\s+on\s+.*equals/i],
    tags: ['linq', 'query-syntax', 'join', 'advanced'],
  },
  {
    id: 'cs-linq-query-groupby-1',
    category: 'Advanced LINQ',
    difficulty: 'medium',
    title: 'Query Syntax: Group By with into',
    text: 'Group numbers by their tens digit using query syntax with group ... by ... into',
    setup: 'int[] numbers = { 5, 15, 25, 12, 32, 45, 48 };',
    setupCode: 'int[] numbers = { 5, 15, 25, 12, 32, 45, 48 };',
    expected:
      '{ { Tens = 0, Numbers = [5] }, { Tens = 1, Numbers = [15, 12] }, { Tens = 2, Numbers = [25] }, { Tens = 3, Numbers = [32] }, { Tens = 4, Numbers = [45, 48] } }',
    sample:
      'from n in numbers group n by n / 10 into g select new { Tens = g.Key, Numbers = g.ToList() }',
    hints: [
      'Use "group ... by ... into ..." for query continuation',
      'The "into" keyword creates a new range variable for the group',
      'Can continue the query with select or additional clauses',
    ],
    validPatterns: [/from\s+\w+\s+in\s+\w+\s+group\s+\w+\s+by.*into\s+\w+\s+select/i],
    tags: ['linq', 'query-syntax', 'groupby', 'advanced'],
  },
  {
    id: 'cs-linq-let-clause-1',
    category: 'Advanced LINQ',
    difficulty: 'medium',
    title: 'Query Syntax: Let Clause for Computed Values',
    text: 'Use let clause to compute total price and filter expensive items',
    setup:
      'var items = new[] { new { Name = "A", Qty = 2, Price = 10m }, new { Name = "B", Qty = 5, Price = 3m }, new { Name = "C", Qty = 1, Price = 50m } };',
    setupCode:
      'var items = new[] { new { Name = "A", Qty = 2, Price = 10m }, new { Name = "B", Qty = 5, Price = 3m }, new { Name = "C", Qty = 1, Price = 50m } };',
    expected: '{ { Name = "A", Total = 20 }, { Name = "C", Total = 50 } }',
    sample:
      'from i in items let total = i.Qty * i.Price where total >= 20 select new { i.Name, Total = total }',
    hints: [
      'The let clause introduces a computed range variable',
      'Avoids recalculating the expression multiple times',
      'Variable is available in subsequent clauses',
    ],
    validPatterns: [/from\s+\w+\s+in\s+\w+\s+let\s+\w+\s*=.*where.*select/i],
    tags: ['linq', 'query-syntax', 'let', 'advanced'],
  },
  {
    id: 'cs-linq-zip-multiple-1',
    category: 'Advanced LINQ',
    difficulty: 'medium',
    title: 'Zip Multiple Sequences',
    text: 'Combine three arrays (ids, names, scores) using chained Zip calls',
    setup:
      'int[] ids = { 1, 2, 3 };\nstring[] names = { "Alice", "Bob", "Carol" };\nint[] scores = { 95, 87, 92 };',
    setupCode:
      'int[] ids = { 1, 2, 3 };\nstring[] names = { "Alice", "Bob", "Carol" };\nint[] scores = { 95, 87, 92 };',
    expected:
      '{ { Id = 1, Name = "Alice", Score = 95 }, { Id = 2, Name = "Bob", Score = 87 }, { Id = 3, Name = "Carol", Score = 92 } }',
    sample:
      'ids.Zip(names, (id, name) => new { Id = id, Name = name }).Zip(scores, (x, score) => new { x.Id, x.Name, Score = score })',
    hints: [
      'Chain Zip calls for more than two sequences',
      'First Zip creates intermediate result',
      'Second Zip combines with third sequence',
    ],
    validPatterns: [/\.Zip\s*\(.*\)\.Zip\s*\(/i],
    tags: ['linq', 'zip', 'multiple-sequences', 'advanced'],
  },
  {
    id: 'cs-linq-tolookup-1',
    category: 'Advanced LINQ',
    difficulty: 'medium',
    title: 'Create Lookup with ToLookup',
    text: 'Create a lookup of words grouped by their length',
    setup: 'string[] words = { "cat", "dog", "elephant", "ant", "bird", "fish" };',
    setupCode: 'string[] words = { "cat", "dog", "elephant", "ant", "bird", "fish" };',
    expected: 'ILookup with [3] = { cat, dog, ant }, [8] = { elephant }, [4] = { bird, fish }',
    sample: 'words.ToLookup(w => w.Length)',
    hints: [
      'ToLookup creates an immutable dictionary-like structure',
      'Executes immediately (unlike GroupBy)',
      'Access with lookup[key] which never throws',
    ],
    validPatterns: [/\.ToLookup\s*\(\s*\w+\s*=>\s*\w+\.Length\s*\)/i],
    tags: ['linq', 'tolookup', 'grouping', 'immediate-execution', 'advanced'],
  },
  {
    id: 'cs-linq-except-intersect-1',
    category: 'Advanced LINQ',
    difficulty: 'medium',
    title: 'Set Operations: Except and Intersect',
    text: 'Find numbers in the first list that are not in the second using Except()',
    setup: 'int[] available = { 1, 2, 3, 4, 5, 6, 7, 8 };\nint[] taken = { 2, 4, 6 };',
    setupCode: 'int[] available = { 1, 2, 3, 4, 5, 6, 7, 8 };\nint[] taken = { 2, 4, 6 };',
    expected: '{ 1, 3, 5, 7, 8 }',
    sample: 'available.Except(taken)',
    hints: [
      'Except returns elements in first but not in second',
      'Intersect returns common elements',
      'Both automatically remove duplicates',
    ],
    validPatterns: [/\.Except\s*\(\s*\w+\s*\)/i],
    tags: ['linq', 'except', 'set-operations', 'advanced'],
  },

  // --- HARD (5 problems) ---
  {
    id: 'cs-linq-complex-groupby-1',
    category: 'Advanced LINQ',
    difficulty: 'hard',
    title: 'Multi-Level GroupBy with Composite Key',
    text: 'Group transactions by year and month, calculate count and total per group',
    setup:
      'var transactions = new[] { new { Date = new DateTime(2024, 1, 15), Amount = 100m }, new { Date = new DateTime(2024, 1, 20), Amount = 150m }, new { Date = new DateTime(2024, 2, 10), Amount = 200m }, new { Date = new DateTime(2024, 2, 25), Amount = 75m }, new { Date = new DateTime(2024, 1, 5), Amount = 50m } };',
    setupCode:
      'var transactions = new[] { new { Date = new DateTime(2024, 1, 15), Amount = 100m }, new { Date = new DateTime(2024, 1, 20), Amount = 150m }, new { Date = new DateTime(2024, 2, 10), Amount = 200m }, new { Date = new DateTime(2024, 2, 25), Amount = 75m }, new { Date = new DateTime(2024, 1, 5), Amount = 50m } };',
    expected:
      '{ { Year = 2024, Month = 1, Count = 3, Total = 300 }, { Year = 2024, Month = 2, Count = 2, Total = 275 } }',
    sample:
      'transactions.GroupBy(t => new { t.Date.Year, t.Date.Month }).Select(g => new { g.Key.Year, g.Key.Month, Count = g.Count(), Total = g.Sum(t => t.Amount) })',
    hints: [
      'Use anonymous type for composite grouping key',
      'Access key parts with g.Key.PropertyName',
      'Combine multiple aggregates in the projection',
    ],
    validPatterns: [/\.GroupBy\s*\(\s*\w+\s*=>\s*new\s*\{.*Year.*Month.*\}\s*\)\.Select/i],
    tags: ['linq', 'groupby', 'composite-key', 'aggregate', 'advanced'],
  },
  {
    id: 'cs-linq-left-outer-join-1',
    category: 'Advanced LINQ',
    difficulty: 'hard',
    title: 'Left Outer Join Pattern',
    text: 'Perform left outer join to get all employees with their department (or "Unassigned" if null)',
    setup:
      'var employees = new[] { new { Name = "Alice", DeptId = (int?)1 }, new { Name = "Bob", DeptId = (int?)null }, new { Name = "Carol", DeptId = (int?)2 } };\nvar departments = new[] { new { Id = 1, Name = "Engineering" }, new { Id = 2, Name = "Marketing" } };',
    setupCode:
      'var employees = new[] { new { Name = "Alice", DeptId = (int?)1 }, new { Name = "Bob", DeptId = (int?)null }, new { Name = "Carol", DeptId = (int?)2 } };\nvar departments = new[] { new { Id = 1, Name = "Engineering" }, new { Id = 2, Name = "Marketing" } };',
    expected:
      '{ { Employee = "Alice", Dept = "Engineering" }, { Employee = "Bob", Dept = "Unassigned" }, { Employee = "Carol", Dept = "Marketing" } }',
    sample:
      'employees.GroupJoin(departments, e => e.DeptId, d => (int?)d.Id, (e, depts) => new { e, depts }).SelectMany(x => x.depts.DefaultIfEmpty(), (x, d) => new { Employee = x.e.Name, Dept = d?.Name ?? "Unassigned" })',
    hints: [
      'Left outer join = GroupJoin + SelectMany + DefaultIfEmpty',
      'DefaultIfEmpty ensures unmatched rows are included',
      'Handle null with ?. and ?? operators',
    ],
    validPatterns: [/\.GroupJoin\s*\(.*\)\.SelectMany\s*\(.*\.DefaultIfEmpty\s*\(\s*\)/i],
    tags: ['linq', 'left-outer-join', 'groupjoin', 'selectmany', 'advanced'],
  },
  {
    id: 'cs-linq-nested-from-1',
    category: 'Advanced LINQ',
    difficulty: 'hard',
    title: 'Query Syntax: Nested From for Combinations',
    text: 'Use multiple from clauses to find all pairs of numbers that sum to 100',
    setup: 'int[] numbers = { 10, 20, 30, 40, 50, 60, 70, 80, 90 };',
    setupCode: 'int[] numbers = { 10, 20, 30, 40, 50, 60, 70, 80, 90 };',
    expected: '{ (10, 90), (20, 80), (30, 70), (40, 60) }',
    sample: 'from a in numbers from b in numbers where a < b && a + b == 100 select (a, b)',
    hints: [
      'Multiple from clauses create a cross join',
      'Use a < b to avoid duplicate pairs',
      'Filter with where after the cross join',
    ],
    validPatterns: [/from\s+\w+\s+in\s+\w+\s+from\s+\w+\s+in\s+\w+\s+where.*<.*&&.*\+.*==\s*100/i],
    tags: ['linq', 'query-syntax', 'nested-from', 'cross-join', 'advanced'],
  },
  {
    id: 'cs-linq-aggregate-seed-result-1',
    category: 'Advanced LINQ',
    difficulty: 'hard',
    title: 'Aggregate with Seed and Result Selector',
    text: 'Count word frequencies and format as "word:count" string sorted by count descending',
    setup: 'string[] words = { "apple", "banana", "apple", "cherry", "banana", "apple" };',
    setupCode: 'string[] words = { "apple", "banana", "apple", "cherry", "banana", "apple" };',
    expected: '"apple:3, banana:2, cherry:1"',
    sample:
      'words.Aggregate(new Dictionary<string, int>(), (dict, word) => { dict[word] = dict.GetValueOrDefault(word) + 1; return dict; }, dict => string.Join(", ", dict.OrderByDescending(kv => kv.Value).Select(kv => $"{kv.Key}:{kv.Value}")))',
    hints: [
      'Aggregate overload: seed, accumulator function, result selector',
      'Seed is the initial accumulator (empty dictionary)',
      'Result selector transforms final accumulator to output',
    ],
    validPatterns: [/\.Aggregate\s*\(\s*new\s+Dictionary.*,\s*\(.*\)\s*=>\s*\{.*\},\s*\w+\s*=>/i],
    tags: ['linq', 'aggregate', 'seed', 'result-selector', 'advanced'],
  },
  {
    id: 'cs-linq-deferred-pitfall-1',
    category: 'Advanced LINQ',
    difficulty: 'hard',
    title: 'Deferred Execution Pitfall',
    text: 'Demonstrate the deferred execution pitfall: the list is modified before the query is enumerated',
    setup:
      'List<int> numbers = new List<int> { 1, 2, 3 };\nvar evens = numbers.Where(x => x % 2 == 0);',
    setupCode:
      'List<int> numbers = new List<int> { 1, 2, 3 };\nvar evens = numbers.Where(x => x % 2 == 0);',
    expected: 'After numbers.Add(4): evens.ToList() returns { 2, 4 }',
    sample: 'numbers.Add(4); var result = evens.ToList();',
    hints: [
      'LINQ queries capture the source reference, not a snapshot',
      'The query executes when enumerated, seeing current state',
      'Use ToList() immediately to capture a snapshot if needed',
      'This behavior can cause unexpected results in loops',
    ],
    validPatterns: [/numbers\.Add\s*\(\s*4\s*\).*evens\.(ToList|ToArray)\s*\(\s*\)/i],
    tags: ['linq', 'deferred-execution', 'pitfall', 'advanced'],
  },

  // ============================================================
  // String Operations - Interpolation, StringBuilder, Span, Regex
  // ============================================================
  {
    id: 'cs-str-interpolation-format-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'String Interpolation with Formatting',
    text: 'Format the price as currency with 2 decimal places using string interpolation',
    setup: 'decimal price = 49.99m;',
    setupCode: 'decimal price = 49.99m;',
    expected: '"Price: $49.99"',
    sample: '$"Price: {price:C2}"',
    hints: [
      'Use :C2 format specifier for currency with 2 decimal places',
      'Format specifiers go after the colon inside the braces',
    ],
    validPatterns: [/\$".*\{price:C2?\}"/i, /\{price:C\d?\}/i],
    tags: ['string', 'interpolation', 'format', 'currency'],
  },
  {
    id: 'cs-str-interpolation-align-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'String Interpolation with Alignment',
    text: 'Create a right-aligned string with the name padded to 10 characters',
    setup: 'string name = "Alice";',
    setupCode: 'string name = "Alice";',
    expected: '"Name:      Alice"',
    sample: '$"Name: {name,10}"',
    hints: [
      'Use comma followed by width for alignment',
      'Positive width right-aligns, negative left-aligns',
    ],
    validPatterns: [/\$".*\{name,10\}"/i, /\{name,\d+\}/i],
    tags: ['string', 'interpolation', 'alignment', 'format'],
  },
  {
    id: 'cs-str-interpolation-datetime-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Format DateTime in Interpolation',
    text: 'Format the date as "yyyy-MM-dd" using string interpolation',
    setup: 'DateTime date = new DateTime(2024, 12, 25);',
    setupCode: 'DateTime date = new DateTime(2024, 12, 25);',
    expected: '"Date: 2024-12-25"',
    sample: '$"Date: {date:yyyy-MM-dd}"',
    hints: [
      'DateTime format strings can be used directly in interpolation',
      'yyyy = 4-digit year, MM = 2-digit month, dd = 2-digit day',
    ],
    validPatterns: [/\$".*\{date:yyyy-MM-dd\}"/i, /\{date:yyyy-MM-dd\}/i],
    tags: ['string', 'interpolation', 'datetime', 'format'],
  },
  {
    id: 'cs-str-interpolation-expression-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Expression in String Interpolation',
    text: 'Calculate and display the area of a rectangle using interpolation with an expression',
    setup: 'int width = 5;\nint height = 3;',
    setupCode: 'int width = 5;\nint height = 3;',
    expected: '"Area: 15"',
    sample: '$"Area: {width * height}"',
    hints: [
      'Any valid C# expression can be used inside interpolation braces',
      'Complex expressions may need parentheses for clarity',
    ],
    validPatterns: [/\$".*\{width\s*\*\s*height\}"/i, /\{width.*\*.*height\}/i],
    tags: ['string', 'interpolation', 'expression'],
  },
  {
    id: 'cs-str-interpolation-ternary-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Ternary Expression in Interpolation',
    text: 'Display "Pass" or "Fail" based on score >= 60 using string interpolation',
    setup: 'int score = 75;',
    setupCode: 'int score = 75;',
    expected: '"Result: Pass"',
    sample: '$"Result: {(score >= 60 ? "Pass" : "Fail")}"',
    hints: [
      'Wrap ternary expressions in parentheses inside interpolation',
      'String literals inside need to be properly escaped or use different quotes',
    ],
    validPatterns: [/\$".*\{\(score\s*>=\s*60\s*\?/i, /score.*>=.*60.*\?.*Pass.*:.*Fail/i],
    tags: ['string', 'interpolation', 'ternary', 'conditional'],
  },
  {
    id: 'cs-str-stringbuilder-basic-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Basic StringBuilder Append',
    text: 'Build the string "Hello World!" using StringBuilder Append methods',
    setup: 'using System.Text;\nvar sb = new StringBuilder();',
    setupCode: 'using System.Text;\nvar sb = new StringBuilder();',
    expected: '"Hello World!"',
    sample: 'sb.Append("Hello").Append(" ").Append("World!");',
    hints: [
      'Append returns the StringBuilder for method chaining',
      'StringBuilder is mutable and more efficient for multiple concatenations',
    ],
    validPatterns: [
      /sb\.Append\("Hello"\).*\.Append\(" "\).*\.Append\("World!"\)/i,
      /sb\.Append.*\.Append.*\.Append/i,
    ],
    tags: ['string', 'stringbuilder', 'append', 'performance'],
  },
  {
    id: 'cs-str-stringbuilder-appendline-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'StringBuilder with AppendLine',
    text: 'Create a multi-line string with "Line 1" and "Line 2" using AppendLine',
    setup: 'using System.Text;\nvar sb = new StringBuilder();',
    setupCode: 'using System.Text;\nvar sb = new StringBuilder();',
    expected: '"Line 1\\nLine 2\\n"',
    sample: 'sb.AppendLine("Line 1").AppendLine("Line 2");',
    hints: [
      'AppendLine adds the text plus a newline character',
      'Use Environment.NewLine for platform-specific line endings',
    ],
    validPatterns: [
      /sb\.AppendLine\("Line 1"\).*\.AppendLine\("Line 2"\)/i,
      /AppendLine.*AppendLine/i,
    ],
    tags: ['string', 'stringbuilder', 'appendline', 'multiline'],
  },
  {
    id: 'cs-str-stringbuilder-insert-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'StringBuilder Insert',
    text: 'Insert "Beautiful " at index 6 in the StringBuilder containing "Hello World!"',
    setup: 'using System.Text;\nvar sb = new StringBuilder("Hello World!");',
    setupCode: 'using System.Text;\nvar sb = new StringBuilder("Hello World!");',
    expected: '"Hello Beautiful World!"',
    sample: 'sb.Insert(6, "Beautiful ");',
    hints: [
      'Insert takes an index and the value to insert',
      'Existing content shifts to the right',
    ],
    validPatterns: [/sb\.Insert\(6,\s*"Beautiful "\)/i, /\.Insert\(6/i],
    tags: ['string', 'stringbuilder', 'insert'],
  },
  {
    id: 'cs-str-stringbuilder-replace-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'StringBuilder Replace',
    text: 'Replace all occurrences of "old" with "new" using StringBuilder Replace',
    setup: 'using System.Text;\nvar sb = new StringBuilder("old value and old data");',
    setupCode: 'using System.Text;\nvar sb = new StringBuilder("old value and old data");',
    expected: '"new value and new data"',
    sample: 'sb.Replace("old", "new");',
    hints: [
      'Replace modifies the StringBuilder in-place',
      'Replaces all occurrences, not just the first',
    ],
    validPatterns: [/sb\.Replace\("old",\s*"new"\)/i, /\.Replace\("old"/i],
    tags: ['string', 'stringbuilder', 'replace'],
  },
  {
    id: 'cs-str-stringbuilder-format-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'StringBuilder with AppendFormat',
    text: 'Append formatted text "Name: Alice, Age: 30" using AppendFormat',
    setup:
      'using System.Text;\nvar sb = new StringBuilder();\nstring name = "Alice";\nint age = 30;',
    setupCode:
      'using System.Text;\nvar sb = new StringBuilder();\nstring name = "Alice";\nint age = 30;',
    expected: '"Name: Alice, Age: 30"',
    sample: 'sb.AppendFormat("Name: {0}, Age: {1}", name, age);',
    hints: [
      'AppendFormat uses the same format syntax as String.Format',
      'Placeholders are {0}, {1}, etc.',
    ],
    validPatterns: [/sb\.AppendFormat\(".*\{0\}.*\{1\}"/i, /\.AppendFormat\(/i],
    tags: ['string', 'stringbuilder', 'format', 'appendformat'],
  },
  {
    id: 'cs-str-span-slice-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Span<char> Slice from String',
    text: 'Extract "World" from the string as a ReadOnlySpan<char> using AsSpan and Slice',
    setup: 'string text = "Hello World!";',
    setupCode: 'string text = "Hello World!";',
    expected: 'ReadOnlySpan<char> containing "World"',
    sample: 'text.AsSpan().Slice(6, 5)',
    hints: [
      'AsSpan() creates a span view without copying',
      'Slice(start, length) extracts a portion',
    ],
    validPatterns: [/text\.AsSpan\(\)\.Slice\(6,\s*5\)/i, /\.AsSpan\(\).*\.Slice\(/i],
    tags: ['string', 'span', 'slice', 'performance'],
  },
  {
    id: 'cs-str-span-range-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Span<char> with Range Operator',
    text: 'Get the last 6 characters of the string as a ReadOnlySpan<char> using range syntax',
    setup: 'string text = "Hello World!";',
    setupCode: 'string text = "Hello World!";',
    expected: 'ReadOnlySpan<char> containing "World!"',
    sample: 'text.AsSpan()[^6..]',
    hints: ['Range operator works with spans', '^6.. means from 6th-from-end to end'],
    validPatterns: [/text\.AsSpan\(\)\[\^6\.\.\.?\]/i, /\.AsSpan\(\)\[\^\d+\.\./i],
    tags: ['string', 'span', 'range', 'index'],
  },
  {
    id: 'cs-str-span-stackalloc-1',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Span<char> with stackalloc',
    text: 'Create a char buffer on the stack and copy the reversed string into it',
    setup: 'string text = "Hello";',
    setupCode: 'string text = "Hello";',
    expected: 'Span<char> containing "olleH"',
    sample:
      'Span<char> buffer = stackalloc char[text.Length];\ntext.AsSpan().CopyTo(buffer);\nbuffer.Reverse();',
    hints: [
      'stackalloc allocates memory on the stack (fast, no GC)',
      'CopyTo copies span contents to another span',
      'Reverse() reverses the span in-place',
    ],
    validPatterns: [/stackalloc\s+char\[/i, /\.CopyTo\(.*\).*\.Reverse\(/i],
    tags: ['string', 'span', 'stackalloc', 'performance', 'advanced'],
  },
  {
    id: 'cs-str-regex-match-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Basic Regex Match',
    text: 'Check if the string contains a valid email pattern using Regex.IsMatch',
    setup: 'using System.Text.RegularExpressions;\nstring email = "user@example.com";',
    setupCode: 'using System.Text.RegularExpressions;\nstring email = "user@example.com";',
    expected: 'true',
    sample: 'Regex.IsMatch(email, @"^[\\w.-]+@[\\w.-]+\\.\\w+$")',
    hints: [
      'Use @ for verbatim strings to avoid double escaping',
      'IsMatch returns true if any match is found',
    ],
    validPatterns: [/Regex\.IsMatch\(email/i, /Regex\.IsMatch.*@/i],
    tags: ['string', 'regex', 'match', 'validation'],
  },
  {
    id: 'cs-str-regex-replace-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Regex Replace',
    text: 'Replace all digits in the string with "#" using Regex.Replace',
    setup: 'using System.Text.RegularExpressions;\nstring text = "Phone: 123-456-7890";',
    setupCode: 'using System.Text.RegularExpressions;\nstring text = "Phone: 123-456-7890";',
    expected: '"Phone: ###-###-####"',
    sample: 'Regex.Replace(text, @"\\d", "#")',
    hints: ['\\d matches any digit', 'Replace replaces all matches by default'],
    validPatterns: [/Regex\.Replace\(text,\s*@?"\\d"/i, /Regex\.Replace.*\\d.*#/i],
    tags: ['string', 'regex', 'replace'],
  },
  {
    id: 'cs-str-regex-groups-1',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Regex Capture Groups',
    text: 'Extract the area code from a phone number using named capture groups',
    setup: 'using System.Text.RegularExpressions;\nstring phone = "(555) 123-4567";',
    setupCode: 'using System.Text.RegularExpressions;\nstring phone = "(555) 123-4567";',
    expected: '"555"',
    sample: 'Regex.Match(phone, @"\\((?<area>\\d{3})\\)").Groups["area"].Value',
    hints: [
      'Named groups use (?<name>pattern) syntax',
      'Access captured value via Groups["name"].Value',
    ],
    validPatterns: [/Regex\.Match.*\(\?<\w+>.*Groups\["\w+"\]/i, /\(\?<area>/i],
    tags: ['string', 'regex', 'groups', 'capture', 'advanced'],
  },
  {
    id: 'cs-str-regex-split-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Regex Split',
    text: 'Split the string by any whitespace characters (spaces, tabs, newlines)',
    setup: 'using System.Text.RegularExpressions;\nstring text = "one  two\\tthree\\nfour";',
    setupCode: 'using System.Text.RegularExpressions;\nstring text = "one  two\\tthree\\nfour";',
    expected: '["one", "two", "three", "four"]',
    sample: 'Regex.Split(text, @"\\s+")',
    hints: ['\\s matches any whitespace character', '+ means one or more occurrences'],
    validPatterns: [/Regex\.Split\(text,\s*@?"\\s\+"/i, /Regex\.Split.*\\s\+/i],
    tags: ['string', 'regex', 'split', 'whitespace'],
  },
  {
    id: 'cs-str-comparison-ordinal-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Ordinal String Comparison',
    text: 'Compare two strings using case-insensitive ordinal comparison',
    setup: 'string a = "Hello";\nstring b = "HELLO";',
    setupCode: 'string a = "Hello";\nstring b = "HELLO";',
    expected: 'true',
    sample: 'string.Equals(a, b, StringComparison.OrdinalIgnoreCase)',
    hints: [
      'OrdinalIgnoreCase is fastest for case-insensitive comparison',
      'Ordinal comparison uses byte-by-byte comparison',
    ],
    validPatterns: [
      /string\.Equals\(a,\s*b,\s*StringComparison\.OrdinalIgnoreCase\)/i,
      /StringComparison\.OrdinalIgnoreCase/i,
    ],
    tags: ['string', 'comparison', 'ordinal', 'case-insensitive'],
  },
  {
    id: 'cs-str-comparison-culture-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Culture-Aware String Comparison',
    text: 'Compare strings using current culture rules (for proper linguistic sorting)',
    setup: 'string a = "cafe";\nstring b = "CAFE";',
    setupCode: 'string a = "cafe";\nstring b = "CAFE";',
    expected: 'true',
    sample: 'string.Equals(a, b, StringComparison.CurrentCultureIgnoreCase)',
    hints: [
      'CurrentCulture uses linguistic rules of the current thread culture',
      'Use for user-facing text comparison',
    ],
    validPatterns: [
      /StringComparison\.CurrentCultureIgnoreCase/i,
      /string\.Equals.*CurrentCultureIgnoreCase/i,
    ],
    tags: ['string', 'comparison', 'culture', 'localization'],
  },
  {
    id: 'cs-str-comparison-invariant-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Invariant Culture Comparison',
    text: 'Compare strings using invariant culture for consistent cross-culture behavior',
    setup: 'string a = "strasse";\nstring b = "STRASSE";',
    setupCode: 'string a = "strasse";\nstring b = "STRASSE";',
    expected: 'true',
    sample: 'string.Compare(a, b, StringComparison.InvariantCultureIgnoreCase) == 0',
    hints: [
      'InvariantCulture provides consistent behavior across cultures',
      'Use for data that will be stored or compared across systems',
    ],
    validPatterns: [
      /StringComparison\.InvariantCultureIgnoreCase/i,
      /string\.Compare.*InvariantCultureIgnoreCase/i,
    ],
    tags: ['string', 'comparison', 'invariant', 'culture'],
  },
  {
    id: 'cs-str-split-options-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Split with StringSplitOptions',
    text: 'Split the string and remove empty entries',
    setup: 'string text = "one,,two,,,three";',
    setupCode: 'string text = "one,,two,,,three";',
    expected: '["one", "two", "three"]',
    sample: "text.Split(',', StringSplitOptions.RemoveEmptyEntries)",
    hints: [
      'StringSplitOptions.RemoveEmptyEntries removes empty strings from result',
      'Can combine with TrimEntries in .NET 5+',
    ],
    validPatterns: [
      /text\.Split\(',.*StringSplitOptions\.RemoveEmptyEntries/i,
      /StringSplitOptions\.RemoveEmptyEntries/i,
    ],
    tags: ['string', 'split', 'options'],
  },
  {
    id: 'cs-str-split-trim-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Split with Trim Entries',
    text: 'Split the string, remove empty entries, and trim whitespace from each',
    setup: 'string text = " one , two , three ";',
    setupCode: 'string text = " one , two , three ";',
    expected: '["one", "two", "three"]',
    sample:
      "text.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)",
    hints: [
      'TrimEntries trims whitespace from each result (requires .NET 5+)',
      'Use | to combine multiple options',
    ],
    validPatterns: [
      /StringSplitOptions\.RemoveEmptyEntries\s*\|\s*StringSplitOptions\.TrimEntries/i,
      /TrimEntries/i,
    ],
    tags: ['string', 'split', 'trim', 'options'],
  },
  {
    id: 'cs-str-format-provider-1',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Format with CultureInfo',
    text: 'Format the number using German culture (uses comma as decimal separator)',
    setup: 'using System.Globalization;\ndouble value = 1234.56;',
    setupCode: 'using System.Globalization;\ndouble value = 1234.56;',
    expected: '"1.234,56"',
    sample: 'value.ToString("N2", CultureInfo.GetCultureInfo("de-DE"))',
    hints: [
      'CultureInfo determines number and date formatting',
      'German uses . for thousands and , for decimals',
    ],
    validPatterns: [
      /\.ToString\("N2",\s*CultureInfo\.GetCultureInfo\("de-DE"\)\)/i,
      /CultureInfo.*de-DE/i,
    ],
    tags: ['string', 'format', 'culture', 'localization', 'advanced'],
  },
  {
    id: 'cs-str-format-composite-1',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Composite Format with Multiple Specifiers',
    text: 'Format a table row with left-aligned name (15 chars) and right-aligned price (10 chars, currency)',
    setup: 'string name = "Widget";\ndecimal price = 29.99m;',
    setupCode: 'string name = "Widget";\ndecimal price = 29.99m;',
    expected: '"Widget             $29.99"',
    sample: 'string.Format("{0,-15}{1,10:C}", name, price)',
    hints: [
      'Negative width left-aligns, positive right-aligns',
      'Combine alignment and format: {index,alignment:format}',
    ],
    validPatterns: [/string\.Format\("\{0,-15\}\{1,10:C\}"/i, /\{\d+,-?\d+:C\}/i],
    tags: ['string', 'format', 'alignment', 'composite', 'advanced'],
  },
  {
    id: 'cs-str-join-linq-1',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Join with LINQ Transformation',
    text: 'Create a comma-separated list of squared values',
    setup: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    expected: '"1, 4, 9, 16, 25"',
    sample: 'string.Join(", ", numbers.Select(n => n * n))',
    hints: [
      'String.Join works with any IEnumerable',
      'Combine with LINQ Select for transformation',
    ],
    validPatterns: [/string\.Join\(".*",\s*numbers\.Select\(.*\*/i, /Join.*Select.*\*/i],
    tags: ['string', 'join', 'linq', 'transform', 'advanced'],
  },

  // ============================================================
  // NEW PROBLEMS - Batch 1: LINQ Methods (50 problems)
  // ============================================================
  {
    id: 'cs-linq-200',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Select with Index',
    text: 'Create tuples of (index, value) for each element using Select with index',
    setup: 'int[] numbers = { 10, 20, 30 };',
    setupCode: 'int[] numbers = { 10, 20, 30 };',
    expected: '{ (0, 10), (1, 20), (2, 30) }',
    sample: 'numbers.Select((value, index) => (index, value))',
    hints: ['Select has an overload that provides the index', 'Index starts at 0'],
    tags: ['linq', 'select', 'index'],
  },
  {
    id: 'cs-linq-201',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Where with Multiple Conditions',
    text: 'Filter numbers that are greater than 5 AND less than 15',
    setup: 'int[] numbers = { 2, 8, 12, 18, 4, 10 };',
    setupCode: 'int[] numbers = { 2, 8, 12, 18, 4, 10 };',
    expected: '{ 8, 12, 10 }',
    sample: 'numbers.Where(x => x > 5 && x < 15)',
    hints: [
      'Use && for AND conditions in the predicate',
      'Where filters based on boolean predicate',
    ],
    tags: ['linq', 'where', 'filter'],
  },
  {
    id: 'cs-linq-202',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'OrderBy with String Property',
    text: 'Sort the names alphabetically using OrderBy',
    setup: 'string[] names = { "Charlie", "Alice", "Bob" };',
    setupCode: 'string[] names = { "Charlie", "Alice", "Bob" };',
    expected: '{ "Alice", "Bob", "Charlie" }',
    sample: 'names.OrderBy(n => n)',
    hints: ['OrderBy sorts in ascending order', 'For strings, this is alphabetical order'],
    tags: ['linq', 'orderby', 'sorting'],
  },
  {
    id: 'cs-linq-203',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Last Element with Last()',
    text: 'Get the last element of the sequence using Last()',
    setup: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    expected: '5',
    sample: 'numbers.Last()',
    hints: ['Last() throws if sequence is empty', 'Use LastOrDefault() for safe access'],
    tags: ['linq', 'last', 'element'],
  },
  {
    id: 'cs-linq-204',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Single Element with Single()',
    text: 'Get the only even number using Single() with predicate',
    setup: 'int[] numbers = { 1, 3, 4, 5, 7 };',
    setupCode: 'int[] numbers = { 1, 3, 4, 5, 7 };',
    expected: '4',
    sample: 'numbers.Single(x => x % 2 == 0)',
    hints: [
      'Single() throws if zero or multiple matches',
      'Use when exactly one match is expected',
    ],
    tags: ['linq', 'single', 'element'],
  },
  {
    id: 'cs-linq-205',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'ElementAt for Random Access',
    text: 'Get the element at index 2 using ElementAt()',
    setup: 'string[] fruits = { "apple", "banana", "cherry", "date" };',
    setupCode: 'string[] fruits = { "apple", "banana", "cherry", "date" };',
    expected: '"cherry"',
    sample: 'fruits.ElementAt(2)',
    hints: ['ElementAt() provides indexed access to sequences', 'Throws if index is out of range'],
    tags: ['linq', 'elementat', 'access'],
  },
  {
    id: 'cs-linq-206',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Reverse a Sequence',
    text: 'Reverse the order of elements using Reverse()',
    setup: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    expected: '{ 5, 4, 3, 2, 1 }',
    sample: 'numbers.Reverse()',
    hints: [
      'LINQ Reverse() returns new sequence',
      'Different from Array.Reverse() which modifies in-place',
    ],
    tags: ['linq', 'reverse', 'order'],
  },
  {
    id: 'cs-linq-207',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'SequenceEqual Comparison',
    text: 'Check if two sequences are equal using SequenceEqual()',
    setup: 'int[] a = { 1, 2, 3 };\nint[] b = { 1, 2, 3 };',
    setupCode: 'int[] a = { 1, 2, 3 };\nint[] b = { 1, 2, 3 };',
    expected: 'true',
    sample: 'a.SequenceEqual(b)',
    hints: ['SequenceEqual compares element by element', 'Order matters for equality'],
    tags: ['linq', 'sequenceequal', 'compare'],
  },
  {
    id: 'cs-linq-208',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'TakeWhile with Predicate',
    text: 'Take elements while they are less than 5 using TakeWhile()',
    setup: 'int[] numbers = { 1, 2, 3, 6, 4, 2 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 6, 4, 2 };',
    expected: '{ 1, 2, 3 }',
    sample: 'numbers.TakeWhile(x => x < 5)',
    hints: ['TakeWhile stops at first non-matching element', 'Does not continue after a break'],
    tags: ['linq', 'takewhile', 'partition'],
  },
  {
    id: 'cs-linq-209',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'SkipWhile with Predicate',
    text: 'Skip elements while they are less than 5 using SkipWhile()',
    setup: 'int[] numbers = { 1, 2, 3, 6, 4, 2 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 6, 4, 2 };',
    expected: '{ 6, 4, 2 }',
    sample: 'numbers.SkipWhile(x => x < 5)',
    hints: ['SkipWhile skips until predicate fails', 'Then takes all remaining elements'],
    tags: ['linq', 'skipwhile', 'partition'],
  },
  {
    id: 'cs-linq-210',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'GroupBy with Element Selector',
    text: 'Group words by length and select only the first letter of each',
    setup: 'string[] words = { "cat", "dog", "elephant", "ant" };',
    setupCode: 'string[] words = { "cat", "dog", "elephant", "ant" };',
    expected: '{ (3, [c, d, a]), (8, [e]) }',
    sample: 'words.GroupBy(w => w.Length, w => w[0])',
    hints: [
      'GroupBy has overload with element selector',
      'Second parameter transforms elements in groups',
    ],
    tags: ['linq', 'groupby', 'projection'],
  },
  {
    id: 'cs-linq-211',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'SelectMany with Result Selector',
    text: 'Flatten orders and include customer name with each order item',
    setup:
      'var customers = new[] { new { Name = "Alice", Orders = new[] { "A1", "A2" } }, new { Name = "Bob", Orders = new[] { "B1" } } };',
    setupCode:
      'var customers = new[] { new { Name = "Alice", Orders = new[] { "A1", "A2" } }, new { Name = "Bob", Orders = new[] { "B1" } } };',
    expected: '{ ("Alice", "A1"), ("Alice", "A2"), ("Bob", "B1") }',
    sample: 'customers.SelectMany(c => c.Orders, (c, o) => (c.Name, o))',
    hints: [
      'SelectMany has overload with result selector',
      'Result selector combines parent and child',
    ],
    tags: ['linq', 'selectmany', 'flatten'],
  },
  {
    id: 'cs-linq-212',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'Aggregate with Seed',
    text: 'Calculate factorial of 5 using Aggregate with seed value 1',
    setup: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    expected: '120',
    sample: 'numbers.Aggregate(1, (acc, n) => acc * n)',
    hints: [
      'Seed value is the initial accumulator',
      'Useful when accumulator type differs from element type',
    ],
    tags: ['linq', 'aggregate', 'reduce'],
  },
  {
    id: 'cs-linq-213',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'DistinctBy Property',
    text: 'Get distinct items by their category using DistinctBy()',
    setup:
      'var items = new[] { new { Name = "A", Cat = 1 }, new { Name = "B", Cat = 2 }, new { Name = "C", Cat = 1 } };',
    setupCode:
      'var items = new[] { new { Name = "A", Cat = 1 }, new { Name = "B", Cat = 2 }, new { Name = "C", Cat = 1 } };',
    expected: '{ { Name = "A", Cat = 1 }, { Name = "B", Cat = 2 } }',
    sample: 'items.DistinctBy(i => i.Cat)',
    hints: ['DistinctBy was added in .NET 6', 'Returns first element for each distinct key'],
    tags: ['linq', 'distinctby', 'unique'],
  },
  {
    id: 'cs-linq-214',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'MinBy and MaxBy',
    text: 'Find the person with minimum age using MinBy()',
    setup:
      'var people = new[] { new { Name = "Alice", Age = 30 }, new { Name = "Bob", Age = 25 }, new { Name = "Carol", Age = 35 } };',
    setupCode:
      'var people = new[] { new { Name = "Alice", Age = 30 }, new { Name = "Bob", Age = 25 }, new { Name = "Carol", Age = 35 } };',
    expected: '{ Name = "Bob", Age = 25 }',
    sample: 'people.MinBy(p => p.Age)',
    hints: ['MinBy returns the element, not the minimum value', 'Added in .NET 6'],
    tags: ['linq', 'minby', 'aggregate'],
  },
  {
    id: 'cs-linq-215',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'Chunk into Batches',
    text: 'Split the array into chunks of 3 elements using Chunk()',
    setup: 'int[] numbers = { 1, 2, 3, 4, 5, 6, 7, 8 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 4, 5, 6, 7, 8 };',
    expected: '{ [1,2,3], [4,5,6], [7,8] }',
    sample: 'numbers.Chunk(3)',
    hints: ['Chunk splits sequence into fixed-size arrays', 'Last chunk may be smaller'],
    tags: ['linq', 'chunk', 'batch'],
  },
  {
    id: 'cs-linq-216',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'UnionBy for Distinct Union',
    text: 'Union two sequences by ID, keeping first occurrence',
    setup:
      'var a = new[] { new { Id = 1, V = "A" }, new { Id = 2, V = "B" } };\nvar b = new[] { new { Id = 2, V = "X" }, new { Id = 3, V = "C" } };',
    setupCode:
      'var a = new[] { new { Id = 1, V = "A" }, new { Id = 2, V = "B" } };\nvar b = new[] { new { Id = 2, V = "X" }, new { Id = 3, V = "C" } };',
    expected: '{ {1,"A"}, {2,"B"}, {3,"C"} }',
    sample: 'a.UnionBy(b, x => x.Id)',
    hints: ['UnionBy removes duplicates based on key selector', 'First occurrence is kept'],
    tags: ['linq', 'unionby', 'set'],
  },
  {
    id: 'cs-linq-217',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'ExceptBy for Set Difference',
    text: 'Get items from first sequence whose IDs are not in second',
    setup:
      'var items = new[] { new { Id = 1 }, new { Id = 2 }, new { Id = 3 } };\nint[] excludeIds = { 2 };',
    setupCode:
      'var items = new[] { new { Id = 1 }, new { Id = 2 }, new { Id = 3 } };\nint[] excludeIds = { 2 };',
    expected: '{ { Id = 1 }, { Id = 3 } }',
    sample: 'items.ExceptBy(excludeIds, i => i.Id)',
    hints: ['ExceptBy compares using key selector', 'Second sequence provides keys to exclude'],
    tags: ['linq', 'exceptby', 'set'],
  },
  {
    id: 'cs-linq-218',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'IntersectBy for Common Elements',
    text: 'Find items whose IDs exist in both sequences',
    setup:
      'var items = new[] { new { Id = 1, N = "A" }, new { Id = 2, N = "B" }, new { Id = 3, N = "C" } };\nint[] keepIds = { 2, 3, 4 };',
    setupCode:
      'var items = new[] { new { Id = 1, N = "A" }, new { Id = 2, N = "B" }, new { Id = 3, N = "C" } };\nint[] keepIds = { 2, 3, 4 };',
    expected: '{ { Id = 2, N = "B" }, { Id = 3, N = "C" } }',
    sample: 'items.IntersectBy(keepIds, i => i.Id)',
    hints: ['IntersectBy finds common elements by key', 'Returns elements from first sequence'],
    tags: ['linq', 'intersectby', 'set'],
  },
  {
    id: 'cs-linq-219',
    category: 'LINQ Methods',
    difficulty: 'hard',
    title: 'Zip Three Sequences',
    text: 'Combine three arrays element-wise using Zip (C# 12)',
    setup: 'int[] a = { 1, 2, 3 };\nint[] b = { 10, 20, 30 };\nint[] c = { 100, 200, 300 };',
    setupCode: 'int[] a = { 1, 2, 3 };\nint[] b = { 10, 20, 30 };\nint[] c = { 100, 200, 300 };',
    expected: '{ (1, 10, 100), (2, 20, 200), (3, 30, 300) }',
    sample: 'a.Zip(b, c)',
    hints: ['Three-way Zip added in .NET 6', 'Returns ValueTuple<T1,T2,T3>'],
    tags: ['linq', 'zip', 'combine'],
  },
  {
    id: 'cs-linq-220',
    category: 'LINQ Methods',
    difficulty: 'hard',
    title: 'TakeLast Elements',
    text: 'Get the last 3 elements using TakeLast()',
    setup: 'int[] numbers = { 1, 2, 3, 4, 5, 6, 7 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 4, 5, 6, 7 };',
    expected: '{ 5, 6, 7 }',
    sample: 'numbers.TakeLast(3)',
    hints: ['TakeLast returns last n elements', 'More efficient than Skip + Count'],
    tags: ['linq', 'takelast', 'partition'],
  },
  {
    id: 'cs-linq-221',
    category: 'LINQ Methods',
    difficulty: 'hard',
    title: 'SkipLast Elements',
    text: 'Get all elements except the last 2 using SkipLast()',
    setup: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    expected: '{ 1, 2, 3 }',
    sample: 'numbers.SkipLast(2)',
    hints: ['SkipLast excludes last n elements', 'Useful for removing trailing elements'],
    tags: ['linq', 'skiplast', 'partition'],
  },
  {
    id: 'cs-linq-222',
    category: 'LINQ Methods',
    difficulty: 'hard',
    title: 'Prepend and Append',
    text: 'Add 0 to beginning and 100 to end using Prepend and Append',
    setup: 'int[] numbers = { 1, 2, 3 };',
    setupCode: 'int[] numbers = { 1, 2, 3 };',
    expected: '{ 0, 1, 2, 3, 100 }',
    sample: 'numbers.Prepend(0).Append(100)',
    hints: ['Prepend adds to beginning', 'Append adds to end'],
    tags: ['linq', 'prepend', 'append'],
  },
  {
    id: 'cs-linq-223',
    category: 'LINQ Methods',
    difficulty: 'hard',
    title: 'Range and Repeat Generation',
    text: 'Generate sequence 1 to 5, then repeat value 0 three times',
    setup: '// Use Enumerable.Range and Enumerable.Repeat',
    setupCode: '// Use Enumerable.Range and Enumerable.Repeat',
    expected: '{ 1, 2, 3, 4, 5, 0, 0, 0 }',
    sample: 'Enumerable.Range(1, 5).Concat(Enumerable.Repeat(0, 3))',
    hints: ['Range(start, count) generates sequence', 'Repeat(element, count) repeats value'],
    tags: ['linq', 'range', 'repeat', 'generate'],
  },
  {
    id: 'cs-linq-224',
    category: 'LINQ Methods',
    difficulty: 'hard',
    title: 'Empty Sequence',
    text: 'Return empty sequence of integers using Enumerable.Empty',
    setup: '// Return empty IEnumerable<int>',
    setupCode: '// Return empty IEnumerable<int>',
    expected: '{ } (empty)',
    sample: 'Enumerable.Empty<int>()',
    hints: ['Empty returns cached empty sequence', 'More efficient than new List<T>()'],
    tags: ['linq', 'empty', 'generate'],
  },
  {
    id: 'cs-linq-225',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Contains with Custom Comparer',
    text: 'Check if list contains "HELLO" using case-insensitive comparison',
    setup: 'string[] words = { "hello", "world" };',
    setupCode: 'string[] words = { "hello", "world" };',
    expected: 'true',
    sample: 'words.Contains("HELLO", StringComparer.OrdinalIgnoreCase)',
    hints: [
      'Contains has overload accepting IEqualityComparer',
      'StringComparer provides common comparers',
    ],
    tags: ['linq', 'contains', 'comparer'],
  },
  {
    id: 'cs-linq-226',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'LongCount for Large Collections',
    text: 'Count elements returning long using LongCount()',
    setup: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    expected: '5L',
    sample: 'numbers.LongCount()',
    hints: ['LongCount returns Int64', 'Use for collections that might exceed Int32.MaxValue'],
    tags: ['linq', 'longcount', 'aggregate'],
  },
  {
    id: 'cs-linq-227',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'AsEnumerable for Type Change',
    text: 'Convert List<T> to IEnumerable<T> to use LINQ extension methods',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    expected: 'IEnumerable<int> { 1, 2, 3 }',
    sample: 'numbers.AsEnumerable()',
    hints: ['AsEnumerable changes compile-time type', 'Useful to avoid shadowed methods'],
    tags: ['linq', 'asenumerable', 'type'],
  },
  {
    id: 'cs-linq-228',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'ToDictionary with Key and Value Selectors',
    text: 'Convert array to dictionary with name as key and length as value',
    setup: 'string[] names = { "Alice", "Bob", "Carol" };',
    setupCode: 'string[] names = { "Alice", "Bob", "Carol" };',
    expected: '{ ["Alice"] = 5, ["Bob"] = 3, ["Carol"] = 5 }',
    sample: 'names.ToDictionary(n => n, n => n.Length)',
    hints: ['ToDictionary creates Dictionary<TKey, TValue>', 'Throws on duplicate keys'],
    tags: ['linq', 'todictionary', 'convert'],
  },
  {
    id: 'cs-linq-229',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'ToHashSet Conversion',
    text: 'Convert array to HashSet removing duplicates',
    setup: 'int[] numbers = { 1, 2, 2, 3, 3, 3 };',
    setupCode: 'int[] numbers = { 1, 2, 2, 3, 3, 3 };',
    expected: 'HashSet<int> { 1, 2, 3 }',
    sample: 'numbers.ToHashSet()',
    hints: ['ToHashSet creates HashSet<T>', 'Automatically removes duplicates'],
    tags: ['linq', 'tohashset', 'convert'],
  },
  {
    id: 'cs-linq-230',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'Order without Key Selector',
    text: 'Sort numbers using Order() method (C# 11+)',
    setup: 'int[] numbers = { 5, 2, 8, 1, 9 };',
    setupCode: 'int[] numbers = { 5, 2, 8, 1, 9 };',
    expected: '{ 1, 2, 5, 8, 9 }',
    sample: 'numbers.Order()',
    hints: ['Order() is simpler than OrderBy(x => x)', 'Added in .NET 7'],
    tags: ['linq', 'order', 'sorting'],
  },
  {
    id: 'cs-linq-231',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'OrderDescending Simple',
    text: 'Sort numbers in descending order using OrderDescending()',
    setup: 'int[] numbers = { 5, 2, 8, 1, 9 };',
    setupCode: 'int[] numbers = { 5, 2, 8, 1, 9 };',
    expected: '{ 9, 8, 5, 2, 1 }',
    sample: 'numbers.OrderDescending()',
    hints: ['OrderDescending() is simpler than OrderByDescending(x => x)', 'Added in .NET 7'],
    tags: ['linq', 'orderdescending', 'sorting'],
  },
  {
    id: 'cs-linq-232',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'Index Method for Position',
    text: 'Get elements with their indices using Index() method',
    setup: 'string[] letters = { "a", "b", "c" };',
    setupCode: 'string[] letters = { "a", "b", "c" };',
    expected: '{ (0, "a"), (1, "b"), (2, "c") }',
    sample: 'letters.Index()',
    hints: ['Index() returns (int Index, T Item) tuples', 'Added in .NET 9'],
    tags: ['linq', 'index', 'enumerate'],
  },
  {
    id: 'cs-linq-233',
    category: 'LINQ Methods',
    difficulty: 'hard',
    title: 'AggregateBy for Grouped Aggregation',
    text: 'Sum values grouped by key using AggregateBy()',
    setup: 'var items = new[] { ("A", 10), ("B", 20), ("A", 30), ("B", 40) };',
    setupCode: 'var items = new[] { ("A", 10), ("B", 20), ("A", 30), ("B", 40) };',
    expected: '{ ["A"] = 40, ["B"] = 60 }',
    sample: 'items.AggregateBy(x => x.Item1, 0, (acc, x) => acc + x.Item2)',
    hints: ['AggregateBy groups and aggregates in one pass', 'Added in .NET 9'],
    tags: ['linq', 'aggregateby', 'grouping'],
  },
  {
    id: 'cs-linq-234',
    category: 'LINQ Methods',
    difficulty: 'hard',
    title: 'CountBy for Grouped Counts',
    text: 'Count occurrences by category using CountBy()',
    setup: 'string[] items = { "A", "B", "A", "C", "A", "B" };',
    setupCode: 'string[] items = { "A", "B", "A", "C", "A", "B" };',
    expected: '{ ["A"] = 3, ["B"] = 2, ["C"] = 1 }',
    sample: 'items.CountBy(x => x)',
    hints: ['CountBy groups and counts in one pass', 'Added in .NET 9'],
    tags: ['linq', 'countby', 'grouping'],
  },
  {
    id: 'cs-linq-235',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'DefaultIfEmpty with Custom Value',
    text: 'Return -1 if sequence is empty',
    setup: 'int[] numbers = { };',
    setupCode: 'int[] numbers = { };',
    expected: '{ -1 }',
    sample: 'numbers.DefaultIfEmpty(-1)',
    hints: [
      'DefaultIfEmpty returns single-element sequence if empty',
      'Specify custom default value',
    ],
    tags: ['linq', 'defaultifempty', 'empty'],
  },
  {
    id: 'cs-linq-236',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Cast to Base Type',
    text: 'Cast all integers to objects using Cast<object>()',
    setup: 'int[] numbers = { 1, 2, 3 };',
    setupCode: 'int[] numbers = { 1, 2, 3 };',
    expected: 'IEnumerable<object> { 1, 2, 3 }',
    sample: 'numbers.Cast<object>()',
    hints: ['Cast performs type conversion', 'Throws if conversion fails'],
    tags: ['linq', 'cast', 'type'],
  },
  {
    id: 'cs-linq-237',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'TryGetNonEnumeratedCount',
    text: 'Try to get count without enumerating using TryGetNonEnumeratedCount()',
    setup: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    expected: 'true, count = 5',
    sample: 'numbers.TryGetNonEnumeratedCount(out int count)',
    hints: ['Returns true if count available without enumeration', 'Works for arrays, lists, etc.'],
    tags: ['linq', 'count', 'performance'],
  },
  {
    id: 'cs-linq-238',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'Select with Tuple Deconstruction',
    text: 'Transform tuples by deconstructing in Select',
    setup: 'var pairs = new[] { (1, "one"), (2, "two"), (3, "three") };',
    setupCode: 'var pairs = new[] { (1, "one"), (2, "two"), (3, "three") };',
    expected: '{ "one:1", "two:2", "three:3" }',
    sample: 'pairs.Select(((int n, string s) t) => $"{t.s}:{t.n}")',
    hints: ['Can deconstruct tuples in lambda parameters', 'Use named tuple for clarity'],
    tags: ['linq', 'select', 'tuple', 'deconstruct'],
  },
  {
    id: 'cs-linq-239',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'Where with Type Pattern',
    text: 'Filter objects to only strings longer than 3 characters',
    setup: 'object[] items = { "hi", 42, "hello", "bye", 100 };',
    setupCode: 'object[] items = { "hi", 42, "hello", "bye", 100 };',
    expected: '{ "hello" }',
    sample: 'items.Where(x => x is string s && s.Length > 3)',
    hints: [
      'Combine type pattern with additional conditions',
      'Pattern variable s is only in scope when matched',
    ],
    tags: ['linq', 'where', 'pattern'],
  },
  {
    id: 'cs-linq-240',
    category: 'LINQ Methods',
    difficulty: 'hard',
    title: 'SelectMany with Query Syntax',
    text: 'Flatten nested using query syntax with multiple from clauses',
    setup:
      'var data = new[] { new { Name = "A", Items = new[] { 1, 2 } }, new { Name = "B", Items = new[] { 3 } } };',
    setupCode:
      'var data = new[] { new { Name = "A", Items = new[] { 1, 2 } }, new { Name = "B", Items = new[] { 3 } } };',
    expected: '{ ("A", 1), ("A", 2), ("B", 3) }',
    sample: 'from d in data from i in d.Items select (d.Name, i)',
    hints: ['Multiple from = SelectMany', 'Query syntax can be more readable for complex queries'],
    tags: ['linq', 'selectmany', 'query'],
  },
  {
    id: 'cs-linq-241',
    category: 'LINQ Methods',
    difficulty: 'hard',
    title: 'GroupJoin with DefaultIfEmpty',
    text: 'Left outer join using GroupJoin and DefaultIfEmpty',
    setup:
      'var left = new[] { 1, 2, 3 };\nvar right = new[] { new { Key = 1, Val = "A" }, new { Key = 3, Val = "C" } };',
    setupCode:
      'var left = new[] { 1, 2, 3 };\nvar right = new[] { new { Key = 1, Val = "A" }, new { Key = 3, Val = "C" } };',
    expected: '{ (1, "A"), (2, null), (3, "C") }',
    sample: 'left.GroupJoin(right, l => l, r => r.Key, (l, rs) => (l, rs.FirstOrDefault()?.Val))',
    hints: ['GroupJoin + DefaultIfEmpty = left outer join', 'Handle null for unmatched items'],
    tags: ['linq', 'groupjoin', 'outerjoin'],
  },
  {
    id: 'cs-linq-242',
    category: 'LINQ Methods',
    difficulty: 'hard',
    title: 'Aggregate Building Object',
    text: 'Build a summary object using Aggregate',
    setup: 'int[] scores = { 85, 92, 78, 95, 88 };',
    setupCode: 'int[] scores = { 85, 92, 78, 95, 88 };',
    expected: '{ Count = 5, Sum = 438, Min = 78, Max = 95 }',
    sample:
      'scores.Aggregate(new { Count = 0, Sum = 0, Min = int.MaxValue, Max = int.MinValue }, (acc, s) => new { Count = acc.Count + 1, Sum = acc.Sum + s, Min = Math.Min(acc.Min, s), Max = Math.Max(acc.Max, s) })',
    hints: [
      'Aggregate can build complex result objects',
      'Use anonymous type for multiple aggregates',
    ],
    tags: ['linq', 'aggregate', 'complex'],
  },
  {
    id: 'cs-linq-243',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'ToArray Materialization',
    text: 'Materialize LINQ query to array',
    setup: 'var query = Enumerable.Range(1, 5).Where(x => x % 2 == 1);',
    setupCode: 'var query = Enumerable.Range(1, 5).Where(x => x % 2 == 1);',
    expected: 'int[] { 1, 3, 5 }',
    sample: 'query.ToArray()',
    hints: ['ToArray forces immediate execution', 'Returns a new array'],
    tags: ['linq', 'toarray', 'materialize'],
  },
  {
    id: 'cs-linq-244',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'OrderBy with Custom Comparer',
    text: 'Sort strings by length using custom comparison',
    setup: 'string[] words = { "cat", "elephant", "dog", "bird" };',
    setupCode: 'string[] words = { "cat", "elephant", "dog", "bird" };',
    expected: '{ "cat", "dog", "bird", "elephant" }',
    sample: 'words.OrderBy(w => w.Length)',
    hints: ['OrderBy accepts key selector', 'Default comparer used for key type'],
    tags: ['linq', 'orderby', 'custom'],
  },
  {
    id: 'cs-linq-245',
    category: 'LINQ Methods',
    difficulty: 'medium',
    title: 'ThenBy Secondary Sort',
    text: 'Sort by length, then alphabetically',
    setup: 'string[] words = { "cat", "ant", "bird", "dog" };',
    setupCode: 'string[] words = { "cat", "ant", "bird", "dog" };',
    expected: '{ "ant", "cat", "dog", "bird" }',
    sample: 'words.OrderBy(w => w.Length).ThenBy(w => w)',
    hints: ['ThenBy adds secondary sort criteria', 'Must follow OrderBy or OrderByDescending'],
    tags: ['linq', 'thenby', 'sorting'],
  },
  {
    id: 'cs-linq-246',
    category: 'LINQ Methods',
    difficulty: 'hard',
    title: 'Custom IEqualityComparer with Distinct',
    text: 'Get distinct strings ignoring case',
    setup: 'string[] words = { "Hello", "HELLO", "World", "WORLD" };',
    setupCode: 'string[] words = { "Hello", "HELLO", "World", "WORLD" };',
    expected: '{ "Hello", "World" }',
    sample: 'words.Distinct(StringComparer.OrdinalIgnoreCase)',
    hints: ['Distinct accepts IEqualityComparer', 'StringComparer provides built-in comparers'],
    tags: ['linq', 'distinct', 'comparer'],
  },
  {
    id: 'cs-linq-247',
    category: 'LINQ Methods',
    difficulty: 'hard',
    title: 'Recursive Flatten with SelectMany',
    text: 'Flatten a tree structure using recursive SelectMany',
    setup:
      'var root = new { Name = "A", Children = new[] { new { Name = "B", Children = Array.Empty<object>() }, new { Name = "C", Children = Array.Empty<object>() } } };',
    setupCode:
      'var root = new { Name = "A", Children = new[] { new { Name = "B", Children = Array.Empty<object>() }, new { Name = "C", Children = Array.Empty<object>() } } };',
    expected: '{ "A", "B", "C" }',
    sample:
      'new[] { root }.SelectMany(n => new[] { n.Name }.Concat(n.Children.SelectMany(c => new[] { ((dynamic)c).Name })))',
    hints: ['Use recursive approach for tree flattening', 'Consider helper method for deep trees'],
    tags: ['linq', 'selectmany', 'recursive', 'tree'],
  },
  {
    id: 'cs-linq-248',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Sum with Selector',
    text: 'Sum the lengths of all strings',
    setup: 'string[] words = { "hello", "world", "test" };',
    setupCode: 'string[] words = { "hello", "world", "test" };',
    expected: '14',
    sample: 'words.Sum(w => w.Length)',
    hints: ['Sum accepts a selector function', 'Projects each element before summing'],
    tags: ['linq', 'sum', 'aggregate'],
  },
  {
    id: 'cs-linq-249',
    category: 'LINQ Methods',
    difficulty: 'easy',
    title: 'Average with Selector',
    text: 'Calculate average string length',
    setup: 'string[] words = { "cat", "elephant", "dog" };',
    setupCode: 'string[] words = { "cat", "elephant", "dog" };',
    expected: '4.666...',
    sample: 'words.Average(w => w.Length)',
    hints: ['Average accepts selector function', 'Returns double'],
    tags: ['linq', 'average', 'aggregate'],
  },

  // ============================================================
  // NEW PROBLEMS - Batch 2: List Operations (25 problems)
  // ============================================================
  {
    id: 'cs-list-250',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'List Capacity vs Count',
    text: 'Set the list capacity to 100 using EnsureCapacity()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    expected: 'Capacity >= 100, Count = 3',
    sample: 'numbers.EnsureCapacity(100);',
    hints: ['EnsureCapacity prevents reallocations', 'Capacity is the internal array size'],
    tags: ['list', 'capacity', 'performance'],
  },
  {
    id: 'cs-list-251',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'TrimExcess to Reduce Memory',
    text: 'Reduce the list capacity to match its count using TrimExcess()',
    setup: 'List<int> numbers = new List<int>(100) { 1, 2, 3 };',
    setupCode: 'List<int> numbers = new List<int>(100) { 1, 2, 3 };',
    expected: 'Capacity reduced to approximately Count',
    sample: 'numbers.TrimExcess();',
    hints: ['TrimExcess frees unused capacity', 'Call after bulk operations complete'],
    tags: ['list', 'trimexcess', 'memory'],
  },
  {
    id: 'cs-list-252',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'InsertRange at Position',
    text: 'Insert array { 10, 20, 30 } at index 1 using InsertRange()',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    expected: '{ 1, 10, 20, 30, 2, 3 }',
    sample: 'numbers.InsertRange(1, new[] { 10, 20, 30 });',
    hints: ['InsertRange inserts collection at specified index', 'Existing elements shift right'],
    tags: ['list', 'insertrange', 'bulk'],
  },
  {
    id: 'cs-list-253',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'RemoveRange from List',
    text: 'Remove 2 elements starting at index 1 using RemoveRange()',
    setup: 'List<int> numbers = new List<int> { 10, 20, 30, 40, 50 };',
    setupCode: 'List<int> numbers = new List<int> { 10, 20, 30, 40, 50 };',
    expected: '{ 10, 40, 50 }',
    sample: 'numbers.RemoveRange(1, 2);',
    hints: [
      'RemoveRange(index, count) removes multiple elements',
      'More efficient than multiple Remove calls',
    ],
    tags: ['list', 'removerange', 'bulk'],
  },
  {
    id: 'cs-list-254',
    category: 'List Methods',
    difficulty: 'medium',
    title: 'GetRange Slice',
    text: 'Get 3 elements starting at index 1 using GetRange()',
    setup: 'List<int> numbers = new List<int> { 10, 20, 30, 40, 50 };',
    setupCode: 'List<int> numbers = new List<int> { 10, 20, 30, 40, 50 };',
    expected: 'List<int> { 20, 30, 40 }',
    sample: 'numbers.GetRange(1, 3)',
    hints: ['GetRange returns a new List<T>', 'Parameters are (index, count)'],
    tags: ['list', 'getrange', 'slice'],
  },
  {
    id: 'cs-list-255',
    category: 'List Methods',
    difficulty: 'medium',
    title: 'Sort with Comparison Delegate',
    text: 'Sort strings by length descending using Sort with comparison',
    setup: 'List<string> words = new List<string> { "cat", "elephant", "dog" };',
    setupCode: 'List<string> words = new List<string> { "cat", "elephant", "dog" };',
    expected: '{ "elephant", "cat", "dog" }',
    sample: 'words.Sort((a, b) => b.Length.CompareTo(a.Length));',
    hints: [
      'Sort accepts Comparison<T> delegate',
      'Return negative for less, positive for greater',
    ],
    tags: ['list', 'sort', 'comparison'],
  },
  {
    id: 'cs-list-256',
    category: 'List Methods',
    difficulty: 'medium',
    title: 'Sort with IComparer',
    text: 'Sort using StringComparer.OrdinalIgnoreCase',
    setup: 'List<string> words = new List<string> { "Banana", "apple", "Cherry" };',
    setupCode: 'List<string> words = new List<string> { "Banana", "apple", "Cherry" };',
    expected: '{ "apple", "Banana", "Cherry" }',
    sample: 'words.Sort(StringComparer.OrdinalIgnoreCase);',
    hints: ['Sort accepts IComparer<T>', 'StringComparer provides common string comparers'],
    tags: ['list', 'sort', 'comparer'],
  },
  {
    id: 'cs-list-257',
    category: 'List Methods',
    difficulty: 'medium',
    title: 'BinarySearch with Insertion Point',
    text: 'Find insertion point for value 25 in sorted list',
    setup: 'List<int> numbers = new List<int> { 10, 20, 30, 40, 50 };',
    setupCode: 'List<int> numbers = new List<int> { 10, 20, 30, 40, 50 };',
    expected: '~2 (bitwise complement of insertion index)',
    sample: 'int index = numbers.BinarySearch(25); // returns ~2',
    hints: [
      'BinarySearch returns bitwise complement if not found',
      'Use ~result to get insertion point',
    ],
    tags: ['list', 'binarysearch', 'search'],
  },
  {
    id: 'cs-list-258',
    category: 'List Methods',
    difficulty: 'medium',
    title: 'FindLastIndex with Predicate',
    text: 'Find the last index where value is even',
    setup: 'List<int> numbers = new List<int> { 1, 4, 3, 6, 5, 8 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 4, 3, 6, 5, 8 };',
    expected: '5',
    sample: 'numbers.FindLastIndex(x => x % 2 == 0)',
    hints: ['FindLastIndex searches from the end', 'Returns -1 if not found'],
    tags: ['list', 'findlastindex', 'search'],
  },
  {
    id: 'cs-list-259',
    category: 'List Methods',
    difficulty: 'hard',
    title: 'CopyTo with Offset',
    text: 'Copy list to array starting at array index 2',
    setup: 'List<int> source = new List<int> { 1, 2, 3 };\nint[] dest = new int[6];',
    setupCode: 'List<int> source = new List<int> { 1, 2, 3 };\nint[] dest = new int[6];',
    expected: 'dest = { 0, 0, 1, 2, 3, 0 }',
    sample: 'source.CopyTo(dest, 2);',
    hints: ['CopyTo copies to array at specified index', 'Destination must have enough space'],
    tags: ['list', 'copyto', 'array'],
  },
  {
    id: 'cs-list-260',
    category: 'List Methods',
    difficulty: 'hard',
    title: 'AsReadOnly Wrapper',
    text: 'Create a read-only wrapper around the list',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    expected: 'ReadOnlyCollection<int> { 1, 2, 3 }',
    sample: 'numbers.AsReadOnly()',
    hints: ['AsReadOnly returns ReadOnlyCollection<T>', 'Changes to original list are visible'],
    tags: ['list', 'asreadonly', 'readonly'],
  },
  {
    id: 'cs-list-261',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'ForEach Action',
    text: 'Print each element using ForEach with lambda',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3 };',
    expected: 'Prints: 1 2 3',
    sample: 'numbers.ForEach(n => Console.Write(n + " "));',
    hints: ['ForEach executes action on each element', 'Cannot break early from ForEach'],
    tags: ['list', 'foreach', 'action'],
  },
  {
    id: 'cs-list-262',
    category: 'List Methods',
    difficulty: 'medium',
    title: 'Reverse Partial Range',
    text: 'Reverse elements from index 1 to 3 (3 elements)',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    expected: '{ 1, 4, 3, 2, 5 }',
    sample: 'numbers.Reverse(1, 3);',
    hints: ['Reverse(index, count) reverses a range', 'Modifies list in-place'],
    tags: ['list', 'reverse', 'range'],
  },
  {
    id: 'cs-list-263',
    category: 'List Methods',
    difficulty: 'medium',
    title: 'Sort Partial Range',
    text: 'Sort only elements from index 1 to 3 (3 elements)',
    setup: 'List<int> numbers = new List<int> { 5, 4, 3, 2, 1 };',
    setupCode: 'List<int> numbers = new List<int> { 5, 4, 3, 2, 1 };',
    expected: '{ 5, 2, 3, 4, 1 }',
    sample: 'numbers.Sort(1, 3, null);',
    hints: ['Sort(index, count, comparer) sorts a range', 'Pass null comparer for default'],
    tags: ['list', 'sort', 'range'],
  },
  {
    id: 'cs-list-264',
    category: 'List Methods',
    difficulty: 'hard',
    title: 'BinarySearch in Range',
    text: 'Binary search for 30 only in range starting at index 2, count 3',
    setup: 'List<int> numbers = new List<int> { 10, 20, 25, 30, 35, 40 };',
    setupCode: 'List<int> numbers = new List<int> { 10, 20, 25, 30, 35, 40 };',
    expected: '3',
    sample: 'numbers.BinarySearch(2, 3, 30, null)',
    hints: ['BinarySearch has range overload', 'Parameters: index, count, item, comparer'],
    tags: ['list', 'binarysearch', 'range'],
  },
  {
    id: 'cs-list-265',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'LastIndexOf Value',
    text: 'Find the last index of value 3',
    setup: 'List<int> numbers = new List<int> { 1, 3, 5, 3, 7 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 3, 5, 3, 7 };',
    expected: '3',
    sample: 'numbers.LastIndexOf(3)',
    hints: ['LastIndexOf searches from the end', 'Returns -1 if not found'],
    tags: ['list', 'lastindexof', 'search'],
  },
  {
    id: 'cs-list-266',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Initialize List with Capacity',
    text: 'Create a list with initial capacity of 50',
    setup: '// Create List<int> with capacity 50',
    setupCode: '// Create List<int> with capacity 50',
    expected: 'List<int> with Capacity = 50, Count = 0',
    sample: 'var list = new List<int>(50);',
    hints: ['Constructor accepts initial capacity', 'Reduces reallocations for known sizes'],
    tags: ['list', 'capacity', 'constructor'],
  },
  {
    id: 'cs-list-267',
    category: 'List Methods',
    difficulty: 'medium',
    title: 'Collection Initializer Syntax',
    text: 'Create a list with values 1, 2, 3 using collection initializer',
    setup: '// Use collection initializer syntax',
    setupCode: '// Use collection initializer syntax',
    expected: 'List<int> { 1, 2, 3 }',
    sample: 'var list = new List<int> { 1, 2, 3 };',
    hints: [
      'Collection initializer calls Add for each element',
      'Concise syntax for initialization',
    ],
    tags: ['list', 'initializer', 'syntax'],
  },
  {
    id: 'cs-list-268',
    category: 'List Methods',
    difficulty: 'medium',
    title: 'List from Array',
    text: 'Create a list from an existing array',
    setup: 'int[] array = { 1, 2, 3, 4, 5 };',
    setupCode: 'int[] array = { 1, 2, 3, 4, 5 };',
    expected: 'List<int> { 1, 2, 3, 4, 5 }',
    sample: 'var list = new List<int>(array);',
    hints: ['Constructor accepts IEnumerable<T>', 'Creates a copy of the elements'],
    tags: ['list', 'constructor', 'conversion'],
  },
  {
    id: 'cs-list-269',
    category: 'List Methods',
    difficulty: 'hard',
    title: 'CollectionsMarshal.AsSpan',
    text: 'Get a Span<T> view of list internal array for performance',
    setup:
      'using System.Runtime.InteropServices;\nList<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    setupCode:
      'using System.Runtime.InteropServices;\nList<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    expected: 'Span<int> { 1, 2, 3, 4, 5 }',
    sample: 'Span<int> span = CollectionsMarshal.AsSpan(numbers);',
    hints: [
      'AsSpan provides direct access to internal array',
      'High performance but dangerous if list is modified',
    ],
    tags: ['list', 'span', 'performance', 'advanced'],
  },
  {
    id: 'cs-list-270',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'Check Empty List',
    text: 'Check if list is empty using Count property',
    setup: 'List<int> numbers = new List<int>();',
    setupCode: 'List<int> numbers = new List<int>();',
    expected: 'true',
    sample: 'numbers.Count == 0',
    hints: ['Count property is O(1)', 'Prefer over Any() for lists'],
    tags: ['list', 'count', 'empty'],
  },
  {
    id: 'cs-list-271',
    category: 'List Methods',
    difficulty: 'medium',
    title: 'SetRange Alternative',
    text: 'Replace elements at indices 1-3 by removing and inserting',
    setup: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    setupCode: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };',
    expected: '{ 1, 10, 20, 30, 5 }',
    sample: 'numbers.RemoveRange(1, 3); numbers.InsertRange(1, new[] { 10, 20, 30 });',
    hints: ['No SetRange method exists', 'Combine RemoveRange and InsertRange'],
    tags: ['list', 'removerange', 'insertrange'],
  },
  {
    id: 'cs-list-272',
    category: 'List Methods',
    difficulty: 'hard',
    title: 'IndexOf with StartIndex',
    text: 'Find index of value 3 starting search at index 2',
    setup: 'List<int> numbers = new List<int> { 3, 1, 3, 5, 3 };',
    setupCode: 'List<int> numbers = new List<int> { 3, 1, 3, 5, 3 };',
    expected: '2',
    sample: 'numbers.IndexOf(3, 2)',
    hints: ['IndexOf has overload with startIndex', 'Searches from specified position'],
    tags: ['list', 'indexof', 'search'],
  },
  {
    id: 'cs-list-273',
    category: 'List Methods',
    difficulty: 'hard',
    title: 'IndexOf with Range',
    text: 'Find index of value 5 within range [1, 3) (start index 1, count 2)',
    setup: 'List<int> numbers = new List<int> { 5, 1, 5, 3, 5 };',
    setupCode: 'List<int> numbers = new List<int> { 5, 1, 5, 3, 5 };',
    expected: '2',
    sample: 'numbers.IndexOf(5, 1, 2)',
    hints: ['IndexOf(item, index, count) searches in range', 'Returns -1 if not found in range'],
    tags: ['list', 'indexof', 'range'],
  },
  {
    id: 'cs-list-274',
    category: 'List Methods',
    difficulty: 'easy',
    title: 'List Index Access',
    text: 'Get and set element at index 2',
    setup: 'List<int> numbers = new List<int> { 10, 20, 30, 40 };',
    setupCode: 'List<int> numbers = new List<int> { 10, 20, 30, 40 };',
    expected: 'Get: 30, After set: { 10, 20, 99, 40 }',
    sample: 'int val = numbers[2]; numbers[2] = 99;',
    hints: ['Lists support indexed access', 'Throws if index out of range'],
    tags: ['list', 'index', 'access'],
  },

  // ============================================================
  // NEW PROBLEMS - Batch 2: Dictionary Methods (25 problems)
  // ============================================================
  {
    id: 'cs-dict-275',
    category: 'Dictionary Methods',
    difficulty: 'easy',
    title: 'Dictionary Count Property',
    text: 'Get the number of key-value pairs in the dictionary',
    setup:
      'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 1, ["b"] = 2, ["c"] = 3 };',
    setupCode:
      'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 1, ["b"] = 2, ["c"] = 3 };',
    expected: '3',
    sample: 'dict.Count',
    hints: ['Count is O(1)', 'Returns number of key-value pairs'],
    tags: ['dictionary', 'count', 'property'],
  },
  {
    id: 'cs-dict-276',
    category: 'Dictionary Methods',
    difficulty: 'easy',
    title: 'Clear Dictionary',
    text: 'Remove all entries from the dictionary',
    setup: 'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 1, ["b"] = 2 };',
    setupCode:
      'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 1, ["b"] = 2 };',
    expected: 'Count = 0',
    sample: 'dict.Clear();',
    hints: ['Clear removes all entries', 'Capacity may remain unchanged'],
    tags: ['dictionary', 'clear', 'remove'],
  },
  {
    id: 'cs-dict-277',
    category: 'Dictionary Methods',
    difficulty: 'easy',
    title: 'Indexer Add/Update',
    text: 'Add or update value using indexer syntax',
    setup: 'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 1 };',
    setupCode: 'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 1 };',
    expected: '{ ["a"] = 5, ["b"] = 10 }',
    sample: 'dict["a"] = 5; dict["b"] = 10;',
    hints: [
      'Indexer adds if key missing, updates if exists',
      'Different from Add which throws on duplicate',
    ],
    tags: ['dictionary', 'indexer', 'update'],
  },
  {
    id: 'cs-dict-278',
    category: 'Dictionary Methods',
    difficulty: 'medium',
    title: 'Remove with Out Value',
    text: 'Remove key and get the removed value',
    setup: 'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 1, ["b"] = 2 };',
    setupCode:
      'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 1, ["b"] = 2 };',
    expected: 'removed = true, value = 1',
    sample: 'bool removed = dict.Remove("a", out int value);',
    hints: ['Remove overload returns the removed value', 'Returns false if key not found'],
    tags: ['dictionary', 'remove', 'out'],
  },
  {
    id: 'cs-dict-279',
    category: 'Dictionary Methods',
    difficulty: 'medium',
    title: 'Enumerate KeyValuePairs',
    text: 'Iterate over all key-value pairs',
    setup: 'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 1, ["b"] = 2 };',
    setupCode:
      'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 1, ["b"] = 2 };',
    expected: 'KeyValuePair<string, int> for each entry',
    sample: 'foreach (var kvp in dict) { Console.WriteLine($"{kvp.Key}: {kvp.Value}"); }',
    hints: [
      'Dictionary enumerates as KeyValuePair<TKey, TValue>',
      'Can deconstruct: foreach (var (k, v) in dict)',
    ],
    tags: ['dictionary', 'enumerate', 'foreach'],
  },
  {
    id: 'cs-dict-280',
    category: 'Dictionary Methods',
    difficulty: 'medium',
    title: 'Deconstruct in Foreach',
    text: 'Iterate with deconstruction syntax',
    setup: 'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 1, ["b"] = 2 };',
    setupCode:
      'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 1, ["b"] = 2 };',
    expected: 'key and value as separate variables',
    sample: 'foreach (var (key, value) in dict) { Console.WriteLine($"{key}: {value}"); }',
    hints: ['KeyValuePair can be deconstructed', 'Cleaner than kvp.Key and kvp.Value'],
    tags: ['dictionary', 'deconstruct', 'foreach'],
  },
  {
    id: 'cs-dict-281',
    category: 'Dictionary Methods',
    difficulty: 'medium',
    title: 'EnsureCapacity for Performance',
    text: 'Ensure dictionary has capacity for at least 100 entries',
    setup: 'Dictionary<string, int> dict = new Dictionary<string, int>();',
    setupCode: 'Dictionary<string, int> dict = new Dictionary<string, int>();',
    expected: 'Internal capacity >= 100',
    sample: 'dict.EnsureCapacity(100);',
    hints: ['EnsureCapacity reduces reallocations', 'Call before bulk insertions'],
    tags: ['dictionary', 'capacity', 'performance'],
  },
  {
    id: 'cs-dict-282',
    category: 'Dictionary Methods',
    difficulty: 'medium',
    title: 'TrimExcess Dictionary',
    text: 'Reduce dictionary capacity to match count',
    setup: 'Dictionary<string, int> dict = new Dictionary<string, int>(1000) { ["a"] = 1 };',
    setupCode: 'Dictionary<string, int> dict = new Dictionary<string, int>(1000) { ["a"] = 1 };',
    expected: 'Capacity reduced',
    sample: 'dict.TrimExcess();',
    hints: ['TrimExcess frees unused memory', 'Call after removing many entries'],
    tags: ['dictionary', 'trimexcess', 'memory'],
  },
  {
    id: 'cs-dict-283',
    category: 'Dictionary Methods',
    difficulty: 'hard',
    title: 'Custom IEqualityComparer',
    text: 'Create dictionary with case-insensitive string keys',
    setup: '// Create dictionary ignoring case for keys',
    setupCode: '// Create dictionary ignoring case for keys',
    expected: 'dict["HELLO"] returns same value as dict["hello"]',
    sample: 'var dict = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);',
    hints: ['Constructor accepts IEqualityComparer<TKey>', 'Affects key comparison and hashing'],
    tags: ['dictionary', 'comparer', 'case-insensitive'],
  },
  {
    id: 'cs-dict-284',
    category: 'Dictionary Methods',
    difficulty: 'hard',
    title: 'GetAlternateLookup',
    text: 'Look up string key using ReadOnlySpan<char> without allocation',
    setup: 'Dictionary<string, int> dict = new Dictionary<string, int> { ["hello"] = 42 };',
    setupCode: 'Dictionary<string, int> dict = new Dictionary<string, int> { ["hello"] = 42 };',
    expected: '42 (looked up without string allocation)',
    sample:
      'dict.GetAlternateLookup<ReadOnlySpan<char>>().TryGetValue("hello".AsSpan(), out var value)',
    hints: [
      'GetAlternateLookup enables lookup with alternate key types',
      'Requires compatible comparer',
    ],
    tags: ['dictionary', 'span', 'performance', 'advanced'],
  },
  {
    id: 'cs-dict-285',
    category: 'Dictionary Methods',
    difficulty: 'easy',
    title: 'Dictionary Collection Initializer',
    text: 'Initialize dictionary with collection initializer syntax',
    setup: '// Create dictionary with initializer',
    setupCode: '// Create dictionary with initializer',
    expected: '{ ["a"] = 1, ["b"] = 2 }',
    sample: 'var dict = new Dictionary<string, int> { ["a"] = 1, ["b"] = 2 };',
    hints: [
      'Index initializer uses ["key"] = value syntax',
      'Alternative: { { "a", 1 }, { "b", 2 } }',
    ],
    tags: ['dictionary', 'initializer', 'syntax'],
  },
  {
    id: 'cs-dict-286',
    category: 'Dictionary Methods',
    difficulty: 'medium',
    title: 'Convert to List of Tuples',
    text: 'Convert dictionary to list of (key, value) tuples',
    setup: 'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 1, ["b"] = 2 };',
    setupCode:
      'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 1, ["b"] = 2 };',
    expected: 'List<(string, int)> { ("a", 1), ("b", 2) }',
    sample: 'dict.Select(kvp => (kvp.Key, kvp.Value)).ToList()',
    hints: ['Dictionary is IEnumerable<KeyValuePair>', 'Project to tuples with Select'],
    tags: ['dictionary', 'convert', 'tuple'],
  },
  {
    id: 'cs-dict-287',
    category: 'Dictionary Methods',
    difficulty: 'medium',
    title: 'Merge Two Dictionaries',
    text: 'Merge second dictionary into first, overwriting duplicates',
    setup:
      'var d1 = new Dictionary<string, int> { ["a"] = 1, ["b"] = 2 };\nvar d2 = new Dictionary<string, int> { ["b"] = 20, ["c"] = 3 };',
    setupCode:
      'var d1 = new Dictionary<string, int> { ["a"] = 1, ["b"] = 2 };\nvar d2 = new Dictionary<string, int> { ["b"] = 20, ["c"] = 3 };',
    expected: 'd1 = { ["a"] = 1, ["b"] = 20, ["c"] = 3 }',
    sample: 'foreach (var kvp in d2) d1[kvp.Key] = kvp.Value;',
    hints: [
      'Indexer overwrites existing keys',
      'Alternative: d2.ToList().ForEach(kvp => d1[kvp.Key] = kvp.Value)',
    ],
    tags: ['dictionary', 'merge', 'combine'],
  },
  {
    id: 'cs-dict-288',
    category: 'Dictionary Methods',
    difficulty: 'hard',
    title: 'ConcurrentDictionary GetOrAdd',
    text: 'Get existing value or add new one atomically',
    setup:
      'using System.Collections.Concurrent;\nvar dict = new ConcurrentDictionary<string, int>();',
    setupCode:
      'using System.Collections.Concurrent;\nvar dict = new ConcurrentDictionary<string, int>();',
    expected: 'Returns existing or newly added value',
    sample: 'int value = dict.GetOrAdd("key", k => ExpensiveComputation(k));',
    hints: ['GetOrAdd is thread-safe', 'Factory function only called if key missing'],
    tags: ['dictionary', 'concurrent', 'thread-safe'],
  },
  {
    id: 'cs-dict-289',
    category: 'Dictionary Methods',
    difficulty: 'hard',
    title: 'ConcurrentDictionary AddOrUpdate',
    text: 'Add new value or update existing atomically',
    setup:
      'using System.Collections.Concurrent;\nvar dict = new ConcurrentDictionary<string, int> { ["count"] = 0 };',
    setupCode:
      'using System.Collections.Concurrent;\nvar dict = new ConcurrentDictionary<string, int> { ["count"] = 0 };',
    expected: 'Increments count atomically',
    sample: 'dict.AddOrUpdate("count", 1, (key, oldValue) => oldValue + 1);',
    hints: [
      'AddOrUpdate handles both add and update cases',
      'Second arg is add value, third is update factory',
    ],
    tags: ['dictionary', 'concurrent', 'atomic'],
  },
  {
    id: 'cs-dict-290',
    category: 'Dictionary Methods',
    difficulty: 'easy',
    title: 'Keys to Array',
    text: 'Convert dictionary keys to an array',
    setup:
      'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 1, ["b"] = 2, ["c"] = 3 };',
    setupCode:
      'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 1, ["b"] = 2, ["c"] = 3 };',
    expected: 'string[] { "a", "b", "c" }',
    sample: 'dict.Keys.ToArray()',
    hints: ['Keys returns KeyCollection', 'Use ToArray() or ToList() to materialize'],
    tags: ['dictionary', 'keys', 'convert'],
  },
  {
    id: 'cs-dict-291',
    category: 'Dictionary Methods',
    difficulty: 'easy',
    title: 'Values Sum',
    text: 'Sum all values in the dictionary',
    setup:
      'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 10, ["b"] = 20, ["c"] = 30 };',
    setupCode:
      'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 10, ["b"] = 20, ["c"] = 30 };',
    expected: '60',
    sample: 'dict.Values.Sum()',
    hints: ['Values returns ValueCollection', 'Use LINQ methods on it'],
    tags: ['dictionary', 'values', 'sum'],
  },
  {
    id: 'cs-dict-292',
    category: 'Dictionary Methods',
    difficulty: 'medium',
    title: 'Filter Dictionary',
    text: 'Create new dictionary with only values greater than 5',
    setup:
      'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 3, ["b"] = 8, ["c"] = 2, ["d"] = 10 };',
    setupCode:
      'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 3, ["b"] = 8, ["c"] = 2, ["d"] = 10 };',
    expected: '{ ["b"] = 8, ["d"] = 10 }',
    sample: 'dict.Where(kvp => kvp.Value > 5).ToDictionary(kvp => kvp.Key, kvp => kvp.Value)',
    hints: ['Use Where to filter', 'ToDictionary recreates dictionary'],
    tags: ['dictionary', 'filter', 'linq'],
  },
  {
    id: 'cs-dict-293',
    category: 'Dictionary Methods',
    difficulty: 'medium',
    title: 'Invert Dictionary',
    text: 'Swap keys and values (assuming unique values)',
    setup:
      'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 1, ["b"] = 2, ["c"] = 3 };',
    setupCode:
      'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 1, ["b"] = 2, ["c"] = 3 };',
    expected: '{ [1] = "a", [2] = "b", [3] = "c" }',
    sample: 'dict.ToDictionary(kvp => kvp.Value, kvp => kvp.Key)',
    hints: ['Use ToDictionary to swap key/value', 'Throws if values are not unique'],
    tags: ['dictionary', 'invert', 'transform'],
  },
  {
    id: 'cs-dict-294',
    category: 'Dictionary Methods',
    difficulty: 'hard',
    title: 'Group Values by Key Selector',
    text: 'Group dictionary entries by value range (0-10, 11-20, etc.)',
    setup:
      'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 5, ["b"] = 15, ["c"] = 8, ["d"] = 12 };',
    setupCode:
      'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 5, ["b"] = 15, ["c"] = 8, ["d"] = 12 };',
    expected: '{ 0: ["a", "c"], 1: ["b", "d"] }',
    sample:
      'dict.GroupBy(kvp => kvp.Value / 10).ToDictionary(g => g.Key, g => g.Select(kvp => kvp.Key).ToList())',
    hints: ['Use GroupBy on KeyValuePairs', 'Integer division gives range bucket'],
    tags: ['dictionary', 'groupby', 'transform'],
  },
  {
    id: 'cs-dict-295',
    category: 'Dictionary Methods',
    difficulty: 'easy',
    title: 'Check Key Exists Before Access',
    text: 'Safely get value with fallback pattern',
    setup: 'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 1 };',
    setupCode: 'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 1 };',
    expected: '0 (key "b" not found)',
    sample: 'int value = dict.ContainsKey("b") ? dict["b"] : 0;',
    hints: ['ContainsKey + indexer is common pattern', 'TryGetValue is more efficient'],
    tags: ['dictionary', 'containskey', 'safe'],
  },
  {
    id: 'cs-dict-296',
    category: 'Dictionary Methods',
    difficulty: 'medium',
    title: 'Update Value Conditionally',
    text: 'Increment value if key exists, otherwise add with value 1',
    setup: 'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 5 };',
    setupCode: 'Dictionary<string, int> dict = new Dictionary<string, int> { ["a"] = 5 };',
    expected: 'dict["a"] = 6, dict["b"] = 1',
    sample:
      'dict["a"] = dict.GetValueOrDefault("a") + 1;\ndict["b"] = dict.GetValueOrDefault("b") + 1;',
    hints: ['GetValueOrDefault returns 0 for missing int keys', 'Compact increment pattern'],
    tags: ['dictionary', 'update', 'increment'],
  },
  {
    id: 'cs-dict-297',
    category: 'Dictionary Methods',
    difficulty: 'hard',
    title: 'Dictionary with Value Tuple',
    text: 'Create dictionary with tuple values',
    setup: '// Store name and age as tuple value',
    setupCode: '// Store name and age as tuple value',
    expected: '{ [1] = ("Alice", 30), [2] = ("Bob", 25) }',
    sample:
      'var dict = new Dictionary<int, (string Name, int Age)> { [1] = ("Alice", 30), [2] = ("Bob", 25) };',
    hints: [
      'Tuple values allow multiple related values',
      'Named tuple elements improve readability',
    ],
    tags: ['dictionary', 'tuple', 'value'],
  },
  {
    id: 'cs-dict-298',
    category: 'Dictionary Methods',
    difficulty: 'hard',
    title: 'FrozenDictionary for Read-Only',
    text: 'Create an immutable frozen dictionary for fast lookups',
    setup:
      'using System.Collections.Frozen;\nvar dict = new Dictionary<string, int> { ["a"] = 1, ["b"] = 2 };',
    setupCode:
      'using System.Collections.Frozen;\nvar dict = new Dictionary<string, int> { ["a"] = 1, ["b"] = 2 };',
    expected: 'FrozenDictionary<string, int> with optimized lookups',
    sample: 'FrozenDictionary<string, int> frozen = dict.ToFrozenDictionary();',
    hints: ['FrozenDictionary is immutable and optimized', 'Added in .NET 8'],
    tags: ['dictionary', 'frozen', 'immutable', 'performance'],
  },
  {
    id: 'cs-dict-299',
    category: 'Dictionary Methods',
    difficulty: 'medium',
    title: 'Dictionary from Tuples',
    text: 'Create dictionary from array of tuples',
    setup: 'var tuples = new[] { ("a", 1), ("b", 2), ("c", 3) };',
    setupCode: 'var tuples = new[] { ("a", 1), ("b", 2), ("c", 3) };',
    expected: '{ ["a"] = 1, ["b"] = 2, ["c"] = 3 }',
    sample: 'tuples.ToDictionary(t => t.Item1, t => t.Item2)',
    hints: ['ToDictionary works with any IEnumerable', 'Specify key and value selectors'],
    tags: ['dictionary', 'tuple', 'convert'],
  },

  // ============================================================
  // NEW PROBLEMS - Batch 3: String Methods (25 problems)
  // ============================================================
  {
    id: 'cs-str-300',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'String IsNullOrEmpty',
    text: 'Check if string is null or empty using String.IsNullOrEmpty()',
    setup: 'string? text = "";',
    setupCode: 'string? text = "";',
    expected: 'true',
    sample: 'string.IsNullOrEmpty(text)',
    hints: ['IsNullOrEmpty checks for null or ""', 'Static method on String class'],
    tags: ['string', 'null', 'empty', 'validation'],
  },
  {
    id: 'cs-str-301',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'String IsNullOrWhiteSpace',
    text: 'Check if string is null, empty, or whitespace',
    setup: 'string? text = "   ";',
    setupCode: 'string? text = "   ";',
    expected: 'true',
    sample: 'string.IsNullOrWhiteSpace(text)',
    hints: [
      'IsNullOrWhiteSpace also checks for whitespace-only',
      'More thorough than IsNullOrEmpty',
    ],
    tags: ['string', 'null', 'whitespace', 'validation'],
  },
  {
    id: 'cs-str-302',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'String Concat Multiple',
    text: 'Concatenate three strings using String.Concat()',
    setup: 'string a = "Hello";\nstring b = " ";\nstring c = "World";',
    setupCode: 'string a = "Hello";\nstring b = " ";\nstring c = "World";',
    expected: '"Hello World"',
    sample: 'string.Concat(a, b, c)',
    hints: ['Concat joins strings without separator', 'More efficient than + for multiple strings'],
    tags: ['string', 'concat', 'join'],
  },
  {
    id: 'cs-str-303',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'String Compare',
    text: 'Compare two strings ignoring case',
    setup: 'string a = "Hello";\nstring b = "HELLO";',
    setupCode: 'string a = "Hello";\nstring b = "HELLO";',
    expected: '0 (equal)',
    sample: 'string.Compare(a, b, StringComparison.OrdinalIgnoreCase)',
    hints: [
      'Compare returns 0 if equal, negative if a < b, positive if a > b',
      'Use StringComparison for case options',
    ],
    tags: ['string', 'compare', 'case'],
  },
  {
    id: 'cs-str-304',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'String Remove',
    text: 'Remove characters starting at index 5',
    setup: 'string text = "Hello World";',
    setupCode: 'string text = "Hello World";',
    expected: '"Hello"',
    sample: 'text.Remove(5)',
    hints: [
      'Remove(startIndex) removes from index to end',
      'Remove(startIndex, count) removes count characters',
    ],
    tags: ['string', 'remove', 'substring'],
  },
  {
    id: 'cs-str-305',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'String Insert',
    text: 'Insert "Beautiful " at index 6',
    setup: 'string text = "Hello World";',
    setupCode: 'string text = "Hello World";',
    expected: '"Hello Beautiful World"',
    sample: 'text.Insert(6, "Beautiful ")',
    hints: ['Insert returns new string', 'Original string is unchanged'],
    tags: ['string', 'insert', 'modify'],
  },
  {
    id: 'cs-str-306',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'String ToCharArray',
    text: 'Convert string to character array',
    setup: 'string text = "Hello";',
    setupCode: 'string text = "Hello";',
    expected: "char[] { 'H', 'e', 'l', 'l', 'o' }",
    sample: 'text.ToCharArray()',
    hints: ['ToCharArray creates a new array', 'Useful for character manipulation'],
    tags: ['string', 'tochararray', 'convert'],
  },
  {
    id: 'cs-str-307',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'String from CharArray',
    text: 'Create string from character array',
    setup: "char[] chars = { 'H', 'e', 'l', 'l', 'o' };",
    setupCode: "char[] chars = { 'H', 'e', 'l', 'l', 'o' };",
    expected: '"Hello"',
    sample: 'new string(chars)',
    hints: ['String constructor accepts char array', 'Also accepts char and count'],
    tags: ['string', 'constructor', 'convert'],
  },
  {
    id: 'cs-str-308',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'String Repeat with Constructor',
    text: 'Create a string of 10 asterisks',
    setup: '// Create "*********" (10 asterisks)',
    setupCode: '// Create "*********" (10 asterisks)',
    expected: '"**********"',
    sample: "new string('*', 10)",
    hints: [
      'String constructor accepts char and count',
      'Efficient for repeating single character',
    ],
    tags: ['string', 'repeat', 'constructor'],
  },
  {
    id: 'cs-str-309',
    category: 'String Methods',
    difficulty: 'hard',
    title: 'String Create with SpanAction',
    text: 'Create string using String.Create for performance',
    setup: 'int length = 5;',
    setupCode: 'int length = 5;',
    expected: '"01234"',
    sample:
      "string.Create(length, 0, (span, state) => { for (int i = 0; i < span.Length; i++) span[i] = (char)('0' + i); })",
    hints: [
      'String.Create avoids intermediate allocations',
      'Span allows direct character writing',
    ],
    tags: ['string', 'create', 'performance', 'span'],
  },
  {
    id: 'cs-str-310',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'String ReplaceLineEndings',
    text: 'Normalize all line endings to Environment.NewLine',
    setup: 'string text = "line1\\r\\nline2\\nline3\\rline4";',
    setupCode: 'string text = "line1\\r\\nline2\\nline3\\rline4";',
    expected: 'All line endings normalized',
    sample: 'text.ReplaceLineEndings()',
    hints: ['ReplaceLineEndings normalizes all line ending types', 'Added in .NET 6'],
    tags: ['string', 'lineendings', 'normalize'],
  },
  {
    id: 'cs-str-311',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'String GetHashCode with Comparison',
    text: 'Get case-insensitive hash code for string',
    setup: 'string text = "Hello";',
    setupCode: 'string text = "Hello";',
    expected: 'Same hash as "HELLO"',
    sample: 'text.GetHashCode(StringComparison.OrdinalIgnoreCase)',
    hints: [
      'GetHashCode overload accepts StringComparison',
      'Useful for case-insensitive dictionaries',
    ],
    tags: ['string', 'hashcode', 'comparison'],
  },
  {
    id: 'cs-str-312',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'String Intern',
    text: 'Intern a string for memory efficiency',
    setup: 'string text = new string("Hello".ToCharArray());',
    setupCode: 'string text = new string("Hello".ToCharArray());',
    expected: 'Interned string reference',
    sample: 'string.Intern(text)',
    hints: ['Interning returns shared string reference', 'Useful for repeated strings'],
    tags: ['string', 'intern', 'memory'],
  },
  {
    id: 'cs-str-313',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'String Contains with Comparison',
    text: 'Check if string contains "world" case-insensitively',
    setup: 'string text = "Hello World";',
    setupCode: 'string text = "Hello World";',
    expected: 'true',
    sample: 'text.Contains("world", StringComparison.OrdinalIgnoreCase)',
    hints: [
      'Contains has overload with StringComparison',
      'More efficient than ToLower().Contains()',
    ],
    tags: ['string', 'contains', 'case-insensitive'],
  },
  {
    id: 'cs-str-314',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'String IndexOf with Comparison',
    text: 'Find index of "WORLD" case-insensitively',
    setup: 'string text = "Hello World";',
    setupCode: 'string text = "Hello World";',
    expected: '6',
    sample: 'text.IndexOf("WORLD", StringComparison.OrdinalIgnoreCase)',
    hints: ['IndexOf accepts StringComparison', 'Returns -1 if not found'],
    tags: ['string', 'indexof', 'case-insensitive'],
  },
  {
    id: 'cs-str-315',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'String LastIndexOf',
    text: 'Find the last occurrence of character "o"',
    setup: 'string text = "Hello World";',
    setupCode: 'string text = "Hello World";',
    expected: '7',
    sample: "text.LastIndexOf('o')",
    hints: ['LastIndexOf searches from the end', 'Works with char or string'],
    tags: ['string', 'lastindexof', 'search'],
  },
  {
    id: 'cs-str-316',
    category: 'String Methods',
    difficulty: 'hard',
    title: 'String IndexOfAny',
    text: 'Find first occurrence of any vowel',
    setup: 'string text = "xyz Hello";',
    setupCode: 'string text = "xyz Hello";',
    expected: '5 (index of "e")',
    sample: "text.IndexOfAny(new[] { 'a', 'e', 'i', 'o', 'u' })",
    hints: ['IndexOfAny finds first match from char array', 'Returns -1 if none found'],
    tags: ['string', 'indexofany', 'search'],
  },
  {
    id: 'cs-str-317',
    category: 'String Methods',
    difficulty: 'hard',
    title: 'String LastIndexOfAny',
    text: 'Find last occurrence of any digit',
    setup: 'string text = "abc123def456";',
    setupCode: 'string text = "abc123def456";',
    expected: '11 (index of "6")',
    sample: 'text.LastIndexOfAny("0123456789".ToCharArray())',
    hints: ['LastIndexOfAny searches from end', 'Useful for finding last delimiter'],
    tags: ['string', 'lastindexofany', 'search'],
  },
  {
    id: 'cs-str-318',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'String StartsWith with Comparison',
    text: 'Check if string starts with "HELLO" case-insensitively',
    setup: 'string text = "Hello World";',
    setupCode: 'string text = "Hello World";',
    expected: 'true',
    sample: 'text.StartsWith("HELLO", StringComparison.OrdinalIgnoreCase)',
    hints: ['StartsWith accepts StringComparison', 'OrdinalIgnoreCase is fastest for ASCII'],
    tags: ['string', 'startswith', 'case-insensitive'],
  },
  {
    id: 'cs-str-319',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'String Split with Count',
    text: 'Split string into maximum 2 parts',
    setup: 'string text = "one,two,three,four";',
    setupCode: 'string text = "one,two,three,four";',
    expected: '["one", "two,three,four"]',
    sample: "text.Split(',', 2)",
    hints: ['Split accepts count parameter', 'Remaining text stays in last element'],
    tags: ['string', 'split', 'count'],
  },
  {
    id: 'cs-str-320',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'String Split Multiple Delimiters',
    text: 'Split by comma, semicolon, or space',
    setup: 'string text = "one,two;three four";',
    setupCode: 'string text = "one,two;three four";',
    expected: '["one", "two", "three", "four"]',
    sample: "text.Split(new[] { ',', ';', ' ' })",
    hints: ['Split accepts char array', 'All delimiters treated equally'],
    tags: ['string', 'split', 'multiple'],
  },
  {
    id: 'cs-str-321',
    category: 'String Methods',
    difficulty: 'hard',
    title: 'String Split String Delimiter',
    text: 'Split by string delimiter "||"',
    setup: 'string text = "one||two||three";',
    setupCode: 'string text = "one||two||three";',
    expected: '["one", "two", "three"]',
    sample: 'text.Split("||")',
    hints: ['Split can use string delimiter', 'Avoids issues with single char delimiters'],
    tags: ['string', 'split', 'string-delimiter'],
  },
  {
    id: 'cs-str-322',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'String Normalize',
    text: 'Normalize Unicode string to Form C',
    setup: 'string text = "cafe\\u0301"; // cafe with combining accent',
    setupCode: 'string text = "cafe\\u0301";',
    expected: '"caf\\u00e9" (precomposed form)',
    sample: 'text.Normalize(NormalizationForm.FormC)',
    hints: ['Normalize converts to standard Unicode form', 'FormC is most common'],
    tags: ['string', 'normalize', 'unicode'],
  },
  {
    id: 'cs-str-323',
    category: 'String Methods',
    difficulty: 'hard',
    title: 'Char.IsLetter Check',
    text: 'Count letters in string using Char.IsLetter',
    setup: 'string text = "Hello, World! 123";',
    setupCode: 'string text = "Hello, World! 123";',
    expected: '10',
    sample: 'text.Count(char.IsLetter)',
    hints: ['Char.IsLetter works with LINQ Count', 'Handles Unicode letters'],
    tags: ['string', 'char', 'isletter'],
  },
  {
    id: 'cs-str-324',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'String Enumeration',
    text: 'Iterate over each character with index',
    setup: 'string text = "ABC";',
    setupCode: 'string text = "ABC";',
    expected: 'Prints: 0:A 1:B 2:C',
    sample: 'for (int i = 0; i < text.Length; i++) Console.Write($"{i}:{text[i]} ");',
    hints: ['Strings are indexable', 'Also enumerable with foreach'],
    tags: ['string', 'iterate', 'index'],
  },

  // ============================================================
  // NEW PROBLEMS - Batch 3: Array Operations (25 problems)
  // ============================================================
  {
    id: 'cs-arr-325',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Array Length Property',
    text: 'Get the length of the array',
    setup: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    expected: '5',
    sample: 'numbers.Length',
    hints: ['Length is a property, not method', 'O(1) operation'],
    tags: ['array', 'length', 'property'],
  },
  {
    id: 'cs-arr-326',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Array.Fill',
    text: 'Fill entire array with value 42',
    setup: 'int[] numbers = new int[5];',
    setupCode: 'int[] numbers = new int[5];',
    expected: '{ 42, 42, 42, 42, 42 }',
    sample: 'Array.Fill(numbers, 42);',
    hints: ['Fill sets all elements to value', 'Modifies array in-place'],
    tags: ['array', 'fill', 'initialize'],
  },
  {
    id: 'cs-arr-327',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Array.Fill Range',
    text: 'Fill elements from index 1, count 3 with value 99',
    setup: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    expected: '{ 1, 99, 99, 99, 5 }',
    sample: 'Array.Fill(numbers, 99, 1, 3);',
    hints: ['Fill has overload for range', 'Parameters: array, value, startIndex, count'],
    tags: ['array', 'fill', 'range'],
  },
  {
    id: 'cs-arr-328',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Array.Clear',
    text: 'Clear array elements (set to default)',
    setup: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    expected: '{ 0, 0, 0, 0, 0 }',
    sample: 'Array.Clear(numbers);',
    hints: ['Clear sets elements to default(T)', 'Array length unchanged'],
    tags: ['array', 'clear', 'reset'],
  },
  {
    id: 'cs-arr-329',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Array.BinarySearch',
    text: 'Binary search for value 30 in sorted array',
    setup: 'int[] numbers = { 10, 20, 30, 40, 50 };',
    setupCode: 'int[] numbers = { 10, 20, 30, 40, 50 };',
    expected: '2',
    sample: 'Array.BinarySearch(numbers, 30)',
    hints: ['Array must be sorted', 'Returns negative if not found'],
    tags: ['array', 'binarysearch', 'search'],
  },
  {
    id: 'cs-arr-330',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Array.FindIndex',
    text: 'Find index of first element greater than 25',
    setup: 'int[] numbers = { 10, 20, 30, 40, 50 };',
    setupCode: 'int[] numbers = { 10, 20, 30, 40, 50 };',
    expected: '2',
    sample: 'Array.FindIndex(numbers, x => x > 25)',
    hints: ['FindIndex takes predicate', 'Returns -1 if not found'],
    tags: ['array', 'findindex', 'predicate'],
  },
  {
    id: 'cs-arr-331',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Array.FindLastIndex',
    text: 'Find last index where element is even',
    setup: 'int[] numbers = { 1, 2, 3, 4, 5, 6 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 4, 5, 6 };',
    expected: '5',
    sample: 'Array.FindLastIndex(numbers, x => x % 2 == 0)',
    hints: ['Searches from end', 'Returns -1 if not found'],
    tags: ['array', 'findlastindex', 'predicate'],
  },
  {
    id: 'cs-arr-332',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Array.TrueForAll',
    text: 'Check if all elements are positive',
    setup: 'int[] numbers = { 1, 5, 10, 8, 3 };',
    setupCode: 'int[] numbers = { 1, 5, 10, 8, 3 };',
    expected: 'true',
    sample: 'Array.TrueForAll(numbers, x => x > 0)',
    hints: ['TrueForAll checks all elements', 'Similar to LINQ All()'],
    tags: ['array', 'trueforall', 'predicate'],
  },
  {
    id: 'cs-arr-333',
    category: 'Array Methods',
    difficulty: 'hard',
    title: 'Array.ConvertAll',
    text: 'Convert int array to string array',
    setup: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    expected: 'string[] { "1", "2", "3", "4", "5" }',
    sample: 'Array.ConvertAll(numbers, x => x.ToString())',
    hints: ['ConvertAll transforms all elements', 'Returns new array'],
    tags: ['array', 'convertall', 'transform'],
  },
  {
    id: 'cs-arr-334',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Array.Empty<T>',
    text: 'Get a cached empty array of integers',
    setup: '// Get empty int array without allocation',
    setupCode: '// Get empty int array without allocation',
    expected: 'int[] with Length = 0',
    sample: 'Array.Empty<int>()',
    hints: ['Empty returns cached instance', 'No allocation per call'],
    tags: ['array', 'empty', 'performance'],
  },
  {
    id: 'cs-arr-335',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Array Slice with Range',
    text: 'Get elements from index 1 to 3 (exclusive) using range',
    setup: 'int[] numbers = { 10, 20, 30, 40, 50 };',
    setupCode: 'int[] numbers = { 10, 20, 30, 40, 50 };',
    expected: '{ 20, 30 }',
    sample: 'numbers[1..3]',
    hints: ['Range operator creates new array', 'End index is exclusive'],
    tags: ['array', 'range', 'slice'],
  },
  {
    id: 'cs-arr-336',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Array Index from End',
    text: 'Get second to last element using ^ operator',
    setup: 'int[] numbers = { 10, 20, 30, 40, 50 };',
    setupCode: 'int[] numbers = { 10, 20, 30, 40, 50 };',
    expected: '40',
    sample: 'numbers[^2]',
    hints: ['^n means n from end', '^1 is last element'],
    tags: ['array', 'index', 'fromend'],
  },
  {
    id: 'cs-arr-337',
    category: 'Array Methods',
    difficulty: 'hard',
    title: 'Span<T> from Array',
    text: 'Create a Span<T> view of array for high performance',
    setup: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    expected: 'Span<int> { 1, 2, 3, 4, 5 }',
    sample: 'Span<int> span = numbers.AsSpan();',
    hints: ['AsSpan creates view without copying', 'Span enables safe stack-only operations'],
    tags: ['array', 'span', 'performance'],
  },
  {
    id: 'cs-arr-338',
    category: 'Array Methods',
    difficulty: 'hard',
    title: 'Memory<T> from Array',
    text: 'Create a Memory<T> for async operations',
    setup: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    expected: 'Memory<int> { 1, 2, 3, 4, 5 }',
    sample: 'Memory<int> mem = numbers.AsMemory();',
    hints: ['Memory can be stored on heap', 'Use .Span to get Span for operations'],
    tags: ['array', 'memory', 'async'],
  },
  {
    id: 'cs-arr-339',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Array.Sort with Comparison',
    text: 'Sort strings by length descending',
    setup: 'string[] words = { "cat", "elephant", "dog", "bird" };',
    setupCode: 'string[] words = { "cat", "elephant", "dog", "bird" };',
    expected: '{ "elephant", "bird", "cat", "dog" }',
    sample: 'Array.Sort(words, (a, b) => b.Length.CompareTo(a.Length));',
    hints: ['Sort accepts Comparison<T> delegate', 'Negative = first is less'],
    tags: ['array', 'sort', 'comparison'],
  },
  {
    id: 'cs-arr-340',
    category: 'Array Methods',
    difficulty: 'hard',
    title: 'Array.Sort Two Arrays',
    text: 'Sort keys and keep values synchronized',
    setup: 'int[] keys = { 3, 1, 2 };\nstring[] values = { "three", "one", "two" };',
    setupCode: 'int[] keys = { 3, 1, 2 };\nstring[] values = { "three", "one", "two" };',
    expected: 'keys: { 1, 2, 3 }, values: { "one", "two", "three" }',
    sample: 'Array.Sort(keys, values);',
    hints: ['Sort reorders both arrays', 'Second array follows first'],
    tags: ['array', 'sort', 'parallel'],
  },
  {
    id: 'cs-arr-341',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Multidimensional Array',
    text: 'Create and access 2D array',
    setup: '// Create 2x3 array',
    setupCode: '// Create 2x3 array',
    expected: 'Access element at row 1, col 2',
    sample: 'int[,] matrix = new int[2, 3] { { 1, 2, 3 }, { 4, 5, 6 } };\nint val = matrix[1, 2];',
    hints: ['2D arrays use [,] syntax', 'Access with [row, col]'],
    tags: ['array', 'multidimensional', '2d'],
  },
  {
    id: 'cs-arr-342',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Jagged Array',
    text: 'Create and access jagged array',
    setup: '// Create jagged array with varying row lengths',
    setupCode: '// Create jagged array with varying row lengths',
    expected: 'Access element at row 1, col 2',
    sample:
      'int[][] jagged = new int[][] { new[] { 1, 2 }, new[] { 3, 4, 5 }, new[] { 6 } };\nint val = jagged[1][2];',
    hints: ['Jagged arrays are arrays of arrays', 'Rows can have different lengths'],
    tags: ['array', 'jagged', 'nested'],
  },
  {
    id: 'cs-arr-343',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Array.GetLength for Dimensions',
    text: 'Get length of each dimension in 2D array',
    setup: 'int[,] matrix = new int[3, 4];',
    setupCode: 'int[,] matrix = new int[3, 4];',
    expected: 'Rows: 3, Cols: 4',
    sample: 'int rows = matrix.GetLength(0);\nint cols = matrix.GetLength(1);',
    hints: ['GetLength(dimension) returns size', 'Dimension 0 is first index'],
    tags: ['array', 'getlength', 'dimensions'],
  },
  {
    id: 'cs-arr-344',
    category: 'Array Methods',
    difficulty: 'hard',
    title: 'Array.CreateInstance Dynamic',
    text: 'Create array of unknown type at runtime',
    setup: 'Type elementType = typeof(int);',
    setupCode: 'Type elementType = typeof(int);',
    expected: 'int[] with 5 elements',
    sample: 'Array arr = Array.CreateInstance(elementType, 5);',
    hints: ['CreateInstance for dynamic arrays', 'Returns Array base type'],
    tags: ['array', 'createinstance', 'reflection'],
  },
  {
    id: 'cs-arr-345',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Buffer.BlockCopy',
    text: 'Copy bytes between arrays efficiently',
    setup: 'int[] src = { 1, 2, 3 };\nint[] dst = new int[3];',
    setupCode: 'int[] src = { 1, 2, 3 };\nint[] dst = new int[3];',
    expected: 'dst = { 1, 2, 3 }',
    sample: 'Buffer.BlockCopy(src, 0, dst, 0, src.Length * sizeof(int));',
    hints: ['BlockCopy works with bytes', 'Faster than Array.Copy for primitives'],
    tags: ['array', 'blockcopy', 'performance'],
  },
  {
    id: 'cs-arr-346',
    category: 'Array Methods',
    difficulty: 'hard',
    title: 'ArraySegment<T>',
    text: 'Create a view of array portion without copying',
    setup: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    setupCode: 'int[] numbers = { 1, 2, 3, 4, 5 };',
    expected: 'ArraySegment viewing { 2, 3, 4 }',
    sample: 'ArraySegment<int> segment = new ArraySegment<int>(numbers, 1, 3);',
    hints: ['ArraySegment is lightweight view', 'Does not copy data'],
    tags: ['array', 'arraysegment', 'view'],
  },
  {
    id: 'cs-arr-347',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Array Initialization',
    text: 'Initialize array with specific values',
    setup: '// Three ways to initialize',
    setupCode: '// Three ways to initialize',
    expected: '{ 1, 2, 3 }',
    sample:
      'int[] a = { 1, 2, 3 };\nint[] b = new[] { 1, 2, 3 };\nint[] c = new int[] { 1, 2, 3 };',
    hints: ['Multiple syntax options', 'Compiler infers type from values'],
    tags: ['array', 'initialization', 'syntax'],
  },
  {
    id: 'cs-arr-348',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Array.ConstrainedCopy',
    text: 'Copy with guaranteed atomicity on failure',
    setup: 'int[] src = { 1, 2, 3, 4, 5 };\nint[] dst = new int[5];',
    setupCode: 'int[] src = { 1, 2, 3, 4, 5 };\nint[] dst = new int[5];',
    expected: 'dst = { 1, 2, 3, 4, 5 }',
    sample: 'Array.ConstrainedCopy(src, 0, dst, 0, 5);',
    hints: ['ConstrainedCopy is atomic', 'Either copies all or none'],
    tags: ['array', 'constrainedcopy', 'atomic'],
  },
  {
    id: 'cs-arr-349',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Array Clone',
    text: 'Create shallow copy of array',
    setup: 'int[] original = { 1, 2, 3 };',
    setupCode: 'int[] original = { 1, 2, 3 };',
    expected: 'New array { 1, 2, 3 }',
    sample: 'int[] copy = (int[])original.Clone();',
    hints: ['Clone creates shallow copy', 'Cast required as returns object'],
    tags: ['array', 'clone', 'copy'],
  },

  // ============================================================
  // NEW PROBLEMS - Batch 4: Async/Await (30 problems)
  // ============================================================
  {
    id: 'cs-async-350',
    category: 'Async/Await',
    difficulty: 'easy',
    title: 'Basic Async Method',
    text: 'Create an async method that returns a string',
    setup: '// Define async method',
    setupCode: '// Define async method',
    expected: 'Task<string> that completes with "Hello"',
    sample: 'async Task<string> GetMessageAsync() => await Task.FromResult("Hello");',
    hints: ['async methods return Task or Task<T>', 'await unwraps the Task result'],
    tags: ['async', 'task', 'basic'],
  },
  {
    id: 'cs-async-351',
    category: 'Async/Await',
    difficulty: 'easy',
    title: 'Task.Delay',
    text: 'Asynchronously wait for 1 second',
    setup: '// Wait asynchronously',
    setupCode: '// Wait asynchronously',
    expected: 'Completes after 1 second',
    sample: 'await Task.Delay(1000);',
    hints: ['Task.Delay is async alternative to Thread.Sleep', 'Does not block thread'],
    tags: ['async', 'delay', 'wait'],
  },
  {
    id: 'cs-async-352',
    category: 'Async/Await',
    difficulty: 'easy',
    title: 'Task.FromResult',
    text: 'Create completed task with value 42',
    setup: '// Create pre-completed task',
    setupCode: '// Create pre-completed task',
    expected: 'Task<int> already completed with 42',
    sample: 'Task<int> task = Task.FromResult(42);',
    hints: ['FromResult creates completed task', 'Useful for cached or sync values'],
    tags: ['async', 'fromresult', 'task'],
  },
  {
    id: 'cs-async-353',
    category: 'Async/Await',
    difficulty: 'easy',
    title: 'Task.CompletedTask',
    text: 'Return a completed Task (void equivalent)',
    setup: '// Return completed non-generic task',
    setupCode: '// Return completed non-generic task',
    expected: 'Task that is already completed',
    sample: 'return Task.CompletedTask;',
    hints: ['CompletedTask is cached singleton', 'Use for async void-like returns'],
    tags: ['async', 'completedtask', 'task'],
  },
  {
    id: 'cs-async-354',
    category: 'Async/Await',
    difficulty: 'medium',
    title: 'Task.WhenAll',
    text: 'Wait for multiple tasks to complete',
    setup:
      'Task<int> t1 = Task.FromResult(1);\nTask<int> t2 = Task.FromResult(2);\nTask<int> t3 = Task.FromResult(3);',
    setupCode:
      'Task<int> t1 = Task.FromResult(1);\nTask<int> t2 = Task.FromResult(2);\nTask<int> t3 = Task.FromResult(3);',
    expected: 'int[] { 1, 2, 3 }',
    sample: 'int[] results = await Task.WhenAll(t1, t2, t3);',
    hints: ['WhenAll runs tasks concurrently', 'Returns array of results'],
    tags: ['async', 'whenall', 'parallel'],
  },
  {
    id: 'cs-async-355',
    category: 'Async/Await',
    difficulty: 'medium',
    title: 'Task.WhenAny',
    text: 'Wait for first task to complete',
    setup:
      'Task<int> slow = Task.Delay(1000).ContinueWith(_ => 1);\nTask<int> fast = Task.FromResult(2);',
    setupCode:
      'Task<int> slow = Task.Delay(1000).ContinueWith(_ => 1);\nTask<int> fast = Task.FromResult(2);',
    expected: 'Task that completed first',
    sample: 'Task<int> winner = await Task.WhenAny(slow, fast);',
    hints: ['WhenAny returns first completed task', 'Await result again to get value'],
    tags: ['async', 'whenany', 'race'],
  },
  {
    id: 'cs-async-356',
    category: 'Async/Await',
    difficulty: 'medium',
    title: 'CancellationToken',
    text: 'Cancel async operation using CancellationToken',
    setup: 'CancellationTokenSource cts = new CancellationTokenSource();',
    setupCode: 'CancellationTokenSource cts = new CancellationTokenSource();',
    expected: 'Task cancelled when token triggered',
    sample: 'await Task.Delay(5000, cts.Token);',
    hints: ['Pass token to async methods', 'cts.Cancel() triggers cancellation'],
    tags: ['async', 'cancellation', 'token'],
  },
  {
    id: 'cs-async-357',
    category: 'Async/Await',
    difficulty: 'medium',
    title: 'CancellationToken ThrowIfCancellationRequested',
    text: 'Check and throw if cancellation requested',
    setup: 'CancellationToken token = ...;',
    setupCode: 'CancellationToken token = ...;',
    expected: 'Throws OperationCanceledException if cancelled',
    sample: 'token.ThrowIfCancellationRequested();',
    hints: ['Explicit cancellation check', 'Throws OperationCanceledException'],
    tags: ['async', 'cancellation', 'throw'],
  },
  {
    id: 'cs-async-358',
    category: 'Async/Await',
    difficulty: 'medium',
    title: 'ConfigureAwait(false)',
    text: 'Avoid capturing synchronization context',
    setup: '// In library code',
    setupCode: '// In library code',
    expected: 'Continues on thread pool thread',
    sample: 'await SomeAsyncOperation().ConfigureAwait(false);',
    hints: ['ConfigureAwait(false) avoids context capture', 'Use in library code, not UI code'],
    tags: ['async', 'configureawait', 'context'],
  },
  {
    id: 'cs-async-359',
    category: 'Async/Await',
    difficulty: 'hard',
    title: 'ValueTask for Performance',
    text: 'Return ValueTask for potentially synchronous result',
    setup: 'private int _cached = 42;',
    setupCode: 'private int _cached = 42;',
    expected: 'ValueTask<int> avoiding allocation when cached',
    sample:
      'ValueTask<int> GetValueAsync() => _cached != 0 ? new ValueTask<int>(_cached) : new ValueTask<int>(LoadAsync());',
    hints: [
      'ValueTask avoids allocation for sync results',
      'Do not await ValueTask multiple times',
    ],
    tags: ['async', 'valuetask', 'performance'],
  },
  {
    id: 'cs-async-360',
    category: 'Async/Await',
    difficulty: 'hard',
    title: 'IAsyncEnumerable',
    text: 'Create async stream that yields values',
    setup: '// Async generator method',
    setupCode: '// Async generator method',
    expected: 'IAsyncEnumerable<int> yielding 1, 2, 3',
    sample:
      'async IAsyncEnumerable<int> GetNumbersAsync() { for (int i = 1; i <= 3; i++) { await Task.Delay(100); yield return i; } }',
    hints: ['IAsyncEnumerable for async streams', 'Use yield return with async'],
    tags: ['async', 'iasyncenumerable', 'stream'],
  },
  {
    id: 'cs-async-361',
    category: 'Async/Await',
    difficulty: 'hard',
    title: 'await foreach',
    text: 'Consume async stream with await foreach',
    setup: 'IAsyncEnumerable<int> numbers = GetNumbersAsync();',
    setupCode: 'IAsyncEnumerable<int> numbers = GetNumbersAsync();',
    expected: 'Processes each value as available',
    sample: 'await foreach (int n in numbers) { Console.WriteLine(n); }',
    hints: ['await foreach consumes async streams', 'Awaits each MoveNextAsync'],
    tags: ['async', 'awaitforeach', 'stream'],
  },
  {
    id: 'cs-async-362',
    category: 'Async/Await',
    difficulty: 'medium',
    title: 'Task.Run for CPU Work',
    text: 'Run CPU-bound work on thread pool',
    setup: 'int ComputeExpensive() => 42;',
    setupCode: 'int ComputeExpensive() => 42;',
    expected: 'Task running on thread pool',
    sample: 'int result = await Task.Run(() => ComputeExpensive());',
    hints: ['Task.Run for CPU-bound work', 'Moves work off UI thread'],
    tags: ['async', 'taskrun', 'threadpool'],
  },
  {
    id: 'cs-async-363',
    category: 'Async/Await',
    difficulty: 'hard',
    title: 'SemaphoreSlim for Throttling',
    text: 'Limit concurrent async operations to 3',
    setup: 'SemaphoreSlim semaphore = new SemaphoreSlim(3);',
    setupCode: 'SemaphoreSlim semaphore = new SemaphoreSlim(3);',
    expected: 'Max 3 concurrent operations',
    sample:
      'await semaphore.WaitAsync();\ntry { await DoWorkAsync(); }\nfinally { semaphore.Release(); }',
    hints: ['SemaphoreSlim has async wait', 'Always release in finally'],
    tags: ['async', 'semaphore', 'throttle'],
  },
  {
    id: 'cs-async-364',
    category: 'Async/Await',
    difficulty: 'hard',
    title: 'AsyncLazy<T> Pattern',
    text: 'Implement lazy async initialization',
    setup: '// Lazy async loading',
    setupCode: '// Lazy async loading',
    expected: 'Value computed once on first await',
    sample:
      'Lazy<Task<int>> lazy = new Lazy<Task<int>>(() => ComputeAsync());\nint value = await lazy.Value;',
    hints: ['Lazy<Task<T>> for async lazy', 'Task cached after first creation'],
    tags: ['async', 'lazy', 'initialization'],
  },
  {
    id: 'cs-async-365',
    category: 'Async/Await',
    difficulty: 'medium',
    title: 'Task Exception Handling',
    text: 'Handle exception from async task',
    setup: 'Task<int> task = Task.FromException<int>(new InvalidOperationException());',
    setupCode: 'Task<int> task = Task.FromException<int>(new InvalidOperationException());',
    expected: 'Catch the exception',
    sample:
      'try { int result = await task; } catch (InvalidOperationException ex) { Console.WriteLine(ex.Message); }',
    hints: ['await throws the task exception', 'try-catch works normally'],
    tags: ['async', 'exception', 'handling'],
  },
  {
    id: 'cs-async-366',
    category: 'Async/Await',
    difficulty: 'hard',
    title: 'Task.WhenAll Exception Aggregation',
    text: 'Handle multiple task exceptions',
    setup:
      'Task t1 = Task.FromException(new ArgumentException());\nTask t2 = Task.FromException(new InvalidOperationException());',
    setupCode:
      'Task t1 = Task.FromException(new ArgumentException());\nTask t2 = Task.FromException(new InvalidOperationException());',
    expected: 'Catch AggregateException with all errors',
    sample:
      'try { await Task.WhenAll(t1, t2); } catch { var exceptions = Task.WhenAll(t1, t2).Exception?.InnerExceptions; }',
    hints: ['WhenAll throws first exception on await', 'Access .Exception for all'],
    tags: ['async', 'exception', 'aggregate'],
  },
  {
    id: 'cs-async-367',
    category: 'Async/Await',
    difficulty: 'easy',
    title: 'Async Lambda',
    text: 'Create async lambda expression',
    setup: 'Func<Task<int>> asyncFunc;',
    setupCode: 'Func<Task<int>> asyncFunc;',
    expected: 'Lambda that returns Task<int>',
    sample: 'asyncFunc = async () => { await Task.Delay(100); return 42; };',
    hints: ['Prefix lambda with async', 'Works with Func<Task<T>>'],
    tags: ['async', 'lambda', 'func'],
  },
  {
    id: 'cs-async-368',
    category: 'Async/Await',
    difficulty: 'medium',
    title: 'Timeout with CancellationTokenSource',
    text: 'Create cancellation token with 5 second timeout',
    setup: '// Create auto-cancelling token',
    setupCode: '// Create auto-cancelling token',
    expected: 'Token cancels after 5 seconds',
    sample: 'using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(5));',
    hints: ['CancellationTokenSource accepts timeout', 'Cancels automatically'],
    tags: ['async', 'timeout', 'cancellation'],
  },
  {
    id: 'cs-async-369',
    category: 'Async/Await',
    difficulty: 'hard',
    title: 'Channel for Producer-Consumer',
    text: 'Create bounded channel for async producer-consumer',
    setup: 'using System.Threading.Channels;',
    setupCode: 'using System.Threading.Channels;',
    expected: 'Channel with max 10 items',
    sample:
      'Channel<int> channel = Channel.CreateBounded<int>(10);\nawait channel.Writer.WriteAsync(42);\nint value = await channel.Reader.ReadAsync();',
    hints: ['Channels are async-friendly queues', 'Bounded channels apply backpressure'],
    tags: ['async', 'channel', 'producer-consumer'],
  },
  {
    id: 'cs-async-370',
    category: 'Async/Await',
    difficulty: 'medium',
    title: 'Task.Yield',
    text: 'Yield control to allow other work to proceed',
    setup: '// In a tight loop',
    setupCode: '// In a tight loop',
    expected: 'Allows other async work to run',
    sample: 'await Task.Yield();',
    hints: ['Yield forces return to scheduler', 'Useful to prevent starvation'],
    tags: ['async', 'yield', 'scheduling'],
  },
  {
    id: 'cs-async-371',
    category: 'Async/Await',
    difficulty: 'hard',
    title: 'TaskCompletionSource',
    text: 'Create manually controlled task',
    setup: 'var tcs = new TaskCompletionSource<int>();',
    setupCode: 'var tcs = new TaskCompletionSource<int>();',
    expected: 'Task that completes when SetResult called',
    sample: 'Task<int> task = tcs.Task;\n// Later: tcs.SetResult(42);',
    hints: ['TaskCompletionSource wraps callback in Task', 'SetResult/SetException/SetCanceled'],
    tags: ['async', 'taskcompletionsource', 'manual'],
  },
  {
    id: 'cs-async-372',
    category: 'Async/Await',
    difficulty: 'easy',
    title: 'Async Main Method',
    text: 'Define async Main entry point',
    setup: '// Program.cs entry point',
    setupCode: '// Program.cs entry point',
    expected: 'Async entry point',
    sample: 'static async Task Main(string[] args) { await RunAsync(); }',
    hints: ['Main can return Task', 'Enables top-level await'],
    tags: ['async', 'main', 'entrypoint'],
  },
  {
    id: 'cs-async-373',
    category: 'Async/Await',
    difficulty: 'medium',
    title: 'Parallel.ForEachAsync',
    text: 'Process items concurrently with degree of parallelism',
    setup: 'int[] items = { 1, 2, 3, 4, 5 };',
    setupCode: 'int[] items = { 1, 2, 3, 4, 5 };',
    expected: 'Processes items in parallel',
    sample:
      'await Parallel.ForEachAsync(items, new ParallelOptions { MaxDegreeOfParallelism = 3 }, async (item, ct) => { await ProcessAsync(item); });',
    hints: ['ForEachAsync is async parallel loop', 'Control concurrency with options'],
    tags: ['async', 'parallel', 'foreach'],
  },
  {
    id: 'cs-async-374',
    category: 'Async/Await',
    difficulty: 'hard',
    title: 'IAsyncDisposable',
    text: 'Implement async disposable pattern',
    setup: 'class AsyncResource : IAsyncDisposable',
    setupCode: 'class AsyncResource : IAsyncDisposable',
    expected: 'Async cleanup on dispose',
    sample:
      'public async ValueTask DisposeAsync() { await CleanupAsync(); GC.SuppressFinalize(this); }',
    hints: ['IAsyncDisposable for async cleanup', 'Use await using for consumption'],
    tags: ['async', 'iasyncdisposable', 'dispose'],
  },
  {
    id: 'cs-async-375',
    category: 'Async/Await',
    difficulty: 'medium',
    title: 'await using',
    text: 'Dispose async resource automatically',
    setup: 'IAsyncDisposable resource = new AsyncResource();',
    setupCode: 'IAsyncDisposable resource = new AsyncResource();',
    expected: 'DisposeAsync called at end of scope',
    sample: 'await using (var resource = new AsyncResource()) { await resource.UseAsync(); }',
    hints: ['await using for IAsyncDisposable', 'Calls DisposeAsync at scope end'],
    tags: ['async', 'awaitusing', 'dispose'],
  },
  {
    id: 'cs-async-376',
    category: 'Async/Await',
    difficulty: 'hard',
    title: 'CancellationToken.Register',
    text: 'Register callback when cancellation occurs',
    setup: 'CancellationToken token = ...;',
    setupCode: 'CancellationToken token = ...;',
    expected: 'Callback invoked on cancellation',
    sample: 'token.Register(() => Console.WriteLine("Cancelled!"));',
    hints: ['Register for cleanup on cancel', 'Returns registration for disposal'],
    tags: ['async', 'cancellation', 'callback'],
  },
  {
    id: 'cs-async-377',
    category: 'Async/Await',
    difficulty: 'hard',
    title: 'LinkedTokenSource',
    text: 'Combine multiple cancellation tokens',
    setup: 'CancellationToken token1 = ...;\nCancellationToken token2 = ...;',
    setupCode: 'CancellationToken token1 = ...;\nCancellationToken token2 = ...;',
    expected: 'Token cancelled if either source cancels',
    sample:
      'using var linked = CancellationTokenSource.CreateLinkedTokenSource(token1, token2);\nCancellationToken combined = linked.Token;',
    hints: ['Linked source cancelled by any input', 'Dispose the linked source'],
    tags: ['async', 'cancellation', 'linked'],
  },
  {
    id: 'cs-async-378',
    category: 'Async/Await',
    difficulty: 'medium',
    title: 'WaitAsync with Timeout',
    text: 'Wait for task with timeout',
    setup: 'Task<int> longTask = ...;',
    setupCode: 'Task<int> longTask = ...;',
    expected: 'Throws TimeoutException if exceeds timeout',
    sample: 'int result = await longTask.WaitAsync(TimeSpan.FromSeconds(5));',
    hints: ['WaitAsync adds timeout to any task', 'Added in .NET 6'],
    tags: ['async', 'waitasync', 'timeout'],
  },
  {
    id: 'cs-async-379',
    category: 'Async/Await',
    difficulty: 'hard',
    title: 'AsyncLocal for Ambient Data',
    text: 'Store ambient data across async flow',
    setup: 'static AsyncLocal<string> _user = new AsyncLocal<string>();',
    setupCode: 'static AsyncLocal<string> _user = new AsyncLocal<string>();',
    expected: 'Value flows through async calls',
    sample: '_user.Value = "Alice";\nawait SomeAsync(); // _user.Value still "Alice"',
    hints: ['AsyncLocal flows with execution context', 'Each async branch gets own copy'],
    tags: ['async', 'asynclocal', 'ambient'],
  },

  // ============================================================
  // NEW PROBLEMS - Batch 4: Pattern Matching (25 problems)
  // ============================================================
  {
    id: 'cs-pattern-380',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Type Pattern',
    text: 'Check if object is string and get its value',
    setup: 'object obj = "Hello";',
    setupCode: 'object obj = "Hello";',
    expected: 'true, s = "Hello"',
    sample: 'if (obj is string s) { Console.WriteLine(s); }',
    hints: ['Type pattern declares variable', 'Variable in scope when matched'],
    tags: ['pattern', 'type', 'is'],
  },
  {
    id: 'cs-pattern-381',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Constant Pattern',
    text: 'Check if value equals specific constant',
    setup: 'int? value = 42;',
    setupCode: 'int? value = 42;',
    expected: 'true',
    sample: 'bool is42 = value is 42;',
    hints: ['Constant pattern checks equality', 'Works with null too'],
    tags: ['pattern', 'constant', 'is'],
  },
  {
    id: 'cs-pattern-382',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Null Pattern',
    text: 'Check if value is null',
    setup: 'string? name = null;',
    setupCode: 'string? name = null;',
    expected: 'true',
    sample: 'bool isNull = name is null;',
    hints: ['is null is null-check pattern', 'Safer than == null'],
    tags: ['pattern', 'null', 'is'],
  },
  {
    id: 'cs-pattern-383',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Not Pattern',
    text: 'Check if value is not null',
    setup: 'string? name = "Alice";',
    setupCode: 'string? name = "Alice";',
    expected: 'true',
    sample: 'if (name is not null) { Console.WriteLine(name); }',
    hints: ['not negates any pattern', 'Cleaner than != null'],
    tags: ['pattern', 'not', 'null'],
  },
  {
    id: 'cs-pattern-384',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Switch Expression',
    text: 'Convert grade letter to GPA using switch expression',
    setup: "char grade = 'B';",
    setupCode: "char grade = 'B';",
    expected: '3.0',
    sample:
      "double gpa = grade switch { 'A' => 4.0, 'B' => 3.0, 'C' => 2.0, 'D' => 1.0, _ => 0.0 };",
    hints: ['Switch expression uses =>', '_ is discard pattern'],
    tags: ['pattern', 'switch', 'expression'],
  },
  {
    id: 'cs-pattern-385',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Relational Pattern',
    text: 'Categorize age using relational patterns',
    setup: 'int age = 25;',
    setupCode: 'int age = 25;',
    expected: '"Adult"',
    sample:
      'string category = age switch { < 13 => "Child", < 20 => "Teen", < 65 => "Adult", _ => "Senior" };',
    hints: ['Relational patterns: <, >, <=, >=', 'Order matters for overlapping'],
    tags: ['pattern', 'relational', 'switch'],
  },
  {
    id: 'cs-pattern-386',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'And Pattern',
    text: 'Check if number is between 1 and 100',
    setup: 'int n = 50;',
    setupCode: 'int n = 50;',
    expected: 'true',
    sample: 'bool inRange = n is >= 1 and <= 100;',
    hints: ['and combines patterns', 'Both must match'],
    tags: ['pattern', 'and', 'combinatorial'],
  },
  {
    id: 'cs-pattern-387',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Or Pattern',
    text: 'Check if day is weekend',
    setup: 'DayOfWeek day = DayOfWeek.Saturday;',
    setupCode: 'DayOfWeek day = DayOfWeek.Saturday;',
    expected: 'true',
    sample: 'bool isWeekend = day is DayOfWeek.Saturday or DayOfWeek.Sunday;',
    hints: ['or combines patterns', 'Either can match'],
    tags: ['pattern', 'or', 'combinatorial'],
  },
  {
    id: 'cs-pattern-388',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Property Pattern',
    text: 'Check if person is adult with property pattern',
    setup: 'var person = new { Name = "Alice", Age = 25 };',
    setupCode: 'var person = new { Name = "Alice", Age = 25 };',
    expected: 'true',
    sample: 'bool isAdult = person is { Age: >= 18 };',
    hints: ['Property pattern checks properties', 'Can nest patterns'],
    tags: ['pattern', 'property', 'object'],
  },
  {
    id: 'cs-pattern-389',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Nested Property Pattern',
    text: 'Check nested properties',
    setup: 'var order = new { Customer = new { Country = "USA" }, Total = 100m };',
    setupCode: 'var order = new { Customer = new { Country = "USA" }, Total = 100m };',
    expected: 'true',
    sample: 'bool isUSOrder = order is { Customer: { Country: "USA" }, Total: > 50 };',
    hints: ['Nest property patterns', 'Check multiple levels'],
    tags: ['pattern', 'property', 'nested'],
  },
  {
    id: 'cs-pattern-390',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Positional Pattern (Deconstruct)',
    text: 'Match tuple using positional pattern',
    setup: 'var point = (3, 4);',
    setupCode: 'var point = (3, 4);',
    expected: '"Right quadrant"',
    sample:
      'string quadrant = point switch { (> 0, > 0) => "Right", (< 0, > 0) => "Left", _ => "Axis" };',
    hints: ['Positional matches tuple elements', 'Works with Deconstruct'],
    tags: ['pattern', 'positional', 'tuple'],
  },
  {
    id: 'cs-pattern-391',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'List Pattern',
    text: 'Match array by its elements',
    setup: 'int[] arr = { 1, 2, 3 };',
    setupCode: 'int[] arr = { 1, 2, 3 };',
    expected: '"Starts with 1, ends with 3"',
    sample: 'string desc = arr switch { [1, .., 3] => "1 to 3", [1, 2] => "1,2", _ => "other" };',
    hints: ['List patterns match collections', '.. is slice pattern'],
    tags: ['pattern', 'list', 'collection'],
  },
  {
    id: 'cs-pattern-392',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Slice Pattern',
    text: 'Capture middle elements with slice pattern',
    setup: 'int[] arr = { 1, 2, 3, 4, 5 };',
    setupCode: 'int[] arr = { 1, 2, 3, 4, 5 };',
    expected: 'first = 1, middle = [2,3,4], last = 5',
    sample: 'if (arr is [var first, .. var middle, var last]) { /* use first, middle, last */ }',
    hints: ['..var captures slice', 'Works with arrays and lists'],
    tags: ['pattern', 'slice', 'capture'],
  },
  {
    id: 'cs-pattern-393',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'When Guard',
    text: 'Add condition to switch pattern with when',
    setup: 'int n = 15;',
    setupCode: 'int n = 15;',
    expected: '"Divisible by both"',
    sample:
      'string result = n switch { _ when n % 3 == 0 && n % 5 == 0 => "FizzBuzz", _ when n % 3 == 0 => "Fizz", _ when n % 5 == 0 => "Buzz", _ => n.ToString() };',
    hints: ['when adds guard condition', 'Evaluated after pattern match'],
    tags: ['pattern', 'when', 'guard'],
  },
  {
    id: 'cs-pattern-394',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Var Pattern Capture',
    text: 'Capture any value using var pattern',
    setup: 'object obj = 42;',
    setupCode: 'object obj = 42;',
    expected: 'Captures value regardless of type',
    sample: 'if (obj is var value) { Console.WriteLine(value); }',
    hints: ['var pattern always matches', 'Useful with when guards'],
    tags: ['pattern', 'var', 'capture'],
  },
  {
    id: 'cs-pattern-395',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Discard Pattern',
    text: 'Ignore values in pattern',
    setup: 'var point = (1, 2, 3);',
    setupCode: 'var point = (1, 2, 3);',
    expected: 'Match any middle value',
    sample: 'bool match = point is (1, _, 3);',
    hints: ['_ discards value', 'Useful to ignore positions'],
    tags: ['pattern', 'discard', 'ignore'],
  },
  {
    id: 'cs-pattern-396',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Extended Property Pattern',
    text: 'Access nested property with dot notation',
    setup: 'var data = new { Info = new { Name = "Test" } };',
    setupCode: 'var data = new { Info = new { Name = "Test" } };',
    expected: 'true',
    sample: 'bool match = data is { Info.Name: "Test" };',
    hints: ['Extended property uses dot notation', 'Cleaner than nested braces'],
    tags: ['pattern', 'property', 'extended'],
  },
  {
    id: 'cs-pattern-397',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Switch on Type',
    text: 'Handle different types in switch expression',
    setup: 'object obj = 42;',
    setupCode: 'object obj = 42;',
    expected: '"Integer: 42"',
    sample:
      'string result = obj switch { int i => $"Integer: {i}", string s => $"String: {s}", _ => "Unknown" };',
    hints: ['Type pattern in switch', 'Variable declared for each arm'],
    tags: ['pattern', 'switch', 'type'],
  },
  {
    id: 'cs-pattern-398',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Pattern in Condition',
    text: 'Use pattern in if condition',
    setup: 'int? value = 10;',
    setupCode: 'int? value = 10;',
    expected: 'Prints 10',
    sample: 'if (value is int v) { Console.WriteLine(v); }',
    hints: ['Pattern in if condition', 'Unwraps nullable'],
    tags: ['pattern', 'if', 'nullable'],
  },
  {
    id: 'cs-pattern-399',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Recursive Pattern',
    text: 'Match deeply nested structure',
    setup:
      'var tree = new { Value = 1, Left = new { Value = 2, Left = (object?)null, Right = (object?)null }, Right = (object?)null };',
    setupCode:
      'var tree = new { Value = 1, Left = new { Value = 2, Left = (object?)null, Right = (object?)null }, Right = (object?)null };',
    expected: 'Match tree with left child value 2',
    sample: 'bool match = tree is { Value: 1, Left: { Value: 2 } };',
    hints: ['Recursive patterns for trees', 'Combine with type patterns'],
    tags: ['pattern', 'recursive', 'tree'],
  },
  {
    id: 'cs-pattern-400',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'String Pattern',
    text: 'Match strings with patterns',
    setup: 'string? text = "hello";',
    setupCode: 'string? text = "hello";',
    expected: '"5 characters"',
    sample:
      'string result = text switch { null => "null", "" => "empty", { Length: var len } => $"{len} characters" };',
    hints: ['String is object with properties', 'Can match Length property'],
    tags: ['pattern', 'string', 'property'],
  },
  {
    id: 'cs-pattern-401',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'List Length Pattern',
    text: 'Match array by length',
    setup: 'int[] arr = { 1, 2, 3 };',
    setupCode: 'int[] arr = { 1, 2, 3 };',
    expected: '"Three elements"',
    sample:
      'string desc = arr switch { [] => "Empty", [_] => "One", [_, _] => "Two", [_, _, _] => "Three", _ => "Many" };',
    hints: ['List pattern matches length', 'Use _ for any element'],
    tags: ['pattern', 'list', 'length'],
  },
  {
    id: 'cs-pattern-402',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Enum Pattern',
    text: 'Match enum values',
    setup: 'ConsoleColor color = ConsoleColor.Red;',
    setupCode: 'ConsoleColor color = ConsoleColor.Red;',
    expected: '"#FF0000"',
    sample:
      'string hex = color switch { ConsoleColor.Red => "#FF0000", ConsoleColor.Green => "#00FF00", ConsoleColor.Blue => "#0000FF", _ => "#000000" };',
    hints: ['Enum values work in patterns', 'Use _ for default'],
    tags: ['pattern', 'enum', 'switch'],
  },
  {
    id: 'cs-pattern-403',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Tuple Switch Expression',
    text: 'Use tuple for state machine',
    setup: 'string state = "idle"; string input = "start";',
    setupCode: 'string state = "idle"; string input = "start";',
    expected: '"running"',
    sample:
      'string newState = (state, input) switch { ("idle", "start") => "running", ("running", "stop") => "idle", ("running", "pause") => "paused", _ => state };',
    hints: ['Tuple enables multi-value switch', 'Great for state machines'],
    tags: ['pattern', 'tuple', 'state-machine'],
  },
  {
    id: 'cs-pattern-404',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Range Pattern',
    text: 'Check if character is letter',
    setup: "char c = 'M';",
    setupCode: "char c = 'M';",
    expected: 'true',
    sample: "bool isLetter = c is >= 'A' and <= 'Z' or >= 'a' and <= 'z';",
    hints: ['Combine relational with and/or', 'Create range checks'],
    tags: ['pattern', 'range', 'char'],
  },

  // ============================================================
  // NEW PROBLEMS - Batch 5: Records (25 problems)
  // ============================================================
  {
    id: 'cs-record-405',
    category: 'Records',
    difficulty: 'easy',
    title: 'Basic Record Declaration',
    text: 'Declare a simple record with Name and Age properties',
    setup: '// Define Person record',
    setupCode: '// Define Person record',
    expected: 'Record with init-only properties',
    sample: 'record Person(string Name, int Age);',
    hints: ['Positional record generates properties', 'Properties are init-only'],
    tags: ['record', 'declaration', 'positional'],
  },
  {
    id: 'cs-record-406',
    category: 'Records',
    difficulty: 'easy',
    title: 'Record Instantiation',
    text: 'Create an instance of a positional record',
    setup: 'record Person(string Name, int Age);',
    setupCode: 'record Person(string Name, int Age);',
    expected: 'Person { Name = "Alice", Age = 30 }',
    sample: 'var person = new Person("Alice", 30);',
    hints: ['Pass arguments in declaration order', 'Constructor generated automatically'],
    tags: ['record', 'instantiation', 'constructor'],
  },
  {
    id: 'cs-record-407',
    category: 'Records',
    difficulty: 'easy',
    title: 'Record Value Equality',
    text: 'Compare two records for equality',
    setup:
      'record Person(string Name, int Age);\nvar p1 = new Person("Alice", 30);\nvar p2 = new Person("Alice", 30);',
    setupCode:
      'record Person(string Name, int Age);\nvar p1 = new Person("Alice", 30);\nvar p2 = new Person("Alice", 30);',
    expected: 'true',
    sample: 'bool equal = p1 == p2;',
    hints: ['Records have value equality', 'Compares all properties'],
    tags: ['record', 'equality', 'value'],
  },
  {
    id: 'cs-record-408',
    category: 'Records',
    difficulty: 'medium',
    title: 'With Expression',
    text: 'Create modified copy using with expression',
    setup: 'record Person(string Name, int Age);\nvar original = new Person("Alice", 30);',
    setupCode: 'record Person(string Name, int Age);\nvar original = new Person("Alice", 30);',
    expected: 'Person { Name = "Alice", Age = 31 }',
    sample: 'var updated = original with { Age = 31 };',
    hints: ['with creates copy with changes', 'Original unchanged'],
    tags: ['record', 'with', 'copy'],
  },
  {
    id: 'cs-record-409',
    category: 'Records',
    difficulty: 'medium',
    title: 'Record Deconstruction',
    text: 'Deconstruct record into variables',
    setup: 'record Person(string Name, int Age);\nvar person = new Person("Alice", 30);',
    setupCode: 'record Person(string Name, int Age);\nvar person = new Person("Alice", 30);',
    expected: 'name = "Alice", age = 30',
    sample: 'var (name, age) = person;',
    hints: ['Positional records support deconstruction', 'Order matches declaration'],
    tags: ['record', 'deconstruct', 'tuple'],
  },
  {
    id: 'cs-record-410',
    category: 'Records',
    difficulty: 'medium',
    title: 'Record ToString',
    text: 'Records have automatic ToString implementation',
    setup: 'record Person(string Name, int Age);\nvar person = new Person("Alice", 30);',
    setupCode: 'record Person(string Name, int Age);\nvar person = new Person("Alice", 30);',
    expected: '"Person { Name = Alice, Age = 30 }"',
    sample: 'string str = person.ToString();',
    hints: ['ToString shows type and properties', 'Useful for debugging'],
    tags: ['record', 'tostring', 'display'],
  },
  {
    id: 'cs-record-411',
    category: 'Records',
    difficulty: 'medium',
    title: 'Record with Additional Members',
    text: 'Add computed property to record',
    setup: '// Add IsAdult property',
    setupCode: '// Add IsAdult property',
    expected: 'Record with extra property',
    sample: 'record Person(string Name, int Age) { public bool IsAdult => Age >= 18; }',
    hints: ['Add body with braces', 'Can add methods, properties'],
    tags: ['record', 'members', 'computed'],
  },
  {
    id: 'cs-record-412',
    category: 'Records',
    difficulty: 'hard',
    title: 'Record Inheritance',
    text: 'Create derived record',
    setup: 'record Person(string Name, int Age);',
    setupCode: 'record Person(string Name, int Age);',
    expected: 'Employee record with extra property',
    sample: 'record Employee(string Name, int Age, string Department) : Person(Name, Age);',
    hints: ['Records support inheritance', 'Pass args to base constructor'],
    tags: ['record', 'inheritance', 'derived'],
  },
  {
    id: 'cs-record-413',
    category: 'Records',
    difficulty: 'medium',
    title: 'Record Struct',
    text: 'Declare a value type record',
    setup: '// Define value type record',
    setupCode: '// Define value type record',
    expected: 'Record struct on stack',
    sample: 'record struct Point(int X, int Y);',
    hints: ['record struct is value type', 'No heap allocation'],
    tags: ['record', 'struct', 'value-type'],
  },
  {
    id: 'cs-record-414',
    category: 'Records',
    difficulty: 'medium',
    title: 'Readonly Record Struct',
    text: 'Declare immutable record struct',
    setup: '// Immutable value record',
    setupCode: '// Immutable value record',
    expected: 'Readonly struct record',
    sample: 'readonly record struct Point(int X, int Y);',
    hints: ['readonly makes struct immutable', 'Properties are readonly'],
    tags: ['record', 'struct', 'readonly'],
  },
  {
    id: 'cs-record-415',
    category: 'Records',
    difficulty: 'hard',
    title: 'Record Class Explicit',
    text: 'Explicitly declare record class',
    setup: '// Explicit reference type record',
    setupCode: '// Explicit reference type record',
    expected: 'Record class (same as record)',
    sample: 'record class Person(string Name, int Age);',
    hints: ['record class is explicit form', 'Same as just record'],
    tags: ['record', 'class', 'explicit'],
  },
  {
    id: 'cs-record-416',
    category: 'Records',
    difficulty: 'hard',
    title: 'Record Primary Constructor Validation',
    text: 'Add validation to record constructor',
    setup: '// Record with validation',
    setupCode: '// Record with validation',
    expected: 'Throws if age negative',
    sample:
      'record Person(string Name, int Age) { public Person { if (Age < 0) throw new ArgumentException(nameof(Age)); } }',
    hints: ['Primary constructor body for validation', 'Runs after properties set'],
    tags: ['record', 'validation', 'constructor'],
  },
  {
    id: 'cs-record-417',
    category: 'Records',
    difficulty: 'medium',
    title: 'Record with Default Values',
    text: 'Declare record with default parameter values',
    setup: '// Record with defaults',
    setupCode: '// Record with defaults',
    expected: 'Default Age is 0',
    sample: 'record Person(string Name, int Age = 0);',
    hints: ['Default values work in records', 'Use named arguments'],
    tags: ['record', 'default', 'parameters'],
  },
  {
    id: 'cs-record-418',
    category: 'Records',
    difficulty: 'easy',
    title: 'Record Property Access',
    text: 'Access record properties',
    setup: 'record Person(string Name, int Age);\nvar person = new Person("Alice", 30);',
    setupCode: 'record Person(string Name, int Age);\nvar person = new Person("Alice", 30);',
    expected: '"Alice"',
    sample: 'string name = person.Name;',
    hints: ['Properties accessible as normal', 'Init-only so cannot set'],
    tags: ['record', 'property', 'access'],
  },
  {
    id: 'cs-record-419',
    category: 'Records',
    difficulty: 'hard',
    title: 'Sealed Record',
    text: 'Prevent record inheritance',
    setup: '// Prevent inheritance',
    setupCode: '// Prevent inheritance',
    expected: 'Cannot be inherited',
    sample: 'sealed record Person(string Name, int Age);',
    hints: ['sealed prevents inheritance', 'Final record type'],
    tags: ['record', 'sealed', 'inheritance'],
  },
  {
    id: 'cs-record-420',
    category: 'Records',
    difficulty: 'medium',
    title: 'Record GetHashCode',
    text: 'Records have value-based hash code',
    setup:
      'record Person(string Name, int Age);\nvar p1 = new Person("Alice", 30);\nvar p2 = new Person("Alice", 30);',
    setupCode:
      'record Person(string Name, int Age);\nvar p1 = new Person("Alice", 30);\nvar p2 = new Person("Alice", 30);',
    expected: 'Same hash code',
    sample: 'bool sameHash = p1.GetHashCode() == p2.GetHashCode();',
    hints: ['Hash based on all properties', 'Safe for dictionary keys'],
    tags: ['record', 'hashcode', 'equality'],
  },
  {
    id: 'cs-record-421',
    category: 'Records',
    difficulty: 'hard',
    title: 'Record EqualityContract',
    text: 'Understand record equality contract',
    setup: 'record Person(string Name, int Age);',
    setupCode: 'record Person(string Name, int Age);',
    expected: 'Type included in equality',
    sample:
      '// Records include EqualityContract for type safety\n// Base != Derived even with same values',
    hints: ['EqualityContract ensures type match', 'Derived records not equal to base'],
    tags: ['record', 'equality', 'contract'],
  },
  {
    id: 'cs-record-422',
    category: 'Records',
    difficulty: 'medium',
    title: 'Record in Pattern Matching',
    text: 'Use record in switch expression',
    setup:
      'record Shape;\nrecord Circle(double Radius) : Shape;\nrecord Rectangle(double Width, double Height) : Shape;',
    setupCode:
      'record Shape;\nrecord Circle(double Radius) : Shape;\nrecord Rectangle(double Width, double Height) : Shape;',
    expected: 'Area calculation',
    sample:
      'double Area(Shape s) => s switch { Circle c => Math.PI * c.Radius * c.Radius, Rectangle r => r.Width * r.Height, _ => 0 };',
    hints: ['Records work great with patterns', 'Deconstruct in patterns'],
    tags: ['record', 'pattern', 'switch'],
  },
  {
    id: 'cs-record-423',
    category: 'Records',
    difficulty: 'easy',
    title: 'Record Collection',
    text: 'Store records in a list',
    setup: 'record Person(string Name, int Age);',
    setupCode: 'record Person(string Name, int Age);',
    expected: 'List of records',
    sample: 'var people = new List<Person> { new("Alice", 30), new("Bob", 25) };',
    hints: ['Records work in collections', 'Value equality for comparisons'],
    tags: ['record', 'collection', 'list'],
  },
  {
    id: 'cs-record-424',
    category: 'Records',
    difficulty: 'hard',
    title: 'Record with Required Members',
    text: 'Mark properties as required',
    setup: '// Record with required property',
    setupCode: '// Record with required property',
    expected: 'Compiler enforces initialization',
    sample:
      'record Person { public required string Name { get; init; } public int Age { get; init; } }',
    hints: ['required forces initialization', 'Works with object initializer'],
    tags: ['record', 'required', 'validation'],
  },
  {
    id: 'cs-record-425',
    category: 'Records',
    difficulty: 'medium',
    title: 'Record with Nullable Property',
    text: 'Declare record with nullable property',
    setup: '// Nullable middle name',
    setupCode: '// Nullable middle name',
    expected: 'Record with optional property',
    sample: 'record Person(string FirstName, string? MiddleName, string LastName);',
    hints: ['Use ? for nullable properties', 'Can be null'],
    tags: ['record', 'nullable', 'optional'],
  },
  {
    id: 'cs-record-426',
    category: 'Records',
    difficulty: 'hard',
    title: 'Record Positional Pattern',
    text: 'Match record using positional pattern',
    setup: 'record Point(int X, int Y);\nvar point = new Point(3, 4);',
    setupCode: 'record Point(int X, int Y);\nvar point = new Point(3, 4);',
    expected: '"Positive quadrant"',
    sample:
      'string quadrant = point switch { (> 0, > 0) => "Positive", (< 0, > 0) => "Second", _ => "Other" };',
    hints: ['Positional records support patterns', 'Deconstruct enables tuple pattern'],
    tags: ['record', 'pattern', 'positional'],
  },
  {
    id: 'cs-record-427',
    category: 'Records',
    difficulty: 'medium',
    title: 'Record Clone',
    text: 'Clone record using with',
    setup: 'record Person(string Name, int Age);\nvar original = new Person("Alice", 30);',
    setupCode: 'record Person(string Name, int Age);\nvar original = new Person("Alice", 30);',
    expected: 'Exact copy',
    sample: 'var clone = original with { };',
    hints: ['Empty with creates clone', 'Shallow copy'],
    tags: ['record', 'clone', 'with'],
  },
  {
    id: 'cs-record-428',
    category: 'Records',
    difficulty: 'hard',
    title: 'Record Custom Equality',
    text: 'Override equality for specific behavior',
    setup: '// Case-insensitive name comparison',
    setupCode: '// Case-insensitive name comparison',
    expected: 'Custom equality logic',
    sample:
      'record Person(string Name) { public virtual bool Equals(Person? other) => other != null && Name.Equals(other.Name, StringComparison.OrdinalIgnoreCase); public override int GetHashCode() => Name.ToUpperInvariant().GetHashCode(); }',
    hints: ['Override Equals and GetHashCode', 'Must override both'],
    tags: ['record', 'equality', 'custom'],
  },
  {
    id: 'cs-record-429',
    category: 'Records',
    difficulty: 'easy',
    title: 'Anonymous Type vs Record',
    text: 'Convert anonymous type usage to record',
    setup: '// Anonymous: var p = new { Name = "Alice", Age = 30 };',
    setupCode: '// Anonymous: var p = new { Name = "Alice", Age = 30 };',
    expected: 'Named record type',
    sample: 'record Person(string Name, int Age);\nvar p = new Person("Alice", 30);',
    hints: ['Records replace anonymous types', 'Can be returned from methods'],
    tags: ['record', 'anonymous', 'convert'],
  },

  // ============================================================
  // NEW PROBLEMS - Batch 5: Nullable Reference Types (25 problems)
  // ============================================================
  {
    id: 'cs-null-430',
    category: 'Nullable Reference Types',
    difficulty: 'easy',
    title: 'Declare Nullable Reference',
    text: 'Declare a nullable string variable',
    setup: '#nullable enable',
    setupCode: '#nullable enable',
    expected: 'Nullable string that can be null',
    sample: 'string? name = null;',
    hints: ['? makes reference type nullable', 'Enables null assignment'],
    tags: ['nullable', 'reference', 'declaration'],
  },
  {
    id: 'cs-null-431',
    category: 'Nullable Reference Types',
    difficulty: 'easy',
    title: 'Non-Nullable Reference',
    text: 'Declare non-nullable string that must have value',
    setup: '#nullable enable',
    setupCode: '#nullable enable',
    expected: 'Must initialize to non-null',
    sample: 'string name = "Alice";',
    hints: ['Without ? type is non-nullable', 'Compiler warns on null'],
    tags: ['nullable', 'non-nullable', 'declaration'],
  },
  {
    id: 'cs-null-432',
    category: 'Nullable Reference Types',
    difficulty: 'easy',
    title: 'Null Coalescing Operator',
    text: 'Provide default value for null',
    setup: 'string? name = null;',
    setupCode: 'string? name = null;',
    expected: '"Unknown"',
    sample: 'string result = name ?? "Unknown";',
    hints: ['?? returns right if left is null', 'Result is non-nullable'],
    tags: ['nullable', 'coalesce', 'default'],
  },
  {
    id: 'cs-null-433',
    category: 'Nullable Reference Types',
    difficulty: 'medium',
    title: 'Null Coalescing Assignment',
    text: 'Assign default only if null',
    setup: 'string? name = null;',
    setupCode: 'string? name = null;',
    expected: 'name = "Default"',
    sample: 'name ??= "Default";',
    hints: ['??= assigns if null', 'Modifies variable in place'],
    tags: ['nullable', 'coalesce', 'assignment'],
  },
  {
    id: 'cs-null-434',
    category: 'Nullable Reference Types',
    difficulty: 'medium',
    title: 'Null Conditional Access',
    text: 'Safely access property of nullable object',
    setup: 'string? name = "Alice";',
    setupCode: 'string? name = "Alice";',
    expected: '5 (or null if name is null)',
    sample: 'int? length = name?.Length;',
    hints: ['?. returns null if left is null', 'Result is nullable'],
    tags: ['nullable', 'conditional', 'access'],
  },
  {
    id: 'cs-null-435',
    category: 'Nullable Reference Types',
    difficulty: 'medium',
    title: 'Null Conditional Method Call',
    text: 'Safely call method on nullable',
    setup: 'string? text = "hello";',
    setupCode: 'string? text = "hello";',
    expected: '"HELLO" or null',
    sample: 'string? upper = text?.ToUpper();',
    hints: ['?. works with methods', 'Entire chain short-circuits'],
    tags: ['nullable', 'conditional', 'method'],
  },
  {
    id: 'cs-null-436',
    category: 'Nullable Reference Types',
    difficulty: 'medium',
    title: 'Null Conditional Chain',
    text: 'Chain multiple null-conditional accesses',
    setup:
      'class Person { public Address? Address { get; set; } }\nclass Address { public string? City { get; set; } }',
    setupCode:
      'class Person { public Address? Address { get; set; } }\nclass Address { public string? City { get; set; } }',
    expected: 'City or null',
    sample: 'Person? person = ...;\nstring? city = person?.Address?.City;',
    hints: ['Chain ?. operators', 'Any null short-circuits'],
    tags: ['nullable', 'chain', 'conditional'],
  },
  {
    id: 'cs-null-437',
    category: 'Nullable Reference Types',
    difficulty: 'hard',
    title: 'Null Forgiving Operator',
    text: 'Tell compiler value is not null',
    setup: 'string? name = GetName(); // May return non-null',
    setupCode: 'string? name = GetName();',
    expected: 'Suppress null warning',
    sample: 'string nonNull = name!;',
    hints: ['! suppresses null warning', 'Use when you know better than compiler'],
    tags: ['nullable', 'forgiving', 'suppress'],
  },
  {
    id: 'cs-null-438',
    category: 'Nullable Reference Types',
    difficulty: 'easy',
    title: 'Nullable Value Type',
    text: 'Declare nullable int',
    setup: '// Nullable value type',
    setupCode: '// Nullable value type',
    expected: 'int? that can be null',
    sample: 'int? count = null;',
    hints: ['Value types use ? too', 'Wraps in Nullable<T>'],
    tags: ['nullable', 'value-type', 'int'],
  },
  {
    id: 'cs-null-439',
    category: 'Nullable Reference Types',
    difficulty: 'medium',
    title: 'HasValue and Value',
    text: 'Check and access nullable value type',
    setup: 'int? count = 42;',
    setupCode: 'int? count = 42;',
    expected: 'true, 42',
    sample: 'if (count.HasValue) { int val = count.Value; }',
    hints: ['HasValue checks for value', 'Value throws if null'],
    tags: ['nullable', 'hasvalue', 'value'],
  },
  {
    id: 'cs-null-440',
    category: 'Nullable Reference Types',
    difficulty: 'medium',
    title: 'GetValueOrDefault',
    text: 'Get value or default for nullable',
    setup: 'int? count = null;',
    setupCode: 'int? count = null;',
    expected: '0 (default for int)',
    sample: 'int result = count.GetValueOrDefault();',
    hints: ['Returns default(T) if null', 'Overload accepts custom default'],
    tags: ['nullable', 'getvalueordefault', 'value'],
  },
  {
    id: 'cs-null-441',
    category: 'Nullable Reference Types',
    difficulty: 'hard',
    title: 'Nullable Context',
    text: 'Enable nullable context in code',
    setup: '// Enable nullable analysis',
    setupCode: '// Enable nullable analysis',
    expected: 'Nullable warnings enabled',
    sample: '#nullable enable\n// Code with nullable analysis\n#nullable disable',
    hints: ['#nullable controls context', 'enable/disable/restore'],
    tags: ['nullable', 'context', 'directive'],
  },
  {
    id: 'cs-null-442',
    category: 'Nullable Reference Types',
    difficulty: 'medium',
    title: 'MemberNotNull Attribute',
    text: 'Tell compiler member is set by method',
    setup: 'using System.Diagnostics.CodeAnalysis;',
    setupCode: 'using System.Diagnostics.CodeAnalysis;',
    expected: 'Compiler knows field is set',
    sample: '[MemberNotNull(nameof(_name))]\nvoid Initialize() { _name = "Default"; }',
    hints: ['MemberNotNull for init methods', 'Helps flow analysis'],
    tags: ['nullable', 'attribute', 'membernotnull'],
  },
  {
    id: 'cs-null-443',
    category: 'Nullable Reference Types',
    difficulty: 'hard',
    title: 'NotNullWhen Attribute',
    text: 'Indicate return value affects null state',
    setup: 'using System.Diagnostics.CodeAnalysis;',
    setupCode: 'using System.Diagnostics.CodeAnalysis;',
    expected: 'Compiler knows param non-null when true',
    sample:
      'bool TryGetValue([NotNullWhen(true)] out string? value) { value = "test"; return true; }',
    hints: ['NotNullWhen for try-pattern', 'true = param is non-null'],
    tags: ['nullable', 'attribute', 'notnullwhen'],
  },
  {
    id: 'cs-null-444',
    category: 'Nullable Reference Types',
    difficulty: 'hard',
    title: 'MaybeNullWhen Attribute',
    text: 'Indicate when output may be null',
    setup: 'using System.Diagnostics.CodeAnalysis;',
    setupCode: 'using System.Diagnostics.CodeAnalysis;',
    expected: 'Compiler knows output null state',
    sample: 'bool TryParse(string s, [MaybeNullWhen(false)] out T result)',
    hints: ['MaybeNullWhen for generic try-pattern', 'false = result may be null'],
    tags: ['nullable', 'attribute', 'maybenullwhen'],
  },
  {
    id: 'cs-null-445',
    category: 'Nullable Reference Types',
    difficulty: 'easy',
    title: 'Pattern Match Null Check',
    text: 'Check for non-null with pattern',
    setup: 'string? name = "Alice";',
    setupCode: 'string? name = "Alice";',
    expected: 'Enters block if non-null',
    sample: 'if (name is not null) { Console.WriteLine(name.Length); }',
    hints: ['is not null pattern', 'Narrows type to non-null'],
    tags: ['nullable', 'pattern', 'check'],
  },
  {
    id: 'cs-null-446',
    category: 'Nullable Reference Types',
    difficulty: 'medium',
    title: 'Null Check with Type Pattern',
    text: 'Combined null check and type check',
    setup: 'object? obj = "Hello";',
    setupCode: 'object? obj = "Hello";',
    expected: 'Checks non-null and type',
    sample: 'if (obj is string s) { Console.WriteLine(s.Length); }',
    hints: ['Type pattern implies non-null', 's is non-nullable string'],
    tags: ['nullable', 'pattern', 'type'],
  },
  {
    id: 'cs-null-447',
    category: 'Nullable Reference Types',
    difficulty: 'hard',
    title: 'Null State Analysis',
    text: 'Compiler tracks null state through code',
    setup: 'string? name = GetName();',
    setupCode: 'string? name = GetName();',
    expected: 'After check, name is non-null',
    sample:
      'if (name == null) return;\n// Here compiler knows name is not null\nConsole.WriteLine(name.Length);',
    hints: ['Compiler tracks null state', 'After null check, type narrows'],
    tags: ['nullable', 'analysis', 'flow'],
  },
  {
    id: 'cs-null-448',
    category: 'Nullable Reference Types',
    difficulty: 'medium',
    title: 'Null Conditional Index',
    text: 'Safely access collection element',
    setup: 'int[]? numbers = null;',
    setupCode: 'int[]? numbers = null;',
    expected: 'null (array is null)',
    sample: 'int? first = numbers?[0];',
    hints: ['?[] for safe indexing', 'Returns null if collection null'],
    tags: ['nullable', 'conditional', 'index'],
  },
  {
    id: 'cs-null-449',
    category: 'Nullable Reference Types',
    difficulty: 'hard',
    title: 'Nullable Generic Constraint',
    text: 'Constrain generic to non-nullable',
    setup: '// Generic with non-nullable constraint',
    setupCode: '// Generic with non-nullable constraint',
    expected: 'T must be non-null',
    sample: 'class Container<T> where T : notnull { public T Value { get; } }',
    hints: ['notnull constraint', 'Prevents nullable type arguments'],
    tags: ['nullable', 'generic', 'constraint'],
  },
  {
    id: 'cs-null-450',
    category: 'Nullable Reference Types',
    difficulty: 'medium',
    title: 'Default Literal with Nullable',
    text: 'Use default for nullable types',
    setup: 'string? name;',
    setupCode: 'string? name;',
    expected: 'null',
    sample: 'name = default;',
    hints: ['default is null for reference types', 'default(T?) is always valid'],
    tags: ['nullable', 'default', 'literal'],
  },
  {
    id: 'cs-null-451',
    category: 'Nullable Reference Types',
    difficulty: 'hard',
    title: 'AllowNull Attribute',
    text: 'Allow null input for non-nullable property',
    setup: 'using System.Diagnostics.CodeAnalysis;',
    setupCode: 'using System.Diagnostics.CodeAnalysis;',
    expected: 'Setter accepts null',
    sample: '[AllowNull]\npublic string Name { get => _name ?? ""; set => _name = value; }',
    hints: ['AllowNull for null-accepting setters', 'Getter still returns non-null'],
    tags: ['nullable', 'attribute', 'allownull'],
  },
  {
    id: 'cs-null-452',
    category: 'Nullable Reference Types',
    difficulty: 'hard',
    title: 'DisallowNull Attribute',
    text: 'Disallow null input for nullable property',
    setup: 'using System.Diagnostics.CodeAnalysis;',
    setupCode: 'using System.Diagnostics.CodeAnalysis;',
    expected: 'Setter rejects null',
    sample: '[DisallowNull]\npublic string? Name { get; set; }',
    hints: ['DisallowNull on nullable type', 'Getter may return null, setter not'],
    tags: ['nullable', 'attribute', 'disallownull'],
  },
  {
    id: 'cs-null-453',
    category: 'Nullable Reference Types',
    difficulty: 'medium',
    title: 'Throw on Null',
    text: 'Throw if argument is null',
    setup: 'void Process(string? name)',
    setupCode: 'void Process(string? name)',
    expected: 'Throws ArgumentNullException',
    sample: 'ArgumentNullException.ThrowIfNull(name);',
    hints: ['ThrowIfNull is concise guard', 'Added in .NET 6'],
    tags: ['nullable', 'throw', 'guard'],
  },
  {
    id: 'cs-null-454',
    category: 'Nullable Reference Types',
    difficulty: 'easy',
    title: 'Required Property',
    text: 'Mark property as required for initialization',
    setup: '// Required non-nullable property',
    setupCode: '// Required non-nullable property',
    expected: 'Must be set in initializer',
    sample: 'class Person { public required string Name { get; init; } }',
    hints: ['required ensures initialization', 'Works with init or set'],
    tags: ['nullable', 'required', 'init'],
  },

  // ============================================================
  // NEW PROBLEMS - Batch 5: Generics (25 problems)
  // ============================================================
  {
    id: 'cs-gen-455',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Class Declaration',
    text: 'Declare a generic container class',
    setup: '// Generic class with type parameter',
    setupCode: '// Generic class with type parameter',
    expected: 'Class that works with any type',
    sample: 'class Box<T> { public T Value { get; set; } }',
    hints: ['<T> is type parameter', 'T is placeholder for any type'],
    tags: ['generic', 'class', 'declaration'],
  },
  {
    id: 'cs-gen-456',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Method',
    text: 'Declare a generic method',
    setup: '// Generic method',
    setupCode: '// Generic method',
    expected: 'Method that works with any type',
    sample: 'T GetDefault<T>() => default!;',
    hints: ['<T> after method name', 'Type inferred from arguments'],
    tags: ['generic', 'method', 'declaration'],
  },
  {
    id: 'cs-gen-457',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Using Generic Class',
    text: 'Instantiate generic class with specific type',
    setup: 'class Box<T> { public T Value { get; set; } }',
    setupCode: 'class Box<T> { public T Value { get; set; } }',
    expected: 'Box containing integer',
    sample: 'var box = new Box<int> { Value = 42 };',
    hints: ['Specify type in angle brackets', 'Type is fixed at instantiation'],
    tags: ['generic', 'instantiation', 'usage'],
  },
  {
    id: 'cs-gen-458',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Multiple Type Parameters',
    text: 'Declare class with two type parameters',
    setup: '// Dictionary-like class',
    setupCode: '// Dictionary-like class',
    expected: 'Class with key and value types',
    sample:
      'class Pair<TKey, TValue> { public TKey Key { get; set; } public TValue Value { get; set; } }',
    hints: ['Comma-separated type parameters', 'Use descriptive names'],
    tags: ['generic', 'multiple', 'parameters'],
  },
  {
    id: 'cs-gen-459',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Class Constraint',
    text: 'Constrain type parameter to reference types',
    setup: '// Only reference types allowed',
    setupCode: '// Only reference types allowed',
    expected: 'T must be class',
    sample: 'class Repository<T> where T : class { }',
    hints: ['where T : class constraint', 'Excludes value types'],
    tags: ['generic', 'constraint', 'class'],
  },
  {
    id: 'cs-gen-460',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Struct Constraint',
    text: 'Constrain type parameter to value types',
    setup: '// Only value types allowed',
    setupCode: '// Only value types allowed',
    expected: 'T must be struct',
    sample: 'class ValueHolder<T> where T : struct { }',
    hints: ['where T : struct constraint', 'Excludes reference types'],
    tags: ['generic', 'constraint', 'struct'],
  },
  {
    id: 'cs-gen-461',
    category: 'Generics',
    difficulty: 'medium',
    title: 'New Constraint',
    text: 'Require parameterless constructor',
    setup: '// T must have default constructor',
    setupCode: '// T must have default constructor',
    expected: 'Can call new T()',
    sample: 'class Factory<T> where T : new() { public T Create() => new T(); }',
    hints: ['new() constraint enables new T()', 'Type must have parameterless constructor'],
    tags: ['generic', 'constraint', 'new'],
  },
  {
    id: 'cs-gen-462',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Interface Constraint',
    text: 'Constrain type to implement interface',
    setup: '// T must implement IComparable',
    setupCode: '// T must implement IComparable',
    expected: 'Can call interface methods',
    sample:
      'class Sorter<T> where T : IComparable<T> { public int Compare(T a, T b) => a.CompareTo(b); }',
    hints: ['Interface constraint enables methods', 'Can have multiple interfaces'],
    tags: ['generic', 'constraint', 'interface'],
  },
  {
    id: 'cs-gen-463',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Base Class Constraint',
    text: 'Constrain type to derive from base',
    setup: 'class Entity { public int Id { get; set; } }',
    setupCode: 'class Entity { public int Id { get; set; } }',
    expected: 'T must derive from Entity',
    sample: 'class Repository<T> where T : Entity { public T GetById(int id) => ...; }',
    hints: ['Base class constraint for inheritance', 'Access base class members'],
    tags: ['generic', 'constraint', 'baseclass'],
  },
  {
    id: 'cs-gen-464',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Multiple Constraints',
    text: 'Combine multiple constraints',
    setup: '// Multiple constraints on T',
    setupCode: '// Multiple constraints on T',
    expected: 'T must satisfy all constraints',
    sample: 'class Service<T> where T : class, IDisposable, new() { }',
    hints: ['Comma-separate constraints', 'new() must be last'],
    tags: ['generic', 'constraint', 'multiple'],
  },
  {
    id: 'cs-gen-465',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Default Value',
    text: 'Get default value for type parameter',
    setup: 'class Container<T>',
    setupCode: 'class Container<T>',
    expected: 'null for ref, 0 for value',
    sample: 'T GetDefault() => default!;',
    hints: ['default gives type default', 'null for class, 0 for int'],
    tags: ['generic', 'default', 'value'],
  },
  {
    id: 'cs-gen-466',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Covariance with out',
    text: 'Declare covariant type parameter',
    setup: '// Covariant interface',
    setupCode: '// Covariant interface',
    expected: 'IEnumerable<Derived> assignable to IEnumerable<Base>',
    sample: 'interface IProducer<out T> { T Produce(); }',
    hints: ['out enables covariance', 'T only in output positions'],
    tags: ['generic', 'covariance', 'out'],
  },
  {
    id: 'cs-gen-467',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Contravariance with in',
    text: 'Declare contravariant type parameter',
    setup: '// Contravariant interface',
    setupCode: '// Contravariant interface',
    expected: 'IComparer<Base> assignable to IComparer<Derived>',
    sample: 'interface IConsumer<in T> { void Consume(T item); }',
    hints: ['in enables contravariance', 'T only in input positions'],
    tags: ['generic', 'contravariance', 'in'],
  },
  {
    id: 'cs-gen-468',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Generic Interface Implementation',
    text: 'Implement generic interface',
    setup: 'interface IRepository<T> { T GetById(int id); void Save(T entity); }',
    setupCode: 'interface IRepository<T> { T GetById(int id); void Save(T entity); }',
    expected: 'Concrete implementation',
    sample:
      'class UserRepository : IRepository<User> { public User GetById(int id) => ...; public void Save(User entity) => ...; }',
    hints: ['Specify type when implementing', 'Or keep generic'],
    tags: ['generic', 'interface', 'implementation'],
  },
  {
    id: 'cs-gen-469',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Generic Inheritance',
    text: 'Inherit from generic class',
    setup: 'class Repository<T> { public virtual T Get() => default!; }',
    setupCode: 'class Repository<T> { public virtual T Get() => default!; }',
    expected: 'Derived generic or concrete class',
    sample: 'class CachedRepository<T> : Repository<T> { public override T Get() => ...; }',
    hints: ['Pass type parameter to base', 'Or specify concrete type'],
    tags: ['generic', 'inheritance', 'derived'],
  },
  {
    id: 'cs-gen-470',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Static Generic Method',
    text: 'Create static generic utility method',
    setup: '// Static generic swap',
    setupCode: '// Static generic swap',
    expected: 'Works with any type',
    sample: 'static void Swap<T>(ref T a, ref T b) { T temp = a; a = b; b = temp; }',
    hints: ['ref parameters for swap', 'Type inferred from arguments'],
    tags: ['generic', 'static', 'method'],
  },
  {
    id: 'cs-gen-471',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Generic Delegate',
    text: 'Use Func<T> generic delegate',
    setup: '// Func delegate',
    setupCode: '// Func delegate',
    expected: 'Function that returns T',
    sample: 'Func<int, string> converter = n => n.ToString();',
    hints: ['Func<TResult> returns TResult', 'Last type is return type'],
    tags: ['generic', 'delegate', 'func'],
  },
  {
    id: 'cs-gen-472',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Action Generic Delegate',
    text: 'Use Action<T> for void delegates',
    setup: '// Action delegate',
    setupCode: '// Action delegate',
    expected: 'Method with no return',
    sample: 'Action<string> print = s => Console.WriteLine(s);',
    hints: ['Action returns void', 'All type params are inputs'],
    tags: ['generic', 'delegate', 'action'],
  },
  {
    id: 'cs-gen-473',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Predicate Generic Delegate',
    text: 'Use Predicate<T> for boolean functions',
    setup: '// Predicate delegate',
    setupCode: '// Predicate delegate',
    expected: 'Function returning bool',
    sample: 'Predicate<int> isEven = n => n % 2 == 0;',
    hints: ['Predicate<T> = Func<T, bool>', 'Used in Find, Exists, etc.'],
    tags: ['generic', 'delegate', 'predicate'],
  },
  {
    id: 'cs-gen-474',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Generic Type Inference',
    text: 'Let compiler infer type arguments',
    setup: 'static T Identity<T>(T value) => value;',
    setupCode: 'static T Identity<T>(T value) => value;',
    expected: 'No explicit type needed',
    sample: 'int result = Identity(42); // T inferred as int',
    hints: ['Compiler infers from arguments', 'Explicit when ambiguous'],
    tags: ['generic', 'inference', 'type'],
  },
  {
    id: 'cs-gen-475',
    category: 'Generics',
    difficulty: 'easy',
    title: 'List<T> Generic Collection',
    text: 'Use generic List collection',
    setup: '// Generic list',
    setupCode: '// Generic list',
    expected: 'Type-safe list',
    sample: 'List<string> names = new List<string> { "Alice", "Bob" };',
    hints: ['List<T> is generic', 'Type-safe at compile time'],
    tags: ['generic', 'list', 'collection'],
  },
  {
    id: 'cs-gen-476',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Dictionary<TKey, TValue>',
    text: 'Use generic dictionary',
    setup: '// Generic dictionary',
    setupCode: '// Generic dictionary',
    expected: 'Type-safe key-value pairs',
    sample: 'Dictionary<string, int> ages = new() { ["Alice"] = 30 };',
    hints: ['Two type parameters', 'Keys and values typed'],
    tags: ['generic', 'dictionary', 'collection'],
  },
  {
    id: 'cs-gen-477',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Unmanaged Constraint',
    text: 'Constrain to unmanaged types',
    setup: '// For pointers and interop',
    setupCode: '// For pointers and interop',
    expected: 'T must be blittable',
    sample: 'unsafe void Process<T>(T* ptr) where T : unmanaged { }',
    hints: ['unmanaged for native interop', 'Includes int, structs without refs'],
    tags: ['generic', 'constraint', 'unmanaged'],
  },
  {
    id: 'cs-gen-478',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Generic Static Interface',
    text: 'Use static abstract interface members',
    setup: 'interface INumber<T> where T : INumber<T> { static abstract T Zero { get; } }',
    setupCode: 'interface INumber<T> where T : INumber<T> { static abstract T Zero { get; } }',
    expected: 'Call static member via generic',
    sample:
      'T Sum<T>(IEnumerable<T> values) where T : INumber<T> => values.Aggregate(T.Zero, (a, b) => a + b);',
    hints: ['Static abstract for generic math', '.NET 7+ feature'],
    tags: ['generic', 'static', 'interface'],
  },
  {
    id: 'cs-gen-479',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Typeof with Generics',
    text: 'Get type information for generic',
    setup: 'class Container<T> { }',
    setupCode: 'class Container<T> { }',
    expected: 'Type object for generic',
    sample: 'Type openType = typeof(Container<>);\nType closedType = typeof(Container<int>);',
    hints: ['<> for open generic type', '<T> for closed generic'],
    tags: ['generic', 'typeof', 'reflection'],
  },
];

export default csharpProblems;
