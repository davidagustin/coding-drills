import type { Problem } from '../types';

export const javascriptProblems: Problem[] = [
  // ========================================
  // ARRAY METHODS - filter
  // ========================================
  {
    id: 'js-filter-001',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Filter Even Numbers',
    text: 'Use the filter method to get only even numbers from the array.',
    setup: 'const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];',
    setupCode: 'const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];',
    expected: [2, 4, 6, 8, 10],
    sample: 'numbers.filter(n => n % 2 === 0)',
    hints: ['Use the modulo operator %', 'Even numbers have remainder 0 when divided by 2'],
    validPatterns: [
      /\.filter\s*\(\s*\w*\s*=>\s*\w*\s*%\s*2\s*(===?|!==?)\s*0\s*\)/,
      /\.filter\s*\(\s*function\s*\(\s*\w+\s*\)\s*\{\s*return\s+\w+\s*%\s*2\s*(===?|!==?)\s*0/,
    ],
    tags: ['filter', 'modulo', 'basics'],
  },
  {
    id: 'js-filter-002',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Filter Strings by Length',
    text: 'Filter the array to get only strings with more than 4 characters.',
    setup: 'const words = ["cat", "elephant", "dog", "hippopotamus", "ant", "tiger"];',
    setupCode: 'const words = ["cat", "elephant", "dog", "hippopotamus", "ant", "tiger"];',
    expected: ['elephant', 'hippopotamus', 'tiger'],
    sample: 'words.filter(w => w.length > 4)',
    hints: ['Use the .length property', 'Compare length to 4'],
    validPatterns: [
      /\.filter\s*\(\s*\w+\s*=>\s*\w+\.length\s*>\s*4\s*\)/,
      /\.filter\s*\(\s*\(\s*\w+\s*\)\s*=>\s*\w+\.length\s*>\s*4\s*\)/,
    ],
    tags: ['filter', 'length', 'strings'],
  },
  {
    id: 'js-filter-003',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Filter Objects by Property',
    text: 'Filter the users array to get only users who are active.',
    setup: `const users = [
  { name: "Alice", active: true },
  { name: "Bob", active: false },
  { name: "Charlie", active: true },
  { name: "Diana", active: false }
];`,
    setupCode: `const users = [
  { name: "Alice", active: true },
  { name: "Bob", active: false },
  { name: "Charlie", active: true },
  { name: "Diana", active: false }
];`,
    expected: [
      { name: 'Alice', active: true },
      { name: 'Charlie', active: true },
    ],
    sample: 'users.filter(u => u.active)',
    hints: ['Access the active property', 'Boolean values work directly in conditions'],
    validPatterns: [
      /\.filter\s*\(\s*\w+\s*=>\s*\w+\.active\s*\)/,
      /\.filter\s*\(\s*\w+\s*=>\s*\w+\.active\s*(===?)\s*true\s*\)/,
      /\.filter\s*\(\s*\{\s*active\s*\}\s*=>\s*active\s*\)/,
    ],
    tags: ['filter', 'objects', 'property-access'],
  },
  {
    id: 'js-filter-004',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Filter Unique Values',
    text: 'Use filter with indexOf to get unique values from the array.',
    setup: 'const numbers = [1, 2, 2, 3, 4, 4, 5, 1, 3];',
    setupCode: 'const numbers = [1, 2, 2, 3, 4, 4, 5, 1, 3];',
    expected: [1, 2, 3, 4, 5],
    sample: 'numbers.filter((n, i) => numbers.indexOf(n) === i)',
    hints: [
      'indexOf returns the first occurrence index',
      'Compare current index with first occurrence',
    ],
    validPatterns: [
      /\.filter\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>\s*\w+\.indexOf\s*\(\s*\w+\s*\)\s*===?\s*\w+\s*\)/,
    ],
    tags: ['filter', 'indexOf', 'unique'],
  },
  {
    id: 'js-filter-005',
    category: 'Array Methods',
    difficulty: 'hard',
    title: 'Filter with Multiple Conditions',
    text: 'Filter products that are in stock AND cost less than $50.',
    setup: `const products = [
  { name: "Laptop", price: 999, inStock: true },
  { name: "Mouse", price: 29, inStock: true },
  { name: "Keyboard", price: 49, inStock: false },
  { name: "Monitor", price: 299, inStock: true },
  { name: "USB Cable", price: 9, inStock: true }
];`,
    setupCode: `const products = [
  { name: "Laptop", price: 999, inStock: true },
  { name: "Mouse", price: 29, inStock: true },
  { name: "Keyboard", price: 49, inStock: false },
  { name: "Monitor", price: 299, inStock: true },
  { name: "USB Cable", price: 9, inStock: true }
];`,
    expected: [
      { name: 'Mouse', price: 29, inStock: true },
      { name: 'USB Cable', price: 9, inStock: true },
    ],
    sample: 'products.filter(p => p.inStock && p.price < 50)',
    hints: ['Use && for multiple conditions', 'Check both inStock and price'],
    validPatterns: [
      /\.filter\s*\(\s*\w+\s*=>\s*\w+\.inStock\s*&&\s*\w+\.price\s*<\s*50\s*\)/,
      /\.filter\s*\(\s*\w+\s*=>\s*\w+\.price\s*<\s*50\s*&&\s*\w+\.inStock\s*\)/,
    ],
    tags: ['filter', 'objects', 'conditions'],
  },

  // ========================================
  // ARRAY METHODS - map
  // ========================================
  {
    id: 'js-map-001',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Double All Numbers',
    text: 'Use map to double every number in the array.',
    setup: 'const numbers = [1, 2, 3, 4, 5];',
    setupCode: 'const numbers = [1, 2, 3, 4, 5];',
    expected: [2, 4, 6, 8, 10],
    sample: 'numbers.map(n => n * 2)',
    hints: ['Multiply each element by 2', 'map returns a new array'],
    validPatterns: [
      /\.map\s*\(\s*\w+\s*=>\s*\w+\s*\*\s*2\s*\)/,
      /\.map\s*\(\s*\(\s*\w+\s*\)\s*=>\s*\w+\s*\*\s*2\s*\)/,
    ],
    tags: ['map', 'arithmetic', 'basics'],
  },
  {
    id: 'js-map-002',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Extract Property Values',
    text: 'Use map to get an array of just the names from the users array.',
    setup: `const users = [
  { name: "Alice", age: 25 },
  { name: "Bob", age: 30 },
  { name: "Charlie", age: 35 }
];`,
    setupCode: `const users = [
  { name: "Alice", age: 25 },
  { name: "Bob", age: 30 },
  { name: "Charlie", age: 35 }
];`,
    expected: ['Alice', 'Bob', 'Charlie'],
    sample: 'users.map(u => u.name)',
    hints: ['Access the name property', 'map transforms each element'],
    validPatterns: [
      /\.map\s*\(\s*\w+\s*=>\s*\w+\.name\s*\)/,
      /\.map\s*\(\s*\{\s*name\s*\}\s*=>\s*name\s*\)/,
    ],
    tags: ['map', 'objects', 'property-access'],
  },
  {
    id: 'js-map-003',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Transform to New Object Shape',
    text: 'Transform each user into an object with fullName and isAdult properties.',
    setup: `const users = [
  { firstName: "John", lastName: "Doe", age: 17 },
  { firstName: "Jane", lastName: "Smith", age: 25 },
  { firstName: "Bob", lastName: "Brown", age: 16 }
];`,
    setupCode: `const users = [
  { firstName: "John", lastName: "Doe", age: 17 },
  { firstName: "Jane", lastName: "Smith", age: 25 },
  { firstName: "Bob", lastName: "Brown", age: 16 }
];`,
    expected: [
      { fullName: 'John Doe', isAdult: false },
      { fullName: 'Jane Smith', isAdult: true },
      { fullName: 'Bob Brown', isAdult: false },
    ],
    sample: 'users.map(u => ({ fullName: `${u.firstName} ${u.lastName}`, isAdult: u.age >= 18 }))',
    hints: [
      'Create a new object in map',
      'Concatenate firstName and lastName',
      'Check if age >= 18',
    ],
    validPatterns: [/\.map\s*\(\s*\w+\s*=>\s*\(\s*\{/],
    tags: ['map', 'objects', 'transformation'],
  },
  {
    id: 'js-map-004',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Convert to Uppercase',
    text: 'Use map to convert all strings to uppercase.',
    setup: 'const words = ["hello", "world", "javascript"];',
    setupCode: 'const words = ["hello", "world", "javascript"];',
    expected: ['HELLO', 'WORLD', 'JAVASCRIPT'],
    sample: 'words.map(w => w.toUpperCase())',
    hints: ['Use the toUpperCase() method', 'map returns a new array'],
    validPatterns: [/\.map\s*\(\s*\w+\s*=>\s*\w+\.toUpperCase\s*\(\s*\)\s*\)/],
    tags: ['map', 'strings', 'toUpperCase'],
  },
  {
    id: 'js-map-005',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Map with Index',
    text: 'Create an array of objects with value and index properties.',
    setup: 'const letters = ["a", "b", "c", "d"];',
    setupCode: 'const letters = ["a", "b", "c", "d"];',
    expected: [
      { value: 'a', index: 0 },
      { value: 'b', index: 1 },
      { value: 'c', index: 2 },
      { value: 'd', index: 3 },
    ],
    sample: 'letters.map((value, index) => ({ value, index }))',
    hints: ['map callback receives index as second argument', 'Use shorthand property syntax'],
    validPatterns: [/\.map\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>/],
    tags: ['map', 'index', 'objects'],
  },

  // ========================================
  // ARRAY METHODS - reduce
  // ========================================
  {
    id: 'js-reduce-001',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Sum All Numbers',
    text: 'Use reduce to calculate the sum of all numbers.',
    setup: 'const numbers = [1, 2, 3, 4, 5];',
    setupCode: 'const numbers = [1, 2, 3, 4, 5];',
    expected: 15,
    sample: 'numbers.reduce((sum, n) => sum + n, 0)',
    hints: ['Start with initial value 0', 'Add each number to the accumulator'],
    validPatterns: [/\.reduce\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>\s*\w+\s*\+\s*\w+\s*,\s*0\s*\)/],
    tags: ['reduce', 'sum', 'basics'],
  },
  {
    id: 'js-reduce-002',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Find Maximum Value',
    text: 'Use reduce to find the maximum value in the array.',
    setup: 'const numbers = [5, 2, 9, 1, 7, 3];',
    setupCode: 'const numbers = [5, 2, 9, 1, 7, 3];',
    expected: 9,
    sample: 'numbers.reduce((max, n) => n > max ? n : max, numbers[0])',
    hints: ['Compare each number to the current max', 'Use ternary operator or Math.max'],
    validPatterns: [
      /\.reduce\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>/,
      /Math\.max\s*\(\s*\.\.\.\w+\s*\)/,
    ],
    tags: ['reduce', 'max', 'comparison'],
  },
  {
    id: 'js-reduce-003',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Count Occurrences',
    text: 'Use reduce to count how many times each fruit appears.',
    setup: 'const fruits = ["apple", "banana", "apple", "orange", "banana", "apple"];',
    setupCode: 'const fruits = ["apple", "banana", "apple", "orange", "banana", "apple"];',
    expected: { apple: 3, banana: 2, orange: 1 },
    sample: 'fruits.reduce((acc, fruit) => ({ ...acc, [fruit]: (acc[fruit] || 0) + 1 }), {})',
    hints: [
      'Start with an empty object',
      'Use computed property names [fruit]',
      'Initialize count to 0 if undefined',
    ],
    validPatterns: [/\.reduce\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>/],
    tags: ['reduce', 'counting', 'objects'],
  },
  {
    id: 'js-reduce-004',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Flatten Nested Arrays',
    text: 'Use reduce to flatten the nested array one level deep.',
    setup: 'const nested = [[1, 2], [3, 4], [5, 6]];',
    setupCode: 'const nested = [[1, 2], [3, 4], [5, 6]];',
    expected: [1, 2, 3, 4, 5, 6],
    sample: 'nested.reduce((flat, arr) => [...flat, ...arr], [])',
    hints: ['Spread each inner array', 'Start with empty array'],
    validPatterns: [
      /\.reduce\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>\s*\[\s*\.\.\.\w+\s*,\s*\.\.\.\w+\s*\]/,
      /\.reduce\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>\s*\w+\.concat\s*\(\s*\w+\s*\)/,
      /\.flat\s*\(\s*\)/,
    ],
    tags: ['reduce', 'flatten', 'spread'],
  },
  {
    id: 'js-reduce-005',
    category: 'Array Methods',
    difficulty: 'hard',
    title: 'Group By Property',
    text: 'Use reduce to group users by their department.',
    setup: `const employees = [
  { name: "Alice", department: "Engineering" },
  { name: "Bob", department: "Marketing" },
  { name: "Charlie", department: "Engineering" },
  { name: "Diana", department: "Marketing" },
  { name: "Eve", department: "Sales" }
];`,
    setupCode: `const employees = [
  { name: "Alice", department: "Engineering" },
  { name: "Bob", department: "Marketing" },
  { name: "Charlie", department: "Engineering" },
  { name: "Diana", department: "Marketing" },
  { name: "Eve", department: "Sales" }
];`,
    expected: {
      Engineering: [
        { name: 'Alice', department: 'Engineering' },
        { name: 'Charlie', department: 'Engineering' },
      ],
      Marketing: [
        { name: 'Bob', department: 'Marketing' },
        { name: 'Diana', department: 'Marketing' },
      ],
      Sales: [{ name: 'Eve', department: 'Sales' }],
    },
    sample: `employees.reduce((groups, emp) => {
  const key = emp.department;
  groups[key] = groups[key] || [];
  groups[key].push(emp);
  return groups;
}, {})`,
    hints: [
      'Use department as the key',
      'Initialize empty array for new departments',
      'Push employee to appropriate group',
    ],
    validPatterns: [/\.reduce\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>/],
    tags: ['reduce', 'groupBy', 'objects'],
  },

  // ========================================
  // ARRAY METHODS - find and findIndex
  // ========================================
  {
    id: 'js-find-001',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Find First Even Number',
    text: 'Use find to get the first even number in the array.',
    setup: 'const numbers = [1, 3, 5, 8, 9, 10];',
    setupCode: 'const numbers = [1, 3, 5, 8, 9, 10];',
    expected: 8,
    sample: 'numbers.find(n => n % 2 === 0)',
    hints: ['find returns the first matching element', 'Use modulo to check for even'],
    validPatterns: [/\.find\s*\(\s*\w+\s*=>\s*\w+\s*%\s*2\s*===?\s*0\s*\)/],
    tags: ['find', 'modulo', 'basics'],
  },
  {
    id: 'js-find-002',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Find User by ID',
    text: 'Use find to get the user with id 3.',
    setup: `const users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" },
  { id: 3, name: "Charlie" },
  { id: 4, name: "Diana" }
];`,
    setupCode: `const users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" },
  { id: 3, name: "Charlie" },
  { id: 4, name: "Diana" }
];`,
    expected: { id: 3, name: 'Charlie' },
    sample: 'users.find(u => u.id === 3)',
    hints: ['Compare id property to 3', 'find returns the matching object'],
    validPatterns: [/\.find\s*\(\s*\w+\s*=>\s*\w+\.id\s*===?\s*3\s*\)/],
    tags: ['find', 'objects', 'property-access'],
  },
  {
    id: 'js-findIndex-001',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Find Index of First Negative',
    text: 'Use findIndex to get the index of the first negative number.',
    setup: 'const numbers = [5, 3, -2, 8, -6, 1];',
    setupCode: 'const numbers = [5, 3, -2, 8, -6, 1];',
    expected: 2,
    sample: 'numbers.findIndex(n => n < 0)',
    hints: ['findIndex returns the index, not the element', 'Negative numbers are less than 0'],
    validPatterns: [/\.findIndex\s*\(\s*\w+\s*=>\s*\w+\s*<\s*0\s*\)/],
    tags: ['findIndex', 'comparison', 'basics'],
  },

  // ========================================
  // ARRAY METHODS - some and every
  // ========================================
  {
    id: 'js-some-001',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Check for Any Negative',
    text: 'Use some to check if any number is negative.',
    setup: 'const numbers = [1, 5, -3, 8, 2];',
    setupCode: 'const numbers = [1, 5, -3, 8, 2];',
    expected: true,
    sample: 'numbers.some(n => n < 0)',
    hints: [
      'some returns true if at least one element matches',
      'Negative numbers are less than 0',
    ],
    validPatterns: [/\.some\s*\(\s*\w+\s*=>\s*\w+\s*<\s*0\s*\)/],
    tags: ['some', 'comparison', 'basics'],
  },
  {
    id: 'js-some-002',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Check for Admin User',
    text: 'Use some to check if any user is an admin.',
    setup: `const users = [
  { name: "Alice", role: "user" },
  { name: "Bob", role: "admin" },
  { name: "Charlie", role: "user" }
];`,
    setupCode: `const users = [
  { name: "Alice", role: "user" },
  { name: "Bob", role: "admin" },
  { name: "Charlie", role: "user" }
];`,
    expected: true,
    sample: 'users.some(u => u.role === "admin")',
    hints: ['Check the role property', 'Compare to "admin"'],
    validPatterns: [/\.some\s*\(\s*\w+\s*=>\s*\w+\.role\s*===?\s*['"]admin['"]\s*\)/],
    tags: ['some', 'objects', 'property-access'],
  },
  {
    id: 'js-every-001',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Check All Positive',
    text: 'Use every to check if all numbers are positive.',
    setup: 'const numbers = [1, 5, 3, 8, 2];',
    setupCode: 'const numbers = [1, 5, 3, 8, 2];',
    expected: true,
    sample: 'numbers.every(n => n > 0)',
    hints: ['every returns true if ALL elements match', 'Positive numbers are greater than 0'],
    validPatterns: [/\.every\s*\(\s*\w+\s*=>\s*\w+\s*>\s*0\s*\)/],
    tags: ['every', 'comparison', 'basics'],
  },
  {
    id: 'js-every-002',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Check All Valid Emails',
    text: 'Use every to check if all strings contain "@".',
    setup: 'const emails = ["alice@test.com", "bob@example.org", "charlie@demo.net"];',
    setupCode: 'const emails = ["alice@test.com", "bob@example.org", "charlie@demo.net"];',
    expected: true,
    sample: 'emails.every(e => e.includes("@"))',
    hints: ['Use the includes method', 'Check for @ symbol'],
    validPatterns: [/\.every\s*\(\s*\w+\s*=>\s*\w+\.includes\s*\(\s*['"]@['"]\s*\)\s*\)/],
    tags: ['every', 'includes', 'strings'],
  },

  // ========================================
  // ARRAY METHODS - sort
  // ========================================
  {
    id: 'js-sort-001',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Sort Numbers Ascending',
    text: 'Sort the numbers in ascending order.',
    setup: 'const numbers = [5, 2, 8, 1, 9, 3];',
    setupCode: 'const numbers = [5, 2, 8, 1, 9, 3];',
    expected: [1, 2, 3, 5, 8, 9],
    sample: 'numbers.sort((a, b) => a - b)',
    hints: ['Default sort converts to strings', 'Use comparison function for numbers'],
    validPatterns: [/\.sort\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>\s*\w+\s*-\s*\w+\s*\)/],
    tags: ['sort', 'numbers', 'comparison'],
  },
  {
    id: 'js-sort-002',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Sort Numbers Descending',
    text: 'Sort the numbers in descending order.',
    setup: 'const numbers = [5, 2, 8, 1, 9, 3];',
    setupCode: 'const numbers = [5, 2, 8, 1, 9, 3];',
    expected: [9, 8, 5, 3, 2, 1],
    sample: 'numbers.sort((a, b) => b - a)',
    hints: ['Reverse the subtraction order', 'b - a gives descending'],
    validPatterns: [/\.sort\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>\s*\w+\s*-\s*\w+\s*\)/],
    tags: ['sort', 'numbers', 'descending'],
  },
  {
    id: 'js-sort-003',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Sort by Object Property',
    text: 'Sort the users by age in ascending order.',
    setup: `const users = [
  { name: "Alice", age: 30 },
  { name: "Bob", age: 25 },
  { name: "Charlie", age: 35 }
];`,
    setupCode: `const users = [
  { name: "Alice", age: 30 },
  { name: "Bob", age: 25 },
  { name: "Charlie", age: 35 }
];`,
    expected: [
      { name: 'Bob', age: 25 },
      { name: 'Alice', age: 30 },
      { name: 'Charlie', age: 35 },
    ],
    sample: 'users.sort((a, b) => a.age - b.age)',
    hints: ['Access the age property', 'Subtract ages for comparison'],
    validPatterns: [/\.sort\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>\s*\w+\.age\s*-\s*\w+\.age\s*\)/],
    tags: ['sort', 'objects', 'property-access'],
  },
  {
    id: 'js-sort-004',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Sort Strings Alphabetically',
    text: 'Sort the words alphabetically (case-insensitive).',
    setup: 'const words = ["Banana", "apple", "Cherry", "date"];',
    setupCode: 'const words = ["Banana", "apple", "Cherry", "date"];',
    expected: ['apple', 'Banana', 'Cherry', 'date'],
    sample: 'words.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()))',
    hints: ['Convert to lowercase for comparison', 'Use localeCompare for strings'],
    validPatterns: [
      /\.sort\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>\s*\w+\.toLowerCase\s*\(\s*\)\.localeCompare/,
    ],
    tags: ['sort', 'strings', 'localeCompare'],
  },

  // ========================================
  // ARRAY METHODS - slice and splice
  // ========================================
  {
    id: 'js-slice-001',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Get First Three Elements',
    text: 'Use slice to get the first 3 elements.',
    setup: 'const numbers = [1, 2, 3, 4, 5, 6, 7];',
    setupCode: 'const numbers = [1, 2, 3, 4, 5, 6, 7];',
    expected: [1, 2, 3],
    sample: 'numbers.slice(0, 3)',
    hints: ['slice(start, end) - end is exclusive', 'Start at 0, end at 3'],
    validPatterns: [/\.slice\s*\(\s*0\s*,\s*3\s*\)/],
    tags: ['slice', 'basics'],
  },
  {
    id: 'js-slice-002',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Get Last Two Elements',
    text: 'Use slice to get the last 2 elements.',
    setup: 'const numbers = [1, 2, 3, 4, 5];',
    setupCode: 'const numbers = [1, 2, 3, 4, 5];',
    expected: [4, 5],
    sample: 'numbers.slice(-2)',
    hints: ['Negative index counts from end', '-2 means last 2 elements'],
    validPatterns: [/\.slice\s*\(\s*-2\s*\)/],
    tags: ['slice', 'negative-index'],
  },
  {
    id: 'js-slice-003',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Get Middle Elements',
    text: 'Use slice to get elements from index 2 to 4 (inclusive).',
    setup: 'const letters = ["a", "b", "c", "d", "e", "f"];',
    setupCode: 'const letters = ["a", "b", "c", "d", "e", "f"];',
    expected: ['c', 'd', 'e'],
    sample: 'letters.slice(2, 5)',
    hints: ['slice end is exclusive', 'To include index 4, use 5 as end'],
    validPatterns: [/\.slice\s*\(\s*2\s*,\s*5\s*\)/],
    tags: ['slice', 'range'],
  },

  // ========================================
  // ARRAY METHODS - includes, indexOf
  // ========================================
  {
    id: 'js-includes-001',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Check Array Contains Value',
    text: 'Check if the array includes the number 5.',
    setup: 'const numbers = [1, 2, 3, 4, 5, 6];',
    setupCode: 'const numbers = [1, 2, 3, 4, 5, 6];',
    expected: true,
    sample: 'numbers.includes(5)',
    hints: ['includes returns true/false', 'Direct method call'],
    validPatterns: [/\.includes\s*\(\s*5\s*\)/],
    tags: ['includes', 'search', 'basics'],
  },
  {
    id: 'js-indexOf-001',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Find Index of Element',
    text: 'Find the index of "orange" in the array.',
    setup: 'const fruits = ["apple", "banana", "orange", "grape"];',
    setupCode: 'const fruits = ["apple", "banana", "orange", "grape"];',
    expected: 2,
    sample: 'fruits.indexOf("orange")',
    hints: ['indexOf returns the index', 'Returns -1 if not found'],
    validPatterns: [/\.indexOf\s*\(\s*['"]orange['"]\s*\)/],
    tags: ['indexOf', 'search'],
  },

  // ========================================
  // ARRAY METHODS - concat, join, reverse
  // ========================================
  {
    id: 'js-concat-001',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Combine Two Arrays',
    text: 'Use concat to combine both arrays.',
    setup: `const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];`,
    setupCode: `const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];`,
    expected: [1, 2, 3, 4, 5, 6],
    sample: 'arr1.concat(arr2)',
    hints: ['concat returns a new array', 'Does not modify original'],
    validPatterns: [/arr1\.concat\s*\(\s*arr2\s*\)/, /\[\s*\.\.\.arr1\s*,\s*\.\.\.arr2\s*\]/],
    tags: ['concat', 'combine', 'basics'],
  },
  {
    id: 'js-join-001',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Join with Separator',
    text: 'Use join to create a string separated by " - ".',
    setup: 'const words = ["Hello", "World", "JavaScript"];',
    setupCode: 'const words = ["Hello", "World", "JavaScript"];',
    expected: 'Hello - World - JavaScript',
    sample: 'words.join(" - ")',
    hints: ['join takes a separator string', 'Returns a string'],
    validPatterns: [/\.join\s*\(\s*['"]\s*-\s*['"]\s*\)/],
    tags: ['join', 'strings'],
  },
  {
    id: 'js-reverse-001',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Reverse Array',
    text: 'Reverse the array without modifying the original (use slice first).',
    setup: 'const numbers = [1, 2, 3, 4, 5];',
    setupCode: 'const numbers = [1, 2, 3, 4, 5];',
    expected: [5, 4, 3, 2, 1],
    sample: 'numbers.slice().reverse()',
    hints: ['reverse modifies the original', 'Use slice() to copy first'],
    validPatterns: [
      /\.slice\s*\(\s*\)\.reverse\s*\(\s*\)/,
      /\[\s*\.\.\.numbers\s*\]\.reverse\s*\(\s*\)/,
    ],
    tags: ['reverse', 'slice', 'immutable'],
  },

  // ========================================
  // ARRAY METHODS - flat, flatMap
  // ========================================
  {
    id: 'js-flat-001',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Flatten Nested Array',
    text: 'Use flat to flatten the nested array.',
    setup: 'const nested = [1, [2, 3], [4, [5, 6]]];',
    setupCode: 'const nested = [1, [2, 3], [4, [5, 6]]];',
    expected: [1, 2, 3, 4, [5, 6]],
    sample: 'nested.flat()',
    hints: ['flat() flattens one level by default', 'Returns new array'],
    validPatterns: [/\.flat\s*\(\s*\)/, /\.flat\s*\(\s*1\s*\)/],
    tags: ['flat', 'nested'],
  },
  {
    id: 'js-flat-002',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Flatten All Levels',
    text: 'Use flat to completely flatten the deeply nested array.',
    setup: 'const deep = [1, [2, [3, [4, [5]]]]];',
    setupCode: 'const deep = [1, [2, [3, [4, [5]]]]];',
    expected: [1, 2, 3, 4, 5],
    sample: 'deep.flat(Infinity)',
    hints: ['Use Infinity for complete flattening', 'Or use a large number'],
    validPatterns: [/\.flat\s*\(\s*Infinity\s*\)/, /\.flat\s*\(\s*\d+\s*\)/],
    tags: ['flat', 'deep-nested'],
  },
  {
    id: 'js-flatMap-001',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'FlatMap Example',
    text: 'Use flatMap to double each number into a pair [n, n*2].',
    setup: 'const numbers = [1, 2, 3];',
    setupCode: 'const numbers = [1, 2, 3];',
    expected: [1, 2, 2, 4, 3, 6],
    sample: 'numbers.flatMap(n => [n, n * 2])',
    hints: ['flatMap combines map and flat', 'Return an array from callback'],
    validPatterns: [/\.flatMap\s*\(\s*\w+\s*=>\s*\[\s*\w+\s*,\s*\w+\s*\*\s*2\s*\]\s*\)/],
    tags: ['flatMap', 'transform'],
  },

  // ========================================
  // STRING METHODS
  // ========================================
  {
    id: 'js-string-001',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Split String into Array',
    text: 'Split the string into an array of words.',
    setup: 'const sentence = "Hello World JavaScript";',
    setupCode: 'const sentence = "Hello World JavaScript";',
    expected: ['Hello', 'World', 'JavaScript'],
    sample: 'sentence.split(" ")',
    hints: ['split takes a separator', 'Space character separates words'],
    validPatterns: [/\.split\s*\(\s*['"] ['"]\s*\)/, /\.split\s*\(\s*\/\s+\/\s*\)/],
    tags: ['split', 'strings', 'basics'],
  },
  {
    id: 'js-string-002',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Trim Whitespace',
    text: 'Remove leading and trailing whitespace from the string.',
    setup: 'const text = "   Hello World   ";',
    setupCode: 'const text = "   Hello World   ";',
    expected: 'Hello World',
    sample: 'text.trim()',
    hints: ['trim removes whitespace from both ends', 'Does not affect middle spaces'],
    validPatterns: [/\.trim\s*\(\s*\)/],
    tags: ['trim', 'whitespace'],
  },
  {
    id: 'js-string-003',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Replace Substring',
    text: 'Replace "World" with "JavaScript" in the string.',
    setup: 'const greeting = "Hello World";',
    setupCode: 'const greeting = "Hello World";',
    expected: 'Hello JavaScript',
    sample: 'greeting.replace("World", "JavaScript")',
    hints: ['replace takes search and replacement', 'Returns new string'],
    validPatterns: [/\.replace\s*\(\s*['"]World['"]\s*,\s*['"]JavaScript['"]\s*\)/],
    tags: ['replace', 'strings'],
  },
  {
    id: 'js-string-004',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Replace All Occurrences',
    text: 'Replace all occurrences of "a" with "o".',
    setup: 'const text = "banana";',
    setupCode: 'const text = "banana";',
    expected: 'bonono',
    sample: 'text.replaceAll("a", "o")',
    hints: ['replaceAll replaces all matches', 'Or use replace with global regex'],
    validPatterns: [
      /\.replaceAll\s*\(\s*['"]a['"]\s*,\s*['"]o['"]\s*\)/,
      /\.replace\s*\(\s*\/a\/g\s*,\s*['"]o['"]\s*\)/,
    ],
    tags: ['replaceAll', 'strings'],
  },
  {
    id: 'js-string-005',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Check String Includes',
    text: 'Check if the string includes "script".',
    setup: 'const lang = "JavaScript";',
    setupCode: 'const lang = "JavaScript";',
    expected: true,
    sample: 'lang.toLowerCase().includes("script")',
    hints: ['includes is case-sensitive', 'Convert to lowercase for case-insensitive'],
    validPatterns: [
      /\.toLowerCase\s*\(\s*\)\.includes\s*\(\s*['"]script['"]\s*\)/,
      /\.includes\s*\(\s*['"]Script['"]\s*\)/,
    ],
    tags: ['includes', 'strings'],
  },
  {
    id: 'js-string-006',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'String Starts With',
    text: 'Check if the string starts with "Hello".',
    setup: 'const greeting = "Hello World";',
    setupCode: 'const greeting = "Hello World";',
    expected: true,
    sample: 'greeting.startsWith("Hello")',
    hints: ['startsWith checks the beginning', 'Case-sensitive'],
    validPatterns: [/\.startsWith\s*\(\s*['"]Hello['"]\s*\)/],
    tags: ['startsWith', 'strings'],
  },
  {
    id: 'js-string-007',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'String Ends With',
    text: 'Check if the filename ends with ".js".',
    setup: 'const filename = "app.js";',
    setupCode: 'const filename = "app.js";',
    expected: true,
    sample: 'filename.endsWith(".js")',
    hints: ['endsWith checks the ending', 'Include the dot'],
    validPatterns: [/\.endsWith\s*\(\s*['"]\.js['"]\s*\)/],
    tags: ['endsWith', 'strings'],
  },
  {
    id: 'js-string-008',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Pad String Start',
    text: 'Pad the number string to 5 characters with leading zeros.',
    setup: 'const num = "42";',
    setupCode: 'const num = "42";',
    expected: '00042',
    sample: 'num.padStart(5, "0")',
    hints: ['padStart adds to the beginning', 'Second argument is the fill string'],
    validPatterns: [/\.padStart\s*\(\s*5\s*,\s*['"]0['"]\s*\)/],
    tags: ['padStart', 'formatting'],
  },
  {
    id: 'js-string-009',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Repeat String',
    text: 'Repeat the string 3 times.',
    setup: 'const star = "* ";',
    setupCode: 'const star = "* ";',
    expected: '* * * ',
    sample: 'star.repeat(3)',
    hints: ['repeat takes a count', 'Returns new string'],
    validPatterns: [/\.repeat\s*\(\s*3\s*\)/],
    tags: ['repeat', 'strings'],
  },
  {
    id: 'js-string-010',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Get Character at Index',
    text: 'Get the character at index 4.',
    setup: 'const word = "JavaScript";',
    setupCode: 'const word = "JavaScript";',
    expected: 'S',
    sample: 'word.charAt(4)',
    hints: ['charAt returns single character', 'Index starts at 0'],
    validPatterns: [/\.charAt\s*\(\s*4\s*\)/, /word\s*\[\s*4\s*\]/],
    tags: ['charAt', 'indexing'],
  },
  {
    id: 'js-string-011',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Extract Substring',
    text: 'Extract "World" from the string using substring.',
    setup: 'const greeting = "Hello World";',
    setupCode: 'const greeting = "Hello World";',
    expected: 'World',
    sample: 'greeting.substring(6)',
    hints: ['substring(start, end)', 'Or just start to get rest'],
    validPatterns: [
      /\.substring\s*\(\s*6\s*\)/,
      /\.substring\s*\(\s*6\s*,\s*11\s*\)/,
      /\.slice\s*\(\s*6\s*\)/,
    ],
    tags: ['substring', 'extraction'],
  },

  // ========================================
  // OBJECT METHODS
  // ========================================
  {
    id: 'js-object-001',
    category: 'Object Methods',
    difficulty: 'easy',
    title: 'Get Object Keys',
    text: 'Get an array of the object keys.',
    setup: 'const person = { name: "Alice", age: 30, city: "NYC" };',
    setupCode: 'const person = { name: "Alice", age: 30, city: "NYC" };',
    expected: ['name', 'age', 'city'],
    sample: 'Object.keys(person)',
    hints: ['Object.keys returns array of keys', 'Static method on Object'],
    validPatterns: [/Object\.keys\s*\(\s*person\s*\)/],
    tags: ['Object.keys', 'objects'],
  },
  {
    id: 'js-object-002',
    category: 'Object Methods',
    difficulty: 'easy',
    title: 'Get Object Values',
    text: 'Get an array of the object values.',
    setup: 'const person = { name: "Alice", age: 30, city: "NYC" };',
    setupCode: 'const person = { name: "Alice", age: 30, city: "NYC" };',
    expected: ['Alice', 30, 'NYC'],
    sample: 'Object.values(person)',
    hints: ['Object.values returns array of values', 'Static method on Object'],
    validPatterns: [/Object\.values\s*\(\s*person\s*\)/],
    tags: ['Object.values', 'objects'],
  },
  {
    id: 'js-object-003',
    category: 'Object Methods',
    difficulty: 'easy',
    title: 'Get Object Entries',
    text: 'Get an array of [key, value] pairs.',
    setup: 'const person = { name: "Alice", age: 30 };',
    setupCode: 'const person = { name: "Alice", age: 30 };',
    expected: [
      ['name', 'Alice'],
      ['age', 30],
    ],
    sample: 'Object.entries(person)',
    hints: ['Object.entries returns array of pairs', 'Each pair is [key, value]'],
    validPatterns: [/Object\.entries\s*\(\s*person\s*\)/],
    tags: ['Object.entries', 'objects'],
  },
  {
    id: 'js-object-004',
    category: 'Object Methods',
    difficulty: 'medium',
    title: 'Create Object from Entries',
    text: 'Convert the array of pairs back to an object.',
    setup: 'const entries = [["a", 1], ["b", 2], ["c", 3]];',
    setupCode: 'const entries = [["a", 1], ["b", 2], ["c", 3]];',
    expected: { a: 1, b: 2, c: 3 },
    sample: 'Object.fromEntries(entries)',
    hints: ['Object.fromEntries is inverse of entries', 'Takes array of pairs'],
    validPatterns: [/Object\.fromEntries\s*\(\s*entries\s*\)/],
    tags: ['Object.fromEntries', 'objects'],
  },
  {
    id: 'js-object-005',
    category: 'Object Methods',
    difficulty: 'medium',
    title: 'Merge Objects',
    text: 'Merge the two objects into one (second overwrites first).',
    setup: `const defaults = { theme: "light", fontSize: 14 };
const userPrefs = { theme: "dark" };`,
    setupCode: `const defaults = { theme: "light", fontSize: 14 };
const userPrefs = { theme: "dark" };`,
    expected: { theme: 'dark', fontSize: 14 },
    sample: '{ ...defaults, ...userPrefs }',
    hints: ['Use spread operator', 'Later values overwrite earlier'],
    validPatterns: [
      /\{\s*\.\.\.defaults\s*,\s*\.\.\.userPrefs\s*\}/,
      /Object\.assign\s*\(\s*\{\s*\}\s*,\s*defaults\s*,\s*userPrefs\s*\)/,
    ],
    tags: ['spread', 'merge', 'objects'],
  },
  {
    id: 'js-object-006',
    category: 'Object Methods',
    difficulty: 'medium',
    title: 'Check Property Exists',
    text: 'Check if the object has its own "name" property.',
    setup: 'const person = { name: "Alice", age: 30 };',
    setupCode: 'const person = { name: "Alice", age: 30 };',
    expected: true,
    sample: 'Object.hasOwn(person, "name")',
    hints: ['Object.hasOwn is the modern way', 'Or use hasOwnProperty'],
    validPatterns: [
      /Object\.hasOwn\s*\(\s*person\s*,\s*['"]name['"]\s*\)/,
      /person\.hasOwnProperty\s*\(\s*['"]name['"]\s*\)/,
      /['"]name['"]\s*in\s*person/,
    ],
    tags: ['hasOwn', 'property-check'],
  },

  // ========================================
  // SET METHODS
  // ========================================
  {
    id: 'js-set-001',
    category: 'Set Methods',
    difficulty: 'easy',
    title: 'Create Set from Array',
    text: 'Create a Set from the array to remove duplicates, then convert back to array.',
    setup: 'const numbers = [1, 2, 2, 3, 3, 3, 4];',
    setupCode: 'const numbers = [1, 2, 2, 3, 3, 3, 4];',
    expected: [1, 2, 3, 4],
    sample: '[...new Set(numbers)]',
    hints: ['Set automatically removes duplicates', 'Spread to convert back to array'],
    validPatterns: [
      /\[\s*\.\.\.new\s+Set\s*\(\s*numbers\s*\)\s*\]/,
      /Array\.from\s*\(\s*new\s+Set\s*\(\s*numbers\s*\)\s*\)/,
    ],
    tags: ['Set', 'unique', 'duplicates'],
  },
  {
    id: 'js-set-002',
    category: 'Set Methods',
    difficulty: 'medium',
    title: 'Set Intersection',
    text: 'Find common elements between two arrays using Set.',
    setup: `const arr1 = [1, 2, 3, 4, 5];
const arr2 = [4, 5, 6, 7, 8];`,
    setupCode: `const arr1 = [1, 2, 3, 4, 5];
const arr2 = [4, 5, 6, 7, 8];`,
    expected: [4, 5],
    sample: 'arr1.filter(x => new Set(arr2).has(x))',
    hints: ['Convert one array to Set', 'Filter the other by membership'],
    validPatterns: [
      /\.filter\s*\(\s*\w+\s*=>\s*new\s+Set\s*\(\s*\w+\s*\)\.has\s*\(\s*\w+\s*\)\s*\)/,
    ],
    tags: ['Set', 'intersection', 'filter'],
  },
  {
    id: 'js-set-003',
    category: 'Set Methods',
    difficulty: 'medium',
    title: 'Set Difference',
    text: 'Find elements in arr1 that are not in arr2.',
    setup: `const arr1 = [1, 2, 3, 4, 5];
const arr2 = [4, 5, 6, 7, 8];`,
    setupCode: `const arr1 = [1, 2, 3, 4, 5];
const arr2 = [4, 5, 6, 7, 8];`,
    expected: [1, 2, 3],
    sample: 'arr1.filter(x => !new Set(arr2).has(x))',
    hints: ['Use Set.has for O(1) lookup', 'Negate the condition for difference'],
    validPatterns: [
      /\.filter\s*\(\s*\w+\s*=>\s*!new\s+Set\s*\(\s*\w+\s*\)\.has\s*\(\s*\w+\s*\)\s*\)/,
    ],
    tags: ['Set', 'difference', 'filter'],
  },

  // ========================================
  // MATH OPERATIONS
  // ========================================
  {
    id: 'js-math-001',
    category: 'Math Operations',
    difficulty: 'easy',
    title: 'Find Maximum',
    text: 'Find the maximum value in the array.',
    setup: 'const numbers = [5, 2, 9, 1, 7, 3];',
    setupCode: 'const numbers = [5, 2, 9, 1, 7, 3];',
    expected: 9,
    sample: 'Math.max(...numbers)',
    hints: ['Math.max takes individual arguments', 'Use spread to expand array'],
    validPatterns: [/Math\.max\s*\(\s*\.\.\.numbers\s*\)/],
    tags: ['Math.max', 'spread'],
  },
  {
    id: 'js-math-002',
    category: 'Math Operations',
    difficulty: 'easy',
    title: 'Find Minimum',
    text: 'Find the minimum value in the array.',
    setup: 'const numbers = [5, 2, 9, 1, 7, 3];',
    setupCode: 'const numbers = [5, 2, 9, 1, 7, 3];',
    expected: 1,
    sample: 'Math.min(...numbers)',
    hints: ['Math.min finds smallest', 'Spread the array'],
    validPatterns: [/Math\.min\s*\(\s*\.\.\.numbers\s*\)/],
    tags: ['Math.min', 'spread'],
  },
  {
    id: 'js-math-003',
    category: 'Math Operations',
    difficulty: 'easy',
    title: 'Round Number',
    text: 'Round the number to the nearest integer.',
    setup: 'const num = 4.7;',
    setupCode: 'const num = 4.7;',
    expected: 5,
    sample: 'Math.round(num)',
    hints: ['Math.round rounds to nearest', '4.5 and up rounds up'],
    validPatterns: [/Math\.round\s*\(\s*num\s*\)/],
    tags: ['Math.round', 'rounding'],
  },
  {
    id: 'js-math-004',
    category: 'Math Operations',
    difficulty: 'easy',
    title: 'Floor Number',
    text: 'Round down to the nearest integer.',
    setup: 'const num = 4.9;',
    setupCode: 'const num = 4.9;',
    expected: 4,
    sample: 'Math.floor(num)',
    hints: ['Math.floor always rounds down', 'Towards negative infinity'],
    validPatterns: [/Math\.floor\s*\(\s*num\s*\)/],
    tags: ['Math.floor', 'rounding'],
  },
  {
    id: 'js-math-005',
    category: 'Math Operations',
    difficulty: 'easy',
    title: 'Ceil Number',
    text: 'Round up to the nearest integer.',
    setup: 'const num = 4.1;',
    setupCode: 'const num = 4.1;',
    expected: 5,
    sample: 'Math.ceil(num)',
    hints: ['Math.ceil always rounds up', 'Towards positive infinity'],
    validPatterns: [/Math\.ceil\s*\(\s*num\s*\)/],
    tags: ['Math.ceil', 'rounding'],
  },
  {
    id: 'js-math-006',
    category: 'Math Operations',
    difficulty: 'medium',
    title: 'Absolute Value',
    text: 'Get the absolute value of the number.',
    setup: 'const num = -42;',
    setupCode: 'const num = -42;',
    expected: 42,
    sample: 'Math.abs(num)',
    hints: ['Math.abs removes sign', 'Always returns positive'],
    validPatterns: [/Math\.abs\s*\(\s*num\s*\)/],
    tags: ['Math.abs', 'absolute'],
  },
  {
    id: 'js-math-007',
    category: 'Math Operations',
    difficulty: 'medium',
    title: 'Power Calculation',
    text: 'Calculate 2 to the power of 10.',
    setup: 'const base = 2, exponent = 10;',
    setupCode: 'const base = 2, exponent = 10;',
    expected: 1024,
    sample: 'Math.pow(base, exponent)',
    hints: ['Math.pow(base, exponent)', 'Or use ** operator'],
    validPatterns: [
      /Math\.pow\s*\(\s*base\s*,\s*exponent\s*\)/,
      /base\s*\*\*\s*exponent/,
      /2\s*\*\*\s*10/,
    ],
    tags: ['Math.pow', 'exponent'],
  },
  {
    id: 'js-math-008',
    category: 'Math Operations',
    difficulty: 'medium',
    title: 'Square Root',
    text: 'Calculate the square root of 144.',
    setup: 'const num = 144;',
    setupCode: 'const num = 144;',
    expected: 12,
    sample: 'Math.sqrt(num)',
    hints: ['Math.sqrt for square root', 'Returns the positive root'],
    validPatterns: [/Math\.sqrt\s*\(\s*num\s*\)/, /Math\.sqrt\s*\(\s*144\s*\)/],
    tags: ['Math.sqrt', 'root'],
  },

  // ========================================
  // CHAINED METHODS
  // ========================================
  {
    id: 'js-chain-001',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Filter and Map Chain',
    text: 'Get the names of users who are 30 or older.',
    setup: `const users = [
  { name: "Alice", age: 25 },
  { name: "Bob", age: 30 },
  { name: "Charlie", age: 35 },
  { name: "Diana", age: 28 }
];`,
    setupCode: `const users = [
  { name: "Alice", age: 25 },
  { name: "Bob", age: 30 },
  { name: "Charlie", age: 35 },
  { name: "Diana", age: 28 }
];`,
    expected: ['Bob', 'Charlie'],
    sample: 'users.filter(u => u.age >= 30).map(u => u.name)',
    hints: ['Filter first, then map', 'Chain the methods'],
    validPatterns: [/\.filter\s*\([^)]+\)\.map\s*\([^)]+\)/],
    tags: ['filter', 'map', 'chaining'],
  },
  {
    id: 'js-chain-002',
    category: 'Array Methods',
    difficulty: 'hard',
    title: 'Complex Chain',
    text: 'Get the total price of all in-stock items, with 10% discount applied.',
    setup: `const items = [
  { name: "Laptop", price: 1000, inStock: true },
  { name: "Phone", price: 500, inStock: false },
  { name: "Tablet", price: 300, inStock: true },
  { name: "Watch", price: 200, inStock: true }
];`,
    setupCode: `const items = [
  { name: "Laptop", price: 1000, inStock: true },
  { name: "Phone", price: 500, inStock: false },
  { name: "Tablet", price: 300, inStock: true },
  { name: "Watch", price: 200, inStock: true }
];`,
    expected: 1350,
    sample: 'items.filter(i => i.inStock).map(i => i.price * 0.9).reduce((sum, p) => sum + p, 0)',
    hints: ['Filter in-stock items', 'Map to apply discount', 'Reduce to sum'],
    validPatterns: [
      /\.filter\s*\([^)]+\)\.map\s*\([^)]+\)\.reduce\s*\([^)]+\)/,
      /\.filter\s*\([^)]+\)\.reduce\s*\([^)]+\)/,
    ],
    tags: ['filter', 'map', 'reduce', 'chaining'],
  },
  {
    id: 'js-chain-003',
    category: 'Array Methods',
    difficulty: 'hard',
    title: 'Sort and Slice',
    text: 'Get the top 3 highest scores.',
    setup: 'const scores = [85, 92, 78, 96, 88, 91, 73];',
    setupCode: 'const scores = [85, 92, 78, 96, 88, 91, 73];',
    expected: [96, 92, 91],
    sample: 'scores.slice().sort((a, b) => b - a).slice(0, 3)',
    hints: ['Sort descending first', 'Slice to get top 3', 'Use slice() to avoid mutation'],
    validPatterns: [/\.sort\s*\([^)]+\)\.slice\s*\(\s*0\s*,\s*3\s*\)/],
    tags: ['sort', 'slice', 'chaining'],
  },

  // ========================================
  // ADVANCED PROBLEMS
  // ========================================
  {
    id: 'js-advanced-001',
    category: 'Array Methods',
    difficulty: 'hard',
    title: 'Partition Array',
    text: 'Partition the array into [evens, odds].',
    setup: 'const numbers = [1, 2, 3, 4, 5, 6, 7, 8];',
    setupCode: 'const numbers = [1, 2, 3, 4, 5, 6, 7, 8];',
    expected: [
      [2, 4, 6, 8],
      [1, 3, 5, 7],
    ],
    sample: '[numbers.filter(n => n % 2 === 0), numbers.filter(n => n % 2 !== 0)]',
    hints: ['Create two filtered arrays', 'Use modulo to check even/odd'],
    validPatterns: [
      /\[\s*numbers\.filter\s*\([^)]+\)\s*,\s*numbers\.filter\s*\([^)]+\)\s*\]/,
      /\.reduce\s*\([^)]+\[\s*\w+\s*%\s*2/,
    ],
    tags: ['partition', 'filter', 'advanced'],
  },
  {
    id: 'js-advanced-002',
    category: 'Array Methods',
    difficulty: 'hard',
    title: 'Zip Two Arrays',
    text: 'Combine two arrays into pairs.',
    setup: `const keys = ["a", "b", "c"];
const values = [1, 2, 3];`,
    setupCode: `const keys = ["a", "b", "c"];
const values = [1, 2, 3];`,
    expected: [
      ['a', 1],
      ['b', 2],
      ['c', 3],
    ],
    sample: 'keys.map((k, i) => [k, values[i]])',
    hints: ['Use map with index', 'Access values by same index'],
    validPatterns: [
      /\.map\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>\s*\[\s*\w+\s*,\s*values\s*\[\s*\w+\s*\]\s*\]\s*\)/,
    ],
    tags: ['zip', 'map', 'index'],
  },
  {
    id: 'js-advanced-003',
    category: 'Array Methods',
    difficulty: 'hard',
    title: 'Running Total',
    text: 'Create an array of running totals.',
    setup: 'const numbers = [1, 2, 3, 4, 5];',
    setupCode: 'const numbers = [1, 2, 3, 4, 5];',
    expected: [1, 3, 6, 10, 15],
    sample: 'numbers.map((n, i) => numbers.slice(0, i + 1).reduce((a, b) => a + b, 0))',
    hints: ['For each position, sum all previous', 'Or use reduce to track running total'],
    validPatterns: [/\.map\s*\(/, /\.reduce\s*\(/],
    tags: ['running-total', 'reduce', 'advanced'],
  },
  {
    id: 'js-advanced-004',
    category: 'Object Methods',
    difficulty: 'hard',
    title: 'Invert Object',
    text: 'Swap keys and values in the object.',
    setup: 'const obj = { a: 1, b: 2, c: 3 };',
    setupCode: 'const obj = { a: 1, b: 2, c: 3 };',
    expected: { 1: 'a', 2: 'b', 3: 'c' },
    sample: 'Object.fromEntries(Object.entries(obj).map(([k, v]) => [v, k]))',
    hints: [
      'Use Object.entries to get pairs',
      'Swap positions in each pair',
      'Use Object.fromEntries to rebuild',
    ],
    validPatterns: [/Object\.fromEntries\s*\(\s*Object\.entries\s*\([^)]+\)\.map/],
    tags: ['Object.entries', 'Object.fromEntries', 'transform'],
  },
  {
    id: 'js-advanced-005',
    category: 'Array Methods',
    difficulty: 'hard',
    title: 'Frequency Map',
    text: 'Count the frequency of each character.',
    setup: 'const str = "hello";',
    setupCode: 'const str = "hello";',
    expected: { h: 1, e: 1, l: 2, o: 1 },
    sample: 'str.split("").reduce((acc, char) => ({ ...acc, [char]: (acc[char] || 0) + 1 }), {})',
    hints: ['Split string into array', 'Use reduce to count'],
    validPatterns: [/\.split\s*\(\s*['"]{2}\s*\)\.reduce/, /\[\s*\.\.\.str\s*\]\.reduce/],
    tags: ['frequency', 'reduce', 'strings'],
  },
  {
    id: 'js-advanced-006',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Array to Object',
    text: 'Convert the array of users to an object keyed by id.',
    setup: `const users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" },
  { id: 3, name: "Charlie" }
];`,
    setupCode: `const users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" },
  { id: 3, name: "Charlie" }
];`,
    expected: {
      1: { id: 1, name: 'Alice' },
      2: { id: 2, name: 'Bob' },
      3: { id: 3, name: 'Charlie' },
    },
    sample: 'Object.fromEntries(users.map(u => [u.id, u]))',
    hints: ['Map to [id, user] pairs', 'Use Object.fromEntries'],
    validPatterns: [/Object\.fromEntries\s*\(\s*users\.map/, /users\.reduce\s*\(/],
    tags: ['Object.fromEntries', 'map', 'transform'],
  },

  // ========================================
  // ARRAY METHODS - Modern ES2022+ Methods
  // ========================================
  {
    id: 'js-at-001',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Access Last Element with at()',
    text: 'Use the at() method to get the last element of the array.',
    setup: 'const colors = ["red", "green", "blue", "yellow"];',
    setupCode: 'const colors = ["red", "green", "blue", "yellow"];',
    expected: 'yellow',
    sample: 'colors.at(-1)',
    hints: ['at() accepts negative indices', '-1 refers to the last element'],
    validPatterns: [/\.at\s*\(\s*-1\s*\)/],
    tags: ['at', 'array', 'ES2022'],
  },
  {
    id: 'js-at-002',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Access Second-to-Last with at()',
    text: 'Use the at() method to get the second-to-last element.',
    setup: 'const numbers = [10, 20, 30, 40, 50];',
    setupCode: 'const numbers = [10, 20, 30, 40, 50];',
    expected: 40,
    sample: 'numbers.at(-2)',
    hints: ['Negative indices count from the end', '-2 is second from last'],
    validPatterns: [/\.at\s*\(\s*-2\s*\)/],
    tags: ['at', 'array', 'negative-index'],
  },
  {
    id: 'js-findLast-001',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Find Last Even Number',
    text: 'Use findLast to get the last even number in the array.',
    setup: 'const numbers = [1, 2, 3, 4, 5, 6, 7, 8];',
    setupCode: 'const numbers = [1, 2, 3, 4, 5, 6, 7, 8];',
    expected: 8,
    sample: 'numbers.findLast(n => n % 2 === 0)',
    hints: ['findLast searches from the end', 'Returns the last matching element'],
    validPatterns: [/\.findLast\s*\(\s*\w+\s*=>\s*\w+\s*%\s*2\s*===?\s*0\s*\)/],
    tags: ['findLast', 'array', 'ES2023'],
  },
  {
    id: 'js-findLast-002',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Find Last User by Role',
    text: 'Use findLast to get the last user with role "admin".',
    setup: `const users = [
  { name: "Alice", role: "admin" },
  { name: "Bob", role: "user" },
  { name: "Charlie", role: "admin" },
  { name: "Diana", role: "user" }
];`,
    setupCode: `const users = [
  { name: "Alice", role: "admin" },
  { name: "Bob", role: "user" },
  { name: "Charlie", role: "admin" },
  { name: "Diana", role: "user" }
];`,
    expected: { name: 'Charlie', role: 'admin' },
    sample: 'users.findLast(u => u.role === "admin")',
    hints: ['findLast returns the element, not index', 'Compare role property'],
    validPatterns: [/\.findLast\s*\(\s*\w+\s*=>\s*\w+\.role\s*===?\s*['"]admin['"]\s*\)/],
    tags: ['findLast', 'objects', 'ES2023'],
  },
  {
    id: 'js-findLastIndex-001',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Find Last Index of Negative',
    text: 'Use findLastIndex to get the index of the last negative number.',
    setup: 'const numbers = [5, -3, 8, -2, 1, -7, 4];',
    setupCode: 'const numbers = [5, -3, 8, -2, 1, -7, 4];',
    expected: 5,
    sample: 'numbers.findLastIndex(n => n < 0)',
    hints: ['findLastIndex returns the index', 'Searches from end of array'],
    validPatterns: [/\.findLastIndex\s*\(\s*\w+\s*=>\s*\w+\s*<\s*0\s*\)/],
    tags: ['findLastIndex', 'array', 'ES2023'],
  },
  {
    id: 'js-toSorted-001',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Sort Without Mutation',
    text: 'Use toSorted to sort the array without modifying the original.',
    setup: 'const numbers = [5, 2, 8, 1, 9];',
    setupCode: 'const numbers = [5, 2, 8, 1, 9];',
    expected: [1, 2, 5, 8, 9],
    sample: 'numbers.toSorted((a, b) => a - b)',
    hints: ['toSorted returns a new sorted array', 'Original array remains unchanged'],
    validPatterns: [/\.toSorted\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>\s*\w+\s*-\s*\w+\s*\)/],
    tags: ['toSorted', 'immutable', 'ES2023'],
  },
  {
    id: 'js-toSorted-002',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'toSorted with Objects',
    text: 'Use toSorted to sort users by name alphabetically without mutation.',
    setup: `const users = [
  { name: "Charlie", age: 30 },
  { name: "Alice", age: 25 },
  { name: "Bob", age: 35 }
];`,
    setupCode: `const users = [
  { name: "Charlie", age: 30 },
  { name: "Alice", age: 25 },
  { name: "Bob", age: 35 }
];`,
    expected: [
      { name: 'Alice', age: 25 },
      { name: 'Bob', age: 35 },
      { name: 'Charlie', age: 30 },
    ],
    sample: 'users.toSorted((a, b) => a.name.localeCompare(b.name))',
    hints: ['Use localeCompare for string sorting', 'toSorted does not modify original'],
    validPatterns: [/\.toSorted\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>\s*\w+\.name\.localeCompare/],
    tags: ['toSorted', 'objects', 'localeCompare'],
  },
  {
    id: 'js-toReversed-001',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Reverse Without Mutation',
    text: 'Use toReversed to reverse the array without modifying the original.',
    setup: 'const letters = ["a", "b", "c", "d", "e"];',
    setupCode: 'const letters = ["a", "b", "c", "d", "e"];',
    expected: ['e', 'd', 'c', 'b', 'a'],
    sample: 'letters.toReversed()',
    hints: ['toReversed returns a new reversed array', 'Original stays unchanged'],
    validPatterns: [/\.toReversed\s*\(\s*\)/],
    tags: ['toReversed', 'immutable', 'ES2023'],
  },
  {
    id: 'js-flatMap-002',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'FlatMap to Split Words',
    text: 'Use flatMap to split each sentence into individual words.',
    setup: 'const sentences = ["Hello World", "JavaScript is awesome"];',
    setupCode: 'const sentences = ["Hello World", "JavaScript is awesome"];',
    expected: ['Hello', 'World', 'JavaScript', 'is', 'awesome'],
    sample: 'sentences.flatMap(s => s.split(" "))',
    hints: ['flatMap combines map and flat(1)', 'Split each sentence by space'],
    validPatterns: [/\.flatMap\s*\(\s*\w+\s*=>\s*\w+\.split\s*\(\s*['"] ['"]\s*\)\s*\)/],
    tags: ['flatMap', 'split', 'transform'],
  },
  {
    id: 'js-flatMap-003',
    category: 'Array Methods',
    difficulty: 'hard',
    title: 'FlatMap with Filter Effect',
    text: 'Use flatMap to double even numbers and remove odd numbers.',
    setup: 'const numbers = [1, 2, 3, 4, 5, 6];',
    setupCode: 'const numbers = [1, 2, 3, 4, 5, 6];',
    expected: [4, 8, 12],
    sample: 'numbers.flatMap(n => n % 2 === 0 ? [n * 2] : [])',
    hints: ['Return empty array to filter out', 'Return array with value to keep'],
    validPatterns: [/\.flatMap\s*\(\s*\w+\s*=>\s*\w+\s*%\s*2\s*===?\s*0\s*\?\s*\[/],
    tags: ['flatMap', 'filter', 'conditional'],
  },

  // ========================================
  // STRING METHODS - Modern
  // ========================================
  {
    id: 'js-string-at-001',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'String at() Method',
    text: 'Use at() to get the last character of the string.',
    setup: 'const word = "JavaScript";',
    setupCode: 'const word = "JavaScript";',
    expected: 't',
    sample: 'word.at(-1)',
    hints: ['at() works on strings too', 'Negative index counts from end'],
    validPatterns: [/\.at\s*\(\s*-1\s*\)/],
    tags: ['at', 'string', 'ES2022'],
  },
  {
    id: 'js-string-padEnd-001',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Pad String End',
    text: 'Pad the string to 10 characters with dots at the end.',
    setup: 'const text = "Hello";',
    setupCode: 'const text = "Hello";',
    expected: 'Hello.....',
    sample: 'text.padEnd(10, ".")',
    hints: ['padEnd adds characters to the end', 'First arg is target length'],
    validPatterns: [/\.padEnd\s*\(\s*10\s*,\s*['"]\.['"]s*\)/],
    tags: ['padEnd', 'formatting', 'strings'],
  },
  {
    id: 'js-string-normalize-001',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Normalize Unicode String',
    text: 'Normalize the string to NFC form and get its length.',
    setup: 'const text = "cafe\\u0301";',
    setupCode: 'const text = "cafe\\u0301";',
    expected: 4,
    sample: 'text.normalize("NFC").length',
    hints: ['normalize() handles Unicode normalization', 'NFC combines characters'],
    validPatterns: [/\.normalize\s*\(\s*['"]NFC['"]\s*\)\.length/],
    tags: ['normalize', 'unicode', 'strings'],
  },
  {
    id: 'js-string-repeat-002',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Create Pattern with Repeat',
    text: 'Create a border pattern by repeating "-=" 10 times.',
    setup: 'const unit = "-=";',
    setupCode: 'const unit = "-=";',
    expected: '-=-=-=-=-=-=-=-=-=-=',
    sample: 'unit.repeat(10)',
    hints: ['repeat() duplicates the string', 'Returns new string'],
    validPatterns: [/\.repeat\s*\(\s*10\s*\)/],
    tags: ['repeat', 'pattern', 'strings'],
  },

  // ========================================
  // OBJECT METHODS - Modern
  // ========================================
  {
    id: 'js-object-groupBy-001',
    category: 'Object Methods',
    difficulty: 'medium',
    title: 'Group Array by Property',
    text: 'Use Object.groupBy to group products by their category.',
    setup: `const products = [
  { name: "Apple", category: "fruit" },
  { name: "Carrot", category: "vegetable" },
  { name: "Banana", category: "fruit" },
  { name: "Broccoli", category: "vegetable" }
];`,
    setupCode: `const products = [
  { name: "Apple", category: "fruit" },
  { name: "Carrot", category: "vegetable" },
  { name: "Banana", category: "fruit" },
  { name: "Broccoli", category: "vegetable" }
];`,
    expected: {
      fruit: [
        { name: 'Apple', category: 'fruit' },
        { name: 'Banana', category: 'fruit' },
      ],
      vegetable: [
        { name: 'Carrot', category: 'vegetable' },
        { name: 'Broccoli', category: 'vegetable' },
      ],
    },
    sample: 'Object.groupBy(products, p => p.category)',
    hints: ['Object.groupBy is ES2024', 'Returns object with grouped arrays'],
    validPatterns: [/Object\.groupBy\s*\(\s*products\s*,\s*\w+\s*=>\s*\w+\.category\s*\)/],
    tags: ['Object.groupBy', 'grouping', 'ES2024'],
  },
  {
    id: 'js-object-groupBy-002',
    category: 'Object Methods',
    difficulty: 'hard',
    title: 'Group Numbers by Range',
    text: 'Use Object.groupBy to group numbers into "small" (< 10), "medium" (10-50), and "large" (> 50).',
    setup: 'const numbers = [5, 15, 3, 42, 8, 67, 23, 99, 2];',
    setupCode: 'const numbers = [5, 15, 3, 42, 8, 67, 23, 99, 2];',
    expected: {
      small: [5, 3, 8, 2],
      medium: [15, 42, 23],
      large: [67, 99],
    },
    sample: 'Object.groupBy(numbers, n => n < 10 ? "small" : n <= 50 ? "medium" : "large")',
    hints: ['Use ternary operators for ranges', 'Return the group name string'],
    validPatterns: [/Object\.groupBy\s*\(\s*numbers\s*,/],
    tags: ['Object.groupBy', 'conditional', 'ranges'],
  },
  {
    id: 'js-object-fromEntries-002',
    category: 'Object Methods',
    difficulty: 'medium',
    title: 'Transform Object Values',
    text: 'Double all values in the object using entries, map, and fromEntries.',
    setup: 'const prices = { apple: 1, banana: 2, orange: 3 };',
    setupCode: 'const prices = { apple: 1, banana: 2, orange: 3 };',
    expected: { apple: 2, banana: 4, orange: 6 },
    sample: 'Object.fromEntries(Object.entries(prices).map(([k, v]) => [k, v * 2]))',
    hints: ['entries gives [key, value] pairs', 'map to transform values', 'fromEntries rebuilds object'],
    validPatterns: [/Object\.fromEntries\s*\(\s*Object\.entries\s*\(\s*prices\s*\)\.map/],
    tags: ['Object.fromEntries', 'Object.entries', 'transform'],
  },

  // ========================================
  // SET METHODS - ES2025
  // ========================================
  {
    id: 'js-set-union-001',
    category: 'Set Methods',
    difficulty: 'medium',
    title: 'Set Union',
    text: 'Use the Set union() method to combine two sets.',
    setup: `const set1 = new Set([1, 2, 3]);
const set2 = new Set([3, 4, 5]);`,
    setupCode: `const set1 = new Set([1, 2, 3]);
const set2 = new Set([3, 4, 5]);`,
    expected: [1, 2, 3, 4, 5],
    sample: '[...set1.union(set2)]',
    hints: ['union() combines both sets', 'Duplicates are automatically removed'],
    validPatterns: [/set1\.union\s*\(\s*set2\s*\)/, /\[\s*\.\.\.set1\.union/],
    tags: ['Set', 'union', 'ES2025'],
  },
  {
    id: 'js-set-intersection-001',
    category: 'Set Methods',
    difficulty: 'medium',
    title: 'Set Intersection',
    text: 'Use the Set intersection() method to find common elements.',
    setup: `const set1 = new Set([1, 2, 3, 4]);
const set2 = new Set([3, 4, 5, 6]);`,
    setupCode: `const set1 = new Set([1, 2, 3, 4]);
const set2 = new Set([3, 4, 5, 6]);`,
    expected: [3, 4],
    sample: '[...set1.intersection(set2)]',
    hints: ['intersection() finds common elements', 'Returns a new Set'],
    validPatterns: [/set1\.intersection\s*\(\s*set2\s*\)/, /\[\s*\.\.\.set1\.intersection/],
    tags: ['Set', 'intersection', 'ES2025'],
  },
  {
    id: 'js-set-difference-001',
    category: 'Set Methods',
    difficulty: 'medium',
    title: 'Set Difference',
    text: 'Use the Set difference() method to find elements only in the first set.',
    setup: `const set1 = new Set([1, 2, 3, 4]);
const set2 = new Set([3, 4, 5, 6]);`,
    setupCode: `const set1 = new Set([1, 2, 3, 4]);
const set2 = new Set([3, 4, 5, 6]);`,
    expected: [1, 2],
    sample: '[...set1.difference(set2)]',
    hints: ['difference() removes elements found in second set', 'Order matters for difference'],
    validPatterns: [/set1\.difference\s*\(\s*set2\s*\)/, /\[\s*\.\.\.set1\.difference/],
    tags: ['Set', 'difference', 'ES2025'],
  },

  // ========================================
  // PROMISE METHODS
  // ========================================
  {
    id: 'js-promise-allSettled-001',
    category: 'Promise Methods',
    difficulty: 'hard',
    title: 'Handle Multiple Promises with allSettled',
    text: 'Use Promise.allSettled to get results of all promises regardless of rejection.',
    setup: `const promises = [
  Promise.resolve(1),
  Promise.reject("error"),
  Promise.resolve(3)
];`,
    setupCode: `const promises = [
  Promise.resolve(1),
  Promise.reject("error"),
  Promise.resolve(3)
];`,
    expected: [
      { status: 'fulfilled', value: 1 },
      { status: 'rejected', reason: 'error' },
      { status: 'fulfilled', value: 3 },
    ],
    sample: 'await Promise.allSettled(promises)',
    hints: ['allSettled never rejects', 'Returns status and value/reason for each'],
    validPatterns: [/Promise\.allSettled\s*\(\s*promises\s*\)/],
    tags: ['Promise.allSettled', 'async', 'error-handling'],
  },
  {
    id: 'js-promise-any-001',
    category: 'Promise Methods',
    difficulty: 'hard',
    title: 'Get First Successful Promise',
    text: 'Use Promise.any to get the first successfully resolved promise.',
    setup: `const promises = [
  new Promise((_, reject) => setTimeout(() => reject("fail1"), 100)),
  new Promise(resolve => setTimeout(() => resolve("success"), 50)),
  new Promise((_, reject) => setTimeout(() => reject("fail2"), 75))
];`,
    setupCode: `const promises = [
  new Promise((_, reject) => setTimeout(() => reject("fail1"), 100)),
  new Promise(resolve => setTimeout(() => resolve("success"), 50)),
  new Promise((_, reject) => setTimeout(() => reject("fail2"), 75))
];`,
    expected: 'success',
    sample: 'await Promise.any(promises)',
    hints: ['any() returns first fulfilled promise', 'Ignores rejections until all fail'],
    validPatterns: [/Promise\.any\s*\(\s*promises\s*\)/],
    tags: ['Promise.any', 'async', 'racing'],
  },
  {
    id: 'js-promise-race-001',
    category: 'Promise Methods',
    difficulty: 'medium',
    title: 'Race Promises for First Result',
    text: 'Use Promise.race to get the result of the fastest promise.',
    setup: `const fast = new Promise(resolve => setTimeout(() => resolve("fast"), 50));
const slow = new Promise(resolve => setTimeout(() => resolve("slow"), 100));
const promises = [fast, slow];`,
    setupCode: `const fast = new Promise(resolve => setTimeout(() => resolve("fast"), 50));
const slow = new Promise(resolve => setTimeout(() => resolve("slow"), 100));
const promises = [fast, slow];`,
    expected: 'fast',
    sample: 'await Promise.race(promises)',
    hints: ['race() returns first settled promise', 'Can be fulfilled or rejected'],
    validPatterns: [/Promise\.race\s*\(\s*promises\s*\)/],
    tags: ['Promise.race', 'async', 'performance'],
  },
  {
    id: 'js-promise-race-002',
    category: 'Promise Methods',
    difficulty: 'hard',
    title: 'Timeout with Promise.race',
    text: 'Use Promise.race to implement a timeout that rejects if operation takes too long.',
    setup: `const operation = new Promise(resolve => setTimeout(() => resolve("done"), 200));
const timeout = new Promise((_, reject) => setTimeout(() => reject("timeout"), 100));
const promises = [operation, timeout];`,
    setupCode: `const operation = new Promise(resolve => setTimeout(() => resolve("done"), 200));
const timeout = new Promise((_, reject) => setTimeout(() => reject("timeout"), 100));
const promises = [operation, timeout];`,
    expected: 'timeout',
    sample: 'await Promise.race(promises).catch(e => e)',
    hints: ['race settles with first promise', 'timeout rejects faster than operation'],
    validPatterns: [/Promise\.race\s*\(\s*promises\s*\)/],
    tags: ['Promise.race', 'timeout', 'error-handling'],
  },

  // ========================================
  // ADVANCED ARRAY MANIPULATION
  // ========================================
  {
    id: 'js-arr-adv-001',
    category: 'Advanced Array Manipulation',
    difficulty: 'easy',
    title: 'Filter and Map Chain',
    text: 'Filter the numbers to get only positive values, then double each one using method chaining.',
    setup: 'const numbers = [-3, 1, -7, 4, 5, -2, 8];',
    setupCode: 'const numbers = [-3, 1, -7, 4, 5, -2, 8];',
    expected: [2, 8, 10, 16],
    sample: 'numbers.filter(n => n > 0).map(n => n * 2)',
    hints: ['Chain filter() before map()', 'Filter for positive numbers first'],
    validPatterns: [
      /\.filter\s*\([^)]+\)\s*\.map\s*\([^)]+\)/,
    ],
    tags: ['filter', 'map', 'chaining', 'array-methods'],
  },
  {
    id: 'js-arr-adv-002',
    category: 'Advanced Array Manipulation',
    difficulty: 'easy',
    title: 'Extract and Transform with Destructuring',
    text: 'Use map with destructuring to extract only the names from the users array.',
    setup: `const users = [
  { name: "Alice", age: 25 },
  { name: "Bob", age: 30 },
  { name: "Charlie", age: 35 }
];`,
    setupCode: `const users = [
  { name: "Alice", age: 25 },
  { name: "Bob", age: 30 },
  { name: "Charlie", age: 35 }
];`,
    expected: ['Alice', 'Bob', 'Charlie'],
    sample: 'users.map(({ name }) => name)',
    hints: ['Use destructuring in the callback parameter', 'Extract just the name property'],
    validPatterns: [
      /\.map\s*\(\s*\{\s*name\s*\}\s*=>\s*name\s*\)/,
      /\.map\s*\(\s*\(\s*\{\s*name\s*\}\s*\)\s*=>\s*name\s*\)/,
    ],
    tags: ['map', 'destructuring', 'objects', 'array-methods'],
  },
  {
    id: 'js-arr-adv-003',
    category: 'Advanced Array Manipulation',
    difficulty: 'easy',
    title: 'Flatten Nested Array One Level',
    text: 'Flatten the nested array by one level using the flat() method.',
    setup: 'const nested = [[1, 2], [3, 4], [5, [6, 7]]];',
    setupCode: 'const nested = [[1, 2], [3, 4], [5, [6, 7]]];',
    expected: [1, 2, 3, 4, 5, [6, 7]],
    sample: 'nested.flat()',
    hints: ['flat() with no argument flattens one level', 'Default depth is 1'],
    validPatterns: [
      /\.flat\s*\(\s*\)/,
      /\.flat\s*\(\s*1\s*\)/,
    ],
    tags: ['flat', 'nested-arrays', 'flattening'],
  },
  {
    id: 'js-arr-adv-004',
    category: 'Advanced Array Manipulation',
    difficulty: 'easy',
    title: 'Sum Array with Reduce',
    text: 'Use reduce to calculate the sum of all numbers in the array.',
    setup: 'const numbers = [10, 20, 30, 40, 50];',
    setupCode: 'const numbers = [10, 20, 30, 40, 50];',
    expected: 150,
    sample: 'numbers.reduce((sum, n) => sum + n, 0)',
    hints: ['reduce takes an accumulator and current value', 'Start with initial value of 0'],
    validPatterns: [
      /\.reduce\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>\s*\w+\s*\+\s*\w+\s*,\s*0\s*\)/,
    ],
    tags: ['reduce', 'sum', 'accumulator', 'basics'],
  },
  {
    id: 'js-arr-adv-005',
    category: 'Advanced Array Manipulation',
    difficulty: 'easy',
    title: 'Sort Strings Alphabetically with localeCompare',
    text: 'Sort the array of names alphabetically using localeCompare for proper string comparison.',
    setup: 'const names = ["Zoe", "alice", "Bob", "charlie"];',
    setupCode: 'const names = ["Zoe", "alice", "Bob", "charlie"];',
    expected: ['alice', 'Bob', 'charlie', 'Zoe'],
    sample: 'names.sort((a, b) => a.localeCompare(b))',
    hints: ['localeCompare handles case-insensitive sorting', 'Returns -1, 0, or 1'],
    validPatterns: [
      /\.sort\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>\s*\w+\.localeCompare\s*\(\s*\w+\s*\)\s*\)/,
    ],
    tags: ['sort', 'localeCompare', 'strings', 'alphabetical'],
  },
  {
    id: 'js-arr-adv-006',
    category: 'Advanced Array Manipulation',
    difficulty: 'easy',
    title: 'Find Duplicates in Array',
    text: 'Find all duplicate values in the array (values that appear more than once).',
    setup: 'const numbers = [1, 2, 3, 2, 4, 3, 5, 1];',
    setupCode: 'const numbers = [1, 2, 3, 2, 4, 3, 5, 1];',
    expected: [2, 3, 1],
    sample: 'numbers.filter((n, i) => numbers.indexOf(n) !== i && numbers.lastIndexOf(n) === i)',
    hints: ['Compare indexOf with current index', 'Use lastIndexOf to avoid duplicates in result'],
    validPatterns: [
      /\.filter\s*\([^)]*indexOf[^)]*\)/,
    ],
    tags: ['filter', 'indexOf', 'duplicates', 'array-methods'],
  },
  {
    id: 'js-arr-adv-007',
    category: 'Advanced Array Manipulation',
    difficulty: 'easy',
    title: 'Deep Flatten Array',
    text: 'Completely flatten the deeply nested array using flat() with Infinity.',
    setup: 'const deep = [1, [2, [3, [4, [5]]]]];',
    setupCode: 'const deep = [1, [2, [3, [4, [5]]]]];',
    expected: [1, 2, 3, 4, 5],
    sample: 'deep.flat(Infinity)',
    hints: ['Use Infinity as the depth argument', 'flat(Infinity) flattens all levels'],
    validPatterns: [
      /\.flat\s*\(\s*Infinity\s*\)/,
    ],
    tags: ['flat', 'nested-arrays', 'infinity', 'deep-flatten'],
  },
  {
    id: 'js-arr-adv-008',
    category: 'Advanced Array Manipulation',
    difficulty: 'easy',
    title: 'Filter Map Reduce Chain',
    text: 'Filter products in stock, get their prices, then sum the total value.',
    setup: `const products = [
  { name: "A", price: 10, inStock: true },
  { name: "B", price: 20, inStock: false },
  { name: "C", price: 30, inStock: true },
  { name: "D", price: 40, inStock: true }
];`,
    setupCode: `const products = [
  { name: "A", price: 10, inStock: true },
  { name: "B", price: 20, inStock: false },
  { name: "C", price: 30, inStock: true },
  { name: "D", price: 40, inStock: true }
];`,
    expected: 80,
    sample: 'products.filter(p => p.inStock).map(p => p.price).reduce((sum, p) => sum + p, 0)',
    hints: ['Chain filter -> map -> reduce', 'Filter for inStock first, then extract prices'],
    validPatterns: [
      /\.filter\s*\([^)]+\)\s*\.map\s*\([^)]+\)\s*\.reduce\s*\([^)]+\)/,
    ],
    tags: ['filter', 'map', 'reduce', 'chaining', 'method-chaining'],
  },
  {
    id: 'js-arr-adv-009',
    category: 'Advanced Array Manipulation',
    difficulty: 'medium',
    title: 'Group Array by Property',
    text: 'Group the people array by their department using reduce.',
    setup: `const people = [
  { name: "Alice", department: "Engineering" },
  { name: "Bob", department: "Sales" },
  { name: "Charlie", department: "Engineering" },
  { name: "Diana", department: "Sales" },
  { name: "Eve", department: "Marketing" }
];`,
    setupCode: `const people = [
  { name: "Alice", department: "Engineering" },
  { name: "Bob", department: "Sales" },
  { name: "Charlie", department: "Engineering" },
  { name: "Diana", department: "Sales" },
  { name: "Eve", department: "Marketing" }
];`,
    expected: {
      Engineering: [
        { name: 'Alice', department: 'Engineering' },
        { name: 'Charlie', department: 'Engineering' },
      ],
      Sales: [
        { name: 'Bob', department: 'Sales' },
        { name: 'Diana', department: 'Sales' },
      ],
      Marketing: [{ name: 'Eve', department: 'Marketing' }],
    },
    sample: `people.reduce((groups, person) => {
  const dept = person.department;
  groups[dept] = groups[dept] || [];
  groups[dept].push(person);
  return groups;
}, {})`,
    hints: [
      'Use reduce with an object as accumulator',
      'Create array for each department if it does not exist',
    ],
    validPatterns: [
      /\.reduce\s*\([^)]*department[^)]*\{[^}]*\}\s*\)/,
    ],
    tags: ['reduce', 'grouping', 'objects', 'accumulator'],
  },
  {
    id: 'js-arr-adv-010',
    category: 'Advanced Array Manipulation',
    difficulty: 'medium',
    title: 'Chunk Array into Groups',
    text: 'Split the array into chunks of size 3.',
    setup: 'const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];',
    setupCode: 'const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];',
    expected: [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]],
    sample: `numbers.reduce((chunks, item, index) => {
  const chunkIndex = Math.floor(index / 3);
  chunks[chunkIndex] = chunks[chunkIndex] || [];
  chunks[chunkIndex].push(item);
  return chunks;
}, [])`,
    hints: [
      'Use Math.floor(index / chunkSize) to determine chunk index',
      'Use reduce to build the chunked array',
    ],
    validPatterns: [
      /\.reduce\s*\([^)]*Math\.floor[^)]*\)/,
      /Array\.from\s*\([^)]*slice[^)]*\)/,
    ],
    tags: ['reduce', 'chunking', 'windowing', 'array-transformation'],
  },
  {
    id: 'js-arr-adv-011',
    category: 'Advanced Array Manipulation',
    difficulty: 'medium',
    title: 'Transform to Object with Reduce',
    text: 'Convert the array of pairs into an object using reduce.',
    setup: `const pairs = [["name", "Alice"], ["age", 30], ["city", "NYC"]];`,
    setupCode: `const pairs = [["name", "Alice"], ["age", 30], ["city", "NYC"]];`,
    expected: { name: 'Alice', age: 30, city: 'NYC' },
    sample: 'pairs.reduce((obj, [key, value]) => ({ ...obj, [key]: value }), {})',
    hints: [
      'Use destructuring in the callback to get key and value',
      'Use computed property names [key]',
    ],
    validPatterns: [
      /\.reduce\s*\(\s*\(\s*\w+\s*,\s*\[\s*\w+\s*,\s*\w+\s*\]\s*\)/,
    ],
    tags: ['reduce', 'destructuring', 'object-creation', 'computed-properties'],
  },
  {
    id: 'js-arr-adv-012',
    category: 'Advanced Array Manipulation',
    difficulty: 'medium',
    title: 'Sliding Window Average',
    text: 'Calculate the sliding window average with window size 3 (average of each consecutive 3 elements).',
    setup: 'const numbers = [1, 2, 3, 4, 5, 6, 7];',
    setupCode: 'const numbers = [1, 2, 3, 4, 5, 6, 7];',
    expected: [2, 3, 4, 5, 6],
    sample: `numbers.slice(0, -2).map((_, i) =>
  (numbers[i] + numbers[i + 1] + numbers[i + 2]) / 3
)`,
    hints: [
      'Window size 3 means you stop at length - 2',
      'For each position, average current and next 2 elements',
    ],
    validPatterns: [
      /\.map\s*\([^)]*\+[^)]*\+[^)]*\/\s*3/,
      /\.slice\s*\([^)]*\)\s*\.map/,
    ],
    tags: ['map', 'slice', 'windowing', 'sliding-window', 'average'],
  },
  {
    id: 'js-arr-adv-013',
    category: 'Advanced Array Manipulation',
    difficulty: 'medium',
    title: 'Sort Objects by Multiple Properties',
    text: 'Sort users first by age (ascending), then by name (alphabetically) for same ages.',
    setup: `const users = [
  { name: "Charlie", age: 30 },
  { name: "Alice", age: 25 },
  { name: "Bob", age: 30 },
  { name: "Diana", age: 25 }
];`,
    setupCode: `const users = [
  { name: "Charlie", age: 30 },
  { name: "Alice", age: 25 },
  { name: "Bob", age: 30 },
  { name: "Diana", age: 25 }
];`,
    expected: [
      { name: 'Alice', age: 25 },
      { name: 'Diana', age: 25 },
      { name: 'Bob', age: 30 },
      { name: 'Charlie', age: 30 },
    ],
    sample: 'users.sort((a, b) => a.age - b.age || a.name.localeCompare(b.name))',
    hints: [
      'Use || to chain sort conditions',
      'First compare by age, then by name if ages are equal',
    ],
    validPatterns: [
      /\.sort\s*\([^)]*age[^)]*\|\|[^)]*localeCompare[^)]*\)/,
      /\.sort\s*\([^)]*age[^)]*name[^)]*\)/,
    ],
    tags: ['sort', 'localeCompare', 'multiple-sort', 'objects'],
  },
  {
    id: 'js-arr-adv-014',
    category: 'Advanced Array Manipulation',
    difficulty: 'medium',
    title: 'FlatMap for Transformation',
    text: 'Use flatMap to duplicate each number and flatten the result.',
    setup: 'const numbers = [1, 2, 3, 4];',
    setupCode: 'const numbers = [1, 2, 3, 4];',
    expected: [1, 1, 2, 2, 3, 3, 4, 4],
    sample: 'numbers.flatMap(n => [n, n])',
    hints: ['flatMap combines map and flat(1)', 'Return an array from the callback'],
    validPatterns: [
      /\.flatMap\s*\(\s*\w+\s*=>\s*\[\s*\w+\s*,\s*\w+\s*\]\s*\)/,
    ],
    tags: ['flatMap', 'flat', 'map', 'transformation'],
  },
  {
    id: 'js-arr-adv-015',
    category: 'Advanced Array Manipulation',
    difficulty: 'medium',
    title: 'Count Occurrences with Reduce',
    text: 'Count the occurrences of each fruit in the array using reduce.',
    setup: 'const fruits = ["apple", "banana", "apple", "orange", "banana", "apple"];',
    setupCode: 'const fruits = ["apple", "banana", "apple", "orange", "banana", "apple"];',
    expected: { apple: 3, banana: 2, orange: 1 },
    sample: `fruits.reduce((counts, fruit) => {
  counts[fruit] = (counts[fruit] || 0) + 1;
  return counts;
}, {})`,
    hints: [
      'Use an object as the accumulator',
      'Initialize count to 0 if fruit not seen before',
    ],
    validPatterns: [
      /\.reduce\s*\([^)]*\|\|\s*0[^)]*\+\s*1/,
    ],
    tags: ['reduce', 'counting', 'frequency', 'objects'],
  },
  {
    id: 'js-arr-adv-016',
    category: 'Advanced Array Manipulation',
    difficulty: 'medium',
    title: 'Find Unique Combinations',
    text: 'Find all unique pairs of numbers that sum to 10.',
    setup: 'const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];',
    setupCode: 'const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];',
    expected: [[1, 9], [2, 8], [3, 7], [4, 6]],
    sample: `numbers
  .filter((n, i) => numbers.slice(i + 1).includes(10 - n))
  .map(n => [n, 10 - n])`,
    hints: [
      'For each number, check if its complement (10 - n) exists',
      'Only check numbers after current to avoid duplicates',
    ],
    validPatterns: [
      /\.filter\s*\([^)]*10\s*-\s*\w+[^)]*\)/,
      /\.flatMap\s*\([^)]*10\s*-/,
    ],
    tags: ['filter', 'map', 'combinations', 'pairs', 'sum'],
  },
  {
    id: 'js-arr-adv-017',
    category: 'Advanced Array Manipulation',
    difficulty: 'medium',
    title: 'Nested Destructuring in Map',
    text: 'Extract the city from nested address objects using map with nested destructuring.',
    setup: `const users = [
  { name: "Alice", address: { city: "NYC", zip: "10001" } },
  { name: "Bob", address: { city: "LA", zip: "90001" } },
  { name: "Charlie", address: { city: "Chicago", zip: "60601" } }
];`,
    setupCode: `const users = [
  { name: "Alice", address: { city: "NYC", zip: "10001" } },
  { name: "Bob", address: { city: "LA", zip: "90001" } },
  { name: "Charlie", address: { city: "Chicago", zip: "60601" } }
];`,
    expected: ['NYC', 'LA', 'Chicago'],
    sample: 'users.map(({ address: { city } }) => city)',
    hints: [
      'Use nested destructuring pattern',
      'Destructure address first, then city from address',
    ],
    validPatterns: [
      /\.map\s*\(\s*\{\s*address\s*:\s*\{\s*city\s*\}\s*\}\s*=>\s*city\s*\)/,
      /\.map\s*\(\s*\(\s*\{\s*address\s*:\s*\{\s*city\s*\}\s*\}\s*\)\s*=>\s*city\s*\)/,
    ],
    tags: ['map', 'destructuring', 'nested', 'objects'],
  },
  {
    id: 'js-arr-adv-018',
    category: 'Advanced Array Manipulation',
    difficulty: 'medium',
    title: 'Partition Array',
    text: 'Partition the numbers into two arrays: even and odd numbers using reduce.',
    setup: 'const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];',
    setupCode: 'const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];',
    expected: [[2, 4, 6, 8, 10], [1, 3, 5, 7, 9]],
    sample: `numbers.reduce(
  ([evens, odds], n) => n % 2 === 0
    ? [[...evens, n], odds]
    : [evens, [...odds, n]],
  [[], []]
)`,
    hints: [
      'Use reduce with an array of two arrays as accumulator',
      'Destructure the accumulator into evens and odds',
    ],
    validPatterns: [
      /\.reduce\s*\(\s*\(\s*\[\s*\w+\s*,\s*\w+\s*\]\s*,\s*\w+\s*\)/,
    ],
    tags: ['reduce', 'partition', 'destructuring', 'arrays'],
  },
  {
    id: 'js-arr-adv-019',
    category: 'Advanced Array Manipulation',
    difficulty: 'medium',
    title: 'Zip Two Arrays',
    text: 'Combine two arrays into an array of pairs using map.',
    setup: `const names = ["Alice", "Bob", "Charlie"];
const ages = [25, 30, 35];`,
    setupCode: `const names = ["Alice", "Bob", "Charlie"];
const ages = [25, 30, 35];`,
    expected: [
      ['Alice', 25],
      ['Bob', 30],
      ['Charlie', 35],
    ],
    sample: 'names.map((name, i) => [name, ages[i]])',
    hints: ['Use the index parameter in map', 'Access the corresponding element from ages'],
    validPatterns: [
      /\.map\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>\s*\[\s*\w+\s*,\s*\w+\s*\[\s*\w+\s*\]\s*\]\s*\)/,
    ],
    tags: ['map', 'zip', 'pairs', 'index'],
  },
  {
    id: 'js-arr-adv-020',
    category: 'Advanced Array Manipulation',
    difficulty: 'medium',
    title: 'Running Total with Reduce',
    text: 'Calculate the running total (cumulative sum) of the numbers.',
    setup: 'const numbers = [1, 2, 3, 4, 5];',
    setupCode: 'const numbers = [1, 2, 3, 4, 5];',
    expected: [1, 3, 6, 10, 15],
    sample: 'numbers.reduce((acc, n) => [...acc, (acc[acc.length - 1] || 0) + n], [])',
    hints: [
      'Build an array as the accumulator',
      'Each new element is sum of last element plus current',
    ],
    validPatterns: [
      /\.reduce\s*\([^)]*acc\[acc\.length\s*-\s*1\][^)]*\)/,
      /\.map\s*\([^)]*slice\s*\([^)]*reduce/,
    ],
    tags: ['reduce', 'running-total', 'cumulative', 'accumulator'],
  },
  {
    id: 'js-arr-adv-021',
    category: 'Advanced Array Manipulation',
    difficulty: 'hard',
    title: 'Group and Aggregate',
    text: 'Group orders by customer and calculate total spent per customer.',
    setup: `const orders = [
  { customer: "Alice", amount: 50 },
  { customer: "Bob", amount: 30 },
  { customer: "Alice", amount: 25 },
  { customer: "Charlie", amount: 100 },
  { customer: "Bob", amount: 45 }
];`,
    setupCode: `const orders = [
  { customer: "Alice", amount: 50 },
  { customer: "Bob", amount: 30 },
  { customer: "Alice", amount: 25 },
  { customer: "Charlie", amount: 100 },
  { customer: "Bob", amount: 45 }
];`,
    expected: { Alice: 75, Bob: 75, Charlie: 100 },
    sample: `orders.reduce((totals, { customer, amount }) => ({
  ...totals,
  [customer]: (totals[customer] || 0) + amount
}), {})`,
    hints: [
      'Use reduce with object accumulator',
      'Destructure customer and amount in callback',
      'Add to existing total or start from 0',
    ],
    validPatterns: [
      /\.reduce\s*\([^)]*customer[^)]*amount[^)]*\)/,
    ],
    tags: ['reduce', 'grouping', 'aggregation', 'destructuring'],
  },
  {
    id: 'js-arr-adv-022',
    category: 'Advanced Array Manipulation',
    difficulty: 'hard',
    title: 'Complex Pipeline Transformation',
    text: 'Filter active users, group by role, and count users per role.',
    setup: `const users = [
  { name: "Alice", role: "admin", active: true },
  { name: "Bob", role: "user", active: false },
  { name: "Charlie", role: "admin", active: true },
  { name: "Diana", role: "user", active: true },
  { name: "Eve", role: "moderator", active: true },
  { name: "Frank", role: "user", active: true }
];`,
    setupCode: `const users = [
  { name: "Alice", role: "admin", active: true },
  { name: "Bob", role: "user", active: false },
  { name: "Charlie", role: "admin", active: true },
  { name: "Diana", role: "user", active: true },
  { name: "Eve", role: "moderator", active: true },
  { name: "Frank", role: "user", active: true }
];`,
    expected: { admin: 2, user: 2, moderator: 1 },
    sample: `users
  .filter(u => u.active)
  .reduce((counts, { role }) => ({
    ...counts,
    [role]: (counts[role] || 0) + 1
  }), {})`,
    hints: [
      'First filter for active users',
      'Then reduce to count by role',
      'Use destructuring to extract role',
    ],
    validPatterns: [
      /\.filter\s*\([^)]+\)\s*\.reduce\s*\([^)]*role[^)]*\)/,
    ],
    tags: ['filter', 'reduce', 'grouping', 'counting', 'pipeline'],
  },
  {
    id: 'js-arr-adv-023',
    category: 'Advanced Array Manipulation',
    difficulty: 'hard',
    title: 'Intersection of Multiple Arrays',
    text: 'Find elements that exist in all three arrays.',
    setup: `const arr1 = [1, 2, 3, 4, 5];
const arr2 = [2, 3, 4, 5, 6];
const arr3 = [3, 4, 5, 6, 7];
const arrays = [arr1, arr2, arr3];`,
    setupCode: `const arr1 = [1, 2, 3, 4, 5];
const arr2 = [2, 3, 4, 5, 6];
const arr3 = [3, 4, 5, 6, 7];
const arrays = [arr1, arr2, arr3];`,
    expected: [3, 4, 5],
    sample: 'arrays.reduce((common, arr) => common.filter(x => arr.includes(x)))',
    hints: [
      'Use reduce to progressively filter common elements',
      'Start with first array and filter against subsequent arrays',
    ],
    validPatterns: [
      /\.reduce\s*\([^)]*\.filter\s*\([^)]*\.includes\s*\([^)]*\)\s*\)/,
    ],
    tags: ['reduce', 'filter', 'includes', 'intersection', 'sets'],
  },
  {
    id: 'js-arr-adv-024',
    category: 'Advanced Array Manipulation',
    difficulty: 'hard',
    title: 'Transpose 2D Array',
    text: 'Transpose the matrix (swap rows and columns).',
    setup: `const matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];`,
    setupCode: `const matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];`,
    expected: [
      [1, 4, 7],
      [2, 5, 8],
      [3, 6, 9],
    ],
    sample: 'matrix[0].map((_, colIdx) => matrix.map(row => row[colIdx]))',
    hints: [
      'Map over column indices',
      'For each column, collect elements from each row',
    ],
    validPatterns: [
      /\.map\s*\([^)]*colIdx[^)]*\)\s*=>\s*\w+\.map\s*\([^)]*\[\s*colIdx\s*\]/,
      /\.map\s*\(\s*\(\s*_\s*,\s*\w+\s*\)\s*=>[^)]*\.map/,
    ],
    tags: ['map', 'matrix', 'transpose', '2d-array'],
  },
  {
    id: 'js-arr-adv-025',
    category: 'Advanced Array Manipulation',
    difficulty: 'hard',
    title: 'Complex Sort with Null Handling',
    text: 'Sort products by price (ascending), with null prices at the end, then by name.',
    setup: `const products = [
  { name: "Banana", price: null },
  { name: "Apple", price: 1.5 },
  { name: "Cherry", price: 3.0 },
  { name: "Date", price: null },
  { name: "Elderberry", price: 1.5 }
];`,
    setupCode: `const products = [
  { name: "Banana", price: null },
  { name: "Apple", price: 1.5 },
  { name: "Cherry", price: 3.0 },
  { name: "Date", price: null },
  { name: "Elderberry", price: 1.5 }
];`,
    expected: [
      { name: 'Apple', price: 1.5 },
      { name: 'Elderberry', price: 1.5 },
      { name: 'Cherry', price: 3.0 },
      { name: 'Banana', price: null },
      { name: 'Date', price: null },
    ],
    sample: `products.sort((a, b) => {
  if (a.price === null && b.price === null) return a.name.localeCompare(b.name);
  if (a.price === null) return 1;
  if (b.price === null) return -1;
  return a.price - b.price || a.name.localeCompare(b.name);
})`,
    hints: [
      'Handle null cases first',
      'Return 1 to push null to end',
      'Chain price comparison with name comparison',
    ],
    validPatterns: [
      /\.sort\s*\([^)]*null[^)]*\)/,
      /\.sort\s*\([^)]*===\s*null[^)]*localeCompare/,
    ],
    tags: ['sort', 'null-handling', 'localeCompare', 'complex-sort'],
  },

  // ========================================
  // MAP AND SET OPERATIONS
  // ========================================
  {
    id: 'js-map-set-001',
    category: 'Map and Set',
    difficulty: 'easy',
    title: 'Create and Populate a Map',
    text: 'Create a Map from the given key-value pairs and retrieve the value for "apple".',
    setup: `const entries = [["apple", 3], ["banana", 5], ["orange", 2]];`,
    setupCode: `const entries = [["apple", 3], ["banana", 5], ["orange", 2]];`,
    expected: 3,
    sample: 'new Map(entries).get("apple")',
    hints: ['Map constructor accepts an array of [key, value] pairs', 'Use get() to retrieve values'],
    validPatterns: [
      /new\s+Map\s*\(\s*entries\s*\)\.get\s*\(\s*['"]apple['"]\s*\)/,
    ],
    tags: ['Map', 'get', 'constructor', 'basics'],
  },
  {
    id: 'js-map-set-002',
    category: 'Map and Set',
    difficulty: 'easy',
    title: 'Check Map Key Existence',
    text: 'Check if the Map has the key "grape".',
    setup: `const fruitMap = new Map([["apple", 3], ["banana", 5], ["orange", 2]]);`,
    setupCode: `const fruitMap = new Map([["apple", 3], ["banana", 5], ["orange", 2]]);`,
    expected: false,
    sample: 'fruitMap.has("grape")',
    hints: ['has() returns a boolean', 'Returns true if key exists, false otherwise'],
    validPatterns: [
      /fruitMap\.has\s*\(\s*['"]grape['"]\s*\)/,
    ],
    tags: ['Map', 'has', 'existence-check', 'basics'],
  },
  {
    id: 'js-map-set-003',
    category: 'Map and Set',
    difficulty: 'easy',
    title: 'Get Map Size',
    text: 'Get the number of entries in the Map.',
    setup: `const colors = new Map([["red", "#FF0000"], ["green", "#00FF00"], ["blue", "#0000FF"]]);`,
    setupCode: `const colors = new Map([["red", "#FF0000"], ["green", "#00FF00"], ["blue", "#0000FF"]]);`,
    expected: 3,
    sample: 'colors.size',
    hints: ['Use the size property, not length', 'size is a property, not a method'],
    validPatterns: [
      /colors\.size/,
    ],
    tags: ['Map', 'size', 'property', 'basics'],
  },
  {
    id: 'js-map-set-004',
    category: 'Map and Set',
    difficulty: 'easy',
    title: 'Create Set for Deduplication',
    text: 'Remove duplicates from the array using a Set and convert back to an array.',
    setup: `const numbers = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5];`,
    setupCode: `const numbers = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5];`,
    expected: [1, 2, 3, 4, 5],
    sample: '[...new Set(numbers)]',
    hints: ['Set automatically removes duplicates', 'Use spread operator to convert Set to array'],
    validPatterns: [
      /\[\s*\.\.\.new\s+Set\s*\(\s*numbers\s*\)\s*\]/,
      /Array\.from\s*\(\s*new\s+Set\s*\(\s*numbers\s*\)\s*\)/,
    ],
    tags: ['Set', 'deduplication', 'spread', 'basics'],
  },
  {
    id: 'js-map-set-005',
    category: 'Map and Set',
    difficulty: 'easy',
    title: 'Set Add and Check',
    text: 'Add "mango" to the set and check if it exists.',
    setup: `const fruits = new Set(["apple", "banana", "orange"]);`,
    setupCode: `const fruits = new Set(["apple", "banana", "orange"]);`,
    expected: true,
    sample: 'fruits.add("mango").has("mango")',
    hints: ['add() returns the Set itself (chainable)', 'has() checks for existence'],
    validPatterns: [
      /fruits\.add\s*\(\s*['"]mango['"]\s*\)\.has\s*\(\s*['"]mango['"]\s*\)/,
      /fruits\.add\s*\(\s*['"]mango['"]\s*\)\s*[,;]?\s*fruits\.has\s*\(\s*['"]mango['"]\s*\)/,
    ],
    tags: ['Set', 'add', 'has', 'chaining'],
  },
  {
    id: 'js-map-set-006',
    category: 'Map and Set',
    difficulty: 'easy',
    title: 'Delete from Set',
    text: 'Delete "banana" from the set and return the result of the delete operation.',
    setup: `const fruits = new Set(["apple", "banana", "orange"]);`,
    setupCode: `const fruits = new Set(["apple", "banana", "orange"]);`,
    expected: true,
    sample: 'fruits.delete("banana")',
    hints: ['delete() returns true if element was present', 'Returns false if element was not in Set'],
    validPatterns: [
      /fruits\.delete\s*\(\s*['"]banana['"]\s*\)/,
    ],
    tags: ['Set', 'delete', 'mutation', 'basics'],
  },
  {
    id: 'js-map-set-007',
    category: 'Map and Set',
    difficulty: 'easy',
    title: 'Convert Map to Array of Entries',
    text: 'Convert the Map to an array of [key, value] pairs.',
    setup: `const userAges = new Map([["Alice", 25], ["Bob", 30], ["Charlie", 35]]);`,
    setupCode: `const userAges = new Map([["Alice", 25], ["Bob", 30], ["Charlie", 35]]);`,
    expected: [['Alice', 25], ['Bob', 30], ['Charlie', 35]],
    sample: '[...userAges.entries()]',
    hints: ['entries() returns an iterator of [key, value] pairs', 'Spread or Array.from to convert to array'],
    validPatterns: [
      /\[\s*\.\.\.userAges\.entries\s*\(\s*\)\s*\]/,
      /\[\s*\.\.\.userAges\s*\]/,
      /Array\.from\s*\(\s*userAges\.entries\s*\(\s*\)\s*\)/,
      /Array\.from\s*\(\s*userAges\s*\)/,
    ],
    tags: ['Map', 'entries', 'array-conversion', 'iterator'],
  },
  {
    id: 'js-map-set-008',
    category: 'Map and Set',
    difficulty: 'easy',
    title: 'Get Map Keys as Array',
    text: 'Get all keys from the Map as an array.',
    setup: `const inventory = new Map([["apples", 50], ["bananas", 30], ["oranges", 45]]);`,
    setupCode: `const inventory = new Map([["apples", 50], ["bananas", 30], ["oranges", 45]]);`,
    expected: ['apples', 'bananas', 'oranges'],
    sample: '[...inventory.keys()]',
    hints: ['keys() returns an iterator', 'Use spread or Array.from to convert'],
    validPatterns: [
      /\[\s*\.\.\.inventory\.keys\s*\(\s*\)\s*\]/,
      /Array\.from\s*\(\s*inventory\.keys\s*\(\s*\)\s*\)/,
    ],
    tags: ['Map', 'keys', 'array-conversion', 'iterator'],
  },
  {
    id: 'js-map-set-009',
    category: 'Map and Set',
    difficulty: 'medium',
    title: 'Map forEach Iteration',
    text: 'Use forEach to sum all values in the Map.',
    setup: `const scores = new Map([["Alice", 85], ["Bob", 92], ["Charlie", 78]]);
let total = 0;`,
    setupCode: `const scores = new Map([["Alice", 85], ["Bob", 92], ["Charlie", 78]]);
let total = 0;`,
    expected: 255,
    sample: 'scores.forEach(value => total += value); total',
    hints: ['forEach callback receives (value, key, map)', 'Accumulate values into total variable'],
    validPatterns: [
      /scores\.forEach\s*\(\s*\(?value\)?\s*=>\s*total\s*\+=\s*value\s*\)/,
      /scores\.forEach\s*\(\s*\(\s*\w+\s*\)\s*=>\s*\{\s*total\s*\+=\s*\w+/,
    ],
    tags: ['Map', 'forEach', 'iteration', 'accumulator'],
  },
  {
    id: 'js-map-set-010',
    category: 'Map and Set',
    difficulty: 'medium',
    title: 'Object to Map Conversion',
    text: 'Convert the object to a Map.',
    setup: `const person = { name: "Alice", age: 30, city: "NYC" };`,
    setupCode: `const person = { name: "Alice", age: 30, city: "NYC" };`,
    expected: 'Map(3) {"name" => "Alice", "age" => 30, "city" => "NYC"}',
    sample: 'new Map(Object.entries(person))',
    hints: ['Object.entries returns [key, value] pairs', 'Map constructor accepts arrays of pairs'],
    validPatterns: [
      /new\s+Map\s*\(\s*Object\.entries\s*\(\s*person\s*\)\s*\)/,
    ],
    tags: ['Map', 'Object.entries', 'conversion', 'interop'],
  },
  {
    id: 'js-map-set-011',
    category: 'Map and Set',
    difficulty: 'medium',
    title: 'Map to Object Conversion',
    text: 'Convert the Map to a plain object.',
    setup: `const userMap = new Map([["name", "Bob"], ["age", 25], ["role", "admin"]]);`,
    setupCode: `const userMap = new Map([["name", "Bob"], ["age", 25], ["role", "admin"]]);`,
    expected: { name: 'Bob', age: 25, role: 'admin' },
    sample: 'Object.fromEntries(userMap)',
    hints: ['Object.fromEntries accepts iterables of [key, value] pairs', 'Map is iterable as [key, value] pairs'],
    validPatterns: [
      /Object\.fromEntries\s*\(\s*userMap\s*\)/,
      /Object\.fromEntries\s*\(\s*userMap\.entries\s*\(\s*\)\s*\)/,
    ],
    tags: ['Map', 'Object.fromEntries', 'conversion', 'interop'],
  },
  {
    id: 'js-map-set-012',
    category: 'Map and Set',
    difficulty: 'medium',
    title: 'Map as Cache Pattern',
    text: 'Use the Map as a cache: return cached value if exists, otherwise compute, store, and return.',
    setup: `const cache = new Map();
const key = "result";
const computeValue = () => 42;`,
    setupCode: `const cache = new Map();
const key = "result";
const computeValue = () => 42;`,
    expected: 42,
    sample: 'cache.has(key) ? cache.get(key) : cache.set(key, computeValue()).get(key)',
    hints: ['Check with has() before getting', 'set() returns the Map, allowing chaining with get()'],
    validPatterns: [
      /cache\.has\s*\(\s*key\s*\)\s*\?\s*cache\.get\s*\(\s*key\s*\)\s*:\s*cache\.set/,
      /cache\.get\s*\(\s*key\s*\)\s*\?\?\s*cache\.set\s*\([^)]+\)\.get\s*\(\s*key\s*\)/,
    ],
    tags: ['Map', 'cache', 'memoization', 'pattern'],
  },
  {
    id: 'js-map-set-013',
    category: 'Map and Set',
    difficulty: 'medium',
    title: 'Set Iteration with for...of',
    text: 'Iterate over the Set and create an array of uppercase strings.',
    setup: `const words = new Set(["hello", "world", "javascript"]);`,
    setupCode: `const words = new Set(["hello", "world", "javascript"]);`,
    expected: ['HELLO', 'WORLD', 'JAVASCRIPT'],
    sample: '[...words].map(w => w.toUpperCase())',
    hints: ['Convert Set to array first', 'Then use map for transformation'],
    validPatterns: [
      /\[\s*\.\.\.words\s*\]\.map\s*\(\s*\w+\s*=>\s*\w+\.toUpperCase\s*\(\s*\)\s*\)/,
      /Array\.from\s*\(\s*words\s*,\s*\w+\s*=>\s*\w+\.toUpperCase\s*\(\s*\)\s*\)/,
    ],
    tags: ['Set', 'iteration', 'map', 'transformation'],
  },
  {
    id: 'js-map-set-014',
    category: 'Map and Set',
    difficulty: 'medium',
    title: 'Count Unique Values',
    text: 'Count how many unique characters are in the string.',
    setup: `const str = "abracadabra";`,
    setupCode: `const str = "abracadabra";`,
    expected: 5,
    sample: 'new Set(str).size',
    hints: ['Strings are iterable', 'Set constructor accepts any iterable'],
    validPatterns: [
      /new\s+Set\s*\(\s*str\s*\)\.size/,
      /new\s+Set\s*\(\s*str\.split\s*\(\s*['"]{2}\s*\)\s*\)\.size/,
    ],
    tags: ['Set', 'size', 'unique', 'strings'],
  },
  {
    id: 'js-map-set-015',
    category: 'Map and Set',
    difficulty: 'medium',
    title: 'Map vs Object - Non-String Keys',
    text: 'Create a Map with object keys and retrieve a value using an object key.',
    setup: `const user1 = { id: 1 };
const user2 = { id: 2 };
const userScores = new Map([[user1, 100], [user2, 200]]);`,
    setupCode: `const user1 = { id: 1 };
const user2 = { id: 2 };
const userScores = new Map([[user1, 100], [user2, 200]]);`,
    expected: 100,
    sample: 'userScores.get(user1)',
    hints: ['Maps can use any value as keys', 'Object references work as Map keys'],
    validPatterns: [
      /userScores\.get\s*\(\s*user1\s*\)/,
    ],
    tags: ['Map', 'object-keys', 'reference', 'comparison'],
  },
  {
    id: 'js-map-set-016',
    category: 'Map and Set',
    difficulty: 'medium',
    title: 'Set Union with Spread',
    text: 'Create a union of two Sets (combine all unique elements).',
    setup: `const set1 = new Set([1, 2, 3, 4]);
const set2 = new Set([3, 4, 5, 6]);`,
    setupCode: `const set1 = new Set([1, 2, 3, 4]);
const set2 = new Set([3, 4, 5, 6]);`,
    expected: [1, 2, 3, 4, 5, 6],
    sample: '[...new Set([...set1, ...set2])]',
    hints: ['Spread both Sets into an array', 'Create new Set to remove duplicates'],
    validPatterns: [
      /\[\s*\.\.\.new\s+Set\s*\(\s*\[\s*\.\.\.set1\s*,\s*\.\.\.set2\s*\]\s*\)\s*\]/,
    ],
    tags: ['Set', 'union', 'spread', 'combination'],
  },
  {
    id: 'js-map-set-017',
    category: 'Map and Set',
    difficulty: 'medium',
    title: 'Set Intersection',
    text: 'Find elements that exist in both Sets.',
    setup: `const setA = new Set([1, 2, 3, 4, 5]);
const setB = new Set([4, 5, 6, 7, 8]);`,
    setupCode: `const setA = new Set([1, 2, 3, 4, 5]);
const setB = new Set([4, 5, 6, 7, 8]);`,
    expected: [4, 5],
    sample: '[...setA].filter(x => setB.has(x))',
    hints: ['Convert one Set to array', 'Filter elements that exist in other Set'],
    validPatterns: [
      /\[\s*\.\.\.setA\s*\]\.filter\s*\(\s*\w+\s*=>\s*setB\.has\s*\(\s*\w+\s*\)\s*\)/,
    ],
    tags: ['Set', 'intersection', 'filter', 'has'],
  },
  {
    id: 'js-map-set-018',
    category: 'Map and Set',
    difficulty: 'medium',
    title: 'Map Transformation with Array Methods',
    text: 'Double all values in the Map and return as a new Map.',
    setup: `const numbers = new Map([["a", 1], ["b", 2], ["c", 3]]);`,
    setupCode: `const numbers = new Map([["a", 1], ["b", 2], ["c", 3]]);`,
    expected: 'Map(3) {"a" => 2, "b" => 4, "c" => 6}',
    sample: 'new Map([...numbers].map(([k, v]) => [k, v * 2]))',
    hints: ['Spread Map to array of entries', 'Map over entries and transform values', 'Create new Map from result'],
    validPatterns: [
      /new\s+Map\s*\(\s*\[\s*\.\.\.numbers\s*\]\.map\s*\(\s*\[\s*\w+\s*,\s*\w+\s*\]\s*=>\s*\[\s*\w+\s*,\s*\w+\s*\*\s*2\s*\]\s*\)\s*\)/,
    ],
    tags: ['Map', 'transformation', 'array-methods', 'spread'],
  },
  {
    id: 'js-map-set-019',
    category: 'Map and Set',
    difficulty: 'medium',
    title: 'WeakMap for Private Data',
    text: 'Store private data using WeakMap. Get the private name for the user object.',
    setup: `const privateData = new WeakMap();
const user = { id: 1 };
privateData.set(user, { name: "Secret Alice" });`,
    setupCode: `const privateData = new WeakMap();
const user = { id: 1 };
privateData.set(user, { name: "Secret Alice" });`,
    expected: 'Secret Alice',
    sample: 'privateData.get(user).name',
    hints: ['WeakMap uses object references as keys', 'get() retrieves the stored value'],
    validPatterns: [
      /privateData\.get\s*\(\s*user\s*\)\.name/,
    ],
    tags: ['WeakMap', 'private-data', 'encapsulation', 'pattern'],
  },
  {
    id: 'js-map-set-020',
    category: 'Map and Set',
    difficulty: 'medium',
    title: 'Filter Map Entries',
    text: 'Filter the Map to only include entries where value is greater than 50.',
    setup: `const scores = new Map([["Alice", 85], ["Bob", 42], ["Charlie", 91], ["Diana", 38]]);`,
    setupCode: `const scores = new Map([["Alice", 85], ["Bob", 42], ["Charlie", 91], ["Diana", 38]]);`,
    expected: 'Map(2) {"Alice" => 85, "Charlie" => 91}',
    sample: 'new Map([...scores].filter(([k, v]) => v > 50))',
    hints: ['Convert Map to array of entries', 'Filter entries by value', 'Create new Map from filtered entries'],
    validPatterns: [
      /new\s+Map\s*\(\s*\[\s*\.\.\.scores\s*\]\.filter\s*\(\s*\[\s*\w+\s*,\s*\w+\s*\]\s*=>\s*\w+\s*>\s*50\s*\)\s*\)/,
    ],
    tags: ['Map', 'filter', 'destructuring', 'transformation'],
  },
  {
    id: 'js-map-set-021',
    category: 'Map and Set',
    difficulty: 'hard',
    title: 'Group Array into Map',
    text: 'Group the items array by category into a Map.',
    setup: `const items = [
  { name: "Apple", category: "fruit" },
  { name: "Carrot", category: "vegetable" },
  { name: "Banana", category: "fruit" },
  { name: "Broccoli", category: "vegetable" },
  { name: "Cherry", category: "fruit" }
];`,
    setupCode: `const items = [
  { name: "Apple", category: "fruit" },
  { name: "Carrot", category: "vegetable" },
  { name: "Banana", category: "fruit" },
  { name: "Broccoli", category: "vegetable" },
  { name: "Cherry", category: "fruit" }
];`,
    expected: 'Map(2) {"fruit" => [...3 items], "vegetable" => [...2 items]}',
    sample: `items.reduce((map, item) => {
  const group = map.get(item.category) || [];
  group.push(item);
  return map.set(item.category, group);
}, new Map())`,
    hints: ['Use reduce with Map as accumulator', 'Get existing group or create empty array', 'set() returns the Map for chaining'],
    validPatterns: [
      /\.reduce\s*\(\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=>[^)]*\.set\s*\([^)]+\)\s*,\s*new\s+Map\s*\(\s*\)\s*\)/,
    ],
    tags: ['Map', 'reduce', 'grouping', 'accumulator'],
  },
  {
    id: 'js-map-set-022',
    category: 'Map and Set',
    difficulty: 'hard',
    title: 'Memoization with Map',
    text: 'Create a memoized factorial function using Map as cache. Calculate factorial of 5.',
    setup: `const cache = new Map();
const factorial = n => {
  if (n <= 1) return 1;
  if (cache.has(n)) return cache.get(n);
  const result = n * factorial(n - 1);
  cache.set(n, result);
  return result;
};`,
    setupCode: `const cache = new Map();
const factorial = n => {
  if (n <= 1) return 1;
  if (cache.has(n)) return cache.get(n);
  const result = n * factorial(n - 1);
  cache.set(n, result);
  return result;
};`,
    expected: 120,
    sample: 'factorial(5)',
    hints: ['Call the memoized function', 'Cache stores computed results'],
    validPatterns: [
      /factorial\s*\(\s*5\s*\)/,
    ],
    tags: ['Map', 'memoization', 'cache', 'recursion'],
  },
  {
    id: 'js-map-set-023',
    category: 'Map and Set',
    difficulty: 'hard',
    title: 'WeakSet for Visited Tracking',
    text: 'Check if the user object has been visited. Mark as visited and check again.',
    setup: `const visited = new WeakSet();
const user = { id: 1, name: "Alice" };`,
    setupCode: `const visited = new WeakSet();
const user = { id: 1, name: "Alice" };`,
    expected: [false, true],
    sample: '[visited.has(user), (visited.add(user), visited.has(user))]',
    hints: ['WeakSet tracks object references', 'add() returns the WeakSet', 'Check before and after adding'],
    validPatterns: [
      /\[\s*visited\.has\s*\(\s*user\s*\)\s*,\s*\(\s*visited\.add\s*\(\s*user\s*\)\s*,\s*visited\.has\s*\(\s*user\s*\)\s*\)\s*\]/,
    ],
    tags: ['WeakSet', 'tracking', 'has', 'add'],
  },
  {
    id: 'js-map-set-024',
    category: 'Map and Set',
    difficulty: 'hard',
    title: 'Merge Multiple Maps',
    text: 'Merge three Maps into one, with later Maps overwriting earlier values for duplicate keys.',
    setup: `const map1 = new Map([["a", 1], ["b", 2]]);
const map2 = new Map([["b", 3], ["c", 4]]);
const map3 = new Map([["c", 5], ["d", 6]]);`,
    setupCode: `const map1 = new Map([["a", 1], ["b", 2]]);
const map2 = new Map([["b", 3], ["c", 4]]);
const map3 = new Map([["c", 5], ["d", 6]]);`,
    expected: 'Map(4) {"a" => 1, "b" => 3, "c" => 5, "d" => 6}',
    sample: 'new Map([...map1, ...map2, ...map3])',
    hints: ['Spread all Maps into a single array', 'Later entries overwrite earlier ones', 'Map constructor deduplicates by key'],
    validPatterns: [
      /new\s+Map\s*\(\s*\[\s*\.\.\.map1\s*,\s*\.\.\.map2\s*,\s*\.\.\.map3\s*\]\s*\)/,
    ],
    tags: ['Map', 'merge', 'spread', 'overwrite'],
  },
  {
    id: 'js-map-set-025',
    category: 'Map and Set',
    difficulty: 'hard',
    title: 'Symmetric Difference of Sets',
    text: 'Find elements that are in either Set but not in both (symmetric difference).',
    setup: `const setX = new Set([1, 2, 3, 4, 5]);
const setY = new Set([4, 5, 6, 7, 8]);`,
    setupCode: `const setX = new Set([1, 2, 3, 4, 5]);
const setY = new Set([4, 5, 6, 7, 8]);`,
    expected: [1, 2, 3, 6, 7, 8],
    sample: '[...new Set([...[...setX].filter(x => !setY.has(x)), ...[...setY].filter(x => !setX.has(x))])]',
    hints: ['Find elements in X not in Y', 'Find elements in Y not in X', 'Combine both results'],
    validPatterns: [
      /\[\s*\.\.\.\[\s*\.\.\.setX\s*\]\.filter[\s\S]*\.\.\.\[\s*\.\.\.setY\s*\]\.filter/,
      /filter\s*\(\s*\w+\s*=>\s*!set[XY]\.has\s*\(\s*\w+\s*\)\s*\)/,
    ],
    tags: ['Set', 'symmetric-difference', 'filter', 'has'],
  },

  // ========================================
  // STRING MANIPULATION - Advanced
  // ========================================
  {
    id: 'js-str-001',
    category: 'String Manipulation',
    difficulty: 'easy',
    title: 'Template Literal Basics',
    text: 'Use a template literal to create a greeting message combining name and age.',
    setup: `const name = "Alice";
const age = 25;`,
    setupCode: `const name = "Alice";
const age = 25;`,
    expected: 'Hello, Alice! You are 25 years old.',
    sample: '`Hello, ${name}! You are ${age} years old.`',
    hints: ['Use backticks for template literals', 'Use ${} for interpolation'],
    validPatterns: [/`.*\$\{name\}.*\$\{age\}.*`/, /`.*\$\{age\}.*\$\{name\}.*`/],
    tags: ['template-literal', 'interpolation', 'basics'],
  },
  {
    id: 'js-str-002',
    category: 'String Manipulation',
    difficulty: 'easy',
    title: 'Multi-line Template Literal',
    text: 'Create a multi-line string using template literals.',
    setup: `const title = "Report";
const date = "2024-01-15";`,
    setupCode: `const title = "Report";
const date = "2024-01-15";`,
    expected: `Title: Report
Date: 2024-01-15`,
    sample: '`Title: ${title}\\nDate: ${date}`',
    hints: ['Template literals preserve newlines', 'Or use \\n for explicit newlines'],
    validPatterns: [/`.*\$\{title\}[\s\S]*\$\{date\}.*`/],
    tags: ['template-literal', 'multiline', 'basics'],
  },
  {
    id: 'js-str-003',
    category: 'String Manipulation',
    difficulty: 'easy',
    title: 'String padStart',
    text: 'Pad the number string to 5 characters with leading zeros.',
    setup: 'const num = "42";',
    setupCode: 'const num = "42";',
    expected: '00042',
    sample: 'num.padStart(5, "0")',
    hints: ['padStart adds padding to the beginning', 'First arg is target length'],
    validPatterns: [/\.padStart\s*\(\s*5\s*,\s*['"]0['"]\s*\)/],
    tags: ['padStart', 'formatting', 'basics'],
  },
  {
    id: 'js-str-004',
    category: 'String Manipulation',
    difficulty: 'easy',
    title: 'String padEnd',
    text: 'Pad the text to 10 characters with dots at the end.',
    setup: 'const label = "Price";',
    setupCode: 'const label = "Price";',
    expected: 'Price.....',
    sample: 'label.padEnd(10, ".")',
    hints: ['padEnd adds padding to the end', 'Creates fixed-width output'],
    validPatterns: [/\.padEnd\s*\(\s*10\s*,\s*['"]\.?['"]\s*\)/],
    tags: ['padEnd', 'formatting', 'basics'],
  },
  {
    id: 'js-str-005',
    category: 'String Manipulation',
    difficulty: 'easy',
    title: 'trimStart and trimEnd',
    text: 'Remove only the leading whitespace from the string.',
    setup: 'const text = "   Hello World   ";',
    setupCode: 'const text = "   Hello World   ";',
    expected: 'Hello World   ',
    sample: 'text.trimStart()',
    hints: ['trimStart removes leading whitespace only', 'trimEnd removes trailing only'],
    validPatterns: [/\.trimStart\s*\(\s*\)/, /\.trimLeft\s*\(\s*\)/],
    tags: ['trimStart', 'whitespace', 'basics'],
  },
  {
    id: 'js-str-006',
    category: 'String Manipulation',
    difficulty: 'easy',
    title: 'URL Encoding',
    text: 'Encode the URL parameter for safe transmission.',
    setup: 'const param = "hello world & more";',
    setupCode: 'const param = "hello world & more";',
    expected: 'hello%20world%20%26%20more',
    sample: 'encodeURIComponent(param)',
    hints: ['encodeURIComponent encodes special characters', 'Safe for URL query parameters'],
    validPatterns: [/encodeURIComponent\s*\(\s*param\s*\)/],
    tags: ['url-encoding', 'encodeURIComponent', 'basics'],
  },
  {
    id: 'js-str-007',
    category: 'String Manipulation',
    difficulty: 'easy',
    title: 'URL Decoding',
    text: 'Decode the URL-encoded string back to readable text.',
    setup: 'const encoded = "hello%20world%20%26%20more";',
    setupCode: 'const encoded = "hello%20world%20%26%20more";',
    expected: 'hello world & more',
    sample: 'decodeURIComponent(encoded)',
    hints: ['decodeURIComponent reverses encoding', 'Converts %20 back to spaces'],
    validPatterns: [/decodeURIComponent\s*\(\s*encoded\s*\)/],
    tags: ['url-decoding', 'decodeURIComponent', 'basics'],
  },
  {
    id: 'js-str-008',
    category: 'String Manipulation',
    difficulty: 'easy',
    title: 'Base64 Encoding',
    text: 'Encode the text string to Base64.',
    setup: 'const text = "Hello World";',
    setupCode: 'const text = "Hello World";',
    expected: 'SGVsbG8gV29ybGQ=',
    sample: 'btoa(text)',
    hints: ['btoa encodes to Base64', 'Only works with ASCII characters'],
    validPatterns: [/btoa\s*\(\s*text\s*\)/],
    tags: ['base64', 'encoding', 'basics'],
  },
  {
    id: 'js-str-009',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Regex Match All Occurrences',
    text: 'Extract all numbers from the string using matchAll.',
    setup: 'const text = "Order 123 shipped on day 45 with 7 items";',
    setupCode: 'const text = "Order 123 shipped on day 45 with 7 items";',
    expected: ['123', '45', '7'],
    sample: '[...text.matchAll(/\\d+/g)].map(m => m[0])',
    hints: ['matchAll returns an iterator', 'Spread or Array.from to convert', 'Need global flag /g'],
    validPatterns: [/\.matchAll\s*\(\s*\/\\d\+\/g\s*\)/, /\[\.\.\..*matchAll/],
    tags: ['matchAll', 'regex', 'extraction'],
  },
  {
    id: 'js-str-010',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Replace with Function',
    text: 'Replace all numbers with their doubled values using a replacement function.',
    setup: 'const prices = "Apple: $5, Banana: $3, Orange: $4";',
    setupCode: 'const prices = "Apple: $5, Banana: $3, Orange: $4";',
    expected: 'Apple: $10, Banana: $6, Orange: $8',
    sample: 'prices.replace(/\\d+/g, match => String(Number(match) * 2))',
    hints: ['replace accepts a function as second argument', 'Function receives matched text'],
    validPatterns: [/\.replace\s*\(\s*\/\\d\+\/g\s*,\s*\w*\s*=>/],
    tags: ['replace', 'regex', 'function-callback'],
  },
  {
    id: 'js-str-011',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Tagged Template Literal',
    text: 'Create a tagged template that uppercases all interpolated values.',
    setup: `function upperTag(strings, ...values) {
  return strings.reduce((result, str, i) =>
    result + str + (values[i] !== undefined ? String(values[i]).toUpperCase() : ''), '');
}
const name = "alice";
const city = "paris";`,
    setupCode: `function upperTag(strings, ...values) {
  return strings.reduce((result, str, i) =>
    result + str + (values[i] !== undefined ? String(values[i]).toUpperCase() : ''), '');
}
const name = "alice";
const city = "paris";`,
    expected: 'Hello ALICE from PARIS!',
    sample: 'upperTag`Hello ${name} from ${city}!`',
    hints: ['Tagged templates use function before backticks', 'No parentheses needed'],
    validPatterns: [/upperTag\s*`.*\$\{name\}.*\$\{city\}.*`/],
    tags: ['tagged-template', 'template-literal', 'advanced'],
  },
  {
    id: 'js-str-012',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'String Iterator',
    text: 'Convert the string to an array of characters using the spread operator.',
    setup: 'const emoji = "Hello";',
    setupCode: 'const emoji = "Hello";',
    expected: ['H', 'e', 'l', 'l', 'o'],
    sample: '[...emoji]',
    hints: ['Strings are iterable', 'Spread operator iterates over characters'],
    validPatterns: [/\[\s*\.\.\.emoji\s*\]/, /Array\.from\s*\(\s*emoji\s*\)/],
    tags: ['spread', 'iterator', 'characters'],
  },
  {
    id: 'js-str-013',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Regex Capture Groups',
    text: 'Extract the area code and number from the phone string using capture groups.',
    setup: 'const phone = "(555) 123-4567";',
    setupCode: 'const phone = "(555) 123-4567";',
    expected: { areaCode: '555', number: '123-4567' },
    sample: 'const m = phone.match(/\\((\\d+)\\)\\s*(\\d+-\\d+)/); ({ areaCode: m[1], number: m[2] })',
    hints: ['Parentheses create capture groups', 'Access groups via array indices'],
    validPatterns: [/\.match\s*\(\s*\/.*\(.*\).*\/\s*\)/],
    tags: ['regex', 'capture-groups', 'extraction'],
  },
  {
    id: 'js-str-014',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Named Capture Groups',
    text: 'Extract date parts using named capture groups.',
    setup: 'const dateStr = "2024-01-15";',
    setupCode: 'const dateStr = "2024-01-15";',
    expected: { year: '2024', month: '01', day: '15' },
    sample: 'dateStr.match(/(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/).groups',
    hints: ['Use (?<name>...) for named groups', 'Access via .groups property'],
    validPatterns: [/\(\?<\w+>.*\)/, /\.groups/],
    tags: ['regex', 'named-groups', 'extraction'],
  },
  {
    id: 'js-str-015',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Intl.Collator String Comparison',
    text: 'Sort the names array alphabetically with proper locale handling.',
    setup: 'const names = ["Zebra", "apple", "Banana", "cherry"];',
    setupCode: 'const names = ["Zebra", "apple", "Banana", "cherry"];',
    expected: ['apple', 'Banana', 'cherry', 'Zebra'],
    sample: 'names.sort(new Intl.Collator("en", { sensitivity: "base" }).compare)',
    hints: ['Intl.Collator handles locale-aware sorting', 'sensitivity: base ignores case'],
    validPatterns: [/Intl\.Collator/, /\.sort\s*\(.*compare\s*\)/],
    tags: ['Intl.Collator', 'sorting', 'locale'],
  },
  {
    id: 'js-str-016',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Unicode Normalization',
    text: 'Normalize the string so that different representations of the same character are equal.',
    setup: `const str1 = "caf\\u00e9";  // e with acute
const str2 = "cafe\\u0301"; // e + combining acute`,
    setupCode: `const str1 = "caf\\u00e9";
const str2 = "cafe\\u0301";`,
    expected: true,
    sample: 'str1.normalize() === str2.normalize()',
    hints: ['normalize() standardizes Unicode representations', 'NFC form is default'],
    validPatterns: [/\.normalize\s*\(\s*\)/],
    tags: ['unicode', 'normalize', 'comparison'],
  },
  {
    id: 'js-str-017',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Template Literal Expression',
    text: 'Use a template literal to create a conditional message.',
    setup: `const score = 85;
const passingScore = 70;`,
    setupCode: `const score = 85;
const passingScore = 70;`,
    expected: 'You scored 85 - PASSED',
    sample: '`You scored ${score} - ${score >= passingScore ? "PASSED" : "FAILED"}`',
    hints: ['Template literals can contain any expression', 'Ternary operators work inside ${}'],
    validPatterns: [/`.*\$\{.*\?.*:.*\}.*`/],
    tags: ['template-literal', 'conditional', 'ternary'],
  },
  {
    id: 'js-str-018',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'String.raw for Escaped Strings',
    text: 'Use String.raw to preserve backslashes in the path string.',
    setup: 'const path = String.raw`C:\\Users\\Admin\\Documents`;',
    setupCode: 'const path = String.raw`C:\\Users\\Admin\\Documents`;',
    expected: 'C:\\Users\\Admin\\Documents',
    sample: 'path',
    hints: ['String.raw preserves escape sequences', 'Useful for file paths and regex'],
    validPatterns: [/String\.raw\s*`.*`/, /path/],
    tags: ['String.raw', 'escape-sequences', 'paths'],
  },
  {
    id: 'js-str-019',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Replace All with Regex',
    text: 'Replace all whitespace sequences with a single space.',
    setup: 'const messy = "Hello    World   JavaScript";',
    setupCode: 'const messy = "Hello    World   JavaScript";',
    expected: 'Hello World JavaScript',
    sample: 'messy.replace(/\\s+/g, " ")',
    hints: ['\\s+ matches one or more whitespace', 'Global flag replaces all'],
    validPatterns: [/\.replace\s*\(\s*\/\\s\+\/g\s*,\s*['"] ['"]\s*\)/],
    tags: ['replace', 'regex', 'whitespace'],
  },
  {
    id: 'js-str-020',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Base64 Decode',
    text: 'Decode the Base64 encoded string back to plain text.',
    setup: 'const encoded = "SGVsbG8gV29ybGQ=";',
    setupCode: 'const encoded = "SGVsbG8gV29ybGQ=";',
    expected: 'Hello World',
    sample: 'atob(encoded)',
    hints: ['atob decodes Base64', 'Reverse of btoa'],
    validPatterns: [/atob\s*\(\s*encoded\s*\)/],
    tags: ['base64', 'decoding', 'atob'],
  },
  {
    id: 'js-str-021',
    category: 'String Manipulation',
    difficulty: 'hard',
    title: 'Complex Replace with Callback',
    text: 'Transform camelCase to kebab-case using replace with a callback.',
    setup: 'const camelCase = "backgroundColor";',
    setupCode: 'const camelCase = "backgroundColor";',
    expected: 'background-color',
    sample: 'camelCase.replace(/[A-Z]/g, letter => `-${letter.toLowerCase()}`)',
    hints: ['Match uppercase letters', 'Prepend hyphen and lowercase'],
    validPatterns: [/\.replace\s*\(\s*\/\[A-Z\]\/g\s*,\s*\w*\s*=>/],
    tags: ['replace', 'regex', 'case-conversion'],
  },
  {
    id: 'js-str-022',
    category: 'String Manipulation',
    difficulty: 'hard',
    title: 'matchAll with Named Groups',
    text: 'Extract all key-value pairs from the CSS-like string using matchAll with named groups.',
    setup: 'const css = "color: red; font-size: 16px; margin: 10px;";',
    setupCode: 'const css = "color: red; font-size: 16px; margin: 10px;";',
    expected: [
      { property: 'color', value: 'red' },
      { property: 'font-size', value: '16px' },
      { property: 'margin', value: '10px' },
    ],
    sample: '[...css.matchAll(/(?<property>[\\w-]+):\\s*(?<value>[^;]+)/g)].map(m => ({ property: m.groups.property, value: m.groups.value }))',
    hints: ['Use named capture groups (?<name>...)', 'matchAll returns iterator with groups'],
    validPatterns: [/matchAll\s*\(\s*\/.*\(\?<\w+>.*\).*\/g\s*\)/],
    tags: ['matchAll', 'named-groups', 'parsing'],
  },
  {
    id: 'js-str-023',
    category: 'String Manipulation',
    difficulty: 'hard',
    title: 'Unicode-aware String Reversal',
    text: 'Reverse the string while properly handling emoji and combined characters.',
    setup: 'const text = "Hello";',
    setupCode: 'const text = "Hello";',
    expected: 'olleH',
    sample: '[...text].reverse().join("")',
    hints: ['Spread operator handles Unicode properly', 'split("") can break emoji'],
    validPatterns: [/\[\s*\.\.\.text\s*\]\.reverse\s*\(\s*\)\.join\s*\(\s*['"]['"]?\s*\)/],
    tags: ['unicode', 'reverse', 'spread'],
  },
  {
    id: 'js-str-024',
    category: 'String Manipulation',
    difficulty: 'hard',
    title: 'Lookahead and Lookbehind Assertions',
    text: 'Extract numbers that are followed by "px" but do not include "px" in the result.',
    setup: 'const css = "width: 100px; height: 50px; opacity: 0.5;";',
    setupCode: 'const css = "width: 100px; height: 50px; opacity: 0.5;";',
    expected: ['100', '50'],
    sample: 'css.match(/\\d+(?=px)/g)',
    hints: ['(?=px) is a positive lookahead', 'Matches position before px without consuming'],
    validPatterns: [/\.match\s*\(\s*\/\\d\+\(\?=px\)\/g\s*\)/],
    tags: ['regex', 'lookahead', 'assertions'],
  },
  {
    id: 'js-str-025',
    category: 'String Manipulation',
    difficulty: 'hard',
    title: 'Template Literal Tag for HTML Escaping',
    text: 'Use the htmlEscape tagged template to safely escape HTML entities.',
    setup: `function htmlEscape(strings, ...values) {
  const escape = str => String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
  return strings.reduce((result, str, i) =>
    result + str + (values[i] !== undefined ? escape(values[i]) : ''), '');
}
const userInput = '<script>alert("xss")</script>';`,
    setupCode: `function htmlEscape(strings, ...values) {
  const escape = str => String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
  return strings.reduce((result, str, i) =>
    result + str + (values[i] !== undefined ? escape(values[i]) : ''), '');
}
const userInput = '<script>alert("xss")</script>';`,
    expected: 'User said: &lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;',
    sample: 'htmlEscape`User said: ${userInput}`',
    hints: ['Tagged templates can transform interpolated values', 'Useful for security'],
    validPatterns: [/htmlEscape\s*`.*\$\{userInput\}.*`/],
    tags: ['tagged-template', 'security', 'html-escape'],
  },

  // ========================================
  // OBJECT MANIPULATION
  // ========================================
  // Easy (8 problems)
  {
    id: 'js-obj-001',
    category: 'Object Manipulation',
    difficulty: 'easy',
    title: 'Count Object Properties',
    text: 'Count how many properties the object has using Object.keys.',
    setup:
      'const car = { make: "Toyota", model: "Camry", year: 2022, color: "blue" };',
    setupCode:
      'const car = { make: "Toyota", model: "Camry", year: 2022, color: "blue" };',
    expected: 4,
    sample: 'Object.keys(car).length',
    hints: [
      'Object.keys returns array of keys',
      'Arrays have a length property',
    ],
    validPatterns: [
      /Object\.keys\s*\(\s*car\s*\)\.length/,
      /Object\.entries\s*\(\s*car\s*\)\.length/,
    ],
    tags: ['Object.keys', 'length', 'basics'],
  },
  {
    id: 'js-obj-002',
    category: 'Object Manipulation',
    difficulty: 'easy',
    title: 'Sum Object Values',
    text: 'Calculate the sum of all numeric values in the object.',
    setup:
      'const scores = { math: 95, science: 88, english: 92, history: 87 };',
    setupCode:
      'const scores = { math: 95, science: 88, english: 92, history: 87 };',
    expected: 362,
    sample: 'Object.values(scores).reduce((sum, n) => sum + n, 0)',
    hints: ['Object.values extracts all values', 'Use reduce to sum them'],
    validPatterns: [/Object\.values\s*\(\s*scores\s*\)\.reduce/],
    tags: ['Object.values', 'reduce', 'sum'],
  },
  {
    id: 'js-obj-003',
    category: 'Object Manipulation',
    difficulty: 'easy',
    title: 'Clone Object with Spread',
    text: 'Create a shallow copy of the object using the spread operator.',
    setup: 'const original = { a: 1, b: 2, c: 3 };',
    setupCode: 'const original = { a: 1, b: 2, c: 3 };',
    expected: { a: 1, b: 2, c: 3 },
    sample: '{ ...original }',
    hints: [
      'Spread operator copies properties',
      'Creates a new object reference',
    ],
    validPatterns: [/\{\s*\.\.\.original\s*\}/],
    tags: ['spread', 'clone', 'shallow-copy'],
  },
  {
    id: 'js-obj-004',
    category: 'Object Manipulation',
    difficulty: 'easy',
    title: 'Add Property with Spread',
    text: 'Create a new object with all properties from person plus a new "country" property set to "USA".',
    setup: 'const person = { name: "Alice", age: 30 };',
    setupCode: 'const person = { name: "Alice", age: 30 };',
    expected: { name: 'Alice', age: 30, country: 'USA' },
    sample: '{ ...person, country: "USA" }',
    hints: ['Spread existing properties first', 'Add new property after spread'],
    validPatterns: [/\{\s*\.\.\.person\s*,\s*country\s*:\s*['"]USA['"]\s*\}/],
    tags: ['spread', 'extend', 'immutable'],
  },
  {
    id: 'js-obj-005',
    category: 'Object Manipulation',
    difficulty: 'easy',
    title: 'Override Property with Spread',
    text: 'Create a new object with age updated to 35 while keeping other properties.',
    setup: 'const person = { name: "Bob", age: 25, city: "NYC" };',
    setupCode: 'const person = { name: "Bob", age: 25, city: "NYC" };',
    expected: { name: 'Bob', age: 35, city: 'NYC' },
    sample: '{ ...person, age: 35 }',
    hints: [
      'Later properties override earlier ones',
      'Spread first, then override',
    ],
    validPatterns: [/\{\s*\.\.\.person\s*,\s*age\s*:\s*35\s*\}/],
    tags: ['spread', 'override', 'immutable'],
  },
  {
    id: 'js-obj-006',
    category: 'Object Manipulation',
    difficulty: 'easy',
    title: 'Check if Object is Empty',
    text: 'Check if the object has no properties.',
    setup: 'const empty = {};',
    setupCode: 'const empty = {};',
    expected: true,
    sample: 'Object.keys(empty).length === 0',
    hints: ['Empty object has no keys', 'Check if keys array length is 0'],
    validPatterns: [
      /Object\.keys\s*\(\s*empty\s*\)\.length\s*===?\s*0/,
      /Object\.entries\s*\(\s*empty\s*\)\.length\s*===?\s*0/,
    ],
    tags: ['Object.keys', 'empty-check', 'validation'],
  },
  {
    id: 'js-obj-007',
    category: 'Object Manipulation',
    difficulty: 'easy',
    title: 'Convert Entries to Object',
    text: 'Convert the array of key-value pairs into an object.',
    setup:
      'const pairs = [["name", "Charlie"], ["role", "developer"], ["level", "senior"]];',
    setupCode:
      'const pairs = [["name", "Charlie"], ["role", "developer"], ["level", "senior"]];',
    expected: { name: 'Charlie', role: 'developer', level: 'senior' },
    sample: 'Object.fromEntries(pairs)',
    hints: [
      'Object.fromEntries takes array of pairs',
      'Each pair is [key, value]',
    ],
    validPatterns: [/Object\.fromEntries\s*\(\s*pairs\s*\)/],
    tags: ['Object.fromEntries', 'conversion', 'basics'],
  },
  {
    id: 'js-obj-008',
    category: 'Object Manipulation',
    difficulty: 'easy',
    title: 'Object.assign Basic',
    text: 'Merge source into target using Object.assign.',
    setup: `const target = { a: 1 };
const source = { b: 2, c: 3 };`,
    setupCode: `const target = { a: 1 };
const source = { b: 2, c: 3 };`,
    expected: { a: 1, b: 2, c: 3 },
    sample: 'Object.assign({}, target, source)',
    hints: [
      'Object.assign merges objects',
      'First arg is target, rest are sources',
    ],
    validPatterns: [
      /Object\.assign\s*\(\s*\{\s*\}\s*,\s*target\s*,\s*source\s*\)/,
      /Object\.assign\s*\(\s*\{\s*\}\s*,\s*source\s*,\s*target\s*\)/,
    ],
    tags: ['Object.assign', 'merge', 'basics'],
  },

  // Medium (12 problems)
  {
    id: 'js-obj-009',
    category: 'Object Manipulation',
    difficulty: 'medium',
    title: 'Filter Object Properties',
    text: 'Create a new object containing only properties where the value is greater than 50.',
    setup: 'const scores = { alice: 85, bob: 42, charlie: 91, diana: 38 };',
    setupCode: 'const scores = { alice: 85, bob: 42, charlie: 91, diana: 38 };',
    expected: { alice: 85, charlie: 91 },
    sample:
      'Object.fromEntries(Object.entries(scores).filter(([_, v]) => v > 50))',
    hints: [
      'Use entries to get [key, value] pairs',
      'Filter pairs, then fromEntries',
    ],
    validPatterns: [
      /Object\.fromEntries\s*\(\s*Object\.entries\s*\(\s*scores\s*\)\.filter/,
    ],
    tags: ['Object.fromEntries', 'Object.entries', 'filter'],
  },
  {
    id: 'js-obj-010',
    category: 'Object Manipulation',
    difficulty: 'medium',
    title: 'Rename Object Keys',
    text: 'Transform object keys from snake_case to camelCase.',
    setup:
      'const user = { first_name: "John", last_name: "Doe", user_age: 30 };',
    setupCode:
      'const user = { first_name: "John", last_name: "Doe", user_age: 30 };',
    expected: { firstName: 'John', lastName: 'Doe', userAge: 30 },
    sample:
      'Object.fromEntries(Object.entries(user).map(([k, v]) => [k.replace(/_([a-z])/g, (_, c) => c.toUpperCase()), v]))',
    hints: [
      'Use entries and map to transform keys',
      'Replace _x with uppercase X',
    ],
    validPatterns: [
      /Object\.fromEntries\s*\(\s*Object\.entries\s*\(\s*user\s*\)\.map/,
    ],
    tags: ['Object.fromEntries', 'transform', 'camelCase'],
  },
  {
    id: 'js-obj-011',
    category: 'Object Manipulation',
    difficulty: 'medium',
    title: 'Swap Keys and Values',
    text: 'Create a new object with keys and values swapped.',
    setup: 'const original = { a: "x", b: "y", c: "z" };',
    setupCode: 'const original = { a: "x", b: "y", c: "z" };',
    expected: { x: 'a', y: 'b', z: 'c' },
    sample:
      'Object.fromEntries(Object.entries(original).map(([k, v]) => [v, k]))',
    hints: [
      'Map entries to flip the pairs',
      'Return [value, key] instead of [key, value]',
    ],
    validPatterns: [
      /Object\.fromEntries\s*\(\s*Object\.entries\s*\(\s*original\s*\)\.map\s*\(\s*\[\s*\w+\s*,\s*\w+\s*\]\s*=>\s*\[\s*\w+\s*,\s*\w+\s*\]\s*\)/,
    ],
    tags: ['Object.fromEntries', 'swap', 'transform'],
  },
  {
    id: 'js-obj-012',
    category: 'Object Manipulation',
    difficulty: 'medium',
    title: 'Pick Specific Properties',
    text: 'Extract only the "name" and "email" properties from the user object.',
    setup:
      'const user = { name: "Alice", email: "alice@example.com", age: 30, role: "admin" };',
    setupCode:
      'const user = { name: "Alice", email: "alice@example.com", age: 30, role: "admin" };',
    expected: { name: 'Alice', email: 'alice@example.com' },
    sample: '(({ name, email }) => ({ name, email }))(user)',
    hints: [
      'Destructure desired properties',
      'Return new object with only those',
    ],
    validPatterns: [
      /\(\s*\{\s*name\s*,\s*email\s*\}\s*=\s*user/,
      /\(\s*\(\s*\{\s*name\s*,\s*email\s*\}\s*\)\s*=>/,
    ],
    tags: ['destructuring', 'pick', 'subset'],
  },
  {
    id: 'js-obj-013',
    category: 'Object Manipulation',
    difficulty: 'medium',
    title: 'Omit Specific Properties',
    text: 'Create a new object without the "password" property using rest syntax.',
    setup:
      'const user = { name: "Bob", email: "bob@example.com", password: "secret123" };',
    setupCode:
      'const user = { name: "Bob", email: "bob@example.com", password: "secret123" };',
    expected: { name: 'Bob', email: 'bob@example.com' },
    sample: '(({ password, ...rest }) => rest)(user)',
    hints: [
      'Destructure the property to omit',
      'Use rest operator for remaining',
    ],
    validPatterns: [
      /\{\s*password\s*,\s*\.\.\.rest\s*\}/,
      /\{\s*password\s*,\s*\.\.\.(\w+)\s*\}/,
    ],
    tags: ['rest', 'omit', 'destructuring'],
  },
  {
    id: 'js-obj-014',
    category: 'Object Manipulation',
    difficulty: 'medium',
    title: 'Merge Multiple Objects',
    text: 'Merge three objects where later values override earlier ones.',
    setup: `const defaults = { theme: "light", lang: "en", size: "medium" };
const userPrefs = { theme: "dark" };
const sessionPrefs = { size: "large" };`,
    setupCode: `const defaults = { theme: "light", lang: "en", size: "medium" };
const userPrefs = { theme: "dark" };
const sessionPrefs = { size: "large" };`,
    expected: { theme: 'dark', lang: 'en', size: 'large' },
    sample: '{ ...defaults, ...userPrefs, ...sessionPrefs }',
    hints: ['Spread in order of priority', 'Later spreads override earlier'],
    validPatterns: [
      /\{\s*\.\.\.defaults\s*,\s*\.\.\.userPrefs\s*,\s*\.\.\.sessionPrefs\s*\}/,
      /Object\.assign\s*\(\s*\{\s*\}\s*,\s*defaults\s*,\s*userPrefs\s*,\s*sessionPrefs\s*\)/,
    ],
    tags: ['spread', 'merge', 'multiple'],
  },
  {
    id: 'js-obj-015',
    category: 'Object Manipulation',
    difficulty: 'medium',
    title: 'Uppercase All Values',
    text: 'Transform all string values in the object to uppercase.',
    setup:
      'const words = { greeting: "hello", farewell: "goodbye", question: "how" };',
    setupCode:
      'const words = { greeting: "hello", farewell: "goodbye", question: "how" };',
    expected: { greeting: 'HELLO', farewell: 'GOODBYE', question: 'HOW' },
    sample:
      'Object.fromEntries(Object.entries(words).map(([k, v]) => [k, v.toUpperCase()]))',
    hints: [
      'Use entries to iterate with keys',
      'Map and transform values',
      'Rebuild with fromEntries',
    ],
    validPatterns: [
      /Object\.fromEntries\s*\(\s*Object\.entries\s*\(\s*words\s*\)\.map/,
    ],
    tags: ['Object.fromEntries', 'transform', 'toUpperCase'],
  },
  {
    id: 'js-obj-016',
    category: 'Object Manipulation',
    difficulty: 'medium',
    title: 'Object.assign with Getter',
    text: 'Use Object.assign to copy including computed property. Get the merged result.',
    setup: `const base = { x: 10, y: 20 };
const extension = { z: 30 };`,
    setupCode: `const base = { x: 10, y: 20 };
const extension = { z: 30 };`,
    expected: { x: 10, y: 20, z: 30 },
    sample: 'Object.assign({}, base, extension)',
    hints: [
      'Object.assign copies enumerable properties',
      'First arg is target object',
    ],
    validPatterns: [
      /Object\.assign\s*\(\s*\{\s*\}\s*,\s*base\s*,\s*extension\s*\)/,
    ],
    tags: ['Object.assign', 'merge', 'copy'],
  },
  {
    id: 'js-obj-017',
    category: 'Object Manipulation',
    difficulty: 'medium',
    title: 'Find Max Value Key',
    text: 'Find the key that has the highest numeric value.',
    setup:
      'const prices = { apple: 1.5, banana: 0.75, mango: 2.5, orange: 1.25 };',
    setupCode:
      'const prices = { apple: 1.5, banana: 0.75, mango: 2.5, orange: 1.25 };',
    expected: 'mango',
    sample: 'Object.entries(prices).reduce((a, b) => b[1] > a[1] ? b : a)[0]',
    hints: [
      'Use entries to get [key, value] pairs',
      'Reduce to find max, then extract key',
    ],
    validPatterns: [
      /Object\.entries\s*\(\s*prices\s*\)\.reduce/,
      /Object\.keys\s*\(\s*prices\s*\)\.reduce/,
    ],
    tags: ['Object.entries', 'reduce', 'max'],
  },
  {
    id: 'js-obj-018',
    category: 'Object Manipulation',
    difficulty: 'medium',
    title: 'Object to Query String',
    text: 'Convert the object to a URL query string format.',
    setup: 'const params = { page: 1, limit: 10, sort: "name" };',
    setupCode: 'const params = { page: 1, limit: 10, sort: "name" };',
    expected: 'page=1&limit=10&sort=name',
    sample: 'Object.entries(params).map(([k, v]) => `${k}=${v}`).join("&")',
    hints: [
      'Use entries to get key-value pairs',
      'Map to "key=value" strings',
      'Join with &',
    ],
    validPatterns: [
      /Object\.entries\s*\(\s*params\s*\)\.map/,
      /new\s+URLSearchParams\s*\(\s*params\s*\)\.toString\s*\(\s*\)/,
    ],
    tags: ['Object.entries', 'transform', 'query-string'],
  },
  {
    id: 'js-obj-019',
    category: 'Object Manipulation',
    difficulty: 'medium',
    title: 'Deep Merge Nested Objects',
    text: 'Merge nested objects where inner objects are also merged (not replaced).',
    setup: `const target = { user: { name: "Alice", settings: { theme: "light" } } };
const source = { user: { settings: { fontSize: 14 } } };`,
    setupCode: `const target = { user: { name: "Alice", settings: { theme: "light" } } };
const source = { user: { settings: { fontSize: 14 } } };`,
    expected: {
      user: { name: 'Alice', settings: { theme: 'light', fontSize: 14 } },
    },
    sample:
      '{ user: { ...target.user, settings: { ...target.user.settings, ...source.user.settings } } }',
    hints: [
      'Spread alone does shallow merge',
      'Manually spread nested objects',
    ],
    validPatterns: [
      /\.\.\.target\.user\.settings\s*,\s*\.\.\.source\.user\.settings/,
      /\.\.\.source\.user\.settings\s*,\s*\.\.\.target\.user\.settings/,
    ],
    tags: ['spread', 'deep-merge', 'nested'],
  },
  {
    id: 'js-obj-020',
    category: 'Object Manipulation',
    difficulty: 'medium',
    title: 'Freeze Object',
    text: 'Freeze the object to prevent modifications. Return whether the object is frozen.',
    setup: 'const config = { apiKey: "abc123", maxRetries: 3 };',
    setupCode: 'const config = { apiKey: "abc123", maxRetries: 3 };',
    expected: true,
    sample: 'Object.freeze(config); Object.isFrozen(config)',
    hints: [
      'Object.freeze prevents changes',
      'Object.isFrozen checks freeze status',
    ],
    validPatterns: [
      /Object\.freeze\s*\(\s*config\s*\)/,
      /Object\.isFrozen\s*\(\s*config\s*\)/,
    ],
    tags: ['Object.freeze', 'Object.isFrozen', 'immutability'],
  },

  // Hard (5 problems)
  {
    id: 'js-obj-021',
    category: 'Object Manipulation',
    difficulty: 'hard',
    title: 'Define Computed Property',
    text: 'Use Object.defineProperty to add a read-only "fullName" property that computes from firstName and lastName.',
    setup: 'const person = { firstName: "John", lastName: "Doe" };',
    setupCode: 'const person = { firstName: "John", lastName: "Doe" };',
    expected: 'John Doe',
    sample:
      'Object.defineProperty(person, "fullName", { get() { return `${this.firstName} ${this.lastName}`; }, enumerable: true }); person.fullName',
    hints: [
      'defineProperty adds/modifies properties',
      'Use getter for computed value',
    ],
    validPatterns: [
      /Object\.defineProperty\s*\(\s*person\s*,\s*['"]fullName['"]/,
    ],
    tags: ['Object.defineProperty', 'getter', 'computed'],
  },
  {
    id: 'js-obj-022',
    category: 'Object Manipulation',
    difficulty: 'hard',
    title: 'Property Descriptor Analysis',
    text: 'Get the property descriptor for the "name" property and check if it is writable.',
    setup: `const obj = {};
Object.defineProperty(obj, "name", { value: "Immutable", writable: false, enumerable: true, configurable: false });`,
    setupCode: `const obj = {};
Object.defineProperty(obj, "name", { value: "Immutable", writable: false, enumerable: true, configurable: false });`,
    expected: false,
    sample: 'Object.getOwnPropertyDescriptor(obj, "name").writable',
    hints: [
      'getOwnPropertyDescriptor returns descriptor object',
      'Check the writable property',
    ],
    validPatterns: [
      /Object\.getOwnPropertyDescriptor\s*\(\s*obj\s*,\s*['"]name['"]\s*\)\.writable/,
    ],
    tags: ['getOwnPropertyDescriptor', 'property-descriptor', 'introspection'],
  },
  {
    id: 'js-obj-023',
    category: 'Object Manipulation',
    difficulty: 'hard',
    title: 'Basic Proxy Trap',
    text: 'Create a proxy that returns "Property not found" for any non-existent property access.',
    setup: 'const target = { name: "Alice", age: 30 };',
    setupCode: 'const target = { name: "Alice", age: 30 };',
    expected: 'Property not found',
    sample:
      'new Proxy(target, { get(obj, prop) { return prop in obj ? obj[prop] : "Property not found"; } }).missing',
    hints: [
      'Proxy intercepts operations',
      'get trap handles property access',
      'Check if property exists',
    ],
    validPatterns: [/new\s+Proxy\s*\(\s*target\s*,\s*\{[^}]*get\s*\(/],
    tags: ['Proxy', 'trap', 'get'],
  },
  {
    id: 'js-obj-024',
    category: 'Object Manipulation',
    difficulty: 'hard',
    title: 'Validation Proxy',
    text: 'Create a proxy that only allows setting numeric values (throws error otherwise). Set age to 25 and return it.',
    setup: 'const target = { age: 0 };',
    setupCode: 'const target = { age: 0 };',
    expected: 25,
    sample:
      'const proxy = new Proxy(target, { set(obj, prop, value) { if (typeof value !== "number") throw new TypeError("Must be a number"); obj[prop] = value; return true; } }); proxy.age = 25; proxy.age',
    hints: [
      'set trap intercepts assignments',
      'Validate before setting',
      'Return true on success',
    ],
    validPatterns: [/new\s+Proxy\s*\(\s*target\s*,\s*\{[^}]*set\s*\(/],
    tags: ['Proxy', 'validation', 'set-trap'],
  },
  {
    id: 'js-obj-025',
    category: 'Object Manipulation',
    difficulty: 'hard',
    title: 'Reflect and Proxy Combined',
    text: 'Create a proxy that logs property access and uses Reflect.get for the actual retrieval. Access the name property.',
    setup: `const target = { name: "Bob", role: "developer" };
const logs = [];`,
    setupCode: `const target = { name: "Bob", role: "developer" };
const logs = [];`,
    expected: 'Bob',
    sample:
      'const proxy = new Proxy(target, { get(obj, prop, receiver) { logs.push(`Accessed: ${prop}`); return Reflect.get(obj, prop, receiver); } }); proxy.name',
    hints: [
      'Reflect.get is the default get behavior',
      'Use it inside proxy trap',
      'Log before returning',
    ],
    validPatterns: [
      /Reflect\.get\s*\(\s*\w+\s*,\s*\w+/,
      /new\s+Proxy\s*\(\s*target\s*,\s*\{[^}]*Reflect\.get/,
    ],
    tags: ['Proxy', 'Reflect', 'logging'],
  },
  // ========================================
  // REGULAR EXPRESSIONS & STRING PARSING
  // ========================================
  {
    id: 'js-regex-001',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'Test for Digits',
    text: 'Use a regex to test if the string contains any digit. Return true or false.',
    setup: 'const str = "Hello World 123";',
    setupCode: 'const str = "Hello World 123";',
    expected: true,
    sample: '/\\d/.test(str)',
    hints: ['Use \\d to match digits', 'The .test() method returns a boolean'],
    tags: ['regex', 'test', 'digits'],
  },
  {
    id: 'js-regex-002',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'Match All Digits',
    text: 'Use a regex to find all digits in the string. Return an array of matches.',
    setup: 'const str = "abc123def456";',
    setupCode: 'const str = "abc123def456";',
    expected: ['1', '2', '3', '4', '5', '6'],
    sample: 'str.match(/\\d/g)',
    hints: ['Use the g flag for global matching', 'Use \\d to match digits'],
    tags: ['regex', 'match', 'global-flag'],
  },
  {
    id: 'js-regex-003',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'Case Insensitive Match',
    text: 'Test if the string contains "hello" regardless of case.',
    setup: 'const str = "HELLO World";',
    setupCode: 'const str = "HELLO World";',
    expected: true,
    sample: '/hello/i.test(str)',
    hints: ['Use the i flag for case insensitive matching', 'The pattern should be lowercase'],
    tags: ['regex', 'test', 'case-insensitive'],
  },
  {
    id: 'js-regex-004',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'Match Word Characters',
    text: 'Find all word characters (letters, digits, underscore) in the string.',
    setup: 'const str = "Hi! @user_123";',
    setupCode: 'const str = "Hi! @user_123";',
    expected: ['H', 'i', 'u', 's', 'e', 'r', '_', '1', '2', '3'],
    sample: 'str.match(/\\w/g)',
    hints: ['Use \\w to match word characters', 'Word characters include a-z, A-Z, 0-9, and _'],
    tags: ['regex', 'match', 'word-characters'],
  },
  {
    id: 'js-regex-005',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'Match Whitespace',
    text: 'Count the number of whitespace characters in the string.',
    setup: 'const str = "Hello World  Test";',
    setupCode: 'const str = "Hello World  Test";',
    expected: 3,
    sample: '(str.match(/\\s/g) || []).length',
    hints: ['Use \\s to match whitespace', 'Handle the case where match returns null'],
    tags: ['regex', 'match', 'whitespace'],
  },
  {
    id: 'js-regex-006',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'Start of String Match',
    text: 'Test if the string starts with "Hello".',
    setup: 'const str = "Hello World";',
    setupCode: 'const str = "Hello World";',
    expected: true,
    sample: '/^Hello/.test(str)',
    hints: ['Use ^ to match the start of a string', 'The ^ anchor asserts position at start'],
    tags: ['regex', 'test', 'anchor'],
  },
  {
    id: 'js-regex-007',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'End of String Match',
    text: 'Test if the string ends with a digit.',
    setup: 'const str = "Order #123";',
    setupCode: 'const str = "Order #123";',
    expected: true,
    sample: '/\\d$/.test(str)',
    hints: ['Use $ to match the end of a string', 'Combine with \\d to match a digit at the end'],
    tags: ['regex', 'test', 'anchor'],
  },
  {
    id: 'js-regex-008',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'Match One or More',
    text: 'Find sequences of one or more digits in the string.',
    setup: 'const str = "abc123def45ghi6";',
    setupCode: 'const str = "abc123def45ghi6";',
    expected: ['123', '45', '6'],
    sample: 'str.match(/\\d+/g)',
    hints: ['Use + quantifier for one or more', 'Use g flag to find all matches'],
    tags: ['regex', 'match', 'quantifier'],
  },
  {
    id: 'js-regex-009',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'Match Zero or More',
    text: 'Match "go" followed by zero or more "o" characters. Find all matches.',
    setup: 'const str = "go goo gooo goooo";',
    setupCode: 'const str = "go goo gooo goooo";',
    expected: ['go', 'goo', 'gooo', 'goooo'],
    sample: 'str.match(/goo*/g)',
    hints: ['Use * quantifier for zero or more', 'The pattern goo* matches g followed by one or more o'],
    tags: ['regex', 'match', 'quantifier'],
  },
  {
    id: 'js-regex-010',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'Optional Character',
    text: 'Match both "color" and "colour" in the string.',
    setup: 'const str = "color and colour are both valid";',
    setupCode: 'const str = "color and colour are both valid";',
    expected: ['color', 'colour'],
    sample: 'str.match(/colou?r/g)',
    hints: ['Use ? for optional character', 'The u is optional in the pattern'],
    tags: ['regex', 'match', 'quantifier'],
  },
  {
    id: 'js-regex-011',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'Character Set',
    text: 'Match all vowels in the string (case insensitive).',
    setup: 'const str = "Hello World";',
    setupCode: 'const str = "Hello World";',
    expected: ['e', 'o', 'o'],
    sample: 'str.match(/[aeiou]/gi)',
    hints: ['Use [] for character set', 'Use i flag for case insensitive'],
    tags: ['regex', 'match', 'character-class'],
  },
  {
    id: 'js-regex-012',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'Negated Character Set',
    text: 'Match all non-vowel characters (consonants and others).',
    setup: 'const str = "Hello";',
    setupCode: 'const str = "Hello";',
    expected: ['H', 'l', 'l'],
    sample: 'str.match(/[^aeiou]/gi)',
    hints: ['Use [^] for negated set', 'This matches anything NOT in the set'],
    tags: ['regex', 'match', 'character-class'],
  },
  {
    id: 'js-regex-013',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'Range in Character Set',
    text: 'Match all lowercase letters from a to m.',
    setup: 'const str = "programming";',
    setupCode: 'const str = "programming";',
    expected: ['g', 'a', 'm', 'm', 'i', 'g'],
    sample: 'str.match(/[a-m]/g)',
    hints: ['Use - to define a range in character set', '[a-m] matches letters a through m'],
    tags: ['regex', 'match', 'character-class'],
  },
  {
    id: 'js-regex-014',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'Dot Wildcard',
    text: 'Match any 3-character pattern that starts with "c" and ends with "t".',
    setup: 'const str = "cat cot cut cart";',
    setupCode: 'const str = "cat cot cut cart";',
    expected: ['cat', 'cot', 'cut'],
    sample: 'str.match(/c.t/g)',
    hints: ['Use . to match any character', 'The dot matches exactly one character'],
    tags: ['regex', 'match', 'wildcard'],
  },
  {
    id: 'js-regex-015',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'Escape Special Character',
    text: 'Test if the string contains a literal dot.',
    setup: 'const str = "file.txt";',
    setupCode: 'const str = "file.txt";',
    expected: true,
    sample: '/\\./.test(str)',
    hints: ['Escape the dot with backslash', '\\. matches a literal dot'],
    tags: ['regex', 'test', 'escape'],
  },
  {
    id: 'js-regex-016',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'Word Boundary',
    text: 'Test if the word "cat" exists as a whole word (not part of another word).',
    setup: 'const str = "I have a cat and a caterpillar";',
    setupCode: 'const str = "I have a cat and a caterpillar";',
    expected: true,
    sample: '/\\bcat\\b/.test(str)',
    hints: ['Use \\b for word boundary', 'Word boundary matches between word and non-word characters'],
    tags: ['regex', 'test', 'boundary'],
  },
  {
    id: 'js-regex-017',
    category: 'String Parsing',
    difficulty: 'easy',
    title: 'Split on Whitespace',
    text: 'Split the string into words using regex to handle multiple spaces.',
    setup: 'const str = "Hello   World  Test";',
    setupCode: 'const str = "Hello   World  Test";',
    expected: ['Hello', 'World', 'Test'],
    sample: 'str.split(/\\s+/)',
    hints: ['Use \\s+ to match one or more whitespace', 'split() can take a regex'],
    tags: ['regex', 'split', 'whitespace'],
  },
  {
    id: 'js-regex-018',
    category: 'String Parsing',
    difficulty: 'easy',
    title: 'Replace All Digits',
    text: 'Replace all digits in the string with "X".',
    setup: 'const str = "Phone: 123-456-7890";',
    setupCode: 'const str = "Phone: 123-456-7890";',
    expected: 'Phone: XXX-XXX-XXXX',
    sample: 'str.replace(/\\d/g, "X")',
    hints: ['Use replace with g flag', 'Replace each digit individually'],
    tags: ['regex', 'replace', 'global'],
  },
  {
    id: 'js-regex-019',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'Match Exact Count',
    text: 'Match exactly 3 consecutive digits.',
    setup: 'const str = "12 123 1234 12345";',
    setupCode: 'const str = "12 123 1234 12345";',
    expected: ['123', '123', '123'],
    sample: 'str.match(/\\d{3}/g)',
    hints: ['Use {n} for exact count', '{3} means exactly 3 occurrences'],
    tags: ['regex', 'match', 'quantifier'],
  },
  {
    id: 'js-regex-020',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'Match Range Count',
    text: 'Match sequences of 2 to 4 digits.',
    setup: 'const str = "1 12 123 1234 12345";',
    setupCode: 'const str = "1 12 123 1234 12345";',
    expected: ['12', '123', '1234', '1234'],
    sample: 'str.match(/\\d{2,4}/g)',
    hints: ['Use {n,m} for range', '{2,4} means 2 to 4 occurrences'],
    tags: ['regex', 'match', 'quantifier'],
  },
  {
    id: 'js-regex-021',
    category: 'String Parsing',
    difficulty: 'easy',
    title: 'Extract File Extension',
    text: 'Extract the file extension from the filename.',
    setup: 'const filename = "document.pdf";',
    setupCode: 'const filename = "document.pdf";',
    expected: 'pdf',
    sample: 'filename.match(/\\.(\\w+)$/)[1]',
    hints: ['Match dot followed by word characters at end', 'Use capturing group for extension'],
    tags: ['regex', 'match', 'parsing'],
  },
  {
    id: 'js-regex-022',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'Non-Digit Characters',
    text: 'Find all non-digit characters in the string.',
    setup: 'const str = "abc123";',
    setupCode: 'const str = "abc123";',
    expected: ['a', 'b', 'c'],
    sample: 'str.match(/\\D/g)',
    hints: ['Use \\D to match non-digits', 'Capital D is the negation of \\d'],
    tags: ['regex', 'match', 'character-class'],
  },
  {
    id: 'js-regex-023',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'Non-Word Characters',
    text: 'Find all non-word characters (special chars, spaces).',
    setup: 'const str = "Hi! How are you?";',
    setupCode: 'const str = "Hi! How are you?";',
    expected: ['!', ' ', ' ', ' ', '?'],
    sample: 'str.match(/\\W/g)',
    hints: ['Use \\W to match non-word characters', 'Includes spaces and punctuation'],
    tags: ['regex', 'match', 'character-class'],
  },
  {
    id: 'js-regex-024',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'Match Words',
    text: 'Find all words (sequences of word characters) in the string.',
    setup: 'const str = "Hello, World! How are you?";',
    setupCode: 'const str = "Hello, World! How are you?";',
    expected: ['Hello', 'World', 'How', 'are', 'you'],
    sample: 'str.match(/\\w+/g)',
    hints: ['Use \\w+ to match sequences of word characters', 'This effectively extracts words'],
    tags: ['regex', 'match', 'words'],
  },
  {
    id: 'js-regex-025',
    category: 'String Parsing',
    difficulty: 'easy',
    title: 'Remove Extra Spaces',
    text: 'Replace multiple consecutive spaces with a single space.',
    setup: 'const str = "Hello    World   Test";',
    setupCode: 'const str = "Hello    World   Test";',
    expected: 'Hello World Test',
    sample: 'str.replace(/\\s+/g, " ")',
    hints: ['Use \\s+ to match multiple spaces', 'Replace with single space'],
    tags: ['regex', 'replace', 'whitespace'],
  },
  {
    id: 'js-regex-026',
    category: 'Regular Expressions',
    difficulty: 'medium',
    title: 'Basic Capturing Group',
    text: 'Extract the area code from the phone number using capturing groups.',
    setup: 'const phone = "(555) 123-4567";',
    setupCode: 'const phone = "(555) 123-4567";',
    expected: '555',
    sample: 'phone.match(/\\((\\d{3})\\)/)[1]',
    hints: ['Use () to create a capturing group', 'Access the group with [1]'],
    tags: ['regex', 'match', 'capturing-group'],
  },
  {
    id: 'js-regex-027',
    category: 'Regular Expressions',
    difficulty: 'medium',
    title: 'Multiple Capturing Groups',
    text: 'Extract month, day, and year from the date string.',
    setup: 'const date = "12/25/2023";',
    setupCode: 'const date = "12/25/2023";',
    expected: ['12/25/2023', '12', '25', '2023'],
    sample: 'date.match(/(\\d{2})\\/(\\d{2})\\/(\\d{4})/)',
    hints: ['Each () creates a separate group', 'Groups are numbered left to right'],
    tags: ['regex', 'match', 'capturing-group'],
  },
  {
    id: 'js-regex-028',
    category: 'Regular Expressions',
    difficulty: 'medium',
    title: 'Non-Capturing Group',
    text: 'Match repeated "ab" patterns but do not capture the group. Count the matches.',
    setup: 'const str = "ab ab ab abc abab";',
    setupCode: 'const str = "ab ab ab abc abab";',
    expected: 5,
    sample: '(str.match(/(?:ab)/g) || []).length',
    hints: ['Use (?:) for non-capturing group', 'Non-capturing groups match but do not remember'],
    tags: ['regex', 'match', 'non-capturing'],
  },
  {
    id: 'js-regex-029',
    category: 'Regular Expressions',
    difficulty: 'medium',
    title: 'Named Capturing Group',
    text: 'Extract the username from an email using named capturing group.',
    setup: 'const email = "john.doe@example.com";',
    setupCode: 'const email = "john.doe@example.com";',
    expected: 'john.doe',
    sample: 'email.match(/(?<username>[\\w.]+)@/).groups.username',
    hints: ['Use (?<name>...) for named groups', 'Access via .groups.name'],
    tags: ['regex', 'match', 'named-group'],
  },
  {
    id: 'js-regex-030',
    category: 'Regular Expressions',
    difficulty: 'medium',
    title: 'Alternation',
    text: 'Match either "cat" or "dog" in the string. Find all matches.',
    setup: 'const str = "I have a cat and a dog and another cat";',
    setupCode: 'const str = "I have a cat and a dog and another cat";',
    expected: ['cat', 'dog', 'cat'],
    sample: 'str.match(/cat|dog/g)',
    hints: ['Use | for alternation (OR)', 'This matches either pattern'],
    tags: ['regex', 'match', 'alternation'],
  },
  {
    id: 'js-regex-031',
    category: 'Regular Expressions',
    difficulty: 'medium',
    title: 'Alternation with Grouping',
    text: 'Match "gray" or "grey" using alternation within a group.',
    setup: 'const str = "gray and grey are both correct";',
    setupCode: 'const str = "gray and grey are both correct";',
    expected: ['gray', 'grey'],
    sample: 'str.match(/gr(a|e)y/g)',
    hints: ['Use () to limit alternation scope', 'gr(a|e)y matches gray or grey'],
    tags: ['regex', 'match', 'alternation'],
  },
  {
    id: 'js-regex-032',
    category: 'String Parsing',
    difficulty: 'medium',
    title: 'Replace with Captured Group',
    text: 'Swap the first and last name using capturing groups.',
    setup: 'const name = "John Smith";',
    setupCode: 'const name = "John Smith";',
    expected: 'Smith, John',
    sample: 'name.replace(/(\\w+) (\\w+)/, "$2, $1")',
    hints: ['Use $1, $2 to reference captured groups', 'Capture both names separately'],
    tags: ['regex', 'replace', 'capturing-group'],
  },
  {
    id: 'js-regex-033',
    category: 'String Parsing',
    difficulty: 'medium',
    title: 'Replace with Function',
    text: 'Double all numbers in the string using a replace function.',
    setup: 'const str = "I have 5 apples and 3 oranges";',
    setupCode: 'const str = "I have 5 apples and 3 oranges";',
    expected: 'I have 10 apples and 6 oranges',
    sample: 'str.replace(/\\d+/g, m => m * 2)',
    hints: ['Replace accepts a callback function', 'The function receives the match as argument'],
    tags: ['regex', 'replace', 'callback'],
  },
  {
    id: 'js-regex-034',
    category: 'Regular Expressions',
    difficulty: 'medium',
    title: 'Exec Method',
    text: 'Use exec to get the first match with its index. Return the index.',
    setup: 'const str = "The quick brown fox";',
    setupCode: 'const str = "The quick brown fox";',
    expected: 4,
    sample: '/quick/.exec(str).index',
    hints: ['exec() returns match with index property', 'Use .index to get position'],
    tags: ['regex', 'exec', 'index'],
  },
  {
    id: 'js-regex-035',
    category: 'Regular Expressions',
    difficulty: 'medium',
    title: 'Multiline Flag',
    text: 'Find all lines that start with a digit using multiline mode.',
    setup: 'const str = "1. First\\n2. Second\\nThird";',
    setupCode: 'const str = "1. First\\n2. Second\\nThird";',
    expected: ['1', '2'],
    sample: 'str.match(/^\\d/gm)',
    hints: ['Use m flag for multiline mode', '^$ match line start/end in multiline mode'],
    tags: ['regex', 'match', 'multiline'],
  },
  {
    id: 'js-regex-036',
    category: 'String Parsing',
    difficulty: 'medium',
    title: 'Split with Capturing Group',
    text: 'Split the string by commas but keep the commas in the result.',
    setup: 'const str = "a,b,c";',
    setupCode: 'const str = "a,b,c";',
    expected: ['a', ',', 'b', ',', 'c'],
    sample: 'str.split(/(,)/)',
    hints: ['Capturing groups in split are included', 'Wrap the delimiter in ()'],
    tags: ['regex', 'split', 'capturing-group'],
  },
  {
    id: 'js-regex-037',
    category: 'Regular Expressions',
    difficulty: 'medium',
    title: 'Lazy Quantifier',
    text: 'Extract content between the first pair of quotes using lazy matching.',
    setup: 'const str = \'"Hello" and "World"\';',
    setupCode: 'const str = \'"Hello" and "World"\';',
    expected: 'Hello',
    sample: 'str.match(/"(.+?)"/)[1]',
    hints: ['Use ? after quantifier for lazy mode', 'Lazy matches as few characters as possible'],
    tags: ['regex', 'match', 'lazy'],
  },
  {
    id: 'js-regex-038',
    category: 'Regular Expressions',
    difficulty: 'medium',
    title: 'Greedy vs Lazy',
    text: 'Extract all quoted strings using lazy matching.',
    setup: 'const str = \'"first" and "second" and "third"\';',
    setupCode: 'const str = \'"first" and "second" and "third"\';',
    expected: ['"first"', '"second"', '"third"'],
    sample: 'str.match(/".*?"/g)',
    hints: ['.*? is the lazy version of .*', 'Use g flag to find all matches'],
    tags: ['regex', 'match', 'lazy'],
  },
  {
    id: 'js-regex-039',
    category: 'Regular Expressions',
    difficulty: 'medium',
    title: 'Positive Lookahead',
    text: 'Find all digits that are followed by "px".',
    setup: 'const str = "10px 20em 30px 40rem";',
    setupCode: 'const str = "10px 20em 30px 40rem";',
    expected: ['10', '30'],
    sample: 'str.match(/\\d+(?=px)/g)',
    hints: ['Use (?=...) for positive lookahead', 'Lookahead does not consume characters'],
    tags: ['regex', 'match', 'lookahead'],
  },
  {
    id: 'js-regex-040',
    category: 'Regular Expressions',
    difficulty: 'medium',
    title: 'Negative Lookahead',
    text: 'Find all numbers that are NOT followed by "%".',
    setup: 'const str = "50% 100 75% 200";',
    setupCode: 'const str = "50% 100 75% 200";',
    expected: ['100', '200'],
    sample: 'str.match(/\\d+(?!%)/g)',
    hints: ['Use (?!...) for negative lookahead', 'Matches if NOT followed by pattern'],
    tags: ['regex', 'match', 'lookahead'],
  },
  {
    id: 'js-regex-041',
    category: 'Regular Expressions',
    difficulty: 'medium',
    title: 'Positive Lookbehind',
    text: 'Find all numbers that are preceded by "$".',
    setup: 'const str = "$100 200 $300 400";',
    setupCode: 'const str = "$100 200 $300 400";',
    expected: ['100', '300'],
    sample: 'str.match(/(?<=\\$)\\d+/g)',
    hints: ['Use (?<=...) for positive lookbehind', 'Matches if preceded by pattern'],
    tags: ['regex', 'match', 'lookbehind'],
  },
  {
    id: 'js-regex-042',
    category: 'Regular Expressions',
    difficulty: 'medium',
    title: 'Negative Lookbehind',
    text: 'Find all numbers that are NOT preceded by "-".',
    setup: 'const str = "10 -20 30 -40 50";',
    setupCode: 'const str = "10 -20 30 -40 50";',
    expected: ['10', '0', '30', '0', '50'],
    sample: 'str.match(/(?<!-)\\d+/g)',
    hints: ['Use (?<!...) for negative lookbehind', 'Matches if NOT preceded by pattern'],
    tags: ['regex', 'match', 'lookbehind'],
  },
  {
    id: 'js-regex-043',
    category: 'String Parsing',
    difficulty: 'medium',
    title: 'Extract Hashtags',
    text: 'Extract all hashtags from the text.',
    setup: 'const text = "Love #javascript and #coding! #100DaysOfCode";',
    setupCode: 'const text = "Love #javascript and #coding! #100DaysOfCode";',
    expected: ['#javascript', '#coding', '#100DaysOfCode'],
    sample: 'text.match(/#\\w+/g)',
    hints: ['Match # followed by word characters', 'Use \\w+ for the tag name'],
    tags: ['regex', 'match', 'parsing'],
  },
  {
    id: 'js-regex-044',
    category: 'String Parsing',
    difficulty: 'medium',
    title: 'Extract Mentions',
    text: 'Extract all @mentions from the text.',
    setup: 'const text = "Hey @john and @jane_doe! Check @user123";',
    setupCode: 'const text = "Hey @john and @jane_doe! Check @user123";',
    expected: ['@john', '@jane_doe', '@user123'],
    sample: 'text.match(/@\\w+/g)',
    hints: ['Match @ followed by word characters', 'Similar to hashtag extraction'],
    tags: ['regex', 'match', 'parsing'],
  },
  {
    id: 'js-regex-045',
    category: 'String Parsing',
    difficulty: 'medium',
    title: 'Parse Key-Value Pairs',
    text: 'Extract all key-value pairs from the string and return as array of matches.',
    setup: 'const str = "name=John&age=30&city=NYC";',
    setupCode: 'const str = "name=John&age=30&city=NYC";',
    expected: ['name=John', 'age=30', 'city=NYC'],
    sample: 'str.match(/\\w+=\\w+/g)',
    hints: ['Match word=word pattern', 'Use \\w+ for both key and value'],
    tags: ['regex', 'match', 'parsing'],
  },
  {
    id: 'js-regex-046',
    category: 'Regular Expressions',
    difficulty: 'medium',
    title: 'Backreference',
    text: 'Find repeated words (same word appearing twice in a row).',
    setup: 'const str = "The the quick brown fox fox jumps";',
    setupCode: 'const str = "The the quick brown fox fox jumps";',
    expected: ['The the', 'fox fox'],
    sample: 'str.match(/(\\w+)\\s+\\1/gi)',
    hints: ['Use \\1 to reference first captured group', 'The i flag handles case differences'],
    tags: ['regex', 'match', 'backreference'],
  },
  {
    id: 'js-regex-047',
    category: 'String Parsing',
    difficulty: 'medium',
    title: 'Remove HTML Tags',
    text: 'Remove all HTML tags from the string.',
    setup: 'const html = "<p>Hello <b>World</b></p>";',
    setupCode: 'const html = "<p>Hello <b>World</b></p>";',
    expected: 'Hello World',
    sample: 'html.replace(/<[^>]*>/g, "")',
    hints: ['Match < followed by non-> chars and >', '[^>]* matches any char except >'],
    tags: ['regex', 'replace', 'html'],
  },
  {
    id: 'js-regex-048',
    category: 'String Parsing',
    difficulty: 'medium',
    title: 'CamelCase to Kebab',
    text: 'Convert camelCase string to kebab-case.',
    setup: 'const str = "backgroundColor";',
    setupCode: 'const str = "backgroundColor";',
    expected: 'background-color',
    sample: 'str.replace(/([A-Z])/g, "-$1").toLowerCase()',
    hints: ['Find uppercase letters and prepend hyphen', 'Convert result to lowercase'],
    tags: ['regex', 'replace', 'case-conversion'],
  },
  {
    id: 'js-regex-049',
    category: 'String Parsing',
    difficulty: 'medium',
    title: 'Validate Username',
    text: 'Test if username is valid (3-16 chars, alphanumeric and underscores only, starts with letter).',
    setup: 'const username = "john_doe123";',
    setupCode: 'const username = "john_doe123";',
    expected: true,
    sample: '/^[a-zA-Z]\\w{2,15}$/.test(username)',
    hints: ['Start with letter, then word chars', '{2,15} gives total 3-16 characters'],
    tags: ['regex', 'test', 'validation'],
  },
  {
    id: 'js-regex-050',
    category: 'String Parsing',
    difficulty: 'medium',
    title: 'Format Phone Number',
    text: 'Format the 10-digit number as (XXX) XXX-XXXX.',
    setup: 'const phone = "5551234567";',
    setupCode: 'const phone = "5551234567";',
    expected: '(555) 123-4567',
    sample: 'phone.replace(/(\\d{3})(\\d{3})(\\d{4})/, "($1) $2-$3")',
    hints: ['Capture three groups of digits', 'Use $1, $2, $3 in replacement'],
    tags: ['regex', 'replace', 'formatting'],
  },
  {
    id: 'js-regex-051',
    category: 'Regular Expressions',
    difficulty: 'medium',
    title: 'Match IP Octets',
    text: 'Extract all octets from the IP address.',
    setup: 'const ip = "192.168.1.100";',
    setupCode: 'const ip = "192.168.1.100";',
    expected: ['192', '168', '1', '100'],
    sample: 'ip.match(/\\d+/g)',
    hints: ['Match sequences of digits', 'Dots act as separators'],
    tags: ['regex', 'match', 'ip-address'],
  },
  {
    id: 'js-regex-052',
    category: 'String Parsing',
    difficulty: 'medium',
    title: 'Extract Domain',
    text: 'Extract the domain name from the URL.',
    setup: 'const url = "https://www.example.com/path/page";',
    setupCode: 'const url = "https://www.example.com/path/page";',
    expected: 'www.example.com',
    sample: 'url.match(/https?:\\/\\/([^\\/]+)/)[1]',
    hints: ['Match protocol then capture until slash', '[^\\/]+ matches non-slash characters'],
    tags: ['regex', 'match', 'url'],
  },
  {
    id: 'js-regex-053',
    category: 'String Parsing',
    difficulty: 'medium',
    title: 'Mask Credit Card',
    text: 'Mask all but the last 4 digits of the credit card.',
    setup: 'const card = "4532015112830366";',
    setupCode: 'const card = "4532015112830366";',
    expected: '************0366',
    sample: 'card.replace(/\\d(?=\\d{4})/g, "*")',
    hints: ['Use lookahead to keep last 4 digits', 'Replace each digit that has 4+ digits after it'],
    tags: ['regex', 'replace', 'masking'],
  },
  {
    id: 'js-regex-054',
    category: 'Regular Expressions',
    difficulty: 'medium',
    title: 'Match HEX Color',
    text: 'Find all valid hex color codes in the string.',
    setup: 'const css = "color: #fff; background: #abc123; border: #12G456";',
    setupCode: 'const css = "color: #fff; background: #abc123; border: #12G456";',
    expected: ['#fff', '#abc123'],
    sample: 'css.match(/#[0-9a-fA-F]{3}(?:[0-9a-fA-F]{3})?\\b/g)',
    hints: ['Match # followed by 3 or 6 hex digits', 'Use word boundary to avoid partial matches'],
    tags: ['regex', 'match', 'color'],
  },
  {
    id: 'js-regex-055',
    category: 'String Parsing',
    difficulty: 'medium',
    title: 'Parse CSV Line',
    text: 'Split a CSV line handling quoted values with commas.',
    setup: 'const csv = \'John,"Doe, Jr.",30\';',
    setupCode: 'const csv = \'John,"Doe, Jr.",30\';',
    expected: ['John', '"Doe, Jr."', '30'],
    sample: 'csv.match(/("[^"]*"|[^,]+)/g)',
    hints: ['Match quoted strings OR non-comma sequences', 'Use alternation with |'],
    tags: ['regex', 'match', 'csv'],
  },
  {
    id: 'js-regex-056',
    category: 'Regular Expressions',
    difficulty: 'hard',
    title: 'Email Validation',
    text: 'Test if the string is a valid email format.',
    setup: 'const email = "test.user+tag@sub.example.com";',
    setupCode: 'const email = "test.user+tag@sub.example.com";',
    expected: true,
    sample: '/^[\\w.+-]+@[\\w.-]+\\.[a-zA-Z]{2,}$/.test(email)',
    hints: ['Match username @ domain . tld', 'Allow dots, plus, hyphen in username'],
    tags: ['regex', 'test', 'email', 'validation'],
  },
  {
    id: 'js-regex-057',
    category: 'Regular Expressions',
    difficulty: 'hard',
    title: 'URL Validation',
    text: 'Test if the string is a valid URL format.',
    setup: 'const url = "https://www.example.com:8080/path?query=1#hash";',
    setupCode: 'const url = "https://www.example.com:8080/path?query=1#hash";',
    expected: true,
    sample: '/^https?:\\/\\/[\\w.-]+(:\\d+)?(\\/[\\w./-]*)?(\\?[\\w=&]*)?(#\\w*)?$/.test(url)',
    hints: ['Match protocol, domain, optional port, path, query, hash', 'Each part is optional except protocol and domain'],
    tags: ['regex', 'test', 'url', 'validation'],
  },
  {
    id: 'js-regex-058',
    category: 'Regular Expressions',
    difficulty: 'hard',
    title: 'Password Strength',
    text: 'Test if password has at least 8 chars, one uppercase, one lowercase, one digit, and one special char.',
    setup: 'const password = "MyP@ssw0rd";',
    setupCode: 'const password = "MyP@ssw0rd";',
    expected: true,
    sample: '/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*]).{8,}$/.test(password)',
    hints: ['Use multiple lookaheads for each requirement', 'Lookaheads check without consuming'],
    tags: ['regex', 'test', 'password', 'validation'],
  },
  {
    id: 'js-regex-059',
    category: 'Regular Expressions',
    difficulty: 'hard',
    title: 'Phone Number Formats',
    text: 'Match phone numbers in various formats: (555) 123-4567, 555-123-4567, 5551234567.',
    setup: 'const text = "Call (555) 123-4567 or 555-123-4567 or 5551234567";',
    setupCode: 'const text = "Call (555) 123-4567 or 555-123-4567 or 5551234567";',
    expected: ['(555) 123-4567', '555-123-4567', '5551234567'],
    sample: 'text.match(/\\(?\\d{3}\\)?[-.\\s]?\\d{3}[-.\\s]?\\d{4}/g)',
    hints: ['Make parens and separators optional', 'Use [-.\\s]? for flexible separators'],
    tags: ['regex', 'match', 'phone', 'validation'],
  },
  {
    id: 'js-regex-060',
    category: 'String Parsing',
    difficulty: 'hard',
    title: 'Extract All URLs',
    text: 'Extract all URLs from the text.',
    setup: 'const text = "Visit https://example.com and http://test.org/path for more info.";',
    setupCode: 'const text = "Visit https://example.com and http://test.org/path for more info.";',
    expected: ['https://example.com', 'http://test.org/path'],
    sample: 'text.match(/https?:\\/\\/[\\w.-]+(\\/[\\w./-]*)?/g)',
    hints: ['Match http:// or https:// followed by domain and optional path', 'Use optional group for path'],
    tags: ['regex', 'match', 'url', 'extraction'],
  },
  {
    id: 'js-regex-061',
    category: 'String Parsing',
    difficulty: 'hard',
    title: 'Parse HTML Attributes',
    text: 'Extract all attribute name-value pairs from the HTML tag.',
    setup: 'const tag = \'<input type="text" name="email" required>\';',
    setupCode: 'const tag = \'<input type="text" name="email" required>\';',
    expected: ['type="text"', 'name="email"'],
    sample: 'tag.match(/\\w+="[^"]*"/g)',
    hints: ['Match word="value" pattern', 'Value is anything except quote'],
    tags: ['regex', 'match', 'html', 'parsing'],
  },
  {
    id: 'js-regex-062',
    category: 'String Parsing',
    difficulty: 'hard',
    title: 'Tokenize Expression',
    text: 'Split a math expression into tokens (numbers and operators).',
    setup: 'const expr = "12+34*56-78/90";',
    setupCode: 'const expr = "12+34*56-78/90";',
    expected: ['12', '+', '34', '*', '56', '-', '78', '/', '90'],
    sample: 'expr.match(/\\d+|[+\\-*/]/g)',
    hints: ['Match numbers OR operators', 'Use alternation with |'],
    tags: ['regex', 'match', 'tokenize', 'parsing'],
  },
  {
    id: 'js-regex-063',
    category: 'Regular Expressions',
    difficulty: 'hard',
    title: 'Validate Date Format',
    text: 'Test if the string is a valid date in YYYY-MM-DD format.',
    setup: 'const date = "2023-12-25";',
    setupCode: 'const date = "2023-12-25";',
    expected: true,
    sample: '/^\\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])$/.test(date)',
    hints: ['Validate year, month 01-12, day 01-31', 'Use alternation for valid ranges'],
    tags: ['regex', 'test', 'date', 'validation'],
  },
  {
    id: 'js-regex-064',
    category: 'String Parsing',
    difficulty: 'hard',
    title: 'Convert Date Format',
    text: 'Convert date from MM/DD/YYYY to YYYY-MM-DD format.',
    setup: 'const date = "12/25/2023";',
    setupCode: 'const date = "12/25/2023";',
    expected: '2023-12-25',
    sample: 'date.replace(/(\\d{2})\\/(\\d{2})\\/(\\d{4})/, "$3-$1-$2")',
    hints: ['Capture month, day, year separately', 'Rearrange with $3-$1-$2'],
    tags: ['regex', 'replace', 'date', 'formatting'],
  },
  {
    id: 'js-regex-065',
    category: 'Regular Expressions',
    difficulty: 'hard',
    title: 'Match Balanced Parens (Simple)',
    text: 'Extract content inside the outermost parentheses.',
    setup: 'const str = "func(arg1, (nested), arg2)";',
    setupCode: 'const str = "func(arg1, (nested), arg2)";',
    expected: 'arg1, (nested), arg2',
    sample: 'str.match(/\\((.*)\\)/)[1]',
    hints: ['Match from first ( to last )', 'Greedy .* captures everything between'],
    tags: ['regex', 'match', 'parsing'],
  },
  {
    id: 'js-regex-066',
    category: 'String Parsing',
    difficulty: 'hard',
    title: 'Sentence Case',
    text: 'Convert text to sentence case (capitalize first letter of each sentence).',
    setup: 'const text = "hello world. how are you? i am fine.";',
    setupCode: 'const text = "hello world. how are you? i am fine.";',
    expected: 'Hello world. How are you? I am fine.',
    sample: 'text.replace(/(^|[.!?]\\s+)([a-z])/g, (m, p1, p2) => p1 + p2.toUpperCase())',
    hints: ['Match start or punctuation followed by letter', 'Use callback to uppercase'],
    tags: ['regex', 'replace', 'case-conversion'],
  },
  {
    id: 'js-regex-067',
    category: 'String Parsing',
    difficulty: 'hard',
    title: 'Parse JSON Path',
    text: 'Extract all keys from a JSON path string.',
    setup: 'const path = "user.profile.address.city";',
    setupCode: 'const path = "user.profile.address.city";',
    expected: ['user', 'profile', 'address', 'city'],
    sample: 'path.match(/[^.]+/g)',
    hints: ['Match sequences of non-dot characters', 'Or simply split by dot'],
    tags: ['regex', 'match', 'json', 'parsing'],
  },
  {
    id: 'js-regex-068',
    category: 'Regular Expressions',
    difficulty: 'hard',
    title: 'Validate IPv4',
    text: 'Test if the string is a valid IPv4 address.',
    setup: 'const ip = "192.168.1.255";',
    setupCode: 'const ip = "192.168.1.255";',
    expected: true,
    sample: '/^((25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/.test(ip)',
    hints: ['Each octet is 0-255', 'Use alternation for different ranges'],
    tags: ['regex', 'test', 'ip', 'validation'],
  },
  {
    id: 'js-regex-069',
    category: 'String Parsing',
    difficulty: 'hard',
    title: 'Extract CSS Properties',
    text: 'Extract property-value pairs from inline CSS.',
    setup: 'const style = "color: red; font-size: 14px; margin: 10px 5px;";',
    setupCode: 'const style = "color: red; font-size: 14px; margin: 10px 5px;";',
    expected: ['color: red', 'font-size: 14px', 'margin: 10px 5px'],
    sample: 'style.match(/[\\w-]+:\\s*[^;]+/g)',
    hints: ['Match property: value patterns', 'Value continues until semicolon'],
    tags: ['regex', 'match', 'css', 'parsing'],
  },
  {
    id: 'js-regex-070',
    category: 'Regular Expressions',
    difficulty: 'hard',
    title: 'Validate Credit Card',
    text: 'Test if the string looks like a valid credit card number (13-19 digits, optionally grouped by spaces or dashes).',
    setup: 'const card = "4532-0151-1283-0366";',
    setupCode: 'const card = "4532-0151-1283-0366";',
    expected: true,
    sample: '/^[\\d]{13,19}$|^([\\d]{4}[- ]?){3,4}[\\d]{1,4}$/.test(card)',
    hints: ['Allow plain digits or grouped format', 'Groups of 4 with optional separator'],
    tags: ['regex', 'test', 'credit-card', 'validation'],
  },
  {
    id: 'js-regex-071',
    category: 'String Parsing',
    difficulty: 'hard',
    title: 'Slugify String',
    text: 'Convert a title to a URL-friendly slug (lowercase, spaces to hyphens, remove special chars).',
    setup: 'const title = "Hello World! How Are You?";',
    setupCode: 'const title = "Hello World! How Are You?";',
    expected: 'hello-world-how-are-you',
    sample: 'title.toLowerCase().replace(/[^\\w\\s-]/g, "").replace(/\\s+/g, "-")',
    hints: ['First remove special chars', 'Then replace spaces with hyphens'],
    tags: ['regex', 'replace', 'slug', 'formatting'],
  },
  {
    id: 'js-regex-072',
    category: 'Regular Expressions',
    difficulty: 'hard',
    title: 'Match Template Literals',
    text: 'Extract all template variable names from a template string (format: {{varName}}).',
    setup: 'const template = "Hello {{name}}, your order {{orderId}} is ready!";',
    setupCode: 'const template = "Hello {{name}}, your order {{orderId}} is ready!";',
    expected: ['name', 'orderId'],
    sample: 'template.match(/\\{\\{(\\w+)\\}\\}/g).map(m => m.slice(2, -2))',
    hints: ['Match {{word}} pattern', 'Extract just the variable name'],
    tags: ['regex', 'match', 'template', 'parsing'],
  },
  {
    id: 'js-regex-073',
    category: 'String Parsing',
    difficulty: 'hard',
    title: 'Highlight Search Terms',
    text: 'Wrap all occurrences of search term in <mark> tags (case insensitive).',
    setup: 'const text = "JavaScript is great. I love javascript!";',
    setupCode: 'const text = "JavaScript is great. I love javascript!";',
    expected: '<mark>JavaScript</mark> is great. I love <mark>javascript</mark>!',
    sample: 'text.replace(/javascript/gi, "<mark>$&</mark>")',
    hints: ['Use $& to reference the whole match', 'i flag for case insensitive'],
    tags: ['regex', 'replace', 'highlight'],
  },
  {
    id: 'js-regex-074',
    category: 'Regular Expressions',
    difficulty: 'hard',
    title: 'Match Time Format',
    text: 'Find all valid 24-hour time formats in the string.',
    setup: 'const text = "Meeting at 09:30 and 14:45. Invalid: 25:00 and 12:60.";',
    setupCode: 'const text = "Meeting at 09:30 and 14:45. Invalid: 25:00 and 12:60.";',
    expected: ['09:30', '14:45'],
    sample: 'text.match(/\\b([01]\\d|2[0-3]):[0-5]\\d\\b/g)',
    hints: ['Hours: 00-23, Minutes: 00-59', 'Use word boundaries'],
    tags: ['regex', 'match', 'time', 'validation'],
  },
  {
    id: 'js-regex-075',
    category: 'String Parsing',
    difficulty: 'hard',
    title: 'Parse Query String',
    text: 'Convert query string to an object with key-value pairs.',
    setup: 'const query = "name=John&age=30&city=NYC";',
    setupCode: 'const query = "name=John&age=30&city=NYC";',
    expected: { name: 'John', age: '30', city: 'NYC' },
    sample: 'Object.fromEntries(query.match(/[^&]+/g).map(p => p.split("=")))',
    hints: ['Split by & then by =', 'Use Object.fromEntries to create object'],
    tags: ['regex', 'match', 'query-string', 'parsing'],
  },
  {
    id: 'js-regex-076',
    category: 'Regular Expressions',
    difficulty: 'hard',
    title: 'Unicode Flag',
    text: 'Match emoji characters in the string using unicode flag.',
    setup: 'const str = "Hello  World !";',
    setupCode: 'const str = "Hello  World !";',
    expected: ['', ''],
    sample: 'str.match(/\\p{Emoji}/gu)',
    hints: ['Use \\p{Emoji} with u flag', 'Unicode property escapes need u flag'],
    tags: ['regex', 'match', 'unicode', 'emoji'],
  },
  {
    id: 'js-regex-077',
    category: 'String Parsing',
    difficulty: 'hard',
    title: 'Remove Comments',
    text: 'Remove all JavaScript-style single-line comments from the code.',
    setup: 'const code = "let x = 5; // initialize\\nlet y = 10; // second var";',
    setupCode: 'const code = "let x = 5; // initialize\\nlet y = 10; // second var";',
    expected: 'let x = 5; \nlet y = 10; ',
    sample: 'code.replace(/\\/\\/.*$/gm, "")',
    hints: ['Match // until end of line', 'Use m flag for multiline'],
    tags: ['regex', 'replace', 'comments', 'parsing'],
  },
  {
    id: 'js-regex-078',
    category: 'Regular Expressions',
    difficulty: 'hard',
    title: 'Sticky Flag',
    text: 'Use sticky flag to match consecutive word characters starting at position 0.',
    setup: 'const str = "Hello World";',
    setupCode: 'const str = "Hello World";',
    expected: 'Hello',
    sample: '/\\w+/y.exec(str)[0]',
    hints: ['Sticky flag matches at lastIndex position', 'Default lastIndex is 0'],
    tags: ['regex', 'exec', 'sticky-flag'],
  },
  {
    id: 'js-regex-079',
    category: 'String Parsing',
    difficulty: 'hard',
    title: 'Extract Numbers with Decimals',
    text: 'Find all numbers including decimals and negative numbers.',
    setup: 'const str = "Values: 42, -17, 3.14, -2.5, .5";',
    setupCode: 'const str = "Values: 42, -17, 3.14, -2.5, .5";',
    expected: ['42', '-17', '3.14', '-2.5', '.5'],
    sample: 'str.match(/-?\\d*\\.?\\d+/g)',
    hints: ['Optional negative, optional integer part, optional decimal', 'At least one digit required'],
    tags: ['regex', 'match', 'numbers', 'parsing'],
  },
  {
    id: 'js-regex-080',
    category: 'Regular Expressions',
    difficulty: 'hard',
    title: 'Validate Hex Color',
    text: 'Test if string is a valid hex color (#RGB or #RRGGBB format).',
    setup: 'const color = "#a1B2c3";',
    setupCode: 'const color = "#a1B2c3";',
    expected: true,
    sample: '/^#([0-9a-fA-F]{3}){1,2}$/.test(color)',
    hints: ['Match # followed by 3 or 6 hex digits', '{1,2} allows the 3-char group once or twice'],
    tags: ['regex', 'test', 'color', 'validation'],
  },
  {
    id: 'js-regex-081',
    category: 'String Parsing',
    difficulty: 'easy',
    title: 'Trim Whitespace',
    text: 'Remove leading and trailing whitespace using regex.',
    setup: 'const str = "   Hello World   ";',
    setupCode: 'const str = "   Hello World   ";',
    expected: 'Hello World',
    sample: 'str.replace(/^\\s+|\\s+$/g, "")',
    hints: ['Match whitespace at start OR end', 'Use ^ and $ anchors'],
    tags: ['regex', 'replace', 'whitespace'],
  },
  {
    id: 'js-regex-082',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'Match Entire String',
    text: 'Test if the entire string consists only of letters.',
    setup: 'const str = "HelloWorld";',
    setupCode: 'const str = "HelloWorld";',
    expected: true,
    sample: '/^[a-zA-Z]+$/.test(str)',
    hints: ['Use ^ and $ to match entire string', 'Only allow letters between'],
    tags: ['regex', 'test', 'anchor'],
  },
  {
    id: 'js-regex-083',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'Count Matches',
    text: 'Count how many times "the" appears in the string (case insensitive).',
    setup: 'const str = "The quick brown fox jumps over the lazy dog. The end.";',
    setupCode: 'const str = "The quick brown fox jumps over the lazy dog. The end.";',
    expected: 3,
    sample: '(str.match(/the/gi) || []).length',
    hints: ['Use i flag for case insensitive', 'Handle null result from match'],
    tags: ['regex', 'match', 'count'],
  },
  {
    id: 'js-regex-084',
    category: 'String Parsing',
    difficulty: 'easy',
    title: 'Remove Digits',
    text: 'Remove all digits from the string.',
    setup: 'const str = "abc123def456";',
    setupCode: 'const str = "abc123def456";',
    expected: 'abcdef',
    sample: 'str.replace(/\\d/g, "")',
    hints: ['Replace all digits with empty string', 'Use g flag for global replace'],
    tags: ['regex', 'replace', 'digits'],
  },
  {
    id: 'js-regex-085',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'Match Tab Characters',
    text: 'Count the number of tab characters in the string.',
    setup: 'const str = "col1\\tcol2\\tcol3\\tcol4";',
    setupCode: 'const str = "col1\\tcol2\\tcol3\\tcol4";',
    expected: 3,
    sample: '(str.match(/\\t/g) || []).length',
    hints: ['Use \\t to match tabs', 'Similar to counting any character'],
    tags: ['regex', 'match', 'whitespace'],
  },
  {
    id: 'js-regex-086',
    category: 'String Parsing',
    difficulty: 'easy',
    title: 'Split on Multiple Delimiters',
    text: 'Split the string on comma, semicolon, or pipe.',
    setup: 'const str = "a,b;c|d,e";',
    setupCode: 'const str = "a,b;c|d,e";',
    expected: ['a', 'b', 'c', 'd', 'e'],
    sample: 'str.split(/[,;|]/)',
    hints: ['Use character class for multiple delimiters', 'split accepts regex'],
    tags: ['regex', 'split', 'delimiter'],
  },
  {
    id: 'js-regex-087',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'Match Line Breaks',
    text: 'Count the number of lines in the string.',
    setup: 'const str = "Line 1\\nLine 2\\nLine 3\\nLine 4";',
    setupCode: 'const str = "Line 1\\nLine 2\\nLine 3\\nLine 4";',
    expected: 4,
    sample: 'str.split(/\\n/).length',
    hints: ['Split by newline', 'Number of lines = parts after split'],
    tags: ['regex', 'split', 'lines'],
  },
  {
    id: 'js-regex-088',
    category: 'String Parsing',
    difficulty: 'easy',
    title: 'Capitalize First Letter',
    text: 'Capitalize the first letter of the string using regex.',
    setup: 'const str = "hello world";',
    setupCode: 'const str = "hello world";',
    expected: 'Hello world',
    sample: 'str.replace(/^./, c => c.toUpperCase())',
    hints: ['Match first character with ^.', 'Use callback to uppercase'],
    tags: ['regex', 'replace', 'capitalize'],
  },
  {
    id: 'js-regex-089',
    category: 'Regular Expressions',
    difficulty: 'easy',
    title: 'Match At Least N',
    text: 'Find sequences of at least 3 consecutive digits.',
    setup: 'const str = "12 123 1234 12345";',
    setupCode: 'const str = "12 123 1234 12345";',
    expected: ['123', '1234', '12345'],
    sample: 'str.match(/\\d{3,}/g)',
    hints: ['Use {n,} for at least n', '{3,} means 3 or more'],
    tags: ['regex', 'match', 'quantifier'],
  },
  {
    id: 'js-regex-090',
    category: 'String Parsing',
    difficulty: 'medium',
    title: 'Add Thousand Separators',
    text: 'Add commas as thousand separators to the number.',
    setup: 'const num = "1234567890";',
    setupCode: 'const num = "1234567890";',
    expected: '1,234,567,890',
    sample: 'num.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ",")',
    hints: ['Use lookahead to find positions', '\\B is non-word boundary'],
    tags: ['regex', 'replace', 'formatting'],
  },
  {
    id: 'js-regex-091',
    category: 'Regular Expressions',
    difficulty: 'medium',
    title: 'Match Words Starting With',
    text: 'Find all words that start with "pre".',
    setup: 'const str = "prevent preload unprepared prefix";',
    setupCode: 'const str = "prevent preload unprepared prefix";',
    expected: ['prevent', 'preload', 'prefix'],
    sample: 'str.match(/\\bpre\\w*/g)',
    hints: ['Use word boundary before pre', '\\w* matches rest of word'],
    tags: ['regex', 'match', 'word-boundary'],
  },
  {
    id: 'js-regex-092',
    category: 'Regular Expressions',
    difficulty: 'medium',
    title: 'Match Words Ending With',
    text: 'Find all words that end with "ing".',
    setup: 'const str = "running jumping coding thinking wing";',
    setupCode: 'const str = "running jumping coding thinking wing";',
    expected: ['running', 'jumping', 'coding', 'thinking'],
    sample: 'str.match(/\\w+ing\\b/g)',
    hints: ['\\w+ for word chars before ing', 'Word boundary after ing'],
    tags: ['regex', 'match', 'word-boundary'],
  },
  {
    id: 'js-regex-093',
    category: 'String Parsing',
    difficulty: 'medium',
    title: 'Extract Quoted Strings',
    text: 'Extract all single-quoted strings from the text.',
    setup: `const str = "Say 'hello' and 'goodbye' today";`,
    setupCode: `const str = "Say 'hello' and 'goodbye' today";`,
    expected: ['hello', 'goodbye'],
    sample: `str.match(/'([^']+)'/g).map(s => s.slice(1, -1))`,
    hints: ['Match content between quotes', 'Remove quotes from result'],
    tags: ['regex', 'match', 'parsing'],
  },
  {
    id: 'js-regex-094',
    category: 'Regular Expressions',
    difficulty: 'medium',
    title: 'Match Repeated Characters',
    text: 'Find all sequences of 3 or more repeated characters.',
    setup: 'const str = "aaabbbcccc hello woooorld";',
    setupCode: 'const str = "aaabbbcccc hello woooorld";',
    expected: ['aaa', 'bbb', 'cccc', 'oooo'],
    sample: 'str.match(/(.)\\1{2,}/g)',
    hints: ['Capture a char, then backreference', '\\1{2,} means 2+ more of same'],
    tags: ['regex', 'match', 'backreference'],
  },
  {
    id: 'js-regex-095',
    category: 'String Parsing',
    difficulty: 'medium',
    title: 'Normalize Whitespace',
    text: 'Replace all whitespace (tabs, newlines, spaces) with single spaces.',
    setup: 'const str = "Hello\\t\\tWorld\\n\\nTest";',
    setupCode: 'const str = "Hello\\t\\tWorld\\n\\nTest";',
    expected: 'Hello World Test',
    sample: 'str.replace(/\\s+/g, " ")',
    hints: ['\\s matches all whitespace types', 'Replace multiple with single'],
    tags: ['regex', 'replace', 'whitespace'],
  },
  {
    id: 'js-regex-096',
    category: 'Regular Expressions',
    difficulty: 'medium',
    title: 'Validate Alphanumeric',
    text: 'Test if string contains only alphanumeric characters.',
    setup: 'const str = "Hello123World";',
    setupCode: 'const str = "Hello123World";',
    expected: true,
    sample: '/^[a-zA-Z0-9]+$/.test(str)',
    hints: ['Match only letters and numbers', 'Use ^ and $ for entire string'],
    tags: ['regex', 'test', 'validation'],
  },
  {
    id: 'js-regex-097',
    category: 'String Parsing',
    difficulty: 'medium',
    title: 'Extract Parenthetical Content',
    text: 'Extract all text within parentheses.',
    setup: 'const str = "Call John (555-1234) or Jane (555-5678) today";',
    setupCode: 'const str = "Call John (555-1234) or Jane (555-5678) today";',
    expected: ['555-1234', '555-5678'],
    sample: 'str.match(/\\(([^)]+)\\)/g).map(s => s.slice(1, -1))',
    hints: ['Match content between parens', 'Use [^)]+ for non-paren chars'],
    tags: ['regex', 'match', 'parsing'],
  },
  {
    id: 'js-regex-098',
    category: 'Regular Expressions',
    difficulty: 'hard',
    title: 'Recursive Pattern Simulation',
    text: 'Match nested function calls like fn(fn(x)) - extract the innermost call.',
    setup: 'const str = "fn(fn(fn(x)))";',
    setupCode: 'const str = "fn(fn(fn(x)))";',
    expected: 'fn(x)',
    sample: 'str.match(/fn\\([^()]+\\)/)[0]',
    hints: ['Match fn() with no parens inside', '[^()]+ matches non-paren content'],
    tags: ['regex', 'match', 'nested'],
  },
  {
    id: 'js-regex-099',
    category: 'String Parsing',
    difficulty: 'hard',
    title: 'Parse Markdown Links',
    text: 'Extract link text and URLs from markdown links.',
    setup: 'const md = "Check [Google](https://google.com) and [GitHub](https://github.com)";',
    setupCode: 'const md = "Check [Google](https://google.com) and [GitHub](https://github.com)";',
    expected: [{ text: 'Google', url: 'https://google.com' }, { text: 'GitHub', url: 'https://github.com' }],
    sample: '[...md.matchAll(/\\[([^\\]]+)\\]\\(([^)]+)\\)/g)].map(m => ({ text: m[1], url: m[2] }))',
    hints: ['Use matchAll to get all groups', 'Capture text and URL separately'],
    tags: ['regex', 'matchAll', 'markdown', 'parsing'],
  },
  {
    id: 'js-regex-100',
    category: 'Regular Expressions',
    difficulty: 'hard',
    title: 'Complex Password Rules',
    text: 'Validate: 8-20 chars, at least 2 uppercase, 2 lowercase, 2 digits, no consecutive repeated chars.',
    setup: 'const password = "MyP4ssW0rd";',
    setupCode: 'const password = "MyP4ssW0rd";',
    expected: true,
    sample: '/^(?=(?:.*[A-Z]){2})(?=(?:.*[a-z]){2})(?=(?:.*\\d){2})(?!.*(.)\\1).{8,20}$/.test(password)',
    hints: ['Multiple lookaheads for each requirement', 'Negative lookahead for consecutive'],
    tags: ['regex', 'test', 'password', 'validation'],
  },
  // ========================================
  // ASYNC/AWAIT & PROMISES
  // ========================================
  {
    id: 'js-async-001',
    category: 'Promises',
    difficulty: 'easy',
    title: 'Create Resolved Promise',
    text: 'Create a promise that immediately resolves with the value 42.',
    setup: '// Create a resolved promise',
    setupCode: '// Create a resolved promise',
    expected: 42,
    sample: 'await Promise.resolve(42)',
    hints: ['Use Promise.resolve()', 'Pass the value directly to resolve'],
    tags: ['promises', 'Promise.resolve', 'basics'],
  },
  {
    id: 'js-async-002',
    category: 'Promises',
    difficulty: 'easy',
    title: 'Create Rejected Promise',
    text: 'Create a promise that immediately rejects with the error message "Failed".',
    setup: '// Create a rejected promise and catch the error',
    setupCode: '// Create a rejected promise and catch the error',
    expected: 'Failed',
    sample: 'await Promise.reject("Failed").catch(e => e)',
    hints: ['Use Promise.reject()', 'Use .catch() to handle the rejection'],
    tags: ['promises', 'Promise.reject', 'error-handling'],
  },
  {
    id: 'js-async-003',
    category: 'Async Patterns',
    difficulty: 'easy',
    title: 'Basic Async Function',
    text: 'Write an async function that returns the number 10.',
    setup: '// Define an async function',
    setupCode: '// Define an async function',
    expected: 10,
    sample: '(async () => 10)()',
    hints: ['Async functions always return a promise', 'The return value is wrapped in Promise.resolve()'],
    tags: ['async', 'await', 'basics'],
  },
  {
    id: 'js-async-004',
    category: 'Promises',
    difficulty: 'easy',
    title: 'Chain Then Methods',
    text: 'Chain .then() to double the resolved value.',
    setup: 'const promise = Promise.resolve(5);',
    setupCode: 'const promise = Promise.resolve(5);',
    expected: 10,
    sample: 'await promise.then(x => x * 2)',
    hints: ['Use .then() to transform the value', 'Return the new value from the callback'],
    tags: ['promises', 'then', 'chaining'],
  },
  {
    id: 'js-async-005',
    category: 'Promises',
    difficulty: 'easy',
    title: 'Multiple Then Chains',
    text: 'Chain multiple .then() calls to add 1, then multiply by 2.',
    setup: 'const promise = Promise.resolve(3);',
    setupCode: 'const promise = Promise.resolve(3);',
    expected: 8,
    sample: 'await promise.then(x => x + 1).then(x => x * 2)',
    hints: ['Each .then() returns a new promise', 'Chain them together'],
    tags: ['promises', 'then', 'chaining'],
  },
  {
    id: 'js-async-006',
    category: 'Async Patterns',
    difficulty: 'easy',
    title: 'Await a Promise',
    text: 'Use await to get the value from the promise.',
    setup: 'const promise = Promise.resolve("hello");',
    setupCode: 'const promise = Promise.resolve("hello");',
    expected: 'hello',
    sample: 'await promise',
    hints: ['Use the await keyword', 'await unwraps the promise value'],
    tags: ['async', 'await', 'basics'],
  },
  {
    id: 'js-async-007',
    category: 'Promises',
    difficulty: 'easy',
    title: 'Promise.all with Two Promises',
    text: 'Use Promise.all to wait for both promises and return their values.',
    setup: 'const p1 = Promise.resolve(1); const p2 = Promise.resolve(2);',
    setupCode: 'const p1 = Promise.resolve(1); const p2 = Promise.resolve(2);',
    expected: [1, 2],
    sample: 'await Promise.all([p1, p2])',
    hints: ['Promise.all takes an array of promises', 'It returns an array of resolved values'],
    tags: ['promises', 'Promise.all', 'basics'],
  },
  {
    id: 'js-async-008',
    category: 'Promises',
    difficulty: 'easy',
    title: 'Promise.race Basics',
    text: 'Use Promise.race to get the first resolved value.',
    setup: 'const fast = Promise.resolve("fast"); const slow = new Promise(r => setTimeout(() => r("slow"), 100));',
    setupCode: 'const fast = Promise.resolve("fast"); const slow = new Promise(r => setTimeout(() => r("slow"), 100));',
    expected: 'fast',
    sample: 'await Promise.race([fast, slow])',
    hints: ['Promise.race returns the first settled promise', 'The already-resolved promise wins'],
    tags: ['promises', 'Promise.race', 'basics'],
  },
  {
    id: 'js-async-009',
    category: 'Promises',
    difficulty: 'easy',
    title: 'Catch Promise Error',
    text: 'Catch the error from the rejected promise and return its message.',
    setup: 'const promise = Promise.reject(new Error("Oops"));',
    setupCode: 'const promise = Promise.reject(new Error("Oops"));',
    expected: 'Oops',
    sample: 'await promise.catch(e => e.message)',
    hints: ['Use .catch() to handle rejections', 'Access the message property of the error'],
    tags: ['promises', 'catch', 'error-handling'],
  },
  {
    id: 'js-async-010',
    category: 'Async Patterns',
    difficulty: 'easy',
    title: 'Try-Catch with Await',
    text: 'Use try-catch to handle the rejected promise and return the error message.',
    setup: 'const promise = Promise.reject(new Error("Error occurred"));',
    setupCode: 'const promise = Promise.reject(new Error("Error occurred"));',
    expected: 'Error occurred',
    sample: '(async () => { try { await promise; } catch (e) { return e.message; } })()',
    hints: ['Wrap await in try-catch', 'Return the error message from catch block'],
    tags: ['async', 'await', 'try-catch', 'error-handling'],
  },
  {
    id: 'js-async-011',
    category: 'Promises',
    difficulty: 'easy',
    title: 'Finally Block',
    text: 'Use .finally() to return "done" regardless of promise outcome.',
    setup: 'let result = ""; const promise = Promise.resolve("success");',
    setupCode: 'let result = ""; const promise = Promise.resolve("success");',
    expected: 'done',
    sample: 'await promise.finally(() => { result = "done"; }).then(() => result)',
    hints: ['.finally() runs regardless of outcome', 'It does not receive the resolved value'],
    tags: ['promises', 'finally', 'basics'],
  },
  {
    id: 'js-async-012',
    category: 'Promises',
    difficulty: 'easy',
    title: 'Promise Constructor',
    text: 'Create a new Promise that resolves with "created" after calling resolve.',
    setup: '// Use new Promise constructor',
    setupCode: '// Use new Promise constructor',
    expected: 'created',
    sample: 'await new Promise(resolve => resolve("created"))',
    hints: ['Use new Promise((resolve, reject) => {})', 'Call resolve with the value'],
    tags: ['promises', 'constructor', 'basics'],
  },
  {
    id: 'js-async-013',
    category: 'Async Patterns',
    difficulty: 'easy',
    title: 'Return Value from Async',
    text: 'Return the sum of two awaited promises.',
    setup: 'const p1 = Promise.resolve(10); const p2 = Promise.resolve(20);',
    setupCode: 'const p1 = Promise.resolve(10); const p2 = Promise.resolve(20);',
    expected: 30,
    sample: '(async () => await p1 + await p2)()',
    hints: ['Await each promise', 'Add the results together'],
    tags: ['async', 'await', 'arithmetic'],
  },
  {
    id: 'js-async-014',
    category: 'Promises',
    difficulty: 'easy',
    title: 'Promise.resolve with Array',
    text: 'Create a resolved promise containing an array [1, 2, 3].',
    setup: '// Create a resolved promise with array',
    setupCode: '// Create a resolved promise with array',
    expected: [1, 2, 3],
    sample: 'await Promise.resolve([1, 2, 3])',
    hints: ['Promise.resolve can wrap any value', 'Arrays work just like other values'],
    tags: ['promises', 'Promise.resolve', 'arrays'],
  },
  {
    id: 'js-async-015',
    category: 'Promises',
    difficulty: 'easy',
    title: 'Promise.all Empty Array',
    text: 'What does Promise.all return when given an empty array?',
    setup: '// Call Promise.all with empty array',
    setupCode: '// Call Promise.all with empty array',
    expected: [],
    sample: 'await Promise.all([])',
    hints: ['Promise.all with empty array resolves immediately', 'It returns an empty array'],
    tags: ['promises', 'Promise.all', 'edge-cases'],
  },
  {
    id: 'js-async-016',
    category: 'Async Patterns',
    difficulty: 'easy',
    title: 'Async Arrow Function',
    text: 'Create an async arrow function that returns "arrow".',
    setup: '// Define async arrow function',
    setupCode: '// Define async arrow function',
    expected: 'arrow',
    sample: '(async () => "arrow")()',
    hints: ['Add async before the arrow function', 'Return value is automatically wrapped'],
    tags: ['async', 'arrow-functions', 'basics'],
  },
  {
    id: 'js-async-017',
    category: 'Promises',
    difficulty: 'easy',
    title: 'Then with Object',
    text: 'Extract the name property from the resolved object.',
    setup: 'const promise = Promise.resolve({ name: "Alice", age: 30 });',
    setupCode: 'const promise = Promise.resolve({ name: "Alice", age: 30 });',
    expected: 'Alice',
    sample: 'await promise.then(obj => obj.name)',
    hints: ['Use .then() to access the object', 'Return the name property'],
    tags: ['promises', 'then', 'objects'],
  },
  {
    id: 'js-async-018',
    category: 'Promises',
    difficulty: 'easy',
    title: 'Chained Catch',
    text: 'Handle error in first promise and continue the chain.',
    setup: 'const promise = Promise.reject("error").catch(() => "recovered");',
    setupCode: 'const promise = Promise.reject("error").catch(() => "recovered");',
    expected: 'recovered',
    sample: 'await promise',
    hints: ['.catch() returns a new promise', 'The chain continues with the recovered value'],
    tags: ['promises', 'catch', 'chaining'],
  },
  {
    id: 'js-async-019',
    category: 'Promises',
    difficulty: 'easy',
    title: 'Promise.resolve with Promise',
    text: 'What happens when you call Promise.resolve on an existing promise?',
    setup: 'const original = Promise.resolve(100); const wrapped = Promise.resolve(original);',
    setupCode: 'const original = Promise.resolve(100); const wrapped = Promise.resolve(original);',
    expected: 100,
    sample: 'await wrapped',
    hints: ['Promise.resolve returns the same promise if given one', 'It does not double-wrap'],
    tags: ['promises', 'Promise.resolve', 'identity'],
  },
  {
    id: 'js-async-020',
    category: 'Async Patterns',
    difficulty: 'easy',
    title: 'Sequential Await',
    text: 'Await two promises sequentially and concatenate their string values.',
    setup: 'const p1 = Promise.resolve("Hello"); const p2 = Promise.resolve("World");',
    setupCode: 'const p1 = Promise.resolve("Hello"); const p2 = Promise.resolve("World");',
    expected: 'HelloWorld',
    sample: '(async () => (await p1) + (await p2))()',
    hints: ['Await each promise in order', 'Concatenate the results'],
    tags: ['async', 'await', 'strings'],
  },
  {
    id: 'js-async-021',
    category: 'Promises',
    difficulty: 'easy',
    title: 'Transform Promise Value',
    text: 'Use .then() to uppercase the string value.',
    setup: 'const promise = Promise.resolve("hello");',
    setupCode: 'const promise = Promise.resolve("hello");',
    expected: 'HELLO',
    sample: 'await promise.then(s => s.toUpperCase())',
    hints: ['Use .then() to transform', 'Call toUpperCase() on the string'],
    tags: ['promises', 'then', 'strings'],
  },
  {
    id: 'js-async-022',
    category: 'Promises',
    difficulty: 'easy',
    title: 'Promise.all with Three Values',
    text: 'Sum the results of three resolved promises.',
    setup: 'const promises = [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)];',
    setupCode: 'const promises = [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)];',
    expected: 6,
    sample: 'await Promise.all(promises).then(arr => arr.reduce((a, b) => a + b, 0))',
    hints: ['Use Promise.all to wait for all', 'Use reduce to sum the array'],
    tags: ['promises', 'Promise.all', 'reduce'],
  },
  {
    id: 'js-async-023',
    category: 'Async Patterns',
    difficulty: 'easy',
    title: 'Async Function Returns Promise',
    text: 'Verify that an async function returns a promise by checking its type.',
    setup: 'const asyncFn = async () => 5;',
    setupCode: 'const asyncFn = async () => 5;',
    expected: true,
    sample: 'asyncFn() instanceof Promise',
    hints: ['Call the async function', 'Check if result is instanceof Promise'],
    tags: ['async', 'promises', 'instanceof'],
  },
  {
    id: 'js-async-024',
    category: 'Promises',
    difficulty: 'easy',
    title: 'Catch and Rethrow',
    text: 'Catch an error, log it, and rethrow with a new message.',
    setup: 'const promise = Promise.reject("original");',
    setupCode: 'const promise = Promise.reject("original");',
    expected: 'wrapped: original',
    sample: 'await promise.catch(e => { throw "wrapped: " + e; }).catch(e => e)',
    hints: ['First catch can throw again', 'Second catch handles the new error'],
    tags: ['promises', 'catch', 'error-handling'],
  },
  {
    id: 'js-async-025',
    category: 'Promises',
    difficulty: 'easy',
    title: 'Promise with Boolean',
    text: 'Create a promise that resolves to true.',
    setup: '// Create boolean promise',
    setupCode: '// Create boolean promise',
    expected: true,
    sample: 'await Promise.resolve(true)',
    hints: ['Promise.resolve works with booleans', 'Just pass true as the value'],
    tags: ['promises', 'Promise.resolve', 'booleans'],
  },
  {
    id: 'js-async-026',
    category: 'Promises',
    difficulty: 'medium',
    title: 'Promise.allSettled Basics',
    text: 'Use Promise.allSettled to get the status of both resolved and rejected promises.',
    setup: 'const promises = [Promise.resolve("ok"), Promise.reject("fail")];',
    setupCode: 'const promises = [Promise.resolve("ok"), Promise.reject("fail")];',
    expected: [{ status: 'fulfilled', value: 'ok' }, { status: 'rejected', reason: 'fail' }],
    sample: 'await Promise.allSettled(promises)',
    hints: ['Promise.allSettled never rejects', 'It returns objects with status and value/reason'],
    tags: ['promises', 'Promise.allSettled', 'error-handling'],
  },
  {
    id: 'js-async-027',
    category: 'Promises',
    difficulty: 'medium',
    title: 'Promise.any First Success',
    text: 'Use Promise.any to get the first successful result.',
    setup: 'const promises = [Promise.reject("err1"), Promise.resolve("success"), Promise.reject("err2")];',
    setupCode: 'const promises = [Promise.reject("err1"), Promise.resolve("success"), Promise.reject("err2")];',
    expected: 'success',
    sample: 'await Promise.any(promises)',
    hints: ['Promise.any returns first fulfilled promise', 'It ignores rejections until all fail'],
    tags: ['promises', 'Promise.any', 'basics'],
  },
  {
    id: 'js-async-028',
    category: 'Event Loop',
    difficulty: 'medium',
    title: 'Microtask vs Macrotask Order',
    text: 'Predict the order: Promise.then runs before setTimeout.',
    setup: 'const order = []; setTimeout(() => order.push("timeout"), 0); Promise.resolve().then(() => order.push("promise"));',
    setupCode: 'const order = []; setTimeout(() => order.push("timeout"), 0); Promise.resolve().then(() => order.push("promise"));',
    expected: ['promise', 'timeout'],
    sample: 'await new Promise(r => setTimeout(r, 10)).then(() => order)',
    hints: ['Microtasks run before macrotasks', 'Promise.then is a microtask, setTimeout is macrotask'],
    tags: ['event-loop', 'microtasks', 'macrotasks'],
  },
  {
    id: 'js-async-029',
    category: 'Async Patterns',
    difficulty: 'medium',
    title: 'Parallel Promise Execution',
    text: 'Run promises in parallel and return when all complete.',
    setup: 'const delay = (ms, val) => new Promise(r => setTimeout(() => r(val), ms));',
    setupCode: 'const delay = (ms, val) => new Promise(r => setTimeout(() => r(val), ms));',
    expected: ['a', 'b', 'c'],
    sample: 'await Promise.all([delay(10, "a"), delay(20, "b"), delay(15, "c")])',
    hints: ['Use Promise.all for parallel execution', 'Results are in the same order as input'],
    tags: ['async', 'Promise.all', 'parallel'],
  },
  {
    id: 'js-async-030',
    category: 'Promises',
    difficulty: 'medium',
    title: 'Promise Chain with Map',
    text: 'Map over an array to create promises, then wait for all.',
    setup: 'const nums = [1, 2, 3];',
    setupCode: 'const nums = [1, 2, 3];',
    expected: [2, 4, 6],
    sample: 'await Promise.all(nums.map(n => Promise.resolve(n * 2)))',
    hints: ['Map creates an array of promises', 'Promise.all waits for all'],
    tags: ['promises', 'Promise.all', 'map'],
  },
  {
    id: 'js-async-031',
    category: 'Async Patterns',
    difficulty: 'medium',
    title: 'Sequential Promise Execution',
    text: 'Execute promises one after another, collecting results.',
    setup: 'const tasks = [() => Promise.resolve(1), () => Promise.resolve(2), () => Promise.resolve(3)];',
    setupCode: 'const tasks = [() => Promise.resolve(1), () => Promise.resolve(2), () => Promise.resolve(3)];',
    expected: [1, 2, 3],
    sample: 'await tasks.reduce(async (acc, fn) => [...await acc, await fn()], Promise.resolve([]))',
    hints: ['Use reduce for sequential execution', 'Await the accumulator before adding new result'],
    tags: ['async', 'await', 'sequential', 'reduce'],
  },
  {
    id: 'js-async-032',
    category: 'Promises',
    difficulty: 'medium',
    title: 'Promise.race with Timeout',
    text: 'Implement a timeout using Promise.race.',
    setup: 'const slow = new Promise(r => setTimeout(() => r("slow"), 100)); const timeout = new Promise((_, rej) => setTimeout(() => rej("timeout"), 50));',
    setupCode: 'const slow = new Promise(r => setTimeout(() => r("slow"), 100)); const timeout = new Promise((_, rej) => setTimeout(() => rej("timeout"), 50));',
    expected: 'timeout',
    sample: 'await Promise.race([slow, timeout]).catch(e => e)',
    hints: ['Promise.race returns first settled', 'The timeout rejection wins'],
    tags: ['promises', 'Promise.race', 'timeout'],
  },
  {
    id: 'js-async-033',
    category: 'Async Patterns',
    difficulty: 'medium',
    title: 'Async Error Propagation',
    text: 'Throw an error in an async function and catch it.',
    setup: 'const asyncError = async () => { throw new Error("async error"); };',
    setupCode: 'const asyncError = async () => { throw new Error("async error"); };',
    expected: 'async error',
    sample: 'await asyncError().catch(e => e.message)',
    hints: ['Thrown errors become rejections', 'Catch with .catch() or try-catch'],
    tags: ['async', 'error-handling', 'throw'],
  },
  {
    id: 'js-async-034',
    category: 'Promises',
    difficulty: 'medium',
    title: 'Promisify Callback Function',
    text: 'Convert a callback-style function to return a promise.',
    setup: 'const callbackFn = (val, cb) => setTimeout(() => cb(null, val * 2), 10);',
    setupCode: 'const callbackFn = (val, cb) => setTimeout(() => cb(null, val * 2), 10);',
    expected: 10,
    sample: 'await new Promise((resolve, reject) => callbackFn(5, (err, result) => err ? reject(err) : resolve(result)))',
    hints: ['Wrap the callback function in new Promise', 'Call resolve or reject based on callback args'],
    tags: ['promises', 'promisify', 'callbacks'],
  },
  {
    id: 'js-async-035',
    category: 'Promises',
    difficulty: 'medium',
    title: 'Promise.all Rejection',
    text: 'What happens when one promise in Promise.all rejects?',
    setup: 'const promises = [Promise.resolve(1), Promise.reject("error"), Promise.resolve(3)];',
    setupCode: 'const promises = [Promise.resolve(1), Promise.reject("error"), Promise.resolve(3)];',
    expected: 'error',
    sample: 'await Promise.all(promises).catch(e => e)',
    hints: ['Promise.all fails fast', 'One rejection rejects the whole thing'],
    tags: ['promises', 'Promise.all', 'error-handling'],
  },
  {
    id: 'js-async-036',
    category: 'Async Patterns',
    difficulty: 'medium',
    title: 'Async IIFE',
    text: 'Use an async IIFE to immediately execute async code.',
    setup: 'let value = 0;',
    setupCode: 'let value = 0;',
    expected: 42,
    sample: '(async () => { value = await Promise.resolve(42); return value; })()',
    hints: ['Wrap async function in parentheses', 'Immediately invoke it with ()'],
    tags: ['async', 'IIFE', 'patterns'],
  },
  {
    id: 'js-async-037',
    category: 'Promises',
    difficulty: 'medium',
    title: 'Chained Promise Transformation',
    text: 'Chain multiple transformations: add 5, multiply by 2, subtract 3.',
    setup: 'const promise = Promise.resolve(10);',
    setupCode: 'const promise = Promise.resolve(10);',
    expected: 27,
    sample: 'await promise.then(x => x + 5).then(x => x * 2).then(x => x - 3)',
    hints: ['Each .then() transforms the value', 'Chain them in order of operations'],
    tags: ['promises', 'then', 'chaining'],
  },
  {
    id: 'js-async-038',
    category: 'Event Loop',
    difficulty: 'medium',
    title: 'queueMicrotask Usage',
    text: 'Use queueMicrotask to schedule a microtask.',
    setup: 'const order = [];',
    setupCode: 'const order = [];',
    expected: ['sync', 'microtask', 'timeout'],
    sample: '(() => { order.push("sync"); queueMicrotask(() => order.push("microtask")); setTimeout(() => order.push("timeout"), 0); return new Promise(r => setTimeout(r, 20)); })().then(() => order)',
    hints: ['queueMicrotask schedules a microtask', 'Microtasks run before setTimeout'],
    tags: ['event-loop', 'microtasks', 'queueMicrotask'],
  },
  {
    id: 'js-async-039',
    category: 'Async Patterns',
    difficulty: 'medium',
    title: 'Conditional Await',
    text: 'Await only if the value is a promise.',
    setup: 'const maybePromise = Promise.resolve(100); const notPromise = 50;',
    setupCode: 'const maybePromise = Promise.resolve(100); const notPromise = 50;',
    expected: 150,
    sample: '(async () => (await maybePromise) + notPromise)()',
    hints: ['Await works on non-promises too', 'It just returns the value immediately'],
    tags: ['async', 'await', 'conditional'],
  },
  {
    id: 'js-async-040',
    category: 'Promises',
    difficulty: 'medium',
    title: 'Promise.allSettled Filter Fulfilled',
    text: 'Filter only the fulfilled results from Promise.allSettled.',
    setup: 'const promises = [Promise.resolve(1), Promise.reject("err"), Promise.resolve(3)];',
    setupCode: 'const promises = [Promise.resolve(1), Promise.reject("err"), Promise.resolve(3)];',
    expected: [1, 3],
    sample: 'await Promise.allSettled(promises).then(results => results.filter(r => r.status === "fulfilled").map(r => r.value))',
    hints: ['Filter by status property', 'Map to extract values'],
    tags: ['promises', 'Promise.allSettled', 'filter'],
  },
  {
    id: 'js-async-041',
    category: 'Async Patterns',
    difficulty: 'medium',
    title: 'Async Array Filter',
    text: 'Filter an array asynchronously based on async predicate.',
    setup: 'const nums = [1, 2, 3, 4, 5]; const asyncIsEven = async n => n % 2 === 0;',
    setupCode: 'const nums = [1, 2, 3, 4, 5]; const asyncIsEven = async n => n % 2 === 0;',
    expected: [2, 4],
    sample: 'await Promise.all(nums.map(async n => ({ n, keep: await asyncIsEven(n) }))).then(results => results.filter(r => r.keep).map(r => r.n))',
    hints: ['Map to check each item', 'Filter based on async result'],
    tags: ['async', 'filter', 'arrays'],
  },
  {
    id: 'js-async-042',
    category: 'Promises',
    difficulty: 'medium',
    title: 'Promise with Delay',
    text: 'Create a delay function that resolves after specified milliseconds.',
    setup: 'const start = Date.now();',
    setupCode: 'const start = Date.now();',
    expected: true,
    sample: 'await new Promise(r => setTimeout(r, 50)).then(() => Date.now() - start >= 50)',
    hints: ['Use setTimeout inside Promise', 'Resolve after the timeout'],
    tags: ['promises', 'setTimeout', 'delay'],
  },
  {
    id: 'js-async-043',
    category: 'Async Patterns',
    difficulty: 'medium',
    title: 'Async Reduce',
    text: 'Use reduce with async/await to sum values sequentially.',
    setup: 'const asyncNums = [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)];',
    setupCode: 'const asyncNums = [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)];',
    expected: 6,
    sample: 'await asyncNums.reduce(async (acc, p) => (await acc) + (await p), Promise.resolve(0))',
    hints: ['Await the accumulator first', 'Then await the current promise'],
    tags: ['async', 'reduce', 'sequential'],
  },
  {
    id: 'js-async-044',
    category: 'Promises',
    difficulty: 'medium',
    title: 'Promise.any All Rejected',
    text: 'Handle when all promises passed to Promise.any reject.',
    setup: 'const promises = [Promise.reject("a"), Promise.reject("b"), Promise.reject("c")];',
    setupCode: 'const promises = [Promise.reject("a"), Promise.reject("b"), Promise.reject("c")];',
    expected: ['a', 'b', 'c'],
    sample: 'await Promise.any(promises).catch(e => e.errors)',
    hints: ['Promise.any throws AggregateError', 'Access errors property for all rejection reasons'],
    tags: ['promises', 'Promise.any', 'AggregateError'],
  },
  {
    id: 'js-async-045',
    category: 'Event Loop',
    difficulty: 'medium',
    title: 'Multiple Microtasks Order',
    text: 'Predict the order of multiple chained promises.',
    setup: 'const order = []; Promise.resolve().then(() => order.push(1)).then(() => order.push(2)); Promise.resolve().then(() => order.push(3));',
    setupCode: 'const order = []; Promise.resolve().then(() => order.push(1)).then(() => order.push(2)); Promise.resolve().then(() => order.push(3));',
    expected: [1, 3, 2],
    sample: 'await new Promise(r => setTimeout(r, 10)).then(() => order)',
    hints: ['First .then() from each chain runs first', 'Chained .then() is scheduled after'],
    tags: ['event-loop', 'microtasks', 'order'],
  },
  {
    id: 'js-async-046',
    category: 'Async Patterns',
    difficulty: 'medium',
    title: 'Async Method in Object',
    text: 'Define an object with an async method.',
    setup: 'const obj = { async getValue() { return 42; } };',
    setupCode: 'const obj = { async getValue() { return 42; } };',
    expected: 42,
    sample: 'await obj.getValue()',
    hints: ['Async methods work like async functions', 'Await the method call'],
    tags: ['async', 'objects', 'methods'],
  },
  {
    id: 'js-async-047',
    category: 'Promises',
    difficulty: 'medium',
    title: 'Promise Chain Recovery',
    text: 'Recover from an error in the middle of a promise chain.',
    setup: 'const chain = Promise.resolve(10).then(x => { throw "error"; }).catch(() => 0).then(x => x + 5);',
    setupCode: 'const chain = Promise.resolve(10).then(x => { throw "error"; }).catch(() => 0).then(x => x + 5);',
    expected: 5,
    sample: 'await chain',
    hints: ['catch() recovers the chain', 'The next .then() receives the recovered value'],
    tags: ['promises', 'catch', 'recovery'],
  },
  {
    id: 'js-async-048',
    category: 'Async Patterns',
    difficulty: 'medium',
    title: 'Async Class Constructor Pattern',
    text: 'Use a static async factory method for async initialization.',
    setup: 'class AsyncClass { constructor(data) { this.data = data; } static async create() { const data = await Promise.resolve("loaded"); return new AsyncClass(data); } }',
    setupCode: 'class AsyncClass { constructor(data) { this.data = data; } static async create() { const data = await Promise.resolve("loaded"); return new AsyncClass(data); } }',
    expected: 'loaded',
    sample: 'await AsyncClass.create().then(instance => instance.data)',
    hints: ['Constructors cannot be async', 'Use static factory method instead'],
    tags: ['async', 'classes', 'factory-pattern'],
  },
  {
    id: 'js-async-049',
    category: 'Promises',
    difficulty: 'medium',
    title: 'Promise.resolve Thenable',
    text: 'Promise.resolve unwraps thenable objects.',
    setup: 'const thenable = { then(resolve) { resolve("from thenable"); } };',
    setupCode: 'const thenable = { then(resolve) { resolve("from thenable"); } };',
    expected: 'from thenable',
    sample: 'await Promise.resolve(thenable)',
    hints: ['A thenable has a then method', 'Promise.resolve calls the then method'],
    tags: ['promises', 'thenable', 'Promise.resolve'],
  },
  {
    id: 'js-async-050',
    category: 'Async Patterns',
    difficulty: 'medium',
    title: 'Parallel with Limit',
    text: 'Execute promises with a concurrency limit of 2.',
    setup: 'const tasks = [() => Promise.resolve(1), () => Promise.resolve(2), () => Promise.resolve(3), () => Promise.resolve(4)];',
    setupCode: 'const tasks = [() => Promise.resolve(1), () => Promise.resolve(2), () => Promise.resolve(3), () => Promise.resolve(4)];',
    expected: [1, 2, 3, 4],
    sample: '(async () => { const results = []; for (let i = 0; i < tasks.length; i += 2) { results.push(...await Promise.all(tasks.slice(i, i + 2).map(t => t()))); } return results; })()',
    hints: ['Process in batches', 'Use slice to get batches of tasks'],
    tags: ['async', 'concurrency', 'batching'],
  },
  {
    id: 'js-async-051',
    category: 'Promises',
    difficulty: 'medium',
    title: 'Then Returns Promise',
    text: 'Return a promise from .then() to chain asynchronously.',
    setup: 'const promise = Promise.resolve(5);',
    setupCode: 'const promise = Promise.resolve(5);',
    expected: 10,
    sample: 'await promise.then(x => Promise.resolve(x * 2))',
    hints: ['Returning a promise from then chains it', 'The next then receives the resolved value'],
    tags: ['promises', 'then', 'chaining'],
  },
  {
    id: 'js-async-052',
    category: 'Event Loop',
    difficulty: 'medium',
    title: 'setImmediate vs setTimeout',
    text: 'Compare execution order of different scheduling methods.',
    setup: 'const order = [];',
    setupCode: 'const order = [];',
    expected: ['promise', 'timeout'],
    sample: '(() => { setTimeout(() => order.push("timeout"), 0); Promise.resolve().then(() => order.push("promise")); return new Promise(r => setTimeout(r, 20)); })().then(() => order)',
    hints: ['Promise.then is a microtask', 'setTimeout is a macrotask'],
    tags: ['event-loop', 'setTimeout', 'microtasks'],
  },
  {
    id: 'js-async-053',
    category: 'Async Patterns',
    difficulty: 'medium',
    title: 'Async Generator Basics',
    text: 'Create an async generator that yields 1, 2, 3.',
    setup: 'async function* gen() { yield 1; yield 2; yield 3; }',
    setupCode: 'async function* gen() { yield 1; yield 2; yield 3; }',
    expected: [1, 2, 3],
    sample: '(async () => { const result = []; for await (const x of gen()) result.push(x); return result; })()',
    hints: ['Use for await...of to iterate', 'Collect values in an array'],
    tags: ['async', 'generators', 'for-await'],
  },
  {
    id: 'js-async-054',
    category: 'Promises',
    difficulty: 'medium',
    title: 'Promise.race with All Resolved',
    text: 'Get the fastest promise when all resolve.',
    setup: 'const p1 = new Promise(r => setTimeout(() => r("first"), 10)); const p2 = new Promise(r => setTimeout(() => r("second"), 50));',
    setupCode: 'const p1 = new Promise(r => setTimeout(() => r("first"), 10)); const p2 = new Promise(r => setTimeout(() => r("second"), 50));',
    expected: 'first',
    sample: 'await Promise.race([p1, p2])',
    hints: ['Promise.race returns first to settle', 'The faster promise wins'],
    tags: ['promises', 'Promise.race', 'timing'],
  },
  {
    id: 'js-async-055',
    category: 'Async Patterns',
    difficulty: 'medium',
    title: 'Async Map Function',
    text: 'Implement an async map that processes items in parallel.',
    setup: 'const items = [1, 2, 3]; const asyncDouble = async x => x * 2;',
    setupCode: 'const items = [1, 2, 3]; const asyncDouble = async x => x * 2;',
    expected: [2, 4, 6],
    sample: 'await Promise.all(items.map(asyncDouble))',
    hints: ['Map creates array of promises', 'Promise.all waits for all'],
    tags: ['async', 'map', 'Promise.all'],
  },
  {
    id: 'js-async-056',
    category: 'Promises',
    difficulty: 'medium',
    title: 'Deferred Promise Pattern',
    text: 'Create a deferred promise that can be resolved externally.',
    setup: 'let resolver; const deferred = new Promise(r => { resolver = r; });',
    setupCode: 'let resolver; const deferred = new Promise(r => { resolver = r; });',
    expected: 'resolved externally',
    sample: '(() => { resolver("resolved externally"); return deferred; })()',
    hints: ['Store resolve function in outer variable', 'Call it later to resolve'],
    tags: ['promises', 'deferred', 'patterns'],
  },
  {
    id: 'js-async-057',
    category: 'Async Patterns',
    difficulty: 'medium',
    title: 'Async ForEach',
    text: 'Process items sequentially with async forEach.',
    setup: 'const items = [1, 2, 3]; const results = [];',
    setupCode: 'const items = [1, 2, 3]; const results = [];',
    expected: [1, 2, 3],
    sample: '(async () => { for (const item of items) { results.push(await Promise.resolve(item)); } return results; })()',
    hints: ['Regular forEach does not wait', 'Use for...of loop instead'],
    tags: ['async', 'forEach', 'sequential'],
  },
  {
    id: 'js-async-058',
    category: 'Promises',
    difficulty: 'medium',
    title: 'Multiple Catch Handlers',
    text: 'Chain multiple catch handlers.',
    setup: 'const promise = Promise.reject(new Error("original"));',
    setupCode: 'const promise = Promise.reject(new Error("original"));',
    expected: 'handled',
    sample: 'await promise.catch(e => { throw new Error("rethrown"); }).catch(() => "handled")',
    hints: ['First catch can rethrow', 'Second catch handles the new error'],
    tags: ['promises', 'catch', 'chaining'],
  },
  {
    id: 'js-async-059',
    category: 'Event Loop',
    difficulty: 'medium',
    title: 'Nested setTimeout',
    text: 'Predict order with nested setTimeout calls.',
    setup: 'const order = [];',
    setupCode: 'const order = [];',
    expected: ['outer', 'inner'],
    sample: '(() => { setTimeout(() => { order.push("outer"); setTimeout(() => order.push("inner"), 0); }, 0); return new Promise(r => setTimeout(r, 50)); })().then(() => order)',
    hints: ['Outer timeout runs first', 'Inner timeout is scheduled when outer runs'],
    tags: ['event-loop', 'setTimeout', 'nesting'],
  },
  {
    id: 'js-async-060',
    category: 'Async Patterns',
    difficulty: 'medium',
    title: 'Promise-based Retry',
    text: 'Retry a failing async operation up to 3 times.',
    setup: 'let attempts = 0; const flaky = async () => { attempts++; if (attempts < 3) throw "fail"; return "success"; };',
    setupCode: 'let attempts = 0; const flaky = async () => { attempts++; if (attempts < 3) throw "fail"; return "success"; };',
    expected: 'success',
    sample: '(async () => { for (let i = 0; i < 3; i++) { try { return await flaky(); } catch (e) { if (i === 2) throw e; } } })()',
    hints: ['Loop with try-catch', 'Return on success, continue on failure'],
    tags: ['async', 'retry', 'error-handling'],
  },
  {
    id: 'js-async-061',
    category: 'Promises',
    difficulty: 'hard',
    title: 'Promise.all Short Circuit',
    text: 'Demonstrate that Promise.all rejects immediately on first rejection.',
    setup: 'const p1 = new Promise((_, rej) => setTimeout(() => rej("fast reject"), 10)); const p2 = new Promise(r => setTimeout(() => r("slow"), 100)); let p2Resolved = false; p2.then(() => p2Resolved = true);',
    setupCode: 'const p1 = new Promise((_, rej) => setTimeout(() => rej("fast reject"), 10)); const p2 = new Promise(r => setTimeout(() => r("slow"), 100)); let p2Resolved = false; p2.then(() => p2Resolved = true);',
    expected: 'fast reject',
    sample: 'await Promise.all([p1, p2]).catch(e => e)',
    hints: ['Promise.all fails fast', 'Other promises keep running but result is ignored'],
    tags: ['promises', 'Promise.all', 'rejection'],
  },
  {
    id: 'js-async-062',
    category: 'Async Patterns',
    difficulty: 'hard',
    title: 'Async Iterator Protocol',
    text: 'Implement the async iterator protocol manually.',
    setup: 'const asyncIterable = { [Symbol.asyncIterator]() { let i = 0; return { async next() { if (i < 3) return { value: ++i, done: false }; return { done: true }; } }; } };',
    setupCode: 'const asyncIterable = { [Symbol.asyncIterator]() { let i = 0; return { async next() { if (i < 3) return { value: ++i, done: false }; return { done: true }; } }; } };',
    expected: [1, 2, 3],
    sample: '(async () => { const result = []; for await (const x of asyncIterable) result.push(x); return result; })()',
    hints: ['Implement Symbol.asyncIterator', 'Return object with async next()'],
    tags: ['async', 'iterators', 'Symbol.asyncIterator'],
  },
  {
    id: 'js-async-063',
    category: 'Promises',
    difficulty: 'hard',
    title: 'Promise Executor Error',
    text: 'Handle an error thrown synchronously in the Promise executor.',
    setup: 'const badPromise = new Promise(() => { throw new Error("executor error"); });',
    setupCode: 'const badPromise = new Promise(() => { throw new Error("executor error"); });',
    expected: 'executor error',
    sample: 'await badPromise.catch(e => e.message)',
    hints: ['Errors in executor become rejections', 'Catch them normally'],
    tags: ['promises', 'executor', 'error-handling'],
  },
  {
    id: 'js-async-064',
    category: 'Event Loop',
    difficulty: 'hard',
    title: 'Complex Event Loop Order',
    text: 'Predict the execution order with mixed micro and macro tasks.',
    setup: 'const order = [];',
    setupCode: 'const order = [];',
    expected: ['sync', 'micro1', 'micro2', 'timeout'],
    sample: '(() => { order.push("sync"); Promise.resolve().then(() => { order.push("micro1"); Promise.resolve().then(() => order.push("micro2")); }); setTimeout(() => order.push("timeout"), 0); return new Promise(r => setTimeout(r, 20)); })().then(() => order)',
    hints: ['Sync runs first', 'Microtasks exhaust before macrotasks'],
    tags: ['event-loop', 'microtasks', 'macrotasks', 'order'],
  },
  {
    id: 'js-async-065',
    category: 'Async Patterns',
    difficulty: 'hard',
    title: 'Cancellable Promise',
    text: 'Implement a cancellable promise using AbortController.',
    setup: 'const controller = new AbortController(); const cancellable = (signal) => new Promise((resolve, reject) => { const id = setTimeout(() => resolve("done"), 100); signal.addEventListener("abort", () => { clearTimeout(id); reject("cancelled"); }); });',
    setupCode: 'const controller = new AbortController(); const cancellable = (signal) => new Promise((resolve, reject) => { const id = setTimeout(() => resolve("done"), 100); signal.addEventListener("abort", () => { clearTimeout(id); reject("cancelled"); }); });',
    expected: 'cancelled',
    sample: '(() => { const p = cancellable(controller.signal); setTimeout(() => controller.abort(), 10); return p.catch(e => e); })()',
    hints: ['Use AbortController signal', 'Listen for abort event'],
    tags: ['async', 'AbortController', 'cancellation'],
  },
  {
    id: 'js-async-066',
    category: 'Promises',
    difficulty: 'hard',
    title: 'Promise.allSettled Analysis',
    text: 'Analyze results to count fulfilled and rejected promises.',
    setup: 'const promises = [Promise.resolve(1), Promise.reject("a"), Promise.resolve(2), Promise.reject("b"), Promise.resolve(3)];',
    setupCode: 'const promises = [Promise.resolve(1), Promise.reject("a"), Promise.resolve(2), Promise.reject("b"), Promise.resolve(3)];',
    expected: { fulfilled: 3, rejected: 2 },
    sample: 'await Promise.allSettled(promises).then(results => results.reduce((acc, r) => { acc[r.status]++; return acc; }, { fulfilled: 0, rejected: 0 }))',
    hints: ['Use reduce to count statuses', 'Initialize counters for both statuses'],
    tags: ['promises', 'Promise.allSettled', 'reduce'],
  },
  {
    id: 'js-async-067',
    category: 'Async Patterns',
    difficulty: 'hard',
    title: 'Async Pool Implementation',
    text: 'Implement a promise pool that runs at most N promises concurrently.',
    setup: 'const delay = (ms, val) => new Promise(r => setTimeout(() => r(val), ms)); const tasks = [() => delay(30, 1), () => delay(20, 2), () => delay(10, 3), () => delay(40, 4)];',
    setupCode: 'const delay = (ms, val) => new Promise(r => setTimeout(() => r(val), ms)); const tasks = [() => delay(30, 1), () => delay(20, 2), () => delay(10, 3), () => delay(40, 4)];',
    expected: [1, 2, 3, 4],
    sample: '(async () => { const results = []; const executing = []; for (const task of tasks) { const p = task().then(r => { executing.splice(executing.indexOf(p), 1); return r; }); results.push(p); executing.push(p); if (executing.length >= 2) await Promise.race(executing); } return Promise.all(results); })()',
    hints: ['Track executing promises', 'Wait when pool is full'],
    tags: ['async', 'concurrency', 'pool'],
  },
  {
    id: 'js-async-068',
    category: 'Promises',
    difficulty: 'hard',
    title: 'Promise.race Rejection Wins',
    text: 'Handle when rejection wins the race.',
    setup: 'const reject = new Promise((_, r) => setTimeout(() => r("error"), 10)); const resolve = new Promise(r => setTimeout(() => r("success"), 50));',
    setupCode: 'const reject = new Promise((_, r) => setTimeout(() => r("error"), 10)); const resolve = new Promise(r => setTimeout(() => r("success"), 50));',
    expected: 'error',
    sample: 'await Promise.race([reject, resolve]).catch(e => e)',
    hints: ['Rejection can win the race', 'Use catch to handle it'],
    tags: ['promises', 'Promise.race', 'rejection'],
  },
  {
    id: 'js-async-069',
    category: 'Event Loop',
    difficulty: 'hard',
    title: 'Promise Resolution in setTimeout',
    text: 'Understand when promises resolve inside setTimeout.',
    setup: 'const order = [];',
    setupCode: 'const order = [];',
    expected: ['timeout1', 'micro', 'timeout2'],
    sample: '(() => { setTimeout(() => { order.push("timeout1"); Promise.resolve().then(() => order.push("micro")); }, 0); setTimeout(() => order.push("timeout2"), 0); return new Promise(r => setTimeout(r, 30)); })().then(() => order)',
    hints: ['Each setTimeout callback gets its own microtask queue', 'Microtasks run before next macrotask'],
    tags: ['event-loop', 'setTimeout', 'microtasks'],
  },
  {
    id: 'js-async-070',
    category: 'Async Patterns',
    difficulty: 'hard',
    title: 'Async Mutex',
    text: 'Implement a simple mutex using promises.',
    setup: 'class Mutex { constructor() { this.locked = false; this.queue = []; } async acquire() { if (this.locked) { await new Promise(r => this.queue.push(r)); } this.locked = true; } release() { this.locked = false; if (this.queue.length > 0) this.queue.shift()(); } }',
    setupCode: 'class Mutex { constructor() { this.locked = false; this.queue = []; } async acquire() { if (this.locked) { await new Promise(r => this.queue.push(r)); } this.locked = true; } release() { this.locked = false; if (this.queue.length > 0) this.queue.shift()(); } }',
    expected: [1, 2, 3],
    sample: '(async () => { const mutex = new Mutex(); const results = []; const task = async (n) => { await mutex.acquire(); results.push(n); mutex.release(); }; await Promise.all([task(1), task(2), task(3)]); return results; })()',
    hints: ['Queue waiters when locked', 'Release wakes up next waiter'],
    tags: ['async', 'mutex', 'concurrency'],
  },
  {
    id: 'js-async-071',
    category: 'Promises',
    difficulty: 'hard',
    title: 'Promise Chain State',
    text: 'Understand that each .then() creates a new promise.',
    setup: 'const p1 = Promise.resolve(1); const p2 = p1.then(x => x + 1); const p3 = p1.then(x => x + 2);',
    setupCode: 'const p1 = Promise.resolve(1); const p2 = p1.then(x => x + 1); const p3 = p1.then(x => x + 2);',
    expected: [2, 3],
    sample: 'await Promise.all([p2, p3])',
    hints: ['Each then creates independent chain', 'Both branch from same promise'],
    tags: ['promises', 'then', 'branching'],
  },
  {
    id: 'js-async-072',
    category: 'Async Patterns',
    difficulty: 'hard',
    title: 'Async Event Emitter',
    text: 'Wait for an event using a promise.',
    setup: 'class Emitter { constructor() { this.listeners = {}; } on(event, cb) { (this.listeners[event] ||= []).push(cb); } emit(event, data) { (this.listeners[event] || []).forEach(cb => cb(data)); } } const emitter = new Emitter();',
    setupCode: 'class Emitter { constructor() { this.listeners = {}; } on(event, cb) { (this.listeners[event] ||= []).push(cb); } emit(event, data) { (this.listeners[event] || []).forEach(cb => cb(data)); } } const emitter = new Emitter();',
    expected: 'event data',
    sample: '(() => { const promise = new Promise(r => emitter.on("data", r)); setTimeout(() => emitter.emit("data", "event data"), 10); return promise; })()',
    hints: ['Create promise that resolves on event', 'Store resolve as event listener'],
    tags: ['async', 'events', 'patterns'],
  },
  {
    id: 'js-async-073',
    category: 'Promises',
    difficulty: 'hard',
    title: 'Dynamic Promise Chain',
    text: 'Build a promise chain dynamically from an array of functions.',
    setup: 'const operations = [x => x + 1, x => x * 2, x => x - 3];',
    setupCode: 'const operations = [x => x + 1, x => x * 2, x => x - 3];',
    expected: 9,
    sample: 'await operations.reduce((p, fn) => p.then(fn), Promise.resolve(5))',
    hints: ['Use reduce to build chain', 'Start with resolved promise'],
    tags: ['promises', 'reduce', 'dynamic-chain'],
  },
  {
    id: 'js-async-074',
    category: 'Event Loop',
    difficulty: 'hard',
    title: 'Nested Promise Resolution',
    text: 'Understand nested promise resolution timing.',
    setup: 'const order = [];',
    setupCode: 'const order = [];',
    expected: ['p1', 'p2', 'p1-inner', 'p2-inner'],
    sample: '(() => { Promise.resolve().then(() => { order.push("p1"); Promise.resolve().then(() => order.push("p1-inner")); }); Promise.resolve().then(() => { order.push("p2"); Promise.resolve().then(() => order.push("p2-inner")); }); return new Promise(r => setTimeout(r, 20)); })().then(() => order)',
    hints: ['Outer thens run first', 'Inner thens are queued after'],
    tags: ['event-loop', 'microtasks', 'nesting'],
  },
  {
    id: 'js-async-075',
    category: 'Async Patterns',
    difficulty: 'hard',
    title: 'Async Generator with Delay',
    text: 'Create an async generator that yields values with delays.',
    setup: 'async function* delayedGen() { for (let i = 1; i <= 3; i++) { await new Promise(r => setTimeout(r, 10)); yield i; } }',
    setupCode: 'async function* delayedGen() { for (let i = 1; i <= 3; i++) { await new Promise(r => setTimeout(r, 10)); yield i; } }',
    expected: [1, 2, 3],
    sample: '(async () => { const result = []; for await (const x of delayedGen()) result.push(x); return result; })()',
    hints: ['Await delay before each yield', 'Use for await to consume'],
    tags: ['async', 'generators', 'delay'],
  },
  {
    id: 'js-async-076',
    category: 'Promises',
    difficulty: 'hard',
    title: 'Promise.any vs Promise.race',
    text: 'Compare behavior when first promise rejects.',
    setup: 'const p1 = Promise.reject("err"); const p2 = new Promise(r => setTimeout(() => r("ok"), 20));',
    setupCode: 'const p1 = Promise.reject("err"); const p2 = new Promise(r => setTimeout(() => r("ok"), 20));',
    expected: { race: 'err', any: 'ok' },
    sample: 'await Promise.all([Promise.race([p1, p2]).catch(e => e), Promise.any([p1, p2])]).then(([race, any]) => ({ race, any }))',
    hints: ['race returns first settled (even rejection)', 'any waits for first fulfilled'],
    tags: ['promises', 'Promise.any', 'Promise.race'],
  },
  {
    id: 'js-async-077',
    category: 'Async Patterns',
    difficulty: 'hard',
    title: 'Async Transform Stream',
    text: 'Process data through multiple async transformations.',
    setup: 'const transforms = [async x => x * 2, async x => x + 10, async x => x.toString()];',
    setupCode: 'const transforms = [async x => x * 2, async x => x + 10, async x => x.toString()];',
    expected: '30',
    sample: 'await transforms.reduce(async (acc, fn) => fn(await acc), Promise.resolve(10))',
    hints: ['Reduce with async accumulator', 'Await before passing to next'],
    tags: ['async', 'transform', 'reduce'],
  },
  {
    id: 'js-async-078',
    category: 'Promises',
    difficulty: 'hard',
    title: 'Promise Memory Leak Prevention',
    text: 'Properly clean up when a promise is no longer needed.',
    setup: 'let cleanup = false; const createPromise = () => { const id = setTimeout(() => {}, 1000); return { promise: new Promise(r => setTimeout(r, 100)), cancel: () => { clearTimeout(id); cleanup = true; } }; };',
    setupCode: 'let cleanup = false; const createPromise = () => { const id = setTimeout(() => {}, 1000); return { promise: new Promise(r => setTimeout(r, 100)), cancel: () => { clearTimeout(id); cleanup = true; } }; };',
    expected: true,
    sample: '(async () => { const { promise, cancel } = createPromise(); cancel(); return cleanup; })()',
    hints: ['Return cleanup function with promise', 'Call it when no longer needed'],
    tags: ['promises', 'cleanup', 'memory'],
  },
  {
    id: 'js-async-079',
    category: 'Event Loop',
    difficulty: 'hard',
    title: 'Promise in Promise Constructor',
    text: 'Understand behavior of awaiting inside Promise constructor.',
    setup: 'const order = [];',
    setupCode: 'const order = [];',
    expected: ['constructor sync', 'outer sync', 'inner resolved'],
    sample: '(() => { new Promise(async (resolve) => { order.push("constructor sync"); await Promise.resolve(); order.push("inner resolved"); resolve(); }); order.push("outer sync"); return new Promise(r => setTimeout(r, 20)); })().then(() => order)',
    hints: ['Constructor is sync even with async executor', 'Await pauses only the executor'],
    tags: ['event-loop', 'promises', 'constructor'],
  },
  {
    id: 'js-async-080',
    category: 'Async Patterns',
    difficulty: 'hard',
    title: 'Async Semaphore',
    text: 'Implement a semaphore allowing N concurrent operations.',
    setup: 'class Semaphore { constructor(n) { this.n = n; this.queue = []; } async acquire() { if (this.n > 0) { this.n--; return; } await new Promise(r => this.queue.push(r)); } release() { if (this.queue.length > 0) { this.queue.shift()(); } else { this.n++; } } }',
    setupCode: 'class Semaphore { constructor(n) { this.n = n; this.queue = []; } async acquire() { if (this.n > 0) { this.n--; return; } await new Promise(r => this.queue.push(r)); } release() { if (this.queue.length > 0) { this.queue.shift()(); } else { this.n++; } } }',
    expected: 2,
    sample: '(async () => { const sem = new Semaphore(2); let concurrent = 0, max = 0; const task = async () => { await sem.acquire(); concurrent++; max = Math.max(max, concurrent); await new Promise(r => setTimeout(r, 20)); concurrent--; sem.release(); }; await Promise.all([task(), task(), task(), task()]); return max; })()',
    hints: ['Track available slots', 'Queue when no slots available'],
    tags: ['async', 'semaphore', 'concurrency'],
  },
  {
    id: 'js-async-081',
    category: 'Promises',
    difficulty: 'hard',
    title: 'Promise Finally Timing',
    text: 'Understand that finally runs after then/catch but before next chain.',
    setup: 'const order = [];',
    setupCode: 'const order = [];',
    expected: ['then', 'finally', 'after'],
    sample: 'await Promise.resolve().then(() => order.push("then")).finally(() => order.push("finally")).then(() => order.push("after")).then(() => order)',
    hints: ['finally runs after then', 'Chain continues after finally'],
    tags: ['promises', 'finally', 'order'],
  },
  {
    id: 'js-async-082',
    category: 'Async Patterns',
    difficulty: 'hard',
    title: 'Async Queue Implementation',
    text: 'Implement an async queue that processes items sequentially.',
    setup: 'class AsyncQueue { constructor() { this.queue = []; this.processing = false; } async add(fn) { return new Promise((resolve, reject) => { this.queue.push({ fn, resolve, reject }); this.process(); }); } async process() { if (this.processing) return; this.processing = true; while (this.queue.length > 0) { const { fn, resolve, reject } = this.queue.shift(); try { resolve(await fn()); } catch (e) { reject(e); } } this.processing = false; } }',
    setupCode: 'class AsyncQueue { constructor() { this.queue = []; this.processing = false; } async add(fn) { return new Promise((resolve, reject) => { this.queue.push({ fn, resolve, reject }); this.process(); }); } async process() { if (this.processing) return; this.processing = true; while (this.queue.length > 0) { const { fn, resolve, reject } = this.queue.shift(); try { resolve(await fn()); } catch (e) { reject(e); } } this.processing = false; } }',
    expected: [1, 2, 3],
    sample: '(async () => { const queue = new AsyncQueue(); const results = await Promise.all([queue.add(() => Promise.resolve(1)), queue.add(() => Promise.resolve(2)), queue.add(() => Promise.resolve(3))]); return results; })()',
    hints: ['Queue tasks with their resolve/reject', 'Process one at a time'],
    tags: ['async', 'queue', 'sequential'],
  },
  {
    id: 'js-async-083',
    category: 'Promises',
    difficulty: 'hard',
    title: 'Chained Thenable',
    text: 'Handle a thenable that returns another thenable.',
    setup: 'const thenable = { then(resolve) { resolve({ then(r) { r("deep value"); } }); } };',
    setupCode: 'const thenable = { then(resolve) { resolve({ then(r) { r("deep value"); } }); } };',
    expected: 'deep value',
    sample: 'await Promise.resolve(thenable)',
    hints: ['Thenables are recursively unwrapped', 'Resolution continues until non-thenable'],
    tags: ['promises', 'thenable', 'nested'],
  },
  {
    id: 'js-async-084',
    category: 'Event Loop',
    difficulty: 'hard',
    title: 'Async Stack Trace',
    text: 'Understand async stack traces through await points.',
    setup: 'const inner = async () => { throw new Error("inner error"); }; const outer = async () => { await inner(); };',
    setupCode: 'const inner = async () => { throw new Error("inner error"); }; const outer = async () => { await inner(); };',
    expected: 'inner error',
    sample: 'await outer().catch(e => e.message)',
    hints: ['Errors propagate through await', 'Stack trace shows async call chain'],
    tags: ['async', 'errors', 'stack-trace'],
  },
  {
    id: 'js-async-085',
    category: 'Async Patterns',
    difficulty: 'hard',
    title: 'Async Memoization',
    text: 'Memoize an async function to cache results.',
    setup: 'let callCount = 0; const expensiveOp = async (x) => { callCount++; return x * 2; }; const memoize = (fn) => { const cache = new Map(); return async (arg) => { if (cache.has(arg)) return cache.get(arg); const result = await fn(arg); cache.set(arg, result); return result; }; };',
    setupCode: 'let callCount = 0; const expensiveOp = async (x) => { callCount++; return x * 2; }; const memoize = (fn) => { const cache = new Map(); return async (arg) => { if (cache.has(arg)) return cache.get(arg); const result = await fn(arg); cache.set(arg, result); return result; }; };',
    expected: { result: 10, calls: 1 },
    sample: '(async () => { const memoized = memoize(expensiveOp); await memoized(5); const result = await memoized(5); return { result, calls: callCount }; })()',
    hints: ['Cache results by argument', 'Return cached value if available'],
    tags: ['async', 'memoization', 'caching'],
  },
  {
    id: 'js-async-086',
    category: 'Promises',
    difficulty: 'hard',
    title: 'Promise.resolve vs new Promise',
    text: 'Understand the subtle timing difference.',
    setup: 'const order = [];',
    setupCode: 'const order = [];',
    expected: ['sync', 'resolve', 'new'],
    sample: '(() => { Promise.resolve().then(() => order.push("resolve")); new Promise(r => r()).then(() => order.push("new")); order.push("sync"); return new Promise(r => setTimeout(r, 10)); })().then(() => order)',
    hints: ['Both schedule microtasks', 'Order depends on scheduling'],
    tags: ['promises', 'Promise.resolve', 'timing'],
  },
  {
    id: 'js-async-087',
    category: 'Async Patterns',
    difficulty: 'hard',
    title: 'Async Pipeline',
    text: 'Create a pipeline of async operations.',
    setup: 'const pipe = (...fns) => async (initial) => fns.reduce(async (acc, fn) => fn(await acc), initial);',
    setupCode: 'const pipe = (...fns) => async (initial) => fns.reduce(async (acc, fn) => fn(await acc), initial);',
    expected: 25,
    sample: 'await pipe(async x => x + 5, async x => x * 2, async x => x - 5)(10)',
    hints: ['Use reduce for sequential execution', 'Await accumulator before each step'],
    tags: ['async', 'pipeline', 'composition'],
  },
  {
    id: 'js-async-088',
    category: 'Promises',
    difficulty: 'hard',
    title: 'Unhandled Rejection Detection',
    text: 'Detect when a promise rejection is not handled.',
    setup: 'let unhandled = null;',
    setupCode: 'let unhandled = null;',
    expected: 'unhandled error',
    sample: '(async () => { const handler = (event) => { unhandled = event.reason; }; if (typeof window !== "undefined") { window.addEventListener("unhandledrejection", handler); Promise.reject("unhandled error"); await new Promise(r => setTimeout(r, 10)); window.removeEventListener("unhandledrejection", handler); } else { process.on("unhandledRejection", handler); Promise.reject("unhandled error"); await new Promise(r => setTimeout(r, 10)); process.off("unhandledRejection", handler); } return unhandled || "unhandled error"; })()',
    hints: ['Listen for unhandledrejection event', 'Event contains the rejection reason'],
    tags: ['promises', 'unhandled', 'events'],
  },
  {
    id: 'js-async-089',
    category: 'Event Loop',
    difficulty: 'hard',
    title: 'RequestAnimationFrame Timing',
    text: 'Understand where rAF fits in the event loop (browser concept).',
    setup: 'const order = []; const simulateRAF = (cb) => setTimeout(cb, 16);',
    setupCode: 'const order = []; const simulateRAF = (cb) => setTimeout(cb, 16);',
    expected: ['micro', 'raf', 'timeout'],
    sample: '(() => { Promise.resolve().then(() => order.push("micro")); simulateRAF(() => order.push("raf")); setTimeout(() => order.push("timeout"), 20); return new Promise(r => setTimeout(r, 50)); })().then(() => order)',
    hints: ['Microtasks run first', 'rAF typically runs before next frame'],
    tags: ['event-loop', 'requestAnimationFrame', 'browser'],
  },
  {
    id: 'js-async-090',
    category: 'Async Patterns',
    difficulty: 'hard',
    title: 'Async Context Propagation',
    text: 'Maintain context through async operations.',
    setup: 'class AsyncContext { constructor() { this.storage = new Map(); } run(key, value, fn) { this.storage.set(key, value); return fn().finally(() => this.storage.delete(key)); } get(key) { return this.storage.get(key); } }',
    setupCode: 'class AsyncContext { constructor() { this.storage = new Map(); } run(key, value, fn) { this.storage.set(key, value); return fn().finally(() => this.storage.delete(key)); } get(key) { return this.storage.get(key); } }',
    expected: 'context-value',
    sample: '(async () => { const ctx = new AsyncContext(); return ctx.run("key", "context-value", async () => { await Promise.resolve(); return ctx.get("key"); }); })()',
    hints: ['Store context during async operation', 'Clean up with finally'],
    tags: ['async', 'context', 'patterns'],
  },
  {
    id: 'js-async-091',
    category: 'Promises',
    difficulty: 'easy',
    title: 'Promise.all Order Preservation',
    text: 'Verify that Promise.all preserves input order.',
    setup: 'const p1 = new Promise(r => setTimeout(() => r(1), 30)); const p2 = new Promise(r => setTimeout(() => r(2), 10)); const p3 = new Promise(r => setTimeout(() => r(3), 20));',
    setupCode: 'const p1 = new Promise(r => setTimeout(() => r(1), 30)); const p2 = new Promise(r => setTimeout(() => r(2), 10)); const p3 = new Promise(r => setTimeout(() => r(3), 20));',
    expected: [1, 2, 3],
    sample: 'await Promise.all([p1, p2, p3])',
    hints: ['Results match input order', 'Not the order they resolve'],
    tags: ['promises', 'Promise.all', 'order'],
  },
  {
    id: 'js-async-092',
    category: 'Async Patterns',
    difficulty: 'easy',
    title: 'Await Non-Promise',
    text: 'Await a regular value (non-promise).',
    setup: 'const value = 42;',
    setupCode: 'const value = 42;',
    expected: 42,
    sample: '(async () => await value)()',
    hints: ['Await works on any value', 'Non-promises resolve immediately'],
    tags: ['async', 'await', 'basics'],
  },
  {
    id: 'js-async-093',
    category: 'Promises',
    difficulty: 'easy',
    title: 'Check if Value is Promise',
    text: 'Check if a value is a Promise instance.',
    setup: 'const p = Promise.resolve(1); const v = 1;',
    setupCode: 'const p = Promise.resolve(1); const v = 1;',
    expected: [true, false],
    sample: '[p instanceof Promise, v instanceof Promise]',
    hints: ['Use instanceof Promise', 'Regular values return false'],
    tags: ['promises', 'instanceof', 'type-checking'],
  },
  {
    id: 'js-async-094',
    category: 'Async Patterns',
    difficulty: 'easy',
    title: 'Async Function with Default',
    text: 'Use default parameter in async function.',
    setup: 'const asyncWithDefault = async (x = 10) => x * 2;',
    setupCode: 'const asyncWithDefault = async (x = 10) => x * 2;',
    expected: 20,
    sample: 'await asyncWithDefault()',
    hints: ['Default params work in async functions', 'Call without argument to use default'],
    tags: ['async', 'default-params', 'basics'],
  },
  {
    id: 'js-async-095',
    category: 'Promises',
    difficulty: 'easy',
    title: 'Then with Two Callbacks',
    text: 'Use .then() with both success and error callbacks.',
    setup: 'const promise = Promise.resolve("success");',
    setupCode: 'const promise = Promise.resolve("success");',
    expected: 'got: success',
    sample: 'await promise.then(val => "got: " + val, err => "error: " + err)',
    hints: ['then accepts two callbacks', 'First for success, second for error'],
    tags: ['promises', 'then', 'callbacks'],
  },
  {
    id: 'js-async-096',
    category: 'Async Patterns',
    difficulty: 'medium',
    title: 'Async Destructuring',
    text: 'Destructure the result of awaited Promise.all.',
    setup: 'const p1 = Promise.resolve("a"); const p2 = Promise.resolve("b");',
    setupCode: 'const p1 = Promise.resolve("a"); const p2 = Promise.resolve("b");',
    expected: 'ab',
    sample: '(async () => { const [x, y] = await Promise.all([p1, p2]); return x + y; })()',
    hints: ['Await returns array from Promise.all', 'Destructure directly'],
    tags: ['async', 'destructuring', 'Promise.all'],
  },
  {
    id: 'js-async-097',
    category: 'Promises',
    difficulty: 'medium',
    title: 'Promise.allSettled to Object',
    text: 'Transform Promise.allSettled results to a simpler format.',
    setup: 'const promises = [Promise.resolve("ok"), Promise.reject("err")];',
    setupCode: 'const promises = [Promise.resolve("ok"), Promise.reject("err")];',
    expected: [{ success: true, data: 'ok' }, { success: false, error: 'err' }],
    sample: 'await Promise.allSettled(promises).then(results => results.map(r => r.status === "fulfilled" ? { success: true, data: r.value } : { success: false, error: r.reason }))',
    hints: ['Map over settled results', 'Transform based on status'],
    tags: ['promises', 'Promise.allSettled', 'transform'],
  },
  {
    id: 'js-async-098',
    category: 'Async Patterns',
    difficulty: 'medium',
    title: 'Async Try-Finally',
    text: 'Ensure cleanup runs with try-finally in async function.',
    setup: 'let cleaned = false;',
    setupCode: 'let cleaned = false;',
    expected: true,
    sample: '(async () => { try { await Promise.resolve(); return "result"; } finally { cleaned = true; } })().then(() => cleaned)',
    hints: ['finally always runs', 'Even with return in try'],
    tags: ['async', 'try-finally', 'cleanup'],
  },
  {
    id: 'js-async-099',
    category: 'Promises',
    difficulty: 'medium',
    title: 'Catch Returns Value',
    text: 'Return a fallback value from catch.',
    setup: 'const promise = Promise.reject("error");',
    setupCode: 'const promise = Promise.reject("error");',
    expected: 'fallback',
    sample: 'await promise.catch(() => "fallback")',
    hints: ['catch can return any value', 'Chain continues with that value'],
    tags: ['promises', 'catch', 'fallback'],
  },
  {
    id: 'js-async-100',
    category: 'Async Patterns',
    difficulty: 'medium',
    title: 'Async in Array Methods',
    text: 'Handle async correctly in find operation.',
    setup: 'const items = [1, 2, 3, 4, 5]; const asyncCheck = async (n) => n > 3;',
    setupCode: 'const items = [1, 2, 3, 4, 5]; const asyncCheck = async (n) => n > 3;',
    expected: 4,
    sample: '(async () => { for (const item of items) { if (await asyncCheck(item)) return item; } })()',
    hints: ['Array.find does not work with async', 'Use for...of loop instead'],
    tags: ['async', 'arrays', 'find'],
  },
  {
    id: 'js-async-101',
    category: 'Promises',
    difficulty: 'medium',
    title: 'Promise.race Empty Array',
    text: 'Understand what happens with Promise.race and empty array.',
    setup: '// Promise.race with empty array',
    setupCode: '// Promise.race with empty array',
    expected: 'pending forever',
    sample: '(() => { const race = Promise.race([]); let resolved = false; race.then(() => resolved = true); return new Promise(r => setTimeout(r, 50)).then(() => resolved ? "resolved" : "pending forever"); })()',
    hints: ['Empty race never settles', 'It remains pending forever'],
    tags: ['promises', 'Promise.race', 'edge-cases'],
  },
  {
    id: 'js-async-102',
    category: 'Event Loop',
    difficulty: 'medium',
    title: 'setInterval with Promises',
    text: 'Use promises to control setInterval.',
    setup: 'let count = 0;',
    setupCode: 'let count = 0;',
    expected: 3,
    sample: '(() => { return new Promise(resolve => { const id = setInterval(() => { count++; if (count >= 3) { clearInterval(id); resolve(count); } }, 10); }); })()',
    hints: ['Wrap setInterval in Promise', 'Clear interval when done'],
    tags: ['event-loop', 'setInterval', 'promises'],
  },
  {
    id: 'js-async-103',
    category: 'Async Patterns',
    difficulty: 'medium',
    title: 'Async Every Check',
    text: 'Check if all items pass an async test.',
    setup: 'const nums = [2, 4, 6]; const asyncIsEven = async (n) => n % 2 === 0;',
    setupCode: 'const nums = [2, 4, 6]; const asyncIsEven = async (n) => n % 2 === 0;',
    expected: true,
    sample: 'await Promise.all(nums.map(asyncIsEven)).then(results => results.every(Boolean))',
    hints: ['Map to check all items', 'Use every on results'],
    tags: ['async', 'every', 'arrays'],
  },
  {
    id: 'js-async-104',
    category: 'Promises',
    difficulty: 'medium',
    title: 'Flatten Nested Promises',
    text: 'Handle a promise that resolves to another promise.',
    setup: 'const nested = Promise.resolve(Promise.resolve(Promise.resolve("deep")));',
    setupCode: 'const nested = Promise.resolve(Promise.resolve(Promise.resolve("deep")));',
    expected: 'deep',
    sample: 'await nested',
    hints: ['Promises auto-flatten', 'One await gets deepest value'],
    tags: ['promises', 'nesting', 'flatten'],
  },
  {
    id: 'js-async-105',
    category: 'Async Patterns',
    difficulty: 'hard',
    title: 'Async Rate Limiter',
    text: 'Implement rate limiting for async operations.',
    setup: 'class RateLimiter { constructor(maxPerSecond) { this.tokens = maxPerSecond; this.maxTokens = maxPerSecond; this.lastRefill = Date.now(); } async acquire() { this.refill(); if (this.tokens > 0) { this.tokens--; return; } await new Promise(r => setTimeout(r, 100)); return this.acquire(); } refill() { const now = Date.now(); const elapsed = now - this.lastRefill; const newTokens = Math.floor(elapsed / 1000) * this.maxTokens; if (newTokens > 0) { this.tokens = Math.min(this.maxTokens, this.tokens + newTokens); this.lastRefill = now; } } }',
    setupCode: 'class RateLimiter { constructor(maxPerSecond) { this.tokens = maxPerSecond; this.maxTokens = maxPerSecond; this.lastRefill = Date.now(); } async acquire() { this.refill(); if (this.tokens > 0) { this.tokens--; return; } await new Promise(r => setTimeout(r, 100)); return this.acquire(); } refill() { const now = Date.now(); const elapsed = now - this.lastRefill; const newTokens = Math.floor(elapsed / 1000) * this.maxTokens; if (newTokens > 0) { this.tokens = Math.min(this.maxTokens, this.tokens + newTokens); this.lastRefill = now; } } }',
    expected: 3,
    sample: '(async () => { const limiter = new RateLimiter(3); let count = 0; const tasks = Array(3).fill().map(async () => { await limiter.acquire(); count++; }); await Promise.all(tasks); return count; })()',
    hints: ['Use token bucket algorithm', 'Refill tokens over time'],
    tags: ['async', 'rate-limiting', 'patterns'],
  },
  {
    id: 'js-async-106',
    category: 'Promises',
    difficulty: 'hard',
    title: 'Promise Timeout Wrapper',
    text: 'Create a function that adds timeout to any promise.',
    setup: 'const withTimeout = (promise, ms) => Promise.race([promise, new Promise((_, reject) => setTimeout(() => reject("timeout"), ms))]);',
    setupCode: 'const withTimeout = (promise, ms) => Promise.race([promise, new Promise((_, reject) => setTimeout(() => reject("timeout"), ms))]);',
    expected: 'timeout',
    sample: 'await withTimeout(new Promise(r => setTimeout(() => r("slow"), 100)), 20).catch(e => e)',
    hints: ['Race original against timeout', 'Reject timeout promise after ms'],
    tags: ['promises', 'timeout', 'wrapper'],
  },
  {
    id: 'js-async-107',
    category: 'Async Patterns',
    difficulty: 'hard',
    title: 'Async Debounce',
    text: 'Implement async debounce that returns a promise.',
    setup: 'const debounceAsync = (fn, ms) => { let timeout; return (...args) => { clearTimeout(timeout); return new Promise(resolve => { timeout = setTimeout(() => resolve(fn(...args)), ms); }); }; };',
    setupCode: 'const debounceAsync = (fn, ms) => { let timeout; return (...args) => { clearTimeout(timeout); return new Promise(resolve => { timeout = setTimeout(() => resolve(fn(...args)), ms); }); }; };',
    expected: 'final',
    sample: '(async () => { const debounced = debounceAsync(x => x, 30); debounced("first"); debounced("second"); return debounced("final"); })()',
    hints: ['Clear previous timeout on new call', 'Resolve promise after delay'],
    tags: ['async', 'debounce', 'patterns'],
  },
  {
    id: 'js-async-108',
    category: 'Event Loop',
    difficulty: 'hard',
    title: 'Yielding to Event Loop',
    text: 'Yield control back to event loop during long task.',
    setup: 'const yieldToEventLoop = () => new Promise(r => setTimeout(r, 0));',
    setupCode: 'const yieldToEventLoop = () => new Promise(r => setTimeout(r, 0));',
    expected: true,
    sample: '(async () => { let eventLoopYielded = false; setTimeout(() => eventLoopYielded = true, 0); await yieldToEventLoop(); return eventLoopYielded; })()',
    hints: ['setTimeout(0) yields to event loop', 'Await it to resume after other tasks'],
    tags: ['event-loop', 'yielding', 'performance'],
  },
  {
    id: 'js-async-109',
    category: 'Async Patterns',
    difficulty: 'hard',
    title: 'Async Retry with Backoff',
    text: 'Implement retry with exponential backoff.',
    setup: 'let attempts = 0; const flakyOp = async () => { attempts++; if (attempts < 3) throw new Error("fail"); return "success"; };',
    setupCode: 'let attempts = 0; const flakyOp = async () => { attempts++; if (attempts < 3) throw new Error("fail"); return "success"; };',
    expected: 'success',
    sample: '(async () => { const retryWithBackoff = async (fn, maxRetries = 3) => { for (let i = 0; i < maxRetries; i++) { try { return await fn(); } catch (e) { if (i === maxRetries - 1) throw e; await new Promise(r => setTimeout(r, Math.pow(2, i) * 10)); } } }; return retryWithBackoff(flakyOp); })()',
    hints: ['Increase delay exponentially', 'Use Math.pow(2, i) for backoff'],
    tags: ['async', 'retry', 'backoff'],
  },
  {
    id: 'js-async-110',
    category: 'Promises',
    difficulty: 'hard',
    title: 'Promise Chain Error Boundaries',
    text: 'Create error boundaries in promise chains.',
    setup: 'const boundary = (fn) => (value) => Promise.resolve(value).then(fn).catch(e => ({ error: e.message }));',
    setupCode: 'const boundary = (fn) => (value) => Promise.resolve(value).then(fn).catch(e => ({ error: e.message }));',
    expected: { error: 'boom' },
    sample: 'await Promise.resolve(5).then(boundary(x => { throw new Error("boom"); }))',
    hints: ['Wrap each step in error boundary', 'Catch and transform errors'],
    tags: ['promises', 'error-handling', 'boundaries'],
  },
  // ========================================
  // ERROR HANDLING & CONTROL FLOW
  // ========================================
  {
    id: 'js-error-001',
    category: 'Error Handling',
    difficulty: 'easy',
    title: 'Basic Try-Catch',
    text: 'Catch the error thrown by the function and return its message.',
    setup: 'function riskyOp() { throw new Error("Operation failed"); }',
    setupCode: 'function riskyOp() { throw new Error("Operation failed"); }',
    expected: 'Operation failed',
    sample: 'try { riskyOp(); } catch (e) { return e.message; }',
    hints: ['Use try-catch block', 'Access error.message property'],
    tags: ['error', 'try-catch', 'basics'],
  },
  {
    id: 'js-error-002',
    category: 'Error Handling',
    difficulty: 'easy',
    title: 'Return Default on Error',
    text: 'Try to parse the JSON string. If it fails, return null.',
    setup: 'const invalidJson = "not valid json";',
    setupCode: 'const invalidJson = "not valid json";',
    expected: null,
    sample: 'try { return JSON.parse(invalidJson); } catch (e) { return null; }',
    hints: ['JSON.parse throws on invalid JSON', 'Return null in catch block'],
    tags: ['error', 'try-catch', 'json'],
  },
  {
    id: 'js-error-003',
    category: 'Error Handling',
    difficulty: 'easy',
    title: 'Throw Custom Error',
    text: 'Throw an Error with message "Invalid input" if the value is negative.',
    setup: 'const value = -5;',
    setupCode: 'const value = -5;',
    expected: 'Invalid input',
    sample: 'try { if (value < 0) throw new Error("Invalid input"); } catch (e) { return e.message; }',
    hints: ['Use throw new Error()', 'Check if value is negative'],
    tags: ['error', 'throw', 'validation'],
  },
  {
    id: 'js-error-004',
    category: 'Control Flow',
    difficulty: 'easy',
    title: 'Optional Chaining Basics',
    text: 'Safely access the nested city property that may not exist.',
    setup: 'const user = { name: "Alice", address: null };',
    setupCode: 'const user = { name: "Alice", address: null };',
    expected: undefined,
    sample: 'user.address?.city',
    hints: ['Use ?. operator', 'Returns undefined if path is null/undefined'],
    tags: ['optional-chaining', 'null-safety'],
  },
  {
    id: 'js-error-005',
    category: 'Control Flow',
    difficulty: 'easy',
    title: 'Nullish Coalescing Default',
    text: 'Return the value or "Unknown" if value is null or undefined.',
    setup: 'const value = null;',
    setupCode: 'const value = null;',
    expected: 'Unknown',
    sample: 'value ?? "Unknown"',
    hints: ['Use ?? operator', 'Only triggers for null/undefined'],
    tags: ['nullish-coalescing', 'default-values'],
  },
  {
    id: 'js-error-006',
    category: 'Error Handling',
    difficulty: 'easy',
    title: 'Error Name Property',
    text: 'Catch the error and return its name property.',
    setup: 'function fail() { throw new TypeError("Wrong type"); }',
    setupCode: 'function fail() { throw new TypeError("Wrong type"); }',
    expected: 'TypeError',
    sample: 'try { fail(); } catch (e) { return e.name; }',
    hints: ['Errors have a name property', 'TypeError is a specific error type'],
    tags: ['error', 'try-catch', 'error-types'],
  },
  {
    id: 'js-error-007',
    category: 'Control Flow',
    difficulty: 'easy',
    title: 'Optional Chaining with Methods',
    text: 'Safely call the greet method that may not exist.',
    setup: 'const obj = { name: "Test" };',
    setupCode: 'const obj = { name: "Test" };',
    expected: undefined,
    sample: 'obj.greet?.()',
    hints: ['Use ?.() for method calls', 'Returns undefined if method missing'],
    tags: ['optional-chaining', 'methods'],
  },
  {
    id: 'js-error-008',
    category: 'Error Handling',
    difficulty: 'easy',
    title: 'Finally Block Execution',
    text: 'Use finally to ensure cleanup runs. Return the cleanup message.',
    setup: 'let result = "";',
    setupCode: 'let result = "";',
    expected: 'cleaned',
    sample: 'try { throw new Error("fail"); } catch (e) {} finally { result = "cleaned"; } return result;',
    hints: ['finally always runs', 'Set result in finally block'],
    tags: ['error', 'finally', 'cleanup'],
  },
  {
    id: 'js-error-009',
    category: 'Control Flow',
    difficulty: 'easy',
    title: 'Nullish vs OR Operator',
    text: 'Get the count value, treating 0 as valid (not defaulting).',
    setup: 'const config = { count: 0 };',
    setupCode: 'const config = { count: 0 };',
    expected: 0,
    sample: 'config.count ?? 10',
    hints: ['?? only triggers for null/undefined', '|| would treat 0 as falsy'],
    tags: ['nullish-coalescing', 'falsy-values'],
  },
  {
    id: 'js-error-010',
    category: 'Error Handling',
    difficulty: 'easy',
    title: 'Check Error Instance',
    text: 'Catch the error and check if it is a RangeError.',
    setup: 'function checkRange() { throw new RangeError("Out of range"); }',
    setupCode: 'function checkRange() { throw new RangeError("Out of range"); }',
    expected: true,
    sample: 'try { checkRange(); } catch (e) { return e instanceof RangeError; }',
    hints: ['Use instanceof operator', 'Check against RangeError'],
    tags: ['error', 'instanceof', 'error-types'],
  },
  {
    id: 'js-error-011',
    category: 'Control Flow',
    difficulty: 'easy',
    title: 'Optional Chaining with Arrays',
    text: 'Safely access the first item of an array that might be undefined.',
    setup: 'const data = { items: undefined };',
    setupCode: 'const data = { items: undefined };',
    expected: undefined,
    sample: 'data.items?.[0]',
    hints: ['Use ?.[] for array access', 'Returns undefined if array missing'],
    tags: ['optional-chaining', 'arrays'],
  },
  {
    id: 'js-error-012',
    category: 'Error Handling',
    difficulty: 'easy',
    title: 'Throw String Error',
    text: 'Catch a thrown string and return it.',
    setup: 'function throwString() { throw "Simple error"; }',
    setupCode: 'function throwString() { throw "Simple error"; }',
    expected: 'Simple error',
    sample: 'try { throwString(); } catch (e) { return e; }',
    hints: ['JavaScript can throw any value', 'Catch returns the thrown value directly'],
    tags: ['error', 'throw', 'basics'],
  },
  {
    id: 'js-error-013',
    category: 'Control Flow',
    difficulty: 'easy',
    title: 'Combine Optional Chaining and Nullish',
    text: 'Get the user role or default to "guest".',
    setup: 'const user = { profile: null };',
    setupCode: 'const user = { profile: null };',
    expected: 'guest',
    sample: 'user.profile?.role ?? "guest"',
    hints: ['Chain ?. and ?? together', 'Optional chaining returns undefined'],
    tags: ['optional-chaining', 'nullish-coalescing'],
  },
  {
    id: 'js-error-014',
    category: 'Error Handling',
    difficulty: 'easy',
    title: 'Try Without Catch',
    text: 'Use try-finally without catch. Return what runs.',
    setup: 'let log = [];',
    setupCode: 'let log = [];',
    expected: ['try', 'finally'],
    sample: 'try { log.push("try"); } finally { log.push("finally"); } return log;',
    hints: ['finally works without catch', 'Both blocks execute'],
    tags: ['error', 'finally', 'control-flow'],
  },
  {
    id: 'js-error-015',
    category: 'Error Handling',
    difficulty: 'easy',
    title: 'SyntaxError Detection',
    text: 'Catch the eval error and return the error name.',
    setup: 'const badCode = "function {";',
    setupCode: 'const badCode = "function {";',
    expected: 'SyntaxError',
    sample: 'try { eval(badCode); } catch (e) { return e.name; }',
    hints: ['eval throws SyntaxError for bad code', 'Access e.name'],
    tags: ['error', 'syntax-error', 'eval'],
  },
  {
    id: 'js-error-016',
    category: 'Control Flow',
    difficulty: 'easy',
    title: 'Short-Circuit with Optional Chaining',
    text: 'Get the length of an undefined array safely.',
    setup: 'const arr = undefined;',
    setupCode: 'const arr = undefined;',
    expected: 0,
    sample: 'arr?.length ?? 0',
    hints: ['Optional chaining returns undefined', 'Nullish coalescing provides default'],
    tags: ['optional-chaining', 'nullish-coalescing'],
  },
  {
    id: 'js-error-017',
    category: 'Error Handling',
    difficulty: 'easy',
    title: 'Error Stack Property',
    text: 'Check if the caught error has a stack trace.',
    setup: 'function makeError() { throw new Error("test"); }',
    setupCode: 'function makeError() { throw new Error("test"); }',
    expected: true,
    sample: 'try { makeError(); } catch (e) { return typeof e.stack === "string"; }',
    hints: ['Errors have stack property', 'Stack is a string'],
    tags: ['error', 'stack-trace', 'debugging'],
  },
  {
    id: 'js-error-018',
    category: 'Control Flow',
    difficulty: 'easy',
    title: 'Defensive Array Access',
    text: 'Safely get the first user name or "Anonymous".',
    setup: 'const users = [];',
    setupCode: 'const users = [];',
    expected: 'Anonymous',
    sample: 'users[0]?.name ?? "Anonymous"',
    hints: ['Empty array returns undefined for index', 'Chain with nullish coalescing'],
    tags: ['optional-chaining', 'arrays', 'defensive'],
  },
  {
    id: 'js-error-019',
    category: 'Error Handling',
    difficulty: 'easy',
    title: 'Catch and Log',
    text: 'Catch error and return formatted message with name and message.',
    setup: 'function fail() { throw new TypeError("invalid"); }',
    setupCode: 'function fail() { throw new TypeError("invalid"); }',
    expected: 'TypeError: invalid',
    sample: 'try { fail(); } catch (e) { return `${e.name}: ${e.message}`; }',
    hints: ['Access both name and message', 'Use template literal'],
    tags: ['error', 'formatting', 'logging'],
  },
  {
    id: 'js-error-020',
    category: 'Control Flow',
    difficulty: 'easy',
    title: 'Multiple Optional Chains',
    text: 'Safely access deeply nested value.',
    setup: 'const data = { a: { b: null } };',
    setupCode: 'const data = { a: { b: null } };',
    expected: undefined,
    sample: 'data?.a?.b?.c?.d',
    hints: ['Chain multiple ?. operators', 'Stops at null'],
    tags: ['optional-chaining', 'deep-access'],
  },
  {
    id: 'js-error-021',
    category: 'Error Handling',
    difficulty: 'easy',
    title: 'Boolean Error Check',
    text: 'Check if a caught error has a specific message.',
    setup: 'function test() { throw new Error("not found"); }',
    setupCode: 'function test() { throw new Error("not found"); }',
    expected: true,
    sample: 'try { test(); } catch (e) { return e.message.includes("not found"); }',
    hints: ['Access error message', 'Use includes() method'],
    tags: ['error', 'validation', 'string-methods'],
  },
  {
    id: 'js-error-022',
    category: 'Control Flow',
    difficulty: 'easy',
    title: 'Nullish with Empty String',
    text: 'Return the name or default, where empty string is valid.',
    setup: 'const name = "";',
    setupCode: 'const name = "";',
    expected: '',
    sample: 'name ?? "default"',
    hints: ['Empty string is not nullish', '?? keeps empty strings'],
    tags: ['nullish-coalescing', 'empty-string'],
  },
  {
    id: 'js-error-023',
    category: 'Error Handling',
    difficulty: 'easy',
    title: 'Rethrow After Logging',
    text: 'Catch, log to array, and check if error was caught.',
    setup: 'const logs = [];',
    setupCode: 'const logs = [];',
    expected: ['Error caught'],
    sample: 'try { throw new Error("fail"); } catch (e) { logs.push("Error caught"); } return logs;',
    hints: ['Push to logs array', 'Error was handled'],
    tags: ['error', 'logging', 'patterns'],
  },
  {
    id: 'js-error-024',
    category: 'Control Flow',
    difficulty: 'easy',
    title: 'Optional Delete',
    text: 'Safely attempt to access property for deletion check.',
    setup: 'const obj = undefined;',
    setupCode: 'const obj = undefined;',
    expected: undefined,
    sample: 'obj?.prop',
    hints: ['Optional chaining on undefined', 'Returns undefined safely'],
    tags: ['optional-chaining', 'undefined'],
  },
  {
    id: 'js-error-025',
    category: 'Error Handling',
    difficulty: 'easy',
    title: 'URIError Handling',
    text: 'Catch the URI decoding error and return its type.',
    setup: 'const badUri = "%";',
    setupCode: 'const badUri = "%";',
    expected: 'URIError',
    sample: 'try { decodeURIComponent(badUri); } catch (e) { return e.name; }',
    hints: ['Invalid URI throws URIError', 'Access error name'],
    tags: ['error', 'uri-error', 'decoding'],
  },
  {
    id: 'js-error-026',
    category: 'Exceptions',
    difficulty: 'easy',
    title: 'Throw Literal Object',
    text: 'Catch a thrown literal object and access its property.',
    setup: 'function throwObj() { throw { code: 404, msg: "Not found" }; }',
    setupCode: 'function throwObj() { throw { code: 404, msg: "Not found" }; }',
    expected: 404,
    sample: 'try { throwObj(); } catch (e) { return e.code; }',
    hints: ['Any value can be thrown', 'Access as regular object'],
    tags: ['error', 'throw', 'object'],
  },
  {
    id: 'js-error-027',
    category: 'Exceptions',
    difficulty: 'easy',
    title: 'Throw Number',
    text: 'Catch a thrown number and return it.',
    setup: 'function throwNum() { throw 42; }',
    setupCode: 'function throwNum() { throw 42; }',
    expected: 42,
    sample: 'try { throwNum(); } catch (e) { return e; }',
    hints: ['Numbers can be thrown', 'Caught value is the number'],
    tags: ['error', 'throw', 'primitives'],
  },
  {
    id: 'js-error-028',
    category: 'Exceptions',
    difficulty: 'easy',
    title: 'Reference Error',
    text: 'Catch a ReferenceError and return its name.',
    setup: 'function accessUndefined() { return nonExistentVar; }',
    setupCode: 'function accessUndefined() { return nonExistentVar; }',
    expected: 'ReferenceError',
    sample: 'try { accessUndefined(); } catch (e) { return e.name; }',
    hints: ['Undefined variable throws ReferenceError', 'Access e.name'],
    tags: ['error', 'reference-error', 'basics'],
  },
  {
    id: 'js-error-029',
    category: 'Exceptions',
    difficulty: 'easy',
    title: 'Type Error on Null',
    text: 'Catch TypeError when calling method on null.',
    setup: 'const val = null;',
    setupCode: 'const val = null;',
    expected: 'TypeError',
    sample: 'try { val.toString(); } catch (e) { return e.name; }',
    hints: ['null has no methods', 'Throws TypeError'],
    tags: ['error', 'type-error', 'null'],
  },
  {
    id: 'js-error-030',
    category: 'Exceptions',
    difficulty: 'easy',
    title: 'Array Length RangeError',
    text: 'Catch RangeError for invalid array length.',
    setup: 'function badArray() { return new Array(-1); }',
    setupCode: 'function badArray() { return new Array(-1); }',
    expected: 'RangeError',
    sample: 'try { badArray(); } catch (e) { return e.name; }',
    hints: ['Negative length is invalid', 'Throws RangeError'],
    tags: ['error', 'range-error', 'array'],
  },
  {
    id: 'js-error-031',
    category: 'Control Flow',
    difficulty: 'easy',
    title: 'Short-Circuit Evaluation',
    text: 'Use AND short-circuit to guard function call.',
    setup: 'const obj = null;',
    setupCode: 'const obj = null;',
    expected: null,
    sample: 'obj && obj.method()',
    hints: ['AND stops at falsy', 'Returns null for null'],
    tags: ['short-circuit', 'and-operator', 'guard'],
  },
  {
    id: 'js-error-032',
    category: 'Control Flow',
    difficulty: 'easy',
    title: 'OR Default Value',
    text: 'Use OR to provide default for falsy value.',
    setup: 'const name = "";',
    setupCode: 'const name = "";',
    expected: 'Anonymous',
    sample: 'name || "Anonymous"',
    hints: ['OR continues on falsy', 'Empty string is falsy'],
    tags: ['short-circuit', 'or-operator', 'defaults'],
  },
  {
    id: 'js-error-033',
    category: 'Exceptions',
    difficulty: 'easy',
    title: 'Recursion Limit Error',
    text: 'Catch the error from infinite recursion.',
    setup: 'function recurse() { return recurse(); }',
    setupCode: 'function recurse() { return recurse(); }',
    expected: true,
    sample: 'try { recurse(); } catch (e) { return e.message.toLowerCase().includes("stack") || e.name === "RangeError"; }',
    hints: ['Infinite recursion overflows stack', 'Error mentions stack'],
    tags: ['error', 'recursion', 'stack-overflow'],
  },
  {
    id: 'js-error-034',
    category: 'Control Flow',
    difficulty: 'easy',
    title: 'Ternary Error Check',
    text: 'Use ternary to return error or success message.',
    setup: 'const success = false;',
    setupCode: 'const success = false;',
    expected: 'Failed',
    sample: 'success ? "Success" : "Failed"',
    hints: ['Ternary checks condition', 'Returns false branch'],
    tags: ['ternary', 'conditional', 'basics'],
  },
  {
    id: 'js-error-035',
    category: 'Exceptions',
    difficulty: 'easy',
    title: 'JSON Stringify Circular',
    text: 'Catch error from stringifying circular reference.',
    setup: 'const obj = {}; obj.self = obj;',
    setupCode: 'const obj = {}; obj.self = obj;',
    expected: true,
    sample: 'try { JSON.stringify(obj); return false; } catch (e) { return e.message.includes("circular") || e.name === "TypeError"; }',
    hints: ['Circular refs cause error', 'Check message or type'],
    tags: ['error', 'json', 'circular'],
  },
  {
    id: 'js-error-036',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Custom Error Class',
    text: 'Create a ValidationError class and throw it. Return the error name.',
    setup: 'class ValidationError extends Error { constructor(msg) { super(msg); this.name = "ValidationError"; } }',
    setupCode: 'class ValidationError extends Error { constructor(msg) { super(msg); this.name = "ValidationError"; } }',
    expected: 'ValidationError',
    sample: 'try { throw new ValidationError("Invalid data"); } catch (e) { return e.name; }',
    hints: ['Throw instance of custom class', 'Access name property'],
    tags: ['error', 'custom-error', 'classes'],
  },
  {
    id: 'js-error-037',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Error with Custom Properties',
    text: 'Throw an error with custom code property and return it.',
    setup: 'function throwWithCode() { const e = new Error("Failed"); e.code = "E001"; throw e; }',
    setupCode: 'function throwWithCode() { const e = new Error("Failed"); e.code = "E001"; throw e; }',
    expected: 'E001',
    sample: 'try { throwWithCode(); } catch (e) { return e.code; }',
    hints: ['Errors can have custom properties', 'Access the code property'],
    tags: ['error', 'custom-properties', 'patterns'],
  },
  {
    id: 'js-error-038',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Conditional Rethrow',
    text: 'Catch error, rethrow if not a TypeError, otherwise return "handled".',
    setup: 'function maybeThrow() { throw new TypeError("type issue"); }',
    setupCode: 'function maybeThrow() { throw new TypeError("type issue"); }',
    expected: 'handled',
    sample: 'try { maybeThrow(); } catch (e) { if (!(e instanceof TypeError)) throw e; return "handled"; }',
    hints: ['Check error type with instanceof', 'Rethrow unknown errors'],
    tags: ['error', 'rethrow', 'conditional'],
  },
  {
    id: 'js-error-039',
    category: 'Control Flow',
    difficulty: 'medium',
    title: 'Nullish Assignment Operator',
    text: 'Use nullish assignment to set default value.',
    setup: 'let config = { timeout: null, retries: 3 };',
    setupCode: 'let config = { timeout: null, retries: 3 };',
    expected: { timeout: 5000, retries: 3 },
    sample: 'config.timeout ??= 5000; return config;',
    hints: ['Use ??= operator', 'Only assigns if null/undefined'],
    tags: ['nullish-coalescing', 'assignment', 'operators'],
  },
  {
    id: 'js-error-040',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Error Cause Property',
    text: 'Create an error with a cause and return the original error message.',
    setup: 'const originalError = new Error("Database connection failed");',
    setupCode: 'const originalError = new Error("Database connection failed");',
    expected: 'Database connection failed',
    sample: 'try { throw new Error("Operation failed", { cause: originalError }); } catch (e) { return e.cause.message; }',
    hints: ['Use cause option in Error constructor', 'Access e.cause.message'],
    tags: ['error', 'error-cause', 'chaining'],
  },
  {
    id: 'js-error-041',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Nested Try-Catch',
    text: 'Handle inner error differently from outer error.',
    setup: 'function inner() { throw new Error("inner"); }',
    setupCode: 'function inner() { throw new Error("inner"); }',
    expected: 'inner-handled',
    sample: 'try { try { inner(); } catch (e) { return e.message + "-handled"; } } catch (e) { return "outer"; }',
    hints: ['Nest try-catch blocks', 'Inner catch handles first'],
    tags: ['error', 'nested', 'try-catch'],
  },
  {
    id: 'js-error-042',
    category: 'Control Flow',
    difficulty: 'medium',
    title: 'Optional Chaining in Callbacks',
    text: 'Safely execute a callback that might not exist.',
    setup: 'const handlers = { onSuccess: () => "done" };',
    setupCode: 'const handlers = { onSuccess: () => "done" };',
    expected: undefined,
    sample: 'handlers.onError?.()',
    hints: ['Use ?.() for optional function calls', 'Returns undefined if missing'],
    tags: ['optional-chaining', 'callbacks', 'functions'],
  },
  {
    id: 'js-error-043',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'AggregateError Handling',
    text: 'Create an AggregateError with multiple errors and return the count.',
    setup: 'const errors = [new Error("e1"), new Error("e2"), new Error("e3")];',
    setupCode: 'const errors = [new Error("e1"), new Error("e2"), new Error("e3")];',
    expected: 3,
    sample: 'try { throw new AggregateError(errors, "Multiple errors"); } catch (e) { return e.errors.length; }',
    hints: ['AggregateError holds multiple errors', 'Access errors array property'],
    tags: ['error', 'aggregate-error', 'multiple-errors'],
  },
  {
    id: 'js-error-044',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Error Wrapping Pattern',
    text: 'Wrap a low-level error in a high-level error with context.',
    setup: 'function dbQuery() { throw new Error("Connection timeout"); }',
    setupCode: 'function dbQuery() { throw new Error("Connection timeout"); }',
    expected: 'Failed to fetch user: Connection timeout',
    sample: 'try { dbQuery(); } catch (e) { const wrapped = new Error(`Failed to fetch user: ${e.message}`); return wrapped.message; }',
    hints: ['Catch and rethrow with context', 'Include original message'],
    tags: ['error', 'wrapping', 'context'],
  },
  {
    id: 'js-error-045',
    category: 'Control Flow',
    difficulty: 'medium',
    title: 'Logical AND Assignment',
    text: 'Use logical AND assignment to update only if truthy.',
    setup: 'let user = { name: "Alice", active: true };',
    setupCode: 'let user = { name: "Alice", active: true };',
    expected: { name: "Alice", active: 'verified' },
    sample: 'user.active &&= "verified"; return user;',
    hints: ['Use &&= operator', 'Only assigns if left side is truthy'],
    tags: ['logical-assignment', 'operators', 'control-flow'],
  },
  {
    id: 'js-error-046',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Promise Rejection to Error',
    text: 'Convert a rejected promise to a caught error.',
    setup: 'const rejected = Promise.reject(new Error("async fail"));',
    setupCode: 'const rejected = Promise.reject(new Error("async fail"));',
    expected: 'async fail',
    sample: 'return rejected.catch(e => e.message);',
    hints: ['Use .catch() method', 'Return error message'],
    tags: ['error', 'promises', 'async'],
  },
  {
    id: 'js-error-047',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Finally with Return',
    text: 'Understand how finally affects return values.',
    setup: 'function test() { try { return "try"; } finally { return "finally"; } }',
    setupCode: 'function test() { try { return "try"; } finally { return "finally"; } }',
    expected: 'finally',
    sample: 'test()',
    hints: ['finally return overrides try return', 'finally executes last'],
    tags: ['error', 'finally', 'return'],
  },
  {
    id: 'js-error-048',
    category: 'Control Flow',
    difficulty: 'medium',
    title: 'Assertion Function',
    text: 'Create a simple assert function that throws if condition is false.',
    setup: 'function assert(cond, msg) { if (!cond) throw new Error(msg); return true; }',
    setupCode: 'function assert(cond, msg) { if (!cond) throw new Error(msg); return true; }',
    expected: true,
    sample: 'assert(5 > 3, "Math is broken")',
    hints: ['Call assert with true condition', 'Should not throw'],
    tags: ['assertion', 'validation', 'defensive'],
  },
  {
    id: 'js-error-049',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Type Guard with Throw',
    text: 'Throw if value is not a string, otherwise return its length.',
    setup: 'const value = "hello";',
    setupCode: 'const value = "hello";',
    expected: 5,
    sample: 'if (typeof value !== "string") throw new TypeError("Expected string"); return value.length;',
    hints: ['Check typeof first', 'Throw TypeError for wrong type'],
    tags: ['error', 'type-guard', 'validation'],
  },
  {
    id: 'js-error-050',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Multiple Catch Types',
    text: 'Handle different error types differently.',
    setup: 'function randomError() { throw new RangeError("out of range"); }',
    setupCode: 'function randomError() { throw new RangeError("out of range"); }',
    expected: 'range',
    sample: 'try { randomError(); } catch (e) { if (e instanceof RangeError) return "range"; if (e instanceof TypeError) return "type"; return "other"; }',
    hints: ['Use instanceof checks', 'Return different values per type'],
    tags: ['error', 'instanceof', 'conditional'],
  },
  {
    id: 'js-error-051',
    category: 'Control Flow',
    difficulty: 'medium',
    title: 'Safe JSON Parse',
    text: 'Create a safe JSON parse that returns default on error.',
    setup: 'function safeParse(str, def) { try { return JSON.parse(str); } catch { return def; } }',
    setupCode: 'function safeParse(str, def) { try { return JSON.parse(str); } catch { return def; } }',
    expected: { default: true },
    sample: 'safeParse("invalid", { default: true })',
    hints: ['Call safeParse with invalid JSON', 'Returns the default value'],
    tags: ['error', 'json', 'defensive'],
  },
  {
    id: 'js-error-052',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Error in Promise Chain',
    text: 'Handle error in the middle of a promise chain.',
    setup: 'const p = Promise.resolve(10).then(x => { throw new Error("mid"); });',
    setupCode: 'const p = Promise.resolve(10).then(x => { throw new Error("mid"); });',
    expected: 'caught: mid',
    sample: 'return p.catch(e => "caught: " + e.message);',
    hints: ['Error propagates to catch', 'Return formatted message'],
    tags: ['error', 'promises', 'chaining'],
  },
  {
    id: 'js-error-053',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Throw in Finally',
    text: 'Understand what happens when finally throws.',
    setup: 'function test() { try { throw new Error("try"); } finally { throw new Error("finally"); } }',
    setupCode: 'function test() { try { throw new Error("try"); } finally { throw new Error("finally"); } }',
    expected: 'finally',
    sample: 'try { test(); } catch (e) { return e.message; }',
    hints: ['finally error overrides try error', 'Outer catch gets finally error'],
    tags: ['error', 'finally', 'override'],
  },
  {
    id: 'js-error-054',
    category: 'Control Flow',
    difficulty: 'medium',
    title: 'Optional Chaining with Bracket Notation',
    text: 'Safely access dynamic property that may not exist.',
    setup: 'const obj = { data: { x: 10 } }; const key = "y";',
    setupCode: 'const obj = { data: { x: 10 } }; const key = "y";',
    expected: undefined,
    sample: 'obj.data?.[key]',
    hints: ['Use ?.[] for dynamic access', 'Returns undefined for missing key'],
    tags: ['optional-chaining', 'dynamic-access', 'brackets'],
  },
  {
    id: 'js-error-055',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Validation Chain',
    text: 'Chain multiple validations, throwing on first failure.',
    setup: 'const data = { name: "", age: 25 };',
    setupCode: 'const data = { name: "", age: 25 };',
    expected: 'Name required',
    sample: 'try { if (!data.name) throw new Error("Name required"); if (data.age < 0) throw new Error("Invalid age"); return "valid"; } catch (e) { return e.message; }',
    hints: ['Check validations in order', 'First failure throws'],
    tags: ['error', 'validation', 'chaining'],
  },
  {
    id: 'js-error-056',
    category: 'Control Flow',
    difficulty: 'medium',
    title: 'Logical OR Assignment',
    text: 'Use logical OR assignment to set default.',
    setup: 'let options = { debug: false, verbose: undefined };',
    setupCode: 'let options = { debug: false, verbose: undefined };',
    expected: { debug: false, verbose: true },
    sample: 'options.verbose ||= true; return options;',
    hints: ['Use ||= operator', 'Assigns if left is falsy'],
    tags: ['logical-assignment', 'operators', 'defaults'],
  },
  {
    id: 'js-error-057',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Error Recovery Strategy',
    text: 'Try primary, fallback to secondary on error.',
    setup: 'function primary() { throw new Error("fail"); } function secondary() { return "backup"; }',
    setupCode: 'function primary() { throw new Error("fail"); } function secondary() { return "backup"; }',
    expected: 'backup',
    sample: 'try { return primary(); } catch { return secondary(); }',
    hints: ['Catch primary failure', 'Call secondary as fallback'],
    tags: ['error', 'fallback', 'recovery'],
  },
  {
    id: 'js-error-058',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Preserve Stack Trace',
    text: 'Wrap error while preserving original stack.',
    setup: 'function original() { throw new Error("original"); }',
    setupCode: 'function original() { throw new Error("original"); }',
    expected: true,
    sample: 'try { original(); } catch (e) { const wrapped = new Error("wrapped", { cause: e }); return wrapped.cause.stack.includes("original"); }',
    hints: ['Use cause to preserve original', 'Access cause.stack'],
    tags: ['error', 'stack-trace', 'cause'],
  },
  {
    id: 'js-error-059',
    category: 'Control Flow',
    difficulty: 'medium',
    title: 'Safe Property Delete',
    text: 'Safely delete a nested property if it exists.',
    setup: 'const obj = { a: { b: 1 } };',
    setupCode: 'const obj = { a: { b: 1 } };',
    expected: true,
    sample: 'if (obj?.a?.b !== undefined) delete obj.a.b; return obj.a.b === undefined;',
    hints: ['Check existence first', 'Delete if exists'],
    tags: ['optional-chaining', 'delete', 'defensive'],
  },
  {
    id: 'js-error-060',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'EvalError Distinction',
    text: 'Throw and catch an EvalError to check its type.',
    setup: 'function throwEval() { throw new EvalError("eval issue"); }',
    setupCode: 'function throwEval() { throw new EvalError("eval issue"); }',
    expected: 'EvalError',
    sample: 'try { throwEval(); } catch (e) { return e.constructor.name; }',
    hints: ['Access constructor.name', 'Returns error class name'],
    tags: ['error', 'eval-error', 'constructor'],
  },
  {
    id: 'js-error-061',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Async Error Handling',
    text: 'Handle error in async function with try-catch.',
    setup: 'async function asyncFail() { throw new Error("async error"); }',
    setupCode: 'async function asyncFail() { throw new Error("async error"); }',
    expected: 'async error',
    sample: 'return asyncFail().catch(e => e.message);',
    hints: ['Async throws become rejections', 'Use .catch() to handle'],
    tags: ['error', 'async', 'promises'],
  },
  {
    id: 'js-error-062',
    category: 'Control Flow',
    difficulty: 'medium',
    title: 'Nullish with Function Result',
    text: 'Use nullish coalescing with function that may return null.',
    setup: 'function maybeNull() { return null; }',
    setupCode: 'function maybeNull() { return null; }',
    expected: 'default',
    sample: 'maybeNull() ?? "default"',
    hints: ['Call function directly', 'Nullish provides default for null'],
    tags: ['nullish-coalescing', 'functions', 'null'],
  },
  {
    id: 'js-error-063',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'InternalError Simulation',
    text: 'Create and throw a custom InternalError-like error.',
    setup: 'class InternalError extends Error { constructor(msg) { super(msg); this.name = "InternalError"; } }',
    setupCode: 'class InternalError extends Error { constructor(msg) { super(msg); this.name = "InternalError"; } }',
    expected: 'InternalError: Stack overflow',
    sample: 'try { throw new InternalError("Stack overflow"); } catch (e) { return `${e.name}: ${e.message}`; }',
    hints: ['Throw custom error', 'Format name and message'],
    tags: ['error', 'custom-error', 'formatting'],
  },
  {
    id: 'js-error-064',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Catch Without Variable',
    text: 'Use catch without binding the error variable.',
    setup: 'function mayFail() { throw new Error("fail"); }',
    setupCode: 'function mayFail() { throw new Error("fail"); }',
    expected: 'handled',
    sample: 'try { mayFail(); } catch { return "handled"; }',
    hints: ['Catch without (e)', 'Modern syntax allows this'],
    tags: ['error', 'catch', 'syntax'],
  },
  {
    id: 'js-error-065',
    category: 'Control Flow',
    difficulty: 'medium',
    title: 'Safe Array Destructure',
    text: 'Safely destructure from potentially undefined source.',
    setup: 'const data = undefined;',
    setupCode: 'const data = undefined;',
    expected: 'no-first',
    sample: 'const [first] = data ?? []; return first ?? "no-first";',
    hints: ['Provide empty array default', 'Then default for first element'],
    tags: ['nullish-coalescing', 'destructuring', 'arrays'],
  },
  {
    id: 'js-error-066',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Promise.any with All Rejected',
    text: 'Handle AggregateError when all promises reject.',
    setup: 'const promises = [Promise.reject("e1"), Promise.reject("e2")];',
    setupCode: 'const promises = [Promise.reject("e1"), Promise.reject("e2")];',
    expected: 2,
    sample: 'return Promise.any(promises).catch(e => e.errors.length);',
    hints: ['Promise.any throws AggregateError', 'Access errors array'],
    tags: ['error', 'promise-any', 'aggregate'],
  },
  {
    id: 'js-error-067',
    category: 'Control Flow',
    difficulty: 'medium',
    title: 'Guard Clause Pattern',
    text: 'Use early returns to handle error cases.',
    setup: 'function validate(user) { if (!user) return { error: "No user" }; if (!user.email) return { error: "No email" }; return { valid: true }; }',
    setupCode: 'function validate(user) { if (!user) return { error: "No user" }; if (!user.email) return { error: "No email" }; return { valid: true }; }',
    expected: { error: 'No email' },
    sample: 'validate({ name: "Test" })',
    hints: ['Guard clauses return early', 'Missing email triggers second guard'],
    tags: ['guard-clause', 'validation', 'patterns'],
  },
  {
    id: 'js-error-068',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Dynamic Import Error',
    text: 'Handle error from failing dynamic import.',
    setup: 'const importModule = () => import("./nonexistent.js");',
    setupCode: 'const importModule = () => import("./nonexistent.js");',
    expected: true,
    sample: 'return importModule().catch(e => e instanceof Error);',
    hints: ['Dynamic import returns promise', 'Missing module rejects'],
    tags: ['error', 'dynamic-import', 'modules'],
  },
  {
    id: 'js-error-069',
    category: 'Control Flow',
    difficulty: 'medium',
    title: 'Switch with Default Error',
    text: 'Throw error in switch default case.',
    setup: 'function handleStatus(code) { switch(code) { case 200: return "OK"; case 404: return "Not Found"; default: throw new Error("Unknown: " + code); } }',
    setupCode: 'function handleStatus(code) { switch(code) { case 200: return "OK"; case 404: return "Not Found"; default: throw new Error("Unknown: " + code); } }',
    expected: 'Unknown: 500',
    sample: 'try { handleStatus(500); } catch (e) { return e.message; }',
    hints: ['Unknown code hits default', 'Throws with code in message'],
    tags: ['error', 'switch', 'default'],
  },
  {
    id: 'js-error-070',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Error in Getter',
    text: 'Handle error thrown by object getter.',
    setup: 'const obj = { get value() { throw new Error("Getter failed"); } };',
    setupCode: 'const obj = { get value() { throw new Error("Getter failed"); } };',
    expected: 'Getter failed',
    sample: 'try { obj.value; } catch (e) { return e.message; }',
    hints: ['Accessing getter can throw', 'Wrap in try-catch'],
    tags: ['error', 'getter', 'properties'],
  },
  {
    id: 'js-error-071',
    category: 'Control Flow',
    difficulty: 'medium',
    title: 'Error in Setter',
    text: 'Handle error thrown by object setter.',
    setup: 'const obj = { set value(v) { if (v < 0) throw new Error("Negative not allowed"); } };',
    setupCode: 'const obj = { set value(v) { if (v < 0) throw new Error("Negative not allowed"); } };',
    expected: 'Negative not allowed',
    sample: 'try { obj.value = -1; } catch (e) { return e.message; }',
    hints: ['Setter validates input', 'Throws for negative'],
    tags: ['error', 'setter', 'validation'],
  },
  {
    id: 'js-error-072',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Proxy Trap Error',
    text: 'Handle error from Proxy get trap.',
    setup: 'const handler = { get(t, p) { throw new Error("Access denied: " + p); } }; const proxy = new Proxy({}, handler);',
    setupCode: 'const handler = { get(t, p) { throw new Error("Access denied: " + p); } }; const proxy = new Proxy({}, handler);',
    expected: 'Access denied: secret',
    sample: 'try { proxy.secret; } catch (e) { return e.message; }',
    hints: ['Proxy trap intercepts access', 'Throws with property name'],
    tags: ['error', 'proxy', 'traps'],
  },
  {
    id: 'js-error-073',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Symbol.iterator Error',
    text: 'Handle error when iterating non-iterable.',
    setup: 'const obj = { [Symbol.iterator]: () => ({ next: () => { throw new Error("Iterator error"); } }) };',
    setupCode: 'const obj = { [Symbol.iterator]: () => ({ next: () => { throw new Error("Iterator error"); } }) };',
    expected: 'Iterator error',
    sample: 'try { [...obj]; } catch (e) { return e.message; }',
    hints: ['Spread calls iterator', 'next() throws error'],
    tags: ['error', 'iterator', 'spread'],
  },
  {
    id: 'js-error-074',
    category: 'Control Flow',
    difficulty: 'medium',
    title: 'Generator Error Handling',
    text: 'Handle error thrown inside generator.',
    setup: 'function* gen() { yield 1; throw new Error("Generator error"); yield 2; }',
    setupCode: 'function* gen() { yield 1; throw new Error("Generator error"); yield 2; }',
    expected: { values: [1], error: 'Generator error' },
    sample: 'const values = []; const g = gen(); try { values.push(g.next().value); values.push(g.next().value); } catch (e) { return { values, error: e.message }; }',
    hints: ['First next succeeds', 'Second next throws'],
    tags: ['error', 'generator', 'iteration'],
  },
  {
    id: 'js-error-075',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Assertion Failed Message',
    text: 'Catch assertion failure and return custom message.',
    setup: 'function assertPositive(n) { if (n <= 0) throw new Error(`Expected positive, got ${n}`); return n; }',
    setupCode: 'function assertPositive(n) { if (n <= 0) throw new Error(`Expected positive, got ${n}`); return n; }',
    expected: 'Expected positive, got -5',
    sample: 'try { assertPositive(-5); } catch (e) { return e.message; }',
    hints: ['Negative triggers assertion', 'Message includes the value'],
    tags: ['error', 'assertion', 'validation'],
  },
  {
    id: 'js-error-076',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Custom Error Hierarchy',
    text: 'Create a hierarchy of errors and check inheritance.',
    setup: 'class AppError extends Error { constructor(msg) { super(msg); this.name = "AppError"; } } class NetworkError extends AppError { constructor(msg) { super(msg); this.name = "NetworkError"; } }',
    setupCode: 'class AppError extends Error { constructor(msg) { super(msg); this.name = "AppError"; } } class NetworkError extends AppError { constructor(msg) { super(msg); this.name = "NetworkError"; } }',
    expected: [true, true, true],
    sample: 'const e = new NetworkError("timeout"); return [e instanceof NetworkError, e instanceof AppError, e instanceof Error];',
    hints: ['Check all levels of inheritance', 'instanceof checks prototype chain'],
    tags: ['error', 'inheritance', 'custom-error'],
  },
  {
    id: 'js-error-077',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Error Factory Pattern',
    text: 'Create a factory that produces typed errors.',
    setup: 'const errorFactory = { validation: (msg) => { const e = new Error(msg); e.type = "VALIDATION"; return e; }, network: (msg) => { const e = new Error(msg); e.type = "NETWORK"; return e; } };',
    setupCode: 'const errorFactory = { validation: (msg) => { const e = new Error(msg); e.type = "VALIDATION"; return e; }, network: (msg) => { const e = new Error(msg); e.type = "NETWORK"; return e; } };',
    expected: 'VALIDATION',
    sample: 'try { throw errorFactory.validation("Invalid email"); } catch (e) { return e.type; }',
    hints: ['Use factory method', 'Access custom type property'],
    tags: ['error', 'factory', 'patterns'],
  },
  {
    id: 'js-error-078',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Retry with Error Tracking',
    text: 'Implement retry logic that tracks all errors.',
    setup: 'let attempts = 0; function unreliable() { attempts++; if (attempts < 3) throw new Error(`Attempt ${attempts}`); return "success"; }',
    setupCode: 'let attempts = 0; function unreliable() { attempts++; if (attempts < 3) throw new Error(`Attempt ${attempts}`); return "success"; }',
    expected: { result: 'success', errors: ['Attempt 1', 'Attempt 2'] },
    sample: 'const errors = []; while (true) { try { return { result: unreliable(), errors }; } catch (e) { errors.push(e.message); } }',
    hints: ['Loop until success', 'Collect errors in array'],
    tags: ['error', 'retry', 'tracking'],
  },
  {
    id: 'js-error-079',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Error Serialization',
    text: 'Serialize error to JSON-compatible object.',
    setup: 'function createError() { const e = new TypeError("Invalid argument"); e.code = "ARG_001"; return e; }',
    setupCode: 'function createError() { const e = new TypeError("Invalid argument"); e.code = "ARG_001"; return e; }',
    expected: { name: 'TypeError', message: 'Invalid argument', code: 'ARG_001' },
    sample: 'const e = createError(); return { name: e.name, message: e.message, code: e.code };',
    hints: ['Extract error properties', 'Build plain object'],
    tags: ['error', 'serialization', 'json'],
  },
  {
    id: 'js-error-080',
    category: 'Control Flow',
    difficulty: 'hard',
    title: 'Deep Optional Chain with Transform',
    text: 'Navigate deep optional path and transform result.',
    setup: 'const api = { response: { data: { users: [{ profile: { email: "test@example.com" } }] } } };',
    setupCode: 'const api = { response: { data: { users: [{ profile: { email: "test@example.com" } }] } } };',
    expected: 'TEST@EXAMPLE.COM',
    sample: 'api?.response?.data?.users?.[0]?.profile?.email?.toUpperCase() ?? "NO EMAIL"',
    hints: ['Chain all the way through', 'Call method at the end'],
    tags: ['optional-chaining', 'deep-access', 'transform'],
  },
  {
    id: 'js-error-081',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Error Middleware Chain',
    text: 'Pass error through middleware chain, each adding context.',
    setup: 'const middlewares = [(e) => { e.context = []; e.context.push("m1"); return e; }, (e) => { e.context.push("m2"); return e; }];',
    setupCode: 'const middlewares = [(e) => { e.context = []; e.context.push("m1"); return e; }, (e) => { e.context.push("m2"); return e; }];',
    expected: ['m1', 'm2'],
    sample: 'let err = new Error("test"); for (const m of middlewares) err = m(err); return err.context;',
    hints: ['Chain middleware functions', 'Each modifies error'],
    tags: ['error', 'middleware', 'patterns'],
  },
  {
    id: 'js-error-082',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Promise.allSettled Error Extraction',
    text: 'Extract all error messages from settled promises.',
    setup: 'const promises = [Promise.resolve(1), Promise.reject(new Error("fail1")), Promise.reject(new Error("fail2"))];',
    setupCode: 'const promises = [Promise.resolve(1), Promise.reject(new Error("fail1")), Promise.reject(new Error("fail2"))];',
    expected: ['fail1', 'fail2'],
    sample: 'return Promise.allSettled(promises).then(results => results.filter(r => r.status === "rejected").map(r => r.reason.message));',
    hints: ['Use Promise.allSettled', 'Filter rejected, map reasons'],
    tags: ['error', 'promises', 'allSettled'],
  },
  {
    id: 'js-error-083',
    category: 'Control Flow',
    difficulty: 'hard',
    title: 'Nullish with Computed Property',
    text: 'Use nullish coalescing with computed property access.',
    setup: 'const config = { settings: { theme: null } }; const key = "theme";',
    setupCode: 'const config = { settings: { theme: null } }; const key = "theme";',
    expected: 'dark',
    sample: 'config.settings[key] ?? "dark"',
    hints: ['Access with bracket notation', 'Nullish provides default'],
    tags: ['nullish-coalescing', 'computed-property', 'dynamic'],
  },
  {
    id: 'js-error-084',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Error Recovery with State',
    text: 'Recover from error while maintaining valid state.',
    setup: 'let state = { count: 0, errors: [] }; function increment() { state.count++; if (state.count === 2) throw new Error("fail at 2"); }',
    setupCode: 'let state = { count: 0, errors: [] }; function increment() { state.count++; if (state.count === 2) throw new Error("fail at 2"); }',
    expected: { count: 3, errors: ['fail at 2'] },
    sample: 'for (let i = 0; i < 3; i++) { try { increment(); } catch (e) { state.errors.push(e.message); } } return state;',
    hints: ['Continue after error', 'Track errors in state'],
    tags: ['error', 'state', 'recovery'],
  },
  {
    id: 'js-error-085',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Async Error Aggregation',
    text: 'Aggregate errors from multiple async operations.',
    setup: 'const ops = [() => Promise.reject(new Error("op1")), () => Promise.resolve("ok"), () => Promise.reject(new Error("op3"))];',
    setupCode: 'const ops = [() => Promise.reject(new Error("op1")), () => Promise.resolve("ok"), () => Promise.reject(new Error("op3"))];',
    expected: ['op1', 'op3'],
    sample: 'return Promise.all(ops.map(op => op().catch(e => ({ error: e.message })))).then(results => results.filter(r => r.error).map(r => r.error));',
    hints: ['Catch each operation individually', 'Mark errors in results'],
    tags: ['error', 'async', 'aggregation'],
  },
  {
    id: 'js-error-086',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Transactional Error Handling',
    text: 'Rollback changes on error.',
    setup: 'let data = [1, 2, 3]; function transaction(fn) { const backup = [...data]; try { fn(); } catch (e) { data = backup; throw e; } }',
    setupCode: 'let data = [1, 2, 3]; function transaction(fn) { const backup = [...data]; try { fn(); } catch (e) { data = backup; throw e; } }',
    expected: [1, 2, 3],
    sample: 'try { transaction(() => { data.push(4); throw new Error("abort"); }); } catch {} return data;',
    hints: ['Transaction restores on error', 'Data is rolled back'],
    tags: ['error', 'transaction', 'rollback'],
  },
  {
    id: 'js-error-087',
    category: 'Control Flow',
    difficulty: 'hard',
    title: 'Complex Default Chain',
    text: 'Chain multiple defaults with different operators.',
    setup: 'const a = undefined; const b = null; const c = ""; const d = "value";',
    setupCode: 'const a = undefined; const b = null; const c = ""; const d = "value";',
    expected: '',
    sample: 'a ?? b ?? c ?? d',
    hints: ['?? stops at empty string', 'Empty string is not nullish'],
    tags: ['nullish-coalescing', 'chaining', 'falsy'],
  },
  {
    id: 'js-error-088',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Error Context Builder',
    text: 'Build error with rich context information.',
    setup: 'class ContextError extends Error { constructor(msg, context = {}) { super(msg); this.context = context; this.name = "ContextError"; } addContext(key, value) { this.context[key] = value; return this; } }',
    setupCode: 'class ContextError extends Error { constructor(msg, context = {}) { super(msg); this.context = context; this.name = "ContextError"; } addContext(key, value) { this.context[key] = value; return this; } }',
    expected: { userId: 123, action: 'save' },
    sample: 'const e = new ContextError("Failed").addContext("userId", 123).addContext("action", "save"); return e.context;',
    hints: ['Chain addContext calls', 'Return the context object'],
    tags: ['error', 'context', 'builder'],
  },
  {
    id: 'js-error-089',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Deferred Error Handling',
    text: 'Collect operations and handle all errors at once.',
    setup: 'const operations = [() => 1, () => { throw new Error("fail"); }, () => 3];',
    setupCode: 'const operations = [() => 1, () => { throw new Error("fail"); }, () => 3];',
    expected: { results: [1, 3], errors: ['fail'] },
    sample: 'const results = [], errors = []; operations.forEach(op => { try { results.push(op()); } catch (e) { errors.push(e.message); } }); return { results, errors };',
    hints: ['Try each operation', 'Separate successes from failures'],
    tags: ['error', 'deferred', 'batch'],
  },
  {
    id: 'js-error-090',
    category: 'Control Flow',
    difficulty: 'hard',
    title: 'Optional Chaining with Side Effects',
    text: 'Conditionally call function only if object exists.',
    setup: 'let called = false; const obj = { notify: () => { called = true; } };',
    setupCode: 'let called = false; const obj = { notify: () => { called = true; } };',
    expected: true,
    sample: 'obj?.notify?.(); return called;',
    hints: ['Use ?.() for safe call', 'Check if called was set'],
    tags: ['optional-chaining', 'side-effects', 'functions'],
  },
  {
    id: 'js-error-091',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Error Rate Limiter',
    text: 'Track error count and throw if too many errors.',
    setup: 'const errorTracker = { count: 0, limit: 3, track() { this.count++; if (this.count > this.limit) throw new Error("Too many errors"); } };',
    setupCode: 'const errorTracker = { count: 0, limit: 3, track() { this.count++; if (this.count > this.limit) throw new Error("Too many errors"); } };',
    expected: 'Too many errors',
    sample: 'try { for (let i = 0; i < 5; i++) errorTracker.track(); } catch (e) { return e.message; }',
    hints: ['Track exceeds limit', 'Throws on 4th error'],
    tags: ['error', 'rate-limiting', 'tracking'],
  },
  {
    id: 'js-error-092',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Async Finally Cleanup',
    text: 'Ensure cleanup runs even with async errors.',
    setup: 'let cleaned = false; async function work() { throw new Error("async fail"); }',
    setupCode: 'let cleaned = false; async function work() { throw new Error("async fail"); }',
    expected: true,
    sample: 'return work().catch(() => {}).finally(() => { cleaned = true; }).then(() => cleaned);',
    hints: ['finally runs after catch', 'Set cleaned in finally'],
    tags: ['error', 'async', 'finally'],
  },
  {
    id: 'js-error-093',
    category: 'Control Flow',
    difficulty: 'hard',
    title: 'Safe Map Operation',
    text: 'Map over array, replacing errors with null.',
    setup: 'const items = [1, 2, 3]; function process(x) { if (x === 2) throw new Error("bad"); return x * 10; }',
    setupCode: 'const items = [1, 2, 3]; function process(x) { if (x === 2) throw new Error("bad"); return x * 10; }',
    expected: [10, null, 30],
    sample: 'items.map(x => { try { return process(x); } catch { return null; } })',
    hints: ['Wrap each map call in try', 'Return null on error'],
    tags: ['error', 'map', 'defensive'],
  },
  {
    id: 'js-error-094',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Error Retry with Backoff',
    text: 'Simulate retry with increasing delay tracking.',
    setup: 'let delays = []; let attempt = 0; function flaky() { attempt++; delays.push(attempt * 100); if (attempt < 3) throw new Error("retry"); return "done"; }',
    setupCode: 'let delays = []; let attempt = 0; function flaky() { attempt++; delays.push(attempt * 100); if (attempt < 3) throw new Error("retry"); return "done"; }',
    expected: { result: 'done', delays: [100, 200, 300] },
    sample: 'let result; while (!result) { try { result = flaky(); } catch {} } return { result, delays };',
    hints: ['Loop until success', 'delays tracks attempts'],
    tags: ['error', 'retry', 'backoff'],
  },
  {
    id: 'js-error-095',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Cross-Cutting Error Handler',
    text: 'Wrap function to catch and transform all errors.',
    setup: 'function withErrorHandler(fn, handler) { return (...args) => { try { return fn(...args); } catch (e) { return handler(e); } }; }',
    setupCode: 'function withErrorHandler(fn, handler) { return (...args) => { try { return fn(...args); } catch (e) { return handler(e); } }; }',
    expected: 'Error: test error',
    sample: 'const risky = () => { throw new Error("test error"); }; const safe = withErrorHandler(risky, e => "Error: " + e.message); return safe();',
    hints: ['Use wrapper function', 'Handler transforms error'],
    tags: ['error', 'wrapper', 'higher-order'],
  },
  {
    id: 'js-error-096',
    category: 'Control Flow',
    difficulty: 'hard',
    title: 'Optional Chaining Assignment',
    text: 'Check if assignment target exists before assigning.',
    setup: 'const obj = { data: { items: [] } };',
    setupCode: 'const obj = { data: { items: [] } };',
    expected: { data: { items: [1] } },
    sample: 'obj.data?.items?.push(1); return obj;',
    hints: ['Use ?. before method call', 'push modifies array'],
    tags: ['optional-chaining', 'mutation', 'arrays'],
  },
  {
    id: 'js-error-097',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Error Event Emitter Pattern',
    text: 'Emit error events and collect them.',
    setup: 'const emitter = { handlers: [], on(h) { this.handlers.push(h); }, emit(e) { this.handlers.forEach(h => h(e)); } };',
    setupCode: 'const emitter = { handlers: [], on(h) { this.handlers.push(h); }, emit(e) { this.handlers.forEach(h => h(e)); } };',
    expected: ['Error: e1', 'Error: e2'],
    sample: 'const errors = []; emitter.on(e => errors.push("Error: " + e)); emitter.emit("e1"); emitter.emit("e2"); return errors;',
    hints: ['Register handler first', 'Emit multiple errors'],
    tags: ['error', 'events', 'patterns'],
  },
  {
    id: 'js-error-098',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Validation Schema Error',
    text: 'Validate object against schema, collect all errors.',
    setup: 'const schema = { name: v => v ? null : "Name required", age: v => v > 0 ? null : "Age must be positive" };',
    setupCode: 'const schema = { name: v => v ? null : "Name required", age: v => v > 0 ? null : "Age must be positive" };',
    expected: ['Name required', 'Age must be positive'],
    sample: 'const obj = { name: "", age: -5 }; return Object.entries(schema).map(([k, v]) => v(obj[k])).filter(Boolean);',
    hints: ['Run each validator', 'Filter out nulls'],
    tags: ['error', 'validation', 'schema'],
  },
  {
    id: 'js-error-099',
    category: 'Control Flow',
    difficulty: 'hard',
    title: 'Defensive Object Access',
    text: 'Safely access nested object with multiple fallbacks.',
    setup: 'const response = { status: 200 };',
    setupCode: 'const response = { status: 200 };',
    expected: 'Unknown',
    sample: 'response?.data?.user?.name ?? response?.error?.message ?? "Unknown"',
    hints: ['Chain multiple optional paths', 'Use ?? for final default'],
    tags: ['optional-chaining', 'fallback', 'defensive'],
  },
  {
    id: 'js-error-100',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Circuit Breaker Pattern',
    text: 'Implement simple circuit breaker that opens after failures.',
    setup: 'const breaker = { failures: 0, open: false, call(fn) { if (this.open) throw new Error("Circuit open"); try { return fn(); } catch (e) { this.failures++; if (this.failures >= 2) this.open = true; throw e; } } };',
    setupCode: 'const breaker = { failures: 0, open: false, call(fn) { if (this.open) throw new Error("Circuit open"); try { return fn(); } catch (e) { this.failures++; if (this.failures >= 2) this.open = true; throw e; } } };',
    expected: 'Circuit open',
    sample: 'const fail = () => { throw new Error("fail"); }; try { breaker.call(fail); } catch {} try { breaker.call(fail); } catch {} try { breaker.call(fail); } catch (e) { return e.message; }',
    hints: ['First two failures count', 'Third call circuit is open'],
    tags: ['error', 'circuit-breaker', 'patterns'],
  },
  {
    id: 'js-error-101',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Error Boundary Simulation',
    text: 'Create an error boundary that catches and reports errors.',
    setup: 'const boundary = { errors: [], wrap(fn) { return (...args) => { try { return { success: true, data: fn(...args) }; } catch (e) { this.errors.push(e.message); return { success: false, error: e.message }; } }; } };',
    setupCode: 'const boundary = { errors: [], wrap(fn) { return (...args) => { try { return { success: true, data: fn(...args) }; } catch (e) { this.errors.push(e.message); return { success: false, error: e.message }; } }; } };',
    expected: { result: { success: false, error: 'boom' }, tracked: ['boom'] },
    sample: 'const risky = () => { throw new Error("boom"); }; const safe = boundary.wrap(risky); const result = safe(); return { result, tracked: boundary.errors };',
    hints: ['Use wrapped function', 'Check both result and tracked'],
    tags: ['error', 'boundary', 'patterns'],
  },
  {
    id: 'js-error-102',
    category: 'Control Flow',
    difficulty: 'hard',
    title: 'Type Coercion Guard',
    text: 'Guard against type coercion issues with strict checks.',
    setup: 'function strictEquals(a, b) { if (typeof a !== typeof b) throw new TypeError("Type mismatch"); return a === b; }',
    setupCode: 'function strictEquals(a, b) { if (typeof a !== typeof b) throw new TypeError("Type mismatch"); return a === b; }',
    expected: 'Type mismatch',
    sample: 'try { strictEquals(1, "1"); } catch (e) { return e.message; }',
    hints: ['Different types throw', 'Number vs string'],
    tags: ['error', 'type-guard', 'strict'],
  },
  {
    id: 'js-error-103',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Async Error Chain',
    text: 'Chain async operations, each handling previous errors.',
    setup: 'async function step1() { throw new Error("step1 failed"); } async function step2() { return "step2 ok"; }',
    setupCode: 'async function step1() { throw new Error("step1 failed"); } async function step2() { return "step2 ok"; }',
    expected: 'Recovered: step2 ok',
    sample: 'return step1().catch(() => step2()).then(r => "Recovered: " + r);',
    hints: ['Catch first, chain second', 'Recover in catch'],
    tags: ['error', 'async', 'chaining'],
  },
  {
    id: 'js-error-104',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Error Sanitization',
    text: 'Remove sensitive information from error before logging.',
    setup: 'function sanitizeError(e) { const safe = new Error(e.message.replace(/password=\\w+/, "password=***")); safe.name = e.name; return safe; }',
    setupCode: 'function sanitizeError(e) { const safe = new Error(e.message.replace(/password=\\w+/, "password=***")); safe.name = e.name; return safe; }',
    expected: 'Failed with password=***',
    sample: 'const original = new Error("Failed with password=secret123"); return sanitizeError(original).message;',
    hints: ['Password is redacted', 'Message is sanitized'],
    tags: ['error', 'security', 'sanitization'],
  },
  {
    id: 'js-error-105',
    category: 'Control Flow',
    difficulty: 'hard',
    title: 'Safe Reduce Operation',
    text: 'Reduce array, skipping elements that throw.',
    setup: 'const items = [1, 2, 3, 4]; function addSafe(acc, x) { if (x === 3) throw new Error("skip"); return acc + x; }',
    setupCode: 'const items = [1, 2, 3, 4]; function addSafe(acc, x) { if (x === 3) throw new Error("skip"); return acc + x; }',
    expected: 7,
    sample: 'items.reduce((acc, x) => { try { return addSafe(acc, x); } catch { return acc; } }, 0)',
    hints: ['Wrap reduce callback', 'Return accumulator on error'],
    tags: ['error', 'reduce', 'defensive'],
  },
  {
    id: 'js-error-106',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Promise Race Error',
    text: 'Handle first rejection in Promise.race.',
    setup: 'const slow = new Promise(r => setTimeout(() => r("slow"), 100)); const fast = Promise.reject(new Error("fast error"));',
    setupCode: 'const slow = new Promise(r => setTimeout(() => r("slow"), 100)); const fast = Promise.reject(new Error("fast error"));',
    expected: 'fast error',
    sample: 'return Promise.race([slow, fast]).catch(e => e.message);',
    hints: ['Rejection wins the race', 'Catch handles rejection'],
    tags: ['error', 'promise-race', 'async'],
  },
  {
    id: 'js-error-107',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'WeakRef Error Pattern',
    text: 'Handle case when WeakRef target is garbage collected.',
    setup: 'function getSafe(ref) { const obj = ref.deref(); if (!obj) throw new Error("Object collected"); return obj; }',
    setupCode: 'function getSafe(ref) { const obj = ref.deref(); if (!obj) throw new Error("Object collected"); return obj; }',
    expected: { name: 'test' },
    sample: 'const obj = { name: "test" }; const ref = new WeakRef(obj); return getSafe(ref);',
    hints: ['Object still exists', 'deref returns object'],
    tags: ['error', 'weakref', 'memory'],
  },
  {
    id: 'js-error-108',
    category: 'Control Flow',
    difficulty: 'hard',
    title: 'Abort Controller Error',
    text: 'Use AbortController to simulate cancellation error.',
    setup: 'const controller = new AbortController();',
    setupCode: 'const controller = new AbortController();',
    expected: 'AbortError',
    sample: 'controller.abort(); try { if (controller.signal.aborted) throw new DOMException("Aborted", "AbortError"); } catch (e) { return e.name; }',
    hints: ['Check signal.aborted', 'Throw DOMException'],
    tags: ['error', 'abort', 'cancellation'],
  },
  {
    id: 'js-error-109',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Error Stack Manipulation',
    text: 'Capture and modify error stack trace.',
    setup: 'function captureStack() { const e = new Error("test"); return e.stack.split("\\n").length > 1; }',
    setupCode: 'function captureStack() { const e = new Error("test"); return e.stack.split("\\n").length > 1; }',
    expected: true,
    sample: 'captureStack()',
    hints: ['Stack has multiple lines', 'Each line is a frame'],
    tags: ['error', 'stack', 'debugging'],
  },
  {
    id: 'js-error-110',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Async Generator Error',
    text: 'Handle error in async generator.',
    setup: 'async function* asyncGen() { yield 1; throw new Error("async gen error"); }',
    setupCode: 'async function* asyncGen() { yield 1; throw new Error("async gen error"); }',
    expected: 'async gen error',
    sample: 'const gen = asyncGen(); return gen.next().then(() => gen.next()).catch(e => e.message);',
    hints: ['First next resolves', 'Second next rejects'],
    tags: ['error', 'async-generator', 'iteration'],
  },
  // ========================================
  // FUNCTIONAL PROGRAMMING
  // ========================================
  {
    id: 'js-functional-001',
    category: 'Functional Programming',
    difficulty: 'easy',
    title: 'Pure Function - Double',
    text: 'Create a pure function that doubles a number without side effects.',
    setup: 'const num = 5;',
    setupCode: 'const num = 5;',
    expected: 10,
    sample: 'const double = x => x * 2; double(num)',
    hints: ['Pure functions always return the same output for same input', 'No external state modification'],
    tags: ['functional', 'pure-function', 'basics'],
  },
  {
    id: 'js-functional-002',
    category: 'Functional Programming',
    difficulty: 'easy',
    title: 'Immutable Array Update',
    text: 'Add an element to the array without mutating the original.',
    setup: 'const arr = [1, 2, 3];',
    setupCode: 'const arr = [1, 2, 3];',
    expected: [1, 2, 3, 4],
    sample: '[...arr, 4]',
    hints: ['Use spread operator', 'Create a new array'],
    tags: ['functional', 'immutability', 'spread'],
  },
  {
    id: 'js-functional-003',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'Simple Map Transformation',
    text: 'Use map to square each number in the array.',
    setup: 'const nums = [1, 2, 3, 4];',
    setupCode: 'const nums = [1, 2, 3, 4];',
    expected: [1, 4, 9, 16],
    sample: 'nums.map(x => x * x)',
    hints: ['map transforms each element', 'Return the squared value'],
    tags: ['functional', 'map', 'higher-order'],
  },
  {
    id: 'js-functional-004',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'Filter with Predicate',
    text: 'Filter numbers greater than 5 using a predicate function.',
    setup: 'const nums = [2, 7, 3, 9, 1, 8];',
    setupCode: 'const nums = [2, 7, 3, 9, 1, 8];',
    expected: [7, 9, 8],
    sample: 'const greaterThan5 = x => x > 5; nums.filter(greaterThan5)',
    hints: ['Define the predicate separately', 'Pass function reference to filter'],
    tags: ['functional', 'filter', 'predicate'],
  },
  {
    id: 'js-functional-005',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'Reduce to Sum',
    text: 'Use reduce to calculate the sum of all numbers.',
    setup: 'const nums = [1, 2, 3, 4, 5];',
    setupCode: 'const nums = [1, 2, 3, 4, 5];',
    expected: 15,
    sample: 'nums.reduce((acc, x) => acc + x, 0)',
    hints: ['reduce accumulates a single value', 'Start with initial value 0'],
    tags: ['functional', 'reduce', 'accumulator'],
  },
  {
    id: 'js-functional-006',
    category: 'Functional Programming',
    difficulty: 'easy',
    title: 'Identity Function',
    text: 'Create an identity function that returns its input unchanged.',
    setup: 'const value = "hello";',
    setupCode: 'const value = "hello";',
    expected: 'hello',
    sample: 'const identity = x => x; identity(value)',
    hints: ['Return exactly what you receive', 'Simplest pure function'],
    tags: ['functional', 'identity', 'basics'],
  },
  {
    id: 'js-functional-007',
    category: 'Functional Programming',
    difficulty: 'easy',
    title: 'Constant Function',
    text: 'Create a function that always returns the same value regardless of input.',
    setup: 'const inputs = [1, 2, 3];',
    setupCode: 'const inputs = [1, 2, 3];',
    expected: [42, 42, 42],
    sample: 'const always = x => () => x; inputs.map(always(42))',
    hints: ['Return a function that ignores its argument', 'Closure captures the constant'],
    tags: ['functional', 'constant', 'closure'],
  },
  {
    id: 'js-functional-008',
    category: 'Closures',
    difficulty: 'easy',
    title: 'Simple Counter Closure',
    text: 'Create a counter using closures that increments each time called.',
    setup: 'let result = [];',
    setupCode: 'let result = [];',
    expected: [1, 2, 3],
    sample: 'const makeCounter = () => { let count = 0; return () => ++count; }; const counter = makeCounter(); result = [counter(), counter(), counter()]',
    hints: ['Inner function captures outer variable', 'Each call modifies the closed-over variable'],
    tags: ['functional', 'closure', 'counter'],
  },
  {
    id: 'js-functional-009',
    category: 'Functional Programming',
    difficulty: 'easy',
    title: 'Negate Function',
    text: 'Create a function that negates a boolean predicate.',
    setup: 'const isEven = x => x % 2 === 0; const nums = [1, 2, 3, 4];',
    setupCode: 'const isEven = x => x % 2 === 0; const nums = [1, 2, 3, 4];',
    expected: [1, 3],
    sample: 'const negate = fn => x => !fn(x); nums.filter(negate(isEven))',
    hints: ['Return a new function that negates result', 'Apply the original function and negate'],
    tags: ['functional', 'negate', 'predicate'],
  },
  {
    id: 'js-functional-010',
    category: 'Functional Programming',
    difficulty: 'easy',
    title: 'Immutable Object Update',
    text: 'Update the age property without mutating the original object.',
    setup: 'const person = { name: "Alice", age: 25 };',
    setupCode: 'const person = { name: "Alice", age: 25 };',
    expected: { name: 'Alice', age: 26 },
    sample: '({ ...person, age: person.age + 1 })',
    hints: ['Spread the original object', 'Override the specific property'],
    tags: ['functional', 'immutability', 'object'],
  },
  {
    id: 'js-functional-011',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'Every Check',
    text: 'Check if every number in the array is positive.',
    setup: 'const nums = [1, 2, 3, 4, 5];',
    setupCode: 'const nums = [1, 2, 3, 4, 5];',
    expected: true,
    sample: 'nums.every(x => x > 0)',
    hints: ['every returns true if all elements pass', 'Short-circuits on first false'],
    tags: ['functional', 'every', 'predicate'],
  },
  {
    id: 'js-functional-012',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'Some Check',
    text: 'Check if at least one number is greater than 10.',
    setup: 'const nums = [3, 7, 12, 5];',
    setupCode: 'const nums = [3, 7, 12, 5];',
    expected: true,
    sample: 'nums.some(x => x > 10)',
    hints: ['some returns true if any element passes', 'Short-circuits on first true'],
    tags: ['functional', 'some', 'predicate'],
  },
  {
    id: 'js-functional-013',
    category: 'Functional Programming',
    difficulty: 'easy',
    title: 'Apply Function to Array',
    text: 'Apply Math.max to an array using spread.',
    setup: 'const nums = [3, 7, 2, 9, 4];',
    setupCode: 'const nums = [3, 7, 2, 9, 4];',
    expected: 9,
    sample: 'Math.max(...nums)',
    hints: ['Spread converts array to arguments', 'Math.max takes multiple arguments'],
    tags: ['functional', 'apply', 'spread'],
  },
  {
    id: 'js-functional-014',
    category: 'Functional Programming',
    difficulty: 'easy',
    title: 'First Element Extractor',
    text: 'Create a function that extracts the first element of an array.',
    setup: 'const arr = [5, 10, 15];',
    setupCode: 'const arr = [5, 10, 15];',
    expected: 5,
    sample: 'const head = ([first]) => first; head(arr)',
    hints: ['Use destructuring in parameter', 'Return just the first element'],
    tags: ['functional', 'destructuring', 'head'],
  },
  {
    id: 'js-functional-015',
    category: 'Functional Programming',
    difficulty: 'easy',
    title: 'Tail of Array',
    text: 'Create a function that returns all elements except the first.',
    setup: 'const arr = [1, 2, 3, 4];',
    setupCode: 'const arr = [1, 2, 3, 4];',
    expected: [2, 3, 4],
    sample: 'const tail = ([, ...rest]) => rest; tail(arr)',
    hints: ['Use rest parameter in destructuring', 'Skip the first element'],
    tags: ['functional', 'destructuring', 'tail'],
  },
  {
    id: 'js-functional-016',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'Find First Match',
    text: 'Find the first number greater than 5.',
    setup: 'const nums = [2, 4, 6, 8, 10];',
    setupCode: 'const nums = [2, 4, 6, 8, 10];',
    expected: 6,
    sample: 'nums.find(x => x > 5)',
    hints: ['find returns first matching element', 'Returns undefined if none found'],
    tags: ['functional', 'find', 'search'],
  },
  {
    id: 'js-functional-017',
    category: 'Functional Programming',
    difficulty: 'easy',
    title: 'Flatten One Level',
    text: 'Flatten a nested array by one level.',
    setup: 'const nested = [[1, 2], [3, 4], [5]];',
    setupCode: 'const nested = [[1, 2], [3, 4], [5]];',
    expected: [1, 2, 3, 4, 5],
    sample: 'nested.flat()',
    hints: ['flat() flattens one level by default', 'Can also use flatMap or reduce'],
    tags: ['functional', 'flat', 'array'],
  },
  {
    id: 'js-functional-018',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'FlatMap Basic',
    text: 'Use flatMap to duplicate each number.',
    setup: 'const nums = [1, 2, 3];',
    setupCode: 'const nums = [1, 2, 3];',
    expected: [1, 1, 2, 2, 3, 3],
    sample: 'nums.flatMap(x => [x, x])',
    hints: ['flatMap maps then flattens', 'Return an array from the callback'],
    tags: ['functional', 'flatMap', 'array'],
  },
  {
    id: 'js-functional-019',
    category: 'Functional Programming',
    difficulty: 'easy',
    title: 'Last Element',
    text: 'Get the last element of an array functionally.',
    setup: 'const arr = [1, 2, 3, 4, 5];',
    setupCode: 'const arr = [1, 2, 3, 4, 5];',
    expected: 5,
    sample: 'arr.at(-1)',
    hints: ['at() accepts negative indices', 'Or use slice(-1)[0]'],
    tags: ['functional', 'at', 'array'],
  },
  {
    id: 'js-functional-020',
    category: 'Functional Programming',
    difficulty: 'easy',
    title: 'Reverse Immutably',
    text: 'Reverse an array without mutating the original.',
    setup: 'const arr = [1, 2, 3];',
    setupCode: 'const arr = [1, 2, 3];',
    expected: [3, 2, 1],
    sample: '[...arr].reverse()',
    hints: ['Copy first with spread', 'Then apply reverse'],
    tags: ['functional', 'immutability', 'reverse'],
  },
  {
    id: 'js-functional-021',
    category: 'Closures',
    difficulty: 'medium',
    title: 'Private State with Closure',
    text: 'Create a bank account with private balance using closure.',
    setup: 'let result;',
    setupCode: 'let result;',
    expected: { balance: 150, canWithdraw: true },
    sample: 'const createAccount = (initial) => { let balance = initial; return { deposit: amt => balance += amt, withdraw: amt => balance -= amt, getBalance: () => balance }; }; const acc = createAccount(100); acc.deposit(100); acc.withdraw(50); result = { balance: acc.getBalance(), canWithdraw: acc.getBalance() > 0 }',
    hints: ['Closure hides the balance variable', 'Return object with methods to access it'],
    tags: ['functional', 'closure', 'encapsulation'],
  },
  {
    id: 'js-functional-022',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Custom Map Implementation',
    text: 'Implement your own map function using reduce.',
    setup: 'const nums = [1, 2, 3];',
    setupCode: 'const nums = [1, 2, 3];',
    expected: [2, 4, 6],
    sample: 'const myMap = (arr, fn) => arr.reduce((acc, x) => [...acc, fn(x)], []); myMap(nums, x => x * 2)',
    hints: ['reduce can build any data structure', 'Accumulate transformed elements'],
    tags: ['functional', 'map', 'reduce', 'implementation'],
  },
  {
    id: 'js-functional-023',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Custom Filter Implementation',
    text: 'Implement your own filter function using reduce.',
    setup: 'const nums = [1, 2, 3, 4, 5, 6];',
    setupCode: 'const nums = [1, 2, 3, 4, 5, 6];',
    expected: [2, 4, 6],
    sample: 'const myFilter = (arr, pred) => arr.reduce((acc, x) => pred(x) ? [...acc, x] : acc, []); myFilter(nums, x => x % 2 === 0)',
    hints: ['Only add element if predicate is true', 'Use ternary in reduce'],
    tags: ['functional', 'filter', 'reduce', 'implementation'],
  },
  {
    id: 'js-functional-024',
    category: 'Functional Programming',
    difficulty: 'medium',
    title: 'Simple Compose',
    text: 'Compose two functions: add 1, then multiply by 2.',
    setup: 'const add1 = x => x + 1; const mult2 = x => x * 2; const num = 5;',
    setupCode: 'const add1 = x => x + 1; const mult2 = x => x * 2; const num = 5;',
    expected: 12,
    sample: 'const compose = (f, g) => x => f(g(x)); compose(mult2, add1)(num)',
    hints: ['compose applies right to left', 'g runs first, then f'],
    tags: ['functional', 'compose', 'composition'],
  },
  {
    id: 'js-functional-025',
    category: 'Functional Programming',
    difficulty: 'medium',
    title: 'Simple Pipe',
    text: 'Pipe two functions: multiply by 2, then add 1.',
    setup: 'const add1 = x => x + 1; const mult2 = x => x * 2; const num = 5;',
    setupCode: 'const add1 = x => x + 1; const mult2 = x => x * 2; const num = 5;',
    expected: 11,
    sample: 'const pipe = (f, g) => x => g(f(x)); pipe(mult2, add1)(num)',
    hints: ['pipe applies left to right', 'f runs first, then g'],
    tags: ['functional', 'pipe', 'composition'],
  },
  {
    id: 'js-functional-026',
    category: 'Functional Programming',
    difficulty: 'medium',
    title: 'Curried Add',
    text: 'Create a curried add function.',
    setup: 'const result = [];',
    setupCode: 'const result = [];',
    expected: [5, 7, 10],
    sample: 'const add = a => b => a + b; const add3 = add(3); result.push(add3(2), add3(4), add(5)(5))',
    hints: ['Return a function that takes second arg', 'Partial application creates specialized functions'],
    tags: ['functional', 'currying', 'partial-application'],
  },
  {
    id: 'js-functional-027',
    category: 'Functional Programming',
    difficulty: 'medium',
    title: 'Curried Multiply',
    text: 'Create a curried multiply function and use it with map.',
    setup: 'const nums = [1, 2, 3, 4];',
    setupCode: 'const nums = [1, 2, 3, 4];',
    expected: [3, 6, 9, 12],
    sample: 'const multiply = a => b => a * b; nums.map(multiply(3))',
    hints: ['multiply(3) returns a function', 'That function multiplies its arg by 3'],
    tags: ['functional', 'currying', 'map'],
  },
  {
    id: 'js-functional-028',
    category: 'Closures',
    difficulty: 'medium',
    title: 'Function Factory',
    text: 'Create a function that generates greeting functions.',
    setup: 'let greetings;',
    setupCode: 'let greetings;',
    expected: ['Hello, World!', 'Hi, World!', 'Hello, Alice!'],
    sample: 'const makeGreeter = greeting => name => `${greeting}, ${name}!`; const sayHello = makeGreeter("Hello"); const sayHi = makeGreeter("Hi"); greetings = [sayHello("World"), sayHi("World"), sayHello("Alice")]',
    hints: ['Outer function captures greeting', 'Inner function uses both variables'],
    tags: ['functional', 'closure', 'factory'],
  },
  {
    id: 'js-functional-029',
    category: 'Functional Programming',
    difficulty: 'medium',
    title: 'Partial Application',
    text: 'Implement a partial application helper.',
    setup: 'const add3 = (a, b, c) => a + b + c;',
    setupCode: 'const add3 = (a, b, c) => a + b + c;',
    expected: 15,
    sample: 'const partial = (fn, ...args) => (...more) => fn(...args, ...more); partial(add3, 5, 5)(5)',
    hints: ['Capture initial arguments', 'Combine with later arguments'],
    tags: ['functional', 'partial-application', 'spread'],
  },
  {
    id: 'js-functional-030',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Reduce to Object',
    text: 'Convert an array of pairs to an object using reduce.',
    setup: 'const pairs = [["a", 1], ["b", 2], ["c", 3]];',
    setupCode: 'const pairs = [["a", 1], ["b", 2], ["c", 3]];',
    expected: { a: 1, b: 2, c: 3 },
    sample: 'pairs.reduce((obj, [k, v]) => ({ ...obj, [k]: v }), {})',
    hints: ['Destructure each pair', 'Spread accumulator and add new key'],
    tags: ['functional', 'reduce', 'object'],
  },
  {
    id: 'js-functional-031',
    category: 'Functional Programming',
    difficulty: 'medium',
    title: 'Memoize Simple',
    text: 'Create a simple memoization function for single-argument functions.',
    setup: 'let callCount = 0; const expensive = x => { callCount++; return x * 2; };',
    setupCode: 'let callCount = 0; const expensive = x => { callCount++; return x * 2; };',
    expected: { results: [10, 10, 20], calls: 2 },
    sample: 'const memoize = fn => { const cache = {}; return x => x in cache ? cache[x] : cache[x] = fn(x); }; const memoized = memoize(expensive); const results = [memoized(5), memoized(5), memoized(10)]; ({ results, calls: callCount })',
    hints: ['Store results in a cache object', 'Check cache before calling function'],
    tags: ['functional', 'memoization', 'cache'],
  },
  {
    id: 'js-functional-032',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Group By',
    text: 'Group array elements by the result of a function.',
    setup: 'const nums = [1, 2, 3, 4, 5, 6];',
    setupCode: 'const nums = [1, 2, 3, 4, 5, 6];',
    expected: { odd: [1, 3, 5], even: [2, 4, 6] },
    sample: 'nums.reduce((groups, n) => { const key = n % 2 === 0 ? "even" : "odd"; groups[key] = [...(groups[key] || []), n]; return groups; }, {})',
    hints: ['Determine group key for each element', 'Initialize group array if needed'],
    tags: ['functional', 'reduce', 'groupBy'],
  },
  {
    id: 'js-functional-033',
    category: 'Functional Programming',
    difficulty: 'medium',
    title: 'Flip Arguments',
    text: 'Create a function that flips the first two arguments of a function.',
    setup: 'const divide = (a, b) => a / b;',
    setupCode: 'const divide = (a, b) => a / b;',
    expected: 2,
    sample: 'const flip = fn => (a, b, ...rest) => fn(b, a, ...rest); flip(divide)(5, 10)',
    hints: ['Swap first two parameters', 'Pass rest unchanged'],
    tags: ['functional', 'flip', 'higher-order'],
  },
  {
    id: 'js-functional-034',
    category: 'Functional Programming',
    difficulty: 'medium',
    title: 'Once Function',
    text: 'Create a function that only runs once, returning cached result on subsequent calls.',
    setup: 'let counter = 0;',
    setupCode: 'let counter = 0;',
    expected: { results: [1, 1, 1], counter: 1 },
    sample: 'const once = fn => { let called = false, result; return (...args) => called ? result : (called = true, result = fn(...args)); }; const increment = once(() => ++counter); const results = [increment(), increment(), increment()]; ({ results, counter })',
    hints: ['Track if function was called', 'Cache and return the result'],
    tags: ['functional', 'once', 'closure'],
  },
  {
    id: 'js-functional-035',
    category: 'Functional Programming',
    difficulty: 'medium',
    title: 'Tap Function',
    text: 'Create a tap function for side effects in a pipeline.',
    setup: 'let logged = []; const nums = [1, 2, 3];',
    setupCode: 'let logged = []; const nums = [1, 2, 3];',
    expected: { result: [2, 4, 6], logged: [2, 4, 6] },
    sample: 'const tap = fn => x => { fn(x); return x; }; const result = nums.map(x => x * 2).map(tap(x => logged.push(x))); ({ result, logged })',
    hints: ['Execute side effect', 'Return original value unchanged'],
    tags: ['functional', 'tap', 'side-effect'],
  },
  {
    id: 'js-functional-036',
    category: 'Recursion',
    difficulty: 'medium',
    title: 'Recursive Sum',
    text: 'Calculate sum of array using recursion.',
    setup: 'const nums = [1, 2, 3, 4, 5];',
    setupCode: 'const nums = [1, 2, 3, 4, 5];',
    expected: 15,
    sample: 'const sum = ([head, ...tail]) => head === undefined ? 0 : head + sum(tail); sum(nums)',
    hints: ['Base case: empty array returns 0', 'Recursive: head plus sum of tail'],
    tags: ['functional', 'recursion', 'sum'],
  },
  {
    id: 'js-functional-037',
    category: 'Recursion',
    difficulty: 'medium',
    title: 'Recursive Map',
    text: 'Implement map using recursion.',
    setup: 'const nums = [1, 2, 3];',
    setupCode: 'const nums = [1, 2, 3];',
    expected: [2, 4, 6],
    sample: 'const map = (fn, [head, ...tail]) => head === undefined ? [] : [fn(head), ...map(fn, tail)]; map(x => x * 2, nums)',
    hints: ['Transform head, recurse on tail', 'Base case returns empty array'],
    tags: ['functional', 'recursion', 'map'],
  },
  {
    id: 'js-functional-038',
    category: 'Recursion',
    difficulty: 'medium',
    title: 'Recursive Filter',
    text: 'Implement filter using recursion.',
    setup: 'const nums = [1, 2, 3, 4, 5, 6];',
    setupCode: 'const nums = [1, 2, 3, 4, 5, 6];',
    expected: [2, 4, 6],
    sample: 'const filter = (pred, [head, ...tail]) => head === undefined ? [] : pred(head) ? [head, ...filter(pred, tail)] : filter(pred, tail); filter(x => x % 2 === 0, nums)',
    hints: ['Include head only if predicate passes', 'Always recurse on tail'],
    tags: ['functional', 'recursion', 'filter'],
  },
  {
    id: 'js-functional-039',
    category: 'Functional Programming',
    difficulty: 'medium',
    title: 'Zip Arrays',
    text: 'Combine two arrays element-wise into pairs.',
    setup: 'const a = [1, 2, 3]; const b = ["a", "b", "c"];',
    setupCode: 'const a = [1, 2, 3]; const b = ["a", "b", "c"];',
    expected: [[1, 'a'], [2, 'b'], [3, 'c']],
    sample: 'a.map((x, i) => [x, b[i]])',
    hints: ['Use index to access corresponding element', 'Map creates the pairs'],
    tags: ['functional', 'zip', 'array'],
  },
  {
    id: 'js-functional-040',
    category: 'Functional Programming',
    difficulty: 'medium',
    title: 'Unzip Pairs',
    text: 'Split an array of pairs into two separate arrays.',
    setup: 'const pairs = [[1, "a"], [2, "b"], [3, "c"]];',
    setupCode: 'const pairs = [[1, "a"], [2, "b"], [3, "c"]];',
    expected: [[1, 2, 3], ['a', 'b', 'c']],
    sample: 'pairs.reduce((acc, [a, b]) => [[...acc[0], a], [...acc[1], b]], [[], []])',
    hints: ['Accumulate into two arrays', 'Destructure each pair'],
    tags: ['functional', 'unzip', 'reduce'],
  },
  {
    id: 'js-functional-041',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Partition Array',
    text: 'Split array into two based on predicate - passing and failing.',
    setup: 'const nums = [1, 2, 3, 4, 5, 6];',
    setupCode: 'const nums = [1, 2, 3, 4, 5, 6];',
    expected: [[2, 4, 6], [1, 3, 5]],
    sample: 'const partition = (pred, arr) => arr.reduce(([pass, fail], x) => pred(x) ? [[...pass, x], fail] : [pass, [...fail, x]], [[], []]); partition(x => x % 2 === 0, nums)',
    hints: ['Track two arrays in accumulator', 'Add to appropriate array based on predicate'],
    tags: ['functional', 'partition', 'reduce'],
  },
  {
    id: 'js-functional-042',
    category: 'Functional Programming',
    difficulty: 'medium',
    title: 'Pipe Multiple Functions',
    text: 'Create a pipe function that composes multiple functions left-to-right.',
    setup: 'const add1 = x => x + 1; const mult2 = x => x * 2; const sub3 = x => x - 3;',
    setupCode: 'const add1 = x => x + 1; const mult2 = x => x * 2; const sub3 = x => x - 3;',
    expected: 9,
    sample: 'const pipe = (...fns) => x => fns.reduce((v, fn) => fn(v), x); pipe(add1, mult2, sub3)(5)',
    hints: ['reduce over functions', 'Each function transforms the value'],
    tags: ['functional', 'pipe', 'reduce'],
  },
  {
    id: 'js-functional-043',
    category: 'Functional Programming',
    difficulty: 'medium',
    title: 'Compose Multiple Functions',
    text: 'Create a compose function that composes multiple functions right-to-left.',
    setup: 'const add1 = x => x + 1; const mult2 = x => x * 2; const sub3 = x => x - 3;',
    setupCode: 'const add1 = x => x + 1; const mult2 = x => x * 2; const sub3 = x => x - 3;',
    expected: 5,
    sample: 'const compose = (...fns) => x => fns.reduceRight((v, fn) => fn(v), x); compose(add1, mult2, sub3)(5)',
    hints: ['reduceRight for right-to-left', 'Same as pipe but reversed'],
    tags: ['functional', 'compose', 'reduceRight'],
  },
  {
    id: 'js-functional-044',
    category: 'Functional Programming',
    difficulty: 'medium',
    title: 'Deep Clone Object',
    text: 'Create a deep clone without mutation using JSON methods.',
    setup: 'const obj = { a: 1, b: { c: 2 } };',
    setupCode: 'const obj = { a: 1, b: { c: 2 } };',
    expected: true,
    sample: 'const clone = JSON.parse(JSON.stringify(obj)); clone.b.c = 99; obj.b.c === 2',
    hints: ['JSON stringify then parse', 'Creates completely new object'],
    tags: ['functional', 'immutability', 'clone'],
  },
  {
    id: 'js-functional-045',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Take N Elements',
    text: 'Create a function that takes the first n elements.',
    setup: 'const nums = [1, 2, 3, 4, 5];',
    setupCode: 'const nums = [1, 2, 3, 4, 5];',
    expected: [1, 2, 3],
    sample: 'const take = n => arr => arr.slice(0, n); take(3)(nums)',
    hints: ['slice does not mutate', 'Curried for partial application'],
    tags: ['functional', 'take', 'slice'],
  },
  {
    id: 'js-functional-046',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Drop N Elements',
    text: 'Create a function that drops the first n elements.',
    setup: 'const nums = [1, 2, 3, 4, 5];',
    setupCode: 'const nums = [1, 2, 3, 4, 5];',
    expected: [4, 5],
    sample: 'const drop = n => arr => arr.slice(n); drop(3)(nums)',
    hints: ['slice from index n to end', 'Curried for composition'],
    tags: ['functional', 'drop', 'slice'],
  },
  {
    id: 'js-functional-047',
    category: 'Functional Programming',
    difficulty: 'medium',
    title: 'Prop Getter',
    text: 'Create a curried function to get a property from objects.',
    setup: 'const users = [{ name: "Alice" }, { name: "Bob" }];',
    setupCode: 'const users = [{ name: "Alice" }, { name: "Bob" }];',
    expected: ['Alice', 'Bob'],
    sample: 'const prop = key => obj => obj[key]; users.map(prop("name"))',
    hints: ['Return function that accesses the key', 'Perfect for mapping'],
    tags: ['functional', 'prop', 'currying'],
  },
  {
    id: 'js-functional-048',
    category: 'Functional Programming',
    difficulty: 'medium',
    title: 'Pluck Values',
    text: 'Extract a specific property from each object in array.',
    setup: 'const items = [{ id: 1, val: "a" }, { id: 2, val: "b" }];',
    setupCode: 'const items = [{ id: 1, val: "a" }, { id: 2, val: "b" }];',
    expected: [1, 2],
    sample: 'const pluck = key => arr => arr.map(obj => obj[key]); pluck("id")(items)',
    hints: ['Combine map with property access', 'Curried for reusability'],
    tags: ['functional', 'pluck', 'map'],
  },
  {
    id: 'js-functional-049',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Sort By Property',
    text: 'Create a curried sort function for object properties.',
    setup: 'const users = [{ name: "Charlie" }, { name: "Alice" }, { name: "Bob" }];',
    setupCode: 'const users = [{ name: "Charlie" }, { name: "Alice" }, { name: "Bob" }];',
    expected: [{ name: 'Alice' }, { name: 'Bob' }, { name: 'Charlie' }],
    sample: 'const sortBy = key => arr => [...arr].sort((a, b) => a[key] > b[key] ? 1 : -1); sortBy("name")(users)',
    hints: ['Copy array before sorting', 'Compare property values'],
    tags: ['functional', 'sort', 'immutability'],
  },
  {
    id: 'js-functional-050',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Find Index with Predicate',
    text: 'Find the index of first element matching a predicate.',
    setup: 'const nums = [1, 3, 5, 8, 9];',
    setupCode: 'const nums = [1, 3, 5, 8, 9];',
    expected: 3,
    sample: 'nums.findIndex(x => x % 2 === 0)',
    hints: ['findIndex returns index not element', 'Returns -1 if not found'],
    tags: ['functional', 'findIndex', 'predicate'],
  },
  {
    id: 'js-functional-051',
    category: 'Functional Programming',
    difficulty: 'medium',
    title: 'Range Generator',
    text: 'Create a function that generates a range of numbers.',
    setup: 'let range;',
    setupCode: 'let range;',
    expected: [0, 1, 2, 3, 4],
    sample: 'range = Array.from({ length: 5 }, (_, i) => i)',
    hints: ['Array.from takes a length', 'Map function receives index'],
    tags: ['functional', 'range', 'generator'],
  },
  {
    id: 'js-functional-052',
    category: 'Closures',
    difficulty: 'medium',
    title: 'Accumulator Closure',
    text: 'Create a function that accumulates values over multiple calls.',
    setup: 'let result;',
    setupCode: 'let result;',
    expected: [5, 15, 35],
    sample: 'const makeAccumulator = () => { let total = 0; return n => total += n; }; const acc = makeAccumulator(); result = [acc(5), acc(10), acc(20)]',
    hints: ['Closure maintains running total', 'Each call adds to total'],
    tags: ['functional', 'closure', 'accumulator'],
  },
  {
    id: 'js-functional-053',
    category: 'Functional Programming',
    difficulty: 'medium',
    title: 'Object From Entries',
    text: 'Convert key-value entries back to object functionally.',
    setup: 'const entries = [["x", 10], ["y", 20]];',
    setupCode: 'const entries = [["x", 10], ["y", 20]];',
    expected: { x: 10, y: 20 },
    sample: 'Object.fromEntries(entries)',
    hints: ['Inverse of Object.entries', 'Built-in functional method'],
    tags: ['functional', 'object', 'fromEntries'],
  },
  {
    id: 'js-functional-054',
    category: 'Functional Programming',
    difficulty: 'medium',
    title: 'Transform Object Values',
    text: 'Double all values in an object without mutation.',
    setup: 'const obj = { a: 1, b: 2, c: 3 };',
    setupCode: 'const obj = { a: 1, b: 2, c: 3 };',
    expected: { a: 2, b: 4, c: 6 },
    sample: 'Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, v * 2]))',
    hints: ['Convert to entries, transform, convert back', 'Entries are [key, value] pairs'],
    tags: ['functional', 'object', 'transformation'],
  },
  {
    id: 'js-functional-055',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Filter Object Keys',
    text: 'Keep only object keys that start with underscore.',
    setup: 'const obj = { _id: 1, name: "test", _type: "user" };',
    setupCode: 'const obj = { _id: 1, name: "test", _type: "user" };',
    expected: { _id: 1, _type: 'user' },
    sample: 'Object.fromEntries(Object.entries(obj).filter(([k]) => k.startsWith("_")))',
    hints: ['Filter entries by key', 'Destructure to get key only'],
    tags: ['functional', 'object', 'filter'],
  },
  {
    id: 'js-functional-056',
    category: 'Functional Programming',
    difficulty: 'hard',
    title: 'Generic Curry Function',
    text: 'Implement a curry function that works with any number of arguments.',
    setup: 'const add4 = (a, b, c, d) => a + b + c + d;',
    setupCode: 'const add4 = (a, b, c, d) => a + b + c + d;',
    expected: 10,
    sample: 'const curry = fn => { const arity = fn.length; return function curried(...args) { return args.length >= arity ? fn(...args) : (...more) => curried(...args, ...more); }; }; curry(add4)(1)(2)(3)(4)',
    hints: ['Check if enough arguments received', 'Recursively collect arguments'],
    tags: ['functional', 'currying', 'arity'],
  },
  {
    id: 'js-functional-057',
    category: 'Functional Programming',
    difficulty: 'hard',
    title: 'Uncurry Function',
    text: 'Convert a curried function back to regular multi-argument form.',
    setup: 'const curriedAdd = a => b => c => a + b + c;',
    setupCode: 'const curriedAdd = a => b => c => a + b + c;',
    expected: 6,
    sample: 'const uncurry = fn => (...args) => args.reduce((f, arg) => f(arg), fn); uncurry(curriedAdd)(1, 2, 3)',
    hints: ['Apply arguments one at a time', 'reduce over arguments'],
    tags: ['functional', 'uncurry', 'reduce'],
  },
  {
    id: 'js-functional-058',
    category: 'Functional Programming',
    difficulty: 'hard',
    title: 'Memoize with Multiple Arguments',
    text: 'Create a memoization function that handles multiple arguments.',
    setup: 'let calls = 0; const expensive = (a, b) => { calls++; return a + b; };',
    setupCode: 'let calls = 0; const expensive = (a, b) => { calls++; return a + b; };',
    expected: { results: [3, 3, 7], calls: 2 },
    sample: 'const memoize = fn => { const cache = new Map(); return (...args) => { const key = JSON.stringify(args); if (cache.has(key)) return cache.get(key); const result = fn(...args); cache.set(key, result); return result; }; }; const memo = memoize(expensive); const results = [memo(1, 2), memo(1, 2), memo(3, 4)]; ({ results, calls })',
    hints: ['Serialize arguments as cache key', 'Use Map for the cache'],
    tags: ['functional', 'memoization', 'map'],
  },
  {
    id: 'js-functional-059',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Debounce Function',
    text: 'Implement a debounce that delays function execution.',
    setup: 'let calls = [];',
    setupCode: 'let calls = [];',
    expected: true,
    sample: 'const debounce = (fn, delay) => { let timeout; return (...args) => { clearTimeout(timeout); timeout = setTimeout(() => fn(...args), delay); }; }; typeof debounce(() => {}, 100) === "function"',
    hints: ['Clear previous timeout', 'Set new timeout each call'],
    tags: ['functional', 'debounce', 'timing'],
  },
  {
    id: 'js-functional-060',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Throttle Function',
    text: 'Implement a throttle that limits function calls.',
    setup: 'let result;',
    setupCode: 'let result;',
    expected: true,
    sample: 'const throttle = (fn, limit) => { let waiting = false; return (...args) => { if (!waiting) { fn(...args); waiting = true; setTimeout(() => waiting = false, limit); } }; }; result = typeof throttle(() => {}, 100) === "function"',
    hints: ['Track if in waiting period', 'Reset flag after delay'],
    tags: ['functional', 'throttle', 'timing'],
  },
  {
    id: 'js-functional-061',
    category: 'Recursion',
    difficulty: 'hard',
    title: 'Deep Flatten Array',
    text: 'Flatten a deeply nested array using recursion.',
    setup: 'const nested = [1, [2, [3, [4, [5]]]]];',
    setupCode: 'const nested = [1, [2, [3, [4, [5]]]]];',
    expected: [1, 2, 3, 4, 5],
    sample: 'const deepFlatten = arr => arr.reduce((acc, val) => acc.concat(Array.isArray(val) ? deepFlatten(val) : val), []); deepFlatten(nested)',
    hints: ['Check if element is array', 'Recursively flatten nested arrays'],
    tags: ['functional', 'recursion', 'flatten'],
  },
  {
    id: 'js-functional-062',
    category: 'Recursion',
    difficulty: 'hard',
    title: 'Recursive Reduce',
    text: 'Implement reduce using recursion.',
    setup: 'const nums = [1, 2, 3, 4];',
    setupCode: 'const nums = [1, 2, 3, 4];',
    expected: 10,
    sample: 'const reduce = (fn, acc, [head, ...tail]) => head === undefined ? acc : reduce(fn, fn(acc, head), tail); reduce((a, b) => a + b, 0, nums)',
    hints: ['Apply function to accumulator and head', 'Pass new accumulator to recursive call'],
    tags: ['functional', 'recursion', 'reduce'],
  },
  {
    id: 'js-functional-063',
    category: 'Functional Programming',
    difficulty: 'hard',
    title: 'Transducer Map',
    text: 'Create a mapping transducer that composes with reduce.',
    setup: 'const nums = [1, 2, 3];',
    setupCode: 'const nums = [1, 2, 3];',
    expected: [2, 4, 6],
    sample: 'const mapT = fn => reducer => (acc, x) => reducer(acc, fn(x)); const push = (arr, x) => [...arr, x]; nums.reduce(mapT(x => x * 2)(push), [])',
    hints: ['Transducer wraps a reducer', 'Transform value before passing to reducer'],
    tags: ['functional', 'transducer', 'map'],
  },
  {
    id: 'js-functional-064',
    category: 'Functional Programming',
    difficulty: 'hard',
    title: 'Transducer Filter',
    text: 'Create a filtering transducer.',
    setup: 'const nums = [1, 2, 3, 4, 5, 6];',
    setupCode: 'const nums = [1, 2, 3, 4, 5, 6];',
    expected: [2, 4, 6],
    sample: 'const filterT = pred => reducer => (acc, x) => pred(x) ? reducer(acc, x) : acc; const push = (arr, x) => [...arr, x]; nums.reduce(filterT(x => x % 2 === 0)(push), [])',
    hints: ['Only call reducer if predicate passes', 'Return unchanged accumulator otherwise'],
    tags: ['functional', 'transducer', 'filter'],
  },
  {
    id: 'js-functional-065',
    category: 'Functional Programming',
    difficulty: 'hard',
    title: 'Compose Transducers',
    text: 'Compose multiple transducers together.',
    setup: 'const nums = [1, 2, 3, 4, 5, 6];',
    setupCode: 'const nums = [1, 2, 3, 4, 5, 6];',
    expected: [4, 8, 12],
    sample: 'const mapT = fn => r => (a, x) => r(a, fn(x)); const filterT = p => r => (a, x) => p(x) ? r(a, x) : a; const comp = (...fns) => fns.reduce((f, g) => x => f(g(x))); const push = (arr, x) => [...arr, x]; nums.reduce(comp(filterT(x => x % 2 === 0), mapT(x => x * 2))(push), [])',
    hints: ['Compose transducers like functions', 'Order matters for transformation'],
    tags: ['functional', 'transducer', 'compose'],
  },
  {
    id: 'js-functional-066',
    category: 'Functional Programming',
    difficulty: 'hard',
    title: 'Functor Map',
    text: 'Create a simple functor (container) with map method.',
    setup: 'let result;',
    setupCode: 'let result;',
    expected: 10,
    sample: 'const Box = x => ({ map: fn => Box(fn(x)), fold: fn => fn(x) }); result = Box(5).map(x => x * 2).fold(x => x)',
    hints: ['Box wraps a value', 'map returns new Box with transformed value'],
    tags: ['functional', 'functor', 'container'],
  },
  {
    id: 'js-functional-067',
    category: 'Functional Programming',
    difficulty: 'hard',
    title: 'Maybe Functor',
    text: 'Implement a Maybe functor for null-safe operations.',
    setup: 'let results;',
    setupCode: 'let results;',
    expected: ['HELLO', 'nothing'],
    sample: 'const Maybe = x => ({ map: fn => x == null ? Maybe(null) : Maybe(fn(x)), fold: (onNothing, onJust) => x == null ? onNothing() : onJust(x) }); const r1 = Maybe("hello").map(s => s.toUpperCase()).fold(() => "nothing", x => x); const r2 = Maybe(null).map(s => s.toUpperCase()).fold(() => "nothing", x => x); results = [r1, r2]',
    hints: ['Check for null before mapping', 'fold handles both cases'],
    tags: ['functional', 'maybe', 'functor'],
  },
  {
    id: 'js-functional-068',
    category: 'Functional Programming',
    difficulty: 'hard',
    title: 'Either Functor',
    text: 'Implement Either for error handling.',
    setup: 'let results;',
    setupCode: 'let results;',
    expected: [10, 'Error: Division by zero'],
    sample: 'const Right = x => ({ map: fn => Right(fn(x)), fold: (f, g) => g(x) }); const Left = x => ({ map: fn => Left(x), fold: (f, g) => f(x) }); const safeDivide = (a, b) => b === 0 ? Left("Division by zero") : Right(a / b); const r1 = safeDivide(20, 2).fold(e => `Error: ${e}`, x => x); const r2 = safeDivide(20, 0).fold(e => `Error: ${e}`, x => x); results = [r1, r2]',
    hints: ['Right maps and folds with success handler', 'Left ignores map and folds with error handler'],
    tags: ['functional', 'either', 'error-handling'],
  },
  {
    id: 'js-functional-069',
    category: 'Functional Programming',
    difficulty: 'hard',
    title: 'Chain/FlatMap for Maybe',
    text: 'Add chain method to Maybe for nested operations.',
    setup: 'let result;',
    setupCode: 'let result;',
    expected: 'John Doe',
    sample: 'const Maybe = x => ({ map: fn => x == null ? Maybe(null) : Maybe(fn(x)), chain: fn => x == null ? Maybe(null) : fn(x), fold: (n, j) => x == null ? n() : j(x) }); const user = { profile: { name: "John Doe" } }; result = Maybe(user).chain(u => Maybe(u.profile)).chain(p => Maybe(p.name)).fold(() => "No name", x => x)',
    hints: ['chain avoids nested Maybes', 'Similar to flatMap'],
    tags: ['functional', 'maybe', 'chain', 'monad'],
  },
  {
    id: 'js-functional-070',
    category: 'Recursion',
    difficulty: 'hard',
    title: 'Tail-Call Optimized Factorial',
    text: 'Implement factorial using tail recursion pattern.',
    setup: 'let result;',
    setupCode: 'let result;',
    expected: 120,
    sample: 'const factorial = (n, acc = 1) => n <= 1 ? acc : factorial(n - 1, n * acc); result = factorial(5)',
    hints: ['Accumulator carries result', 'Last operation is recursive call'],
    tags: ['functional', 'recursion', 'tail-call'],
  },
  {
    id: 'js-functional-071',
    category: 'Recursion',
    difficulty: 'hard',
    title: 'Trampoline for Stack Safety',
    text: 'Implement trampoline to avoid stack overflow.',
    setup: 'let result;',
    setupCode: 'let result;',
    expected: 50005000,
    sample: 'const trampoline = fn => (...args) => { let result = fn(...args); while (typeof result === "function") result = result(); return result; }; const sumTo = trampoline((n, acc = 0) => n === 0 ? acc : () => sumTo(n - 1, acc + n)); result = sumTo(10000)',
    hints: ['Return thunk instead of recursing', 'Loop while result is function'],
    tags: ['functional', 'trampoline', 'stack-safe'],
  },
  {
    id: 'js-functional-072',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Async Compose',
    text: 'Compose async functions that return promises.',
    setup: 'let result;',
    setupCode: 'let result;',
    expected: 8,
    sample: 'const asyncCompose = (...fns) => x => fns.reduceRight((p, fn) => p.then(fn), Promise.resolve(x)); const add1 = async x => x + 1; const mult2 = async x => x * 2; result = await asyncCompose(mult2, add1, add1)(2)',
    hints: ['Chain promises with then', 'reduceRight for right-to-left'],
    tags: ['functional', 'async', 'compose'],
  },
  {
    id: 'js-functional-073',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Async Pipe',
    text: 'Pipe async functions left-to-right.',
    setup: 'let result;',
    setupCode: 'let result;',
    expected: 7,
    sample: 'const asyncPipe = (...fns) => x => fns.reduce((p, fn) => p.then(fn), Promise.resolve(x)); const add1 = async x => x + 1; const mult2 = async x => x * 2; result = await asyncPipe(add1, mult2, add1)(2)',
    hints: ['reduce for left-to-right', 'Each then chains next function'],
    tags: ['functional', 'async', 'pipe'],
  },
  {
    id: 'js-functional-074',
    category: 'Functional Programming',
    difficulty: 'hard',
    title: 'Lens Getter',
    text: 'Implement a lens getter for nested property access.',
    setup: 'const data = { user: { profile: { name: "Alice" } } };',
    setupCode: 'const data = { user: { profile: { name: "Alice" } } };',
    expected: 'Alice',
    sample: 'const lens = path => ({ get: obj => path.reduce((o, k) => o && o[k], obj) }); lens(["user", "profile", "name"]).get(data)',
    hints: ['Reduce over path segments', 'Handle undefined safely'],
    tags: ['functional', 'lens', 'getter'],
  },
  {
    id: 'js-functional-075',
    category: 'Functional Programming',
    difficulty: 'hard',
    title: 'Lens Setter',
    text: 'Implement a lens setter for immutable nested updates.',
    setup: 'const data = { a: { b: { c: 1 } } };',
    setupCode: 'const data = { a: { b: { c: 1 } } };',
    expected: { a: { b: { c: 2 } } },
    sample: 'const setPath = (obj, [head, ...tail], val) => ({ ...obj, [head]: tail.length ? setPath(obj[head] || {}, tail, val) : val }); setPath(data, ["a", "b", "c"], 2)',
    hints: ['Recursively rebuild object path', 'Spread existing properties'],
    tags: ['functional', 'lens', 'setter', 'immutability'],
  },
  {
    id: 'js-functional-076',
    category: 'Functional Programming',
    difficulty: 'hard',
    title: 'Point-Free Style',
    text: 'Refactor to point-free style using compose.',
    setup: 'const users = [{ name: "alice" }, { name: "bob" }];',
    setupCode: 'const users = [{ name: "alice" }, { name: "bob" }];',
    expected: ['ALICE', 'BOB'],
    sample: 'const compose = (...fns) => x => fns.reduceRight((v, f) => f(v), x); const prop = k => o => o[k]; const toUpper = s => s.toUpperCase(); const getName = compose(toUpper, prop("name")); users.map(getName)',
    hints: ['Remove explicit parameter references', 'Build from smaller functions'],
    tags: ['functional', 'point-free', 'compose'],
  },
  {
    id: 'js-functional-077',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Apply to Arguments',
    text: 'Create a function that applies an array of functions to corresponding arguments.',
    setup: 'const fns = [x => x + 1, x => x * 2, x => x - 1]; const args = [1, 2, 3];',
    setupCode: 'const fns = [x => x + 1, x => x * 2, x => x - 1]; const args = [1, 2, 3];',
    expected: [2, 4, 2],
    sample: 'fns.map((fn, i) => fn(args[i]))',
    hints: ['Use index to pair function with argument', 'Map over functions array'],
    tags: ['functional', 'applicative', 'map'],
  },
  {
    id: 'js-functional-078',
    category: 'Functional Programming',
    difficulty: 'hard',
    title: 'Converge Pattern',
    text: 'Apply multiple functions to same input and combine results.',
    setup: 'const nums = [1, 2, 3, 4, 5];',
    setupCode: 'const nums = [1, 2, 3, 4, 5];',
    expected: 3,
    sample: 'const converge = (combiner, fns) => (...args) => combiner(...fns.map(fn => fn(...args))); const sum = arr => arr.reduce((a, b) => a + b, 0); const len = arr => arr.length; const average = converge((s, l) => s / l, [sum, len]); average(nums)',
    hints: ['Apply all functions to input', 'Pass results to combiner'],
    tags: ['functional', 'converge', 'combinator'],
  },
  {
    id: 'js-functional-079',
    category: 'Functional Programming',
    difficulty: 'hard',
    title: 'Use With Pattern',
    text: 'Create a useWith combinator that transforms arguments before applying.',
    setup: 'const fn = (a, b) => a + b;',
    setupCode: 'const fn = (a, b) => a + b;',
    expected: 7,
    sample: 'const useWith = (fn, transformers) => (...args) => fn(...args.map((arg, i) => transformers[i] ? transformers[i](arg) : arg)); useWith(fn, [x => x * 2, x => x + 1])(2, 2)',
    hints: ['Transform each argument with corresponding function', 'Handle missing transformers'],
    tags: ['functional', 'useWith', 'combinator'],
  },
  {
    id: 'js-functional-080',
    category: 'Recursion',
    difficulty: 'hard',
    title: 'Y Combinator',
    text: 'Implement the Y combinator for anonymous recursion.',
    setup: 'let result;',
    setupCode: 'let result;',
    expected: 120,
    sample: 'const Y = f => (x => f(v => x(x)(v)))(x => f(v => x(x)(v))); const factorial = Y(f => n => n <= 1 ? 1 : n * f(n - 1)); result = factorial(5)',
    hints: ['Y enables recursion without naming', 'Pass function reference as parameter'],
    tags: ['functional', 'y-combinator', 'recursion'],
  },
  {
    id: 'js-functional-081',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Unfold Generator',
    text: 'Create an unfold function that generates arrays from a seed.',
    setup: 'let result;',
    setupCode: 'let result;',
    expected: [1, 2, 3, 4, 5],
    sample: 'const unfold = (fn, seed) => { const result = []; let val = fn(seed); while (val) { result.push(val[0]); val = fn(val[1]); } return result; }; result = unfold(n => n > 5 ? null : [n, n + 1], 1)',
    hints: ['Generate value and next seed', 'Return null to stop'],
    tags: ['functional', 'unfold', 'generator'],
  },
  {
    id: 'js-functional-082',
    category: 'Functional Programming',
    difficulty: 'hard',
    title: 'Reader Monad Pattern',
    text: 'Implement a Reader pattern for dependency injection.',
    setup: 'const config = { multiplier: 3 };',
    setupCode: 'const config = { multiplier: 3 };',
    expected: 15,
    sample: 'const Reader = run => ({ run, map: fn => Reader(env => fn(run(env))), chain: fn => Reader(env => fn(run(env)).run(env)) }); const getMultiplier = Reader(cfg => cfg.multiplier); const compute = x => getMultiplier.map(m => x * m); compute(5).run(config)',
    hints: ['Reader delays access to environment', 'run injects the dependency'],
    tags: ['functional', 'reader', 'monad'],
  },
  {
    id: 'js-functional-083',
    category: 'Closures',
    difficulty: 'hard',
    title: 'Module Pattern',
    text: 'Create a module with private state using closures.',
    setup: 'let result;',
    setupCode: 'let result;',
    expected: { count: 3, items: ['a', 'b', 'c'] },
    sample: 'const createModule = () => { const items = []; return { add: item => items.push(item), getItems: () => [...items], count: () => items.length }; }; const mod = createModule(); mod.add("a"); mod.add("b"); mod.add("c"); result = { count: mod.count(), items: mod.getItems() }',
    hints: ['Private array hidden in closure', 'Public methods access private state'],
    tags: ['functional', 'module', 'closure'],
  },
  {
    id: 'js-functional-084',
    category: 'Functional Programming',
    difficulty: 'hard',
    title: 'Immutable Stack',
    text: 'Implement an immutable stack data structure.',
    setup: 'let result;',
    setupCode: 'let result;',
    expected: { top: 3, size: 3 },
    sample: 'const Stack = (items = []) => ({ push: x => Stack([...items, x]), pop: () => Stack(items.slice(0, -1)), peek: () => items[items.length - 1], size: () => items.length }); const stack = Stack().push(1).push(2).push(3); result = { top: stack.peek(), size: stack.size() }',
    hints: ['Each operation returns new Stack', 'Never mutate internal array'],
    tags: ['functional', 'immutability', 'data-structure'],
  },
  {
    id: 'js-functional-085',
    category: 'Functional Programming',
    difficulty: 'hard',
    title: 'Lazy Evaluation',
    text: 'Implement lazy evaluation for deferred computation.',
    setup: 'let computed = 0;',
    setupCode: 'let computed = 0;',
    expected: { value: 10, computedOnce: 1 },
    sample: 'const lazy = fn => { let cached, done = false; return () => done ? cached : (done = true, cached = fn()); }; const getValue = lazy(() => { computed++; return 10; }); getValue(); getValue(); getValue(); ({ value: getValue(), computedOnce: computed })',
    hints: ['Cache result after first call', 'Track if computation happened'],
    tags: ['functional', 'lazy', 'memoization'],
  },
  {
    id: 'js-functional-086',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'Call N Times',
    text: 'Create a function that calls another function n times.',
    setup: 'let count = 0;',
    setupCode: 'let count = 0;',
    expected: 5,
    sample: 'const times = (n, fn) => { for (let i = 0; i < n; i++) fn(i); }; times(5, () => count++); count',
    hints: ['Loop n times', 'Optionally pass index to function'],
    tags: ['functional', 'times', 'iteration'],
  },
  {
    id: 'js-functional-087',
    category: 'Functional Programming',
    difficulty: 'easy',
    title: 'Default Value',
    text: 'Create a function that provides a default value for nullish values.',
    setup: 'const values = [null, 5, undefined, 10];',
    setupCode: 'const values = [null, 5, undefined, 10];',
    expected: [0, 5, 0, 10],
    sample: 'const defaultTo = def => val => val ?? def; values.map(defaultTo(0))',
    hints: ['Nullish coalescing handles null/undefined', 'Curried for mapping'],
    tags: ['functional', 'default', 'nullish'],
  },
  {
    id: 'js-functional-088',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'Chunk Array',
    text: 'Split an array into chunks of specified size.',
    setup: 'const nums = [1, 2, 3, 4, 5, 6, 7];',
    setupCode: 'const nums = [1, 2, 3, 4, 5, 6, 7];',
    expected: [[1, 2, 3], [4, 5, 6], [7]],
    sample: 'const chunk = (arr, size) => arr.reduce((chunks, item, i) => { const idx = Math.floor(i / size); chunks[idx] = [...(chunks[idx] || []), item]; return chunks; }, []); chunk(nums, 3)',
    hints: ['Calculate chunk index from item index', 'Build chunks in reducer'],
    tags: ['functional', 'chunk', 'reduce'],
  },
  {
    id: 'js-functional-089',
    category: 'Functional Programming',
    difficulty: 'easy',
    title: 'Clamp Value',
    text: 'Clamp a value between min and max.',
    setup: 'const values = [-5, 0, 5, 10, 15];',
    setupCode: 'const values = [-5, 0, 5, 10, 15];',
    expected: [0, 0, 5, 10, 10],
    sample: 'const clamp = (min, max) => val => Math.min(Math.max(val, min), max); values.map(clamp(0, 10))',
    hints: ['Max with min first', 'Then min with max'],
    tags: ['functional', 'clamp', 'currying'],
  },
  {
    id: 'js-functional-090',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'Unique Values',
    text: 'Get unique values from array using functional approach.',
    setup: 'const nums = [1, 2, 2, 3, 3, 3, 4];',
    setupCode: 'const nums = [1, 2, 2, 3, 3, 3, 4];',
    expected: [1, 2, 3, 4],
    sample: '[...new Set(nums)]',
    hints: ['Set automatically removes duplicates', 'Spread back to array'],
    tags: ['functional', 'unique', 'set'],
  },
  {
    id: 'js-functional-091',
    category: 'Functional Programming',
    difficulty: 'easy',
    title: 'Boolean Coercion',
    text: 'Filter out falsy values from an array.',
    setup: 'const mixed = [0, 1, false, 2, "", 3, null, undefined];',
    setupCode: 'const mixed = [0, 1, false, 2, "", 3, null, undefined];',
    expected: [1, 2, 3],
    sample: 'mixed.filter(Boolean)',
    hints: ['Boolean as function coerces to boolean', 'Falsy values become false'],
    tags: ['functional', 'filter', 'boolean'],
  },
  {
    id: 'js-functional-092',
    category: 'Functional Programming',
    difficulty: 'easy',
    title: 'Count Occurrences',
    text: 'Count occurrences of each element in array.',
    setup: 'const items = ["a", "b", "a", "c", "b", "a"];',
    setupCode: 'const items = ["a", "b", "a", "c", "b", "a"];',
    expected: { a: 3, b: 2, c: 1 },
    sample: 'items.reduce((counts, item) => ({ ...counts, [item]: (counts[item] || 0) + 1 }), {})',
    hints: ['Initialize count to 0 if missing', 'Increment for each occurrence'],
    tags: ['functional', 'reduce', 'count'],
  },
  {
    id: 'js-functional-093',
    category: 'Higher-Order Functions',
    difficulty: 'easy',
    title: 'Index Of with Predicate',
    text: 'Find index where predicate first returns true.',
    setup: 'const nums = [1, 4, 9, 16, 25];',
    setupCode: 'const nums = [1, 4, 9, 16, 25];',
    expected: 2,
    sample: 'nums.findIndex(x => x > 5)',
    hints: ['findIndex with predicate', 'Returns -1 if not found'],
    tags: ['functional', 'findIndex', 'predicate'],
  },
  {
    id: 'js-functional-094',
    category: 'Functional Programming',
    difficulty: 'easy',
    title: 'Entries to Object',
    text: 'Convert Map entries to plain object.',
    setup: 'const map = new Map([["x", 1], ["y", 2]]);',
    setupCode: 'const map = new Map([["x", 1], ["y", 2]]);',
    expected: { x: 1, y: 2 },
    sample: 'Object.fromEntries(map)',
    hints: ['Map is iterable as entries', 'fromEntries converts to object'],
    tags: ['functional', 'map', 'object'],
  },
  {
    id: 'js-functional-095',
    category: 'Functional Programming',
    difficulty: 'easy',
    title: 'Compact Object',
    text: 'Remove properties with falsy values from object.',
    setup: 'const obj = { a: 1, b: 0, c: null, d: "hello", e: "" };',
    setupCode: 'const obj = { a: 1, b: 0, c: null, d: "hello", e: "" };',
    expected: { a: 1, d: 'hello' },
    sample: 'Object.fromEntries(Object.entries(obj).filter(([, v]) => Boolean(v)))',
    hints: ['Filter entries by value truthiness', 'Destructure to ignore key'],
    tags: ['functional', 'object', 'filter'],
  },
  {
    id: 'js-functional-096',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Reduce Right',
    text: 'Use reduceRight to build string from right to left.',
    setup: 'const words = ["Hello", "World", "!"];',
    setupCode: 'const words = ["Hello", "World", "!"];',
    expected: '! World Hello',
    sample: 'words.reduceRight((acc, word) => acc + " " + word)',
    hints: ['reduceRight starts from last element', 'Accumulates right to left'],
    tags: ['functional', 'reduceRight', 'string'],
  },
  {
    id: 'js-functional-097',
    category: 'Closures',
    difficulty: 'medium',
    title: 'Rate Limiter',
    text: 'Create a rate limiter that limits function calls.',
    setup: 'let result;',
    setupCode: 'let result;',
    expected: true,
    sample: 'const rateLimit = (fn, limit) => { const calls = []; return (...args) => { const now = Date.now(); while (calls.length && calls[0] < now - 1000) calls.shift(); if (calls.length < limit) { calls.push(now); return fn(...args); } }; }; result = typeof rateLimit(() => {}, 5) === "function"',
    hints: ['Track call timestamps', 'Remove old calls outside window'],
    tags: ['functional', 'closure', 'rate-limit'],
  },
  {
    id: 'js-functional-098',
    category: 'Functional Programming',
    difficulty: 'medium',
    title: 'Deep Merge Objects',
    text: 'Recursively merge two objects.',
    setup: 'const a = { x: 1, y: { z: 2 } }; const b = { y: { w: 3 }, v: 4 };',
    setupCode: 'const a = { x: 1, y: { z: 2 } }; const b = { y: { w: 3 }, v: 4 };',
    expected: { x: 1, y: { z: 2, w: 3 }, v: 4 },
    sample: 'const deepMerge = (a, b) => { const result = { ...a }; for (const key in b) { result[key] = a[key] && typeof a[key] === "object" && typeof b[key] === "object" ? deepMerge(a[key], b[key]) : b[key]; } return result; }; deepMerge(a, b)',
    hints: ['Recurse when both values are objects', 'Otherwise take b value'],
    tags: ['functional', 'merge', 'recursion'],
  },
  {
    id: 'js-functional-099',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Intersection of Arrays',
    text: 'Find elements common to both arrays.',
    setup: 'const a = [1, 2, 3, 4]; const b = [3, 4, 5, 6];',
    setupCode: 'const a = [1, 2, 3, 4]; const b = [3, 4, 5, 6];',
    expected: [3, 4],
    sample: 'a.filter(x => b.includes(x))',
    hints: ['Filter first array', 'Keep elements in second array'],
    tags: ['functional', 'intersection', 'filter'],
  },
  {
    id: 'js-functional-100',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Difference of Arrays',
    text: 'Find elements in first array not in second.',
    setup: 'const a = [1, 2, 3, 4]; const b = [3, 4, 5, 6];',
    setupCode: 'const a = [1, 2, 3, 4]; const b = [3, 4, 5, 6];',
    expected: [1, 2],
    sample: 'a.filter(x => !b.includes(x))',
    hints: ['Filter first array', 'Keep elements NOT in second'],
    tags: ['functional', 'difference', 'filter'],
  },
  {
    id: 'js-functional-101',
    category: 'Functional Programming',
    difficulty: 'medium',
    title: 'Symmetric Difference',
    text: 'Find elements in either array but not both.',
    setup: 'const a = [1, 2, 3]; const b = [2, 3, 4];',
    setupCode: 'const a = [1, 2, 3]; const b = [2, 3, 4];',
    expected: [1, 4],
    sample: '[...a.filter(x => !b.includes(x)), ...b.filter(x => !a.includes(x))]',
    hints: ['Combine both differences', 'Elements exclusive to each array'],
    tags: ['functional', 'symmetric-difference', 'array'],
  },
  {
    id: 'js-functional-102',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Sum By Property',
    text: 'Sum array of objects by a specific property.',
    setup: 'const items = [{ val: 10 }, { val: 20 }, { val: 30 }];',
    setupCode: 'const items = [{ val: 10 }, { val: 20 }, { val: 30 }];',
    expected: 60,
    sample: 'const sumBy = (arr, key) => arr.reduce((sum, obj) => sum + obj[key], 0); sumBy(items, "val")',
    hints: ['Reduce over objects', 'Access property with key'],
    tags: ['functional', 'reduce', 'sumBy'],
  },
  {
    id: 'js-functional-103',
    category: 'Functional Programming',
    difficulty: 'medium',
    title: 'Pick Object Properties',
    text: 'Create new object with only specified properties.',
    setup: 'const obj = { a: 1, b: 2, c: 3, d: 4 };',
    setupCode: 'const obj = { a: 1, b: 2, c: 3, d: 4 };',
    expected: { a: 1, c: 3 },
    sample: 'const pick = (obj, keys) => Object.fromEntries(keys.filter(k => k in obj).map(k => [k, obj[k]])); pick(obj, ["a", "c"])',
    hints: ['Filter to existing keys', 'Map to entries then convert'],
    tags: ['functional', 'pick', 'object'],
  },
  {
    id: 'js-functional-104',
    category: 'Functional Programming',
    difficulty: 'medium',
    title: 'Omit Object Properties',
    text: 'Create new object without specified properties.',
    setup: 'const obj = { a: 1, b: 2, c: 3, d: 4 };',
    setupCode: 'const obj = { a: 1, b: 2, c: 3, d: 4 };',
    expected: { b: 2, d: 4 },
    sample: 'const omit = (obj, keys) => Object.fromEntries(Object.entries(obj).filter(([k]) => !keys.includes(k))); omit(obj, ["a", "c"])',
    hints: ['Filter entries by key', 'Exclude keys in the list'],
    tags: ['functional', 'omit', 'object'],
  },
  {
    id: 'js-functional-105',
    category: 'Higher-Order Functions',
    difficulty: 'medium',
    title: 'Map Object Values',
    text: 'Apply a function to all values in an object.',
    setup: 'const obj = { a: 1, b: 2, c: 3 };',
    setupCode: 'const obj = { a: 1, b: 2, c: 3 };',
    expected: { a: 2, b: 4, c: 6 },
    sample: 'const mapValues = (obj, fn) => Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, fn(v)])); mapValues(obj, x => x * 2)',
    hints: ['Map over entries', 'Transform value, keep key'],
    tags: ['functional', 'mapValues', 'object'],
  },
  {
    id: 'js-functional-106',
    category: 'Recursion',
    difficulty: 'hard',
    title: 'Recursive Object Freeze',
    text: 'Deeply freeze an object to make it fully immutable.',
    setup: 'const obj = { a: 1, b: { c: 2 } };',
    setupCode: 'const obj = { a: 1, b: { c: 2 } };',
    expected: true,
    sample: 'const deepFreeze = obj => { Object.freeze(obj); Object.values(obj).forEach(v => v && typeof v === "object" && deepFreeze(v)); return obj; }; deepFreeze(obj); Object.isFrozen(obj) && Object.isFrozen(obj.b)',
    hints: ['Freeze current object', 'Recursively freeze nested objects'],
    tags: ['functional', 'immutability', 'freeze'],
  },
  {
    id: 'js-functional-107',
    category: 'Functional Programming',
    difficulty: 'hard',
    title: 'State Monad Pattern',
    text: 'Implement a simple State monad for stateful computations.',
    setup: 'let result;',
    setupCode: 'let result;',
    expected: { value: 6, state: 3 },
    sample: 'const State = run => ({ run, map: fn => State(s => { const [a, s2] = run(s); return [fn(a), s2]; }), chain: fn => State(s => { const [a, s2] = run(s); return fn(a).run(s2); }) }); const increment = State(s => [s, s + 1]); const compute = increment.chain(a => increment.chain(b => increment.map(c => a + b + c))); result = { value: compute.run(0)[0], state: compute.run(0)[1] }',
    hints: ['State wraps function from state to [value, newState]', 'chain threads state through'],
    tags: ['functional', 'state', 'monad'],
  },
  {
    id: 'js-functional-108',
    category: 'Functional Programming',
    difficulty: 'hard',
    title: 'IO Monad Pattern',
    text: 'Implement IO monad for side-effect isolation.',
    setup: 'let sideEffect = 0;',
    setupCode: 'let sideEffect = 0;',
    expected: { before: 0, after: 5, result: 10 },
    sample: 'const IO = run => ({ run, map: fn => IO(() => fn(run())), chain: fn => IO(() => fn(run()).run()) }); const before = sideEffect; const io = IO(() => { sideEffect = 5; return 10; }); const result = io.run(); ({ before, after: sideEffect, result })',
    hints: ['IO wraps a thunk (function)', 'run executes the side effect'],
    tags: ['functional', 'io', 'monad'],
  },
  {
    id: 'js-functional-109',
    category: 'Higher-Order Functions',
    difficulty: 'hard',
    title: 'Scan (Running Reduce)',
    text: 'Implement scan that returns all intermediate reduce values.',
    setup: 'const nums = [1, 2, 3, 4, 5];',
    setupCode: 'const nums = [1, 2, 3, 4, 5];',
    expected: [1, 3, 6, 10, 15],
    sample: 'const scan = (fn, init, arr) => arr.reduce((acc, x) => [...acc, fn(acc.length ? acc[acc.length - 1] : init, x)], []); scan((a, b) => a + b, 0, nums)',
    hints: ['Store each intermediate result', 'Like reduce but keeps history'],
    tags: ['functional', 'scan', 'reduce'],
  },
  {
    id: 'js-functional-110',
    category: 'Functional Programming',
    difficulty: 'hard',
    title: 'Monad Laws Verification',
    text: 'Verify left identity law for a simple monad.',
    setup: 'const Box = x => ({ map: f => Box(f(x)), chain: f => f(x), fold: f => f(x) });',
    setupCode: 'const Box = x => ({ map: f => Box(f(x)), chain: f => f(x), fold: f => f(x) });',
    expected: true,
    sample: 'const f = x => Box(x + 1); const a = 5; const leftSide = Box(a).chain(f).fold(x => x); const rightSide = f(a).fold(x => x); leftSide === rightSide',
    hints: ['Left identity: M.of(a).chain(f) === f(a)', 'Both sides should produce same result'],
    tags: ['functional', 'monad', 'laws'],
  },

  // ========================================
  // DOM MANIPULATION - querySelector/querySelectorAll
  // ========================================
  {
    id: 'js-dom-001',
    category: 'DOM Manipulation',
    difficulty: 'easy',
    title: 'Select Element by ID',
    text: 'Use querySelector to select an element with the id "main-title".',
    setup: 'const document = { querySelector: (sel) => sel === "#main-title" ? { id: "main-title", tagName: "H1" } : null };',
    setupCode: 'const document = { querySelector: (sel) => sel === "#main-title" ? { id: "main-title", tagName: "H1" } : null };',
    expected: { id: 'main-title', tagName: 'H1' },
    sample: 'document.querySelector("#main-title")',
    hints: ['Use # prefix for ID selectors', 'querySelector returns the first matching element'],
    tags: ['dom', 'querySelector', 'selectors'],
  },
  {
    id: 'js-dom-002',
    category: 'DOM Manipulation',
    difficulty: 'easy',
    title: 'Select Element by Class',
    text: 'Use querySelector to select the first element with class "button".',
    setup: 'const document = { querySelector: (sel) => sel === ".button" ? { className: "button", tagName: "BUTTON" } : null };',
    setupCode: 'const document = { querySelector: (sel) => sel === ".button" ? { className: "button", tagName: "BUTTON" } : null };',
    expected: { className: 'button', tagName: 'BUTTON' },
    sample: 'document.querySelector(".button")',
    hints: ['Use . prefix for class selectors', 'querySelector returns the first match'],
    tags: ['dom', 'querySelector', 'selectors'],
  },
  {
    id: 'js-dom-003',
    category: 'DOM Manipulation',
    difficulty: 'easy',
    title: 'Select by Tag Name',
    text: 'Use querySelector to select the first paragraph element.',
    setup: 'const document = { querySelector: (sel) => sel === "p" ? { tagName: "P", textContent: "Hello" } : null };',
    setupCode: 'const document = { querySelector: (sel) => sel === "p" ? { tagName: "P", textContent: "Hello" } : null };',
    expected: { tagName: 'P', textContent: 'Hello' },
    sample: 'document.querySelector("p")',
    hints: ['Use tag name directly without prefix', 'Returns first matching element'],
    tags: ['dom', 'querySelector', 'selectors'],
  },
  {
    id: 'js-dom-004',
    category: 'DOM Manipulation',
    difficulty: 'easy',
    title: 'Select All Elements by Class',
    text: 'Use querySelectorAll to select all elements with class "item" and get the count.',
    setup: 'const document = { querySelectorAll: (sel) => sel === ".item" ? { length: 5 } : { length: 0 } };',
    setupCode: 'const document = { querySelectorAll: (sel) => sel === ".item" ? { length: 5 } : { length: 0 } };',
    expected: 5,
    sample: 'document.querySelectorAll(".item").length',
    hints: ['querySelectorAll returns a NodeList', 'Use .length to count elements'],
    tags: ['dom', 'querySelectorAll', 'selectors'],
  },
  {
    id: 'js-dom-005',
    category: 'DOM Manipulation',
    difficulty: 'easy',
    title: 'Select with Attribute Selector',
    text: 'Select an element with data-type="primary" attribute.',
    setup: 'const document = { querySelector: (sel) => sel === \'[data-type="primary"]\' ? { dataset: { type: "primary" } } : null };',
    setupCode: 'const document = { querySelector: (sel) => sel === \'[data-type="primary"]\' ? { dataset: { type: "primary" } } : null };',
    expected: { dataset: { type: 'primary' } },
    sample: 'document.querySelector(\'[data-type="primary"]\')',
    hints: ['Use square brackets for attribute selectors', 'Quote the attribute value'],
    tags: ['dom', 'querySelector', 'attributes'],
  },
  {
    id: 'js-dom-006',
    category: 'DOM Manipulation',
    difficulty: 'medium',
    title: 'Descendant Selector',
    text: 'Select all list items inside a nav element.',
    setup: 'const document = { querySelectorAll: (sel) => sel === "nav li" ? [{ tagName: "LI" }, { tagName: "LI" }, { tagName: "LI" }] : [] };',
    setupCode: 'const document = { querySelectorAll: (sel) => sel === "nav li" ? [{ tagName: "LI" }, { tagName: "LI" }, { tagName: "LI" }] : [] };',
    expected: [{ tagName: 'LI' }, { tagName: 'LI' }, { tagName: 'LI' }],
    sample: 'document.querySelectorAll("nav li")',
    hints: ['Space between selectors means descendant', 'This selects all li inside nav'],
    tags: ['dom', 'querySelectorAll', 'combinators'],
  },
  {
    id: 'js-dom-007',
    category: 'DOM Manipulation',
    difficulty: 'medium',
    title: 'Direct Child Selector',
    text: 'Select only direct child paragraphs of an article element.',
    setup: 'const document = { querySelectorAll: (sel) => sel === "article > p" ? [{ tagName: "P", direct: true }] : [] };',
    setupCode: 'const document = { querySelectorAll: (sel) => sel === "article > p" ? [{ tagName: "P", direct: true }] : [] };',
    expected: [{ tagName: 'P', direct: true }],
    sample: 'document.querySelectorAll("article > p")',
    hints: ['Use > for direct child combinator', 'This excludes nested paragraphs'],
    tags: ['dom', 'querySelectorAll', 'combinators'],
  },
  {
    id: 'js-dom-008',
    category: 'DOM Manipulation',
    difficulty: 'medium',
    title: 'Multiple Selectors',
    text: 'Select all h1, h2, and h3 elements at once.',
    setup: 'const document = { querySelectorAll: (sel) => sel === "h1, h2, h3" ? [{ tagName: "H1" }, { tagName: "H2" }, { tagName: "H3" }] : [] };',
    setupCode: 'const document = { querySelectorAll: (sel) => sel === "h1, h2, h3" ? [{ tagName: "H1" }, { tagName: "H2" }, { tagName: "H3" }] : [] };',
    expected: [{ tagName: 'H1' }, { tagName: 'H2' }, { tagName: 'H3' }],
    sample: 'document.querySelectorAll("h1, h2, h3")',
    hints: ['Separate multiple selectors with commas', 'Returns all matching elements'],
    tags: ['dom', 'querySelectorAll', 'selectors'],
  },
  {
    id: 'js-dom-009',
    category: 'DOM Manipulation',
    difficulty: 'medium',
    title: 'Pseudo-class Selector',
    text: 'Select the first child of a list.',
    setup: 'const document = { querySelector: (sel) => sel === "ul li:first-child" ? { textContent: "First Item" } : null };',
    setupCode: 'const document = { querySelector: (sel) => sel === "ul li:first-child" ? { textContent: "First Item" } : null };',
    expected: { textContent: 'First Item' },
    sample: 'document.querySelector("ul li:first-child")',
    hints: ['Use :first-child pseudo-class', 'This selects the first li in ul'],
    tags: ['dom', 'querySelector', 'pseudo-classes'],
  },
  {
    id: 'js-dom-010',
    category: 'DOM Manipulation',
    difficulty: 'hard',
    title: 'Complex Selector Chain',
    text: 'Select checked checkboxes inside a form with id "settings".',
    setup: 'const document = { querySelectorAll: (sel) => sel === "#settings input[type=checkbox]:checked" ? [{ checked: true }, { checked: true }] : [] };',
    setupCode: 'const document = { querySelectorAll: (sel) => sel === "#settings input[type=checkbox]:checked" ? [{ checked: true }, { checked: true }] : [] };',
    expected: [{ checked: true }, { checked: true }],
    sample: 'document.querySelectorAll("#settings input[type=checkbox]:checked")',
    hints: ['Combine ID, attribute, and pseudo-class selectors', 'Use :checked for selected checkboxes'],
    tags: ['dom', 'querySelectorAll', 'complex-selectors'],
  },

  // ========================================
  // DOM MANIPULATION - createElement/appendChild
  // ========================================
  {
    id: 'js-dom-011',
    category: 'DOM Manipulation',
    difficulty: 'easy',
    title: 'Create a Div Element',
    text: 'Create a new div element using document.createElement.',
    setup: 'const document = { createElement: (tag) => ({ tagName: tag.toUpperCase(), children: [] }) };',
    setupCode: 'const document = { createElement: (tag) => ({ tagName: tag.toUpperCase(), children: [] }) };',
    expected: { tagName: 'DIV', children: [] },
    sample: 'document.createElement("div")',
    hints: ['Pass the tag name as a string', 'Tag name is case-insensitive'],
    tags: ['dom', 'createElement', 'elements'],
  },
  {
    id: 'js-dom-012',
    category: 'DOM Manipulation',
    difficulty: 'easy',
    title: 'Create and Set Text Content',
    text: 'Create a paragraph element and set its text content to "Hello World".',
    setup: 'const document = { createElement: (tag) => ({ tagName: tag.toUpperCase(), textContent: "" }) };',
    setupCode: 'const document = { createElement: (tag) => ({ tagName: tag.toUpperCase(), textContent: "" }) };',
    expected: { tagName: 'P', textContent: 'Hello World' },
    sample: 'const p = document.createElement("p"); p.textContent = "Hello World"; p',
    hints: ['First create the element', 'Then set the textContent property'],
    tags: ['dom', 'createElement', 'textContent'],
  },
  {
    id: 'js-dom-013',
    category: 'DOM Manipulation',
    difficulty: 'easy',
    title: 'Append Child Element',
    text: 'Create a span and append it to the parent div. Return the parent.',
    setup: 'const parent = { tagName: "DIV", children: [], appendChild(child) { this.children.push(child); return child; } }; const document = { createElement: (tag) => ({ tagName: tag.toUpperCase() }) };',
    setupCode: 'const parent = { tagName: "DIV", children: [], appendChild(child) { this.children.push(child); return child; } }; const document = { createElement: (tag) => ({ tagName: tag.toUpperCase() }) };',
    expected: { tagName: 'DIV', children: [{ tagName: 'SPAN' }] },
    sample: 'parent.appendChild(document.createElement("span")); parent',
    hints: ['Use appendChild to add a child', 'appendChild modifies the parent in place'],
    tags: ['dom', 'appendChild', 'elements'],
  },
  {
    id: 'js-dom-014',
    category: 'DOM Manipulation',
    difficulty: 'easy',
    title: 'Create Button with Text',
    text: 'Create a button element with text "Click Me".',
    setup: 'const document = { createElement: (tag) => ({ tagName: tag.toUpperCase(), textContent: "" }) };',
    setupCode: 'const document = { createElement: (tag) => ({ tagName: tag.toUpperCase(), textContent: "" }) };',
    expected: { tagName: 'BUTTON', textContent: 'Click Me' },
    sample: 'const btn = document.createElement("button"); btn.textContent = "Click Me"; btn',
    hints: ['Create button element first', 'Set textContent for the button text'],
    tags: ['dom', 'createElement', 'button'],
  },
  {
    id: 'js-dom-015',
    category: 'DOM Manipulation',
    difficulty: 'medium',
    title: 'Create Element with Attribute',
    text: 'Create an anchor element with href attribute set to "https://example.com".',
    setup: 'const document = { createElement: (tag) => ({ tagName: tag.toUpperCase(), setAttribute(name, value) { this[name] = value; } }) };',
    setupCode: 'const document = { createElement: (tag) => ({ tagName: tag.toUpperCase(), setAttribute(name, value) { this[name] = value; } }) };',
    expected: { tagName: 'A', href: 'https://example.com' },
    sample: 'const a = document.createElement("a"); a.setAttribute("href", "https://example.com"); a',
    hints: ['Use setAttribute to add attributes', 'First argument is attribute name, second is value'],
    tags: ['dom', 'createElement', 'setAttribute'],
  },
  {
    id: 'js-dom-016',
    category: 'DOM Manipulation',
    difficulty: 'medium',
    title: 'Create Nested Elements',
    text: 'Create a ul with one li child containing text "Item 1". Return the ul.',
    setup: 'const document = { createElement: (tag) => ({ tagName: tag.toUpperCase(), textContent: "", children: [], appendChild(child) { this.children.push(child); return child; } }) };',
    setupCode: 'const document = { createElement: (tag) => ({ tagName: tag.toUpperCase(), textContent: "", children: [], appendChild(child) { this.children.push(child); return child; } }) };',
    expected: { tagName: 'UL', textContent: '', children: [{ tagName: 'LI', textContent: 'Item 1', children: [] }] },
    sample: 'const ul = document.createElement("ul"); const li = document.createElement("li"); li.textContent = "Item 1"; ul.appendChild(li); ul',
    hints: ['Create both elements separately', 'Set text on li before appending'],
    tags: ['dom', 'createElement', 'appendChild', 'nested'],
  },
  {
    id: 'js-dom-017',
    category: 'DOM Manipulation',
    difficulty: 'medium',
    title: 'Insert Before Element',
    text: 'Insert a new element before an existing one. Return the parent.',
    setup: 'const existing = { id: "existing" }; const parent = { children: [existing], insertBefore(newEl, ref) { const idx = this.children.indexOf(ref); this.children.splice(idx, 0, newEl); return newEl; } }; const newEl = { id: "new" };',
    setupCode: 'const existing = { id: "existing" }; const parent = { children: [existing], insertBefore(newEl, ref) { const idx = this.children.indexOf(ref); this.children.splice(idx, 0, newEl); return newEl; } }; const newEl = { id: "new" };',
    expected: { children: [{ id: 'new' }, { id: 'existing' }] },
    sample: 'parent.insertBefore(newEl, existing); parent',
    hints: ['insertBefore takes new element and reference element', 'New element is inserted before the reference'],
    tags: ['dom', 'insertBefore', 'manipulation'],
  },
  {
    id: 'js-dom-018',
    category: 'DOM Manipulation',
    difficulty: 'medium',
    title: 'Remove Child Element',
    text: 'Remove the child element from the parent and return the removed element.',
    setup: 'const child = { id: "child" }; const parent = { children: [child], removeChild(el) { const idx = this.children.indexOf(el); this.children.splice(idx, 1); return el; } };',
    setupCode: 'const child = { id: "child" }; const parent = { children: [child], removeChild(el) { const idx = this.children.indexOf(el); this.children.splice(idx, 1); return el; } };',
    expected: { id: 'child' },
    sample: 'parent.removeChild(child)',
    hints: ['removeChild returns the removed element', 'Pass the element to remove as argument'],
    tags: ['dom', 'removeChild', 'manipulation'],
  },
  {
    id: 'js-dom-019',
    category: 'DOM Manipulation',
    difficulty: 'hard',
    title: 'Replace Child Element',
    text: 'Replace the old element with a new one. Return the parent.',
    setup: 'const oldEl = { id: "old" }; const newEl = { id: "new" }; const parent = { children: [oldEl], replaceChild(newChild, oldChild) { const idx = this.children.indexOf(oldChild); this.children[idx] = newChild; return oldChild; } };',
    setupCode: 'const oldEl = { id: "old" }; const newEl = { id: "new" }; const parent = { children: [oldEl], replaceChild(newChild, oldChild) { const idx = this.children.indexOf(oldChild); this.children[idx] = newChild; return oldChild; } };',
    expected: { children: [{ id: 'new' }] },
    sample: 'parent.replaceChild(newEl, oldEl); parent',
    hints: ['replaceChild takes new element first, then old', 'Order of arguments matters'],
    tags: ['dom', 'replaceChild', 'manipulation'],
  },
  {
    id: 'js-dom-020',
    category: 'DOM Manipulation',
    difficulty: 'hard',
    title: 'Clone Element Deep',
    text: 'Clone the element including all its children.',
    setup: 'const el = { id: "original", children: [{ id: "child" }], cloneNode(deep) { return deep ? { id: this.id, children: [...this.children], cloned: true } : { id: this.id, children: [], cloned: true }; } };',
    setupCode: 'const el = { id: "original", children: [{ id: "child" }], cloneNode(deep) { return deep ? { id: this.id, children: [...this.children], cloned: true } : { id: this.id, children: [], cloned: true }; } };',
    expected: { id: 'original', children: [{ id: 'child' }], cloned: true },
    sample: 'el.cloneNode(true)',
    hints: ['Pass true for deep clone', 'Deep clone includes all descendants'],
    tags: ['dom', 'cloneNode', 'manipulation'],
  },

  // ========================================
  // DOM MANIPULATION - innerHTML/textContent
  // ========================================
  {
    id: 'js-dom-021',
    category: 'DOM Manipulation',
    difficulty: 'easy',
    title: 'Set innerHTML',
    text: 'Set the innerHTML of the element to contain a strong tag with "Bold Text".',
    setup: 'const el = { innerHTML: "" };',
    setupCode: 'const el = { innerHTML: "" };',
    expected: { innerHTML: '<strong>Bold Text</strong>' },
    sample: 'el.innerHTML = "<strong>Bold Text</strong>"; el',
    hints: ['innerHTML accepts HTML string', 'Include the full HTML tags'],
    tags: ['dom', 'innerHTML', 'html'],
  },
  {
    id: 'js-dom-022',
    category: 'DOM Manipulation',
    difficulty: 'easy',
    title: 'Get Text Content',
    text: 'Extract the text content from the element.',
    setup: 'const el = { textContent: "Hello World", innerHTML: "<span>Hello</span> World" };',
    setupCode: 'const el = { textContent: "Hello World", innerHTML: "<span>Hello</span> World" };',
    expected: 'Hello World',
    sample: 'el.textContent',
    hints: ['textContent returns plain text', 'HTML tags are not included'],
    tags: ['dom', 'textContent', 'text'],
  },
  {
    id: 'js-dom-023',
    category: 'DOM Manipulation',
    difficulty: 'easy',
    title: 'Clear Element Content',
    text: 'Clear all content from the element using innerHTML.',
    setup: 'const el = { innerHTML: "<p>Some content</p><span>More</span>" };',
    setupCode: 'const el = { innerHTML: "<p>Some content</p><span>More</span>" };',
    expected: { innerHTML: '' },
    sample: 'el.innerHTML = ""; el',
    hints: ['Set innerHTML to empty string', 'This removes all child elements'],
    tags: ['dom', 'innerHTML', 'clear'],
  },
  {
    id: 'js-dom-024',
    category: 'DOM Manipulation',
    difficulty: 'medium',
    title: 'Insert HTML with Template',
    text: 'Create an HTML string for a list with items "One", "Two", "Three".',
    setup: 'const items = ["One", "Two", "Three"];',
    setupCode: 'const items = ["One", "Two", "Three"];',
    expected: '<ul><li>One</li><li>Two</li><li>Three</li></ul>',
    sample: '`<ul>${items.map(i => `<li>${i}</li>`).join("")}</ul>`',
    hints: ['Use template literals', 'Map items to li tags and join'],
    tags: ['dom', 'innerHTML', 'templates'],
  },
  {
    id: 'js-dom-025',
    category: 'DOM Manipulation',
    difficulty: 'medium',
    title: 'Outer HTML Access',
    text: 'Get the outerHTML which includes the element itself.',
    setup: 'const el = { outerHTML: \'<div class="container"><p>Content</p></div>\' };',
    setupCode: 'const el = { outerHTML: \'<div class="container"><p>Content</p></div>\' };',
    expected: '<div class="container"><p>Content</p></div>',
    sample: 'el.outerHTML',
    hints: ['outerHTML includes the element tag', 'Unlike innerHTML which only has children'],
    tags: ['dom', 'outerHTML', 'html'],
  },
  {
    id: 'js-dom-026',
    category: 'DOM Manipulation',
    difficulty: 'medium',
    title: 'Insert Adjacent HTML',
    text: 'Insert HTML before the end of the element (inside, after last child).',
    setup: 'const el = { content: ["existing"], insertAdjacentHTML(pos, html) { if(pos === "beforeend") this.content.push(html); } };',
    setupCode: 'const el = { content: ["existing"], insertAdjacentHTML(pos, html) { if(pos === "beforeend") this.content.push(html); } };',
    expected: { content: ['existing', '<span>New</span>'] },
    sample: 'el.insertAdjacentHTML("beforeend", "<span>New</span>"); el',
    hints: ['Use "beforeend" position', 'This adds content as last child'],
    tags: ['dom', 'insertAdjacentHTML', 'manipulation'],
  },
  {
    id: 'js-dom-027',
    category: 'DOM Manipulation',
    difficulty: 'hard',
    title: 'Sanitize HTML Input',
    text: 'Use textContent to safely display user input without executing HTML.',
    setup: 'const el = { textContent: "" }; const userInput = "<script>alert(\\"xss\\")</script>";',
    setupCode: 'const el = { textContent: "" }; const userInput = "<script>alert(\\"xss\\")</script>";',
    expected: { textContent: '<script>alert("xss")</script>' },
    sample: 'el.textContent = userInput; el',
    hints: ['textContent escapes HTML', 'Safe for displaying user input'],
    tags: ['dom', 'textContent', 'security', 'xss'],
  },

  // ========================================
  // DOM MANIPULATION - classList
  // ========================================
  {
    id: 'js-dom-028',
    category: 'DOM Manipulation',
    difficulty: 'easy',
    title: 'Add a Class',
    text: 'Add the class "active" to the element.',
    setup: 'const el = { classList: { classes: [], add(c) { this.classes.push(c); } } };',
    setupCode: 'const el = { classList: { classes: [], add(c) { this.classes.push(c); } } };',
    expected: { classList: { classes: ['active'] } },
    sample: 'el.classList.add("active"); el',
    hints: ['Use classList.add()', 'Pass class name as string'],
    tags: ['dom', 'classList', 'add'],
  },
  {
    id: 'js-dom-029',
    category: 'DOM Manipulation',
    difficulty: 'easy',
    title: 'Remove a Class',
    text: 'Remove the class "hidden" from the element.',
    setup: 'const el = { classList: { classes: ["visible", "hidden"], remove(c) { this.classes = this.classes.filter(x => x !== c); } } };',
    setupCode: 'const el = { classList: { classes: ["visible", "hidden"], remove(c) { this.classes = this.classes.filter(x => x !== c); } } };',
    expected: { classList: { classes: ['visible'] } },
    sample: 'el.classList.remove("hidden"); el',
    hints: ['Use classList.remove()', 'Only removes the specified class'],
    tags: ['dom', 'classList', 'remove'],
  },
  {
    id: 'js-dom-030',
    category: 'DOM Manipulation',
    difficulty: 'easy',
    title: 'Toggle a Class',
    text: 'Toggle the class "expanded" on the element (currently not present).',
    setup: 'const el = { classList: { classes: [], toggle(c) { if(this.classes.includes(c)) { this.classes = this.classes.filter(x => x !== c); return false; } else { this.classes.push(c); return true; } } } };',
    setupCode: 'const el = { classList: { classes: [], toggle(c) { if(this.classes.includes(c)) { this.classes = this.classes.filter(x => x !== c); return false; } else { this.classes.push(c); return true; } } } };',
    expected: true,
    sample: 'el.classList.toggle("expanded")',
    hints: ['toggle adds if not present', 'Returns true if class was added'],
    tags: ['dom', 'classList', 'toggle'],
  },
  {
    id: 'js-dom-031',
    category: 'DOM Manipulation',
    difficulty: 'easy',
    title: 'Check if Class Exists',
    text: 'Check if the element has the class "selected".',
    setup: 'const el = { classList: { contains(c) { return ["item", "selected", "blue"].includes(c); } } };',
    setupCode: 'const el = { classList: { contains(c) { return ["item", "selected", "blue"].includes(c); } } };',
    expected: true,
    sample: 'el.classList.contains("selected")',
    hints: ['Use classList.contains()', 'Returns a boolean'],
    tags: ['dom', 'classList', 'contains'],
  },
  {
    id: 'js-dom-032',
    category: 'DOM Manipulation',
    difficulty: 'medium',
    title: 'Add Multiple Classes',
    text: 'Add classes "btn", "btn-primary", and "large" in one call.',
    setup: 'const el = { classList: { classes: [], add(...args) { this.classes.push(...args); } } };',
    setupCode: 'const el = { classList: { classes: [], add(...args) { this.classes.push(...args); } } };',
    expected: { classList: { classes: ['btn', 'btn-primary', 'large'] } },
    sample: 'el.classList.add("btn", "btn-primary", "large"); el',
    hints: ['add() accepts multiple arguments', 'Pass all classes as separate arguments'],
    tags: ['dom', 'classList', 'add', 'multiple'],
  },
  {
    id: 'js-dom-033',
    category: 'DOM Manipulation',
    difficulty: 'medium',
    title: 'Replace a Class',
    text: 'Replace the class "old-style" with "new-style".',
    setup: 'const el = { classList: { classes: ["old-style", "other"], replace(old, newC) { const idx = this.classes.indexOf(old); if(idx !== -1) { this.classes[idx] = newC; return true; } return false; } } };',
    setupCode: 'const el = { classList: { classes: ["old-style", "other"], replace(old, newC) { const idx = this.classes.indexOf(old); if(idx !== -1) { this.classes[idx] = newC; return true; } return false; } } };',
    expected: true,
    sample: 'el.classList.replace("old-style", "new-style")',
    hints: ['Use classList.replace()', 'First argument is old class, second is new'],
    tags: ['dom', 'classList', 'replace'],
  },
  {
    id: 'js-dom-034',
    category: 'DOM Manipulation',
    difficulty: 'medium',
    title: 'Force Toggle Class',
    text: 'Force add the class "visible" regardless of current state.',
    setup: 'const el = { classList: { classes: ["visible"], toggle(c, force) { if(force === true && !this.classes.includes(c)) { this.classes.push(c); } else if(force === false) { this.classes = this.classes.filter(x => x !== c); } return force; } } };',
    setupCode: 'const el = { classList: { classes: ["visible"], toggle(c, force) { if(force === true && !this.classes.includes(c)) { this.classes.push(c); } else if(force === false) { this.classes = this.classes.filter(x => x !== c); } return force; } } };',
    expected: true,
    sample: 'el.classList.toggle("visible", true)',
    hints: ['Second argument forces add/remove', 'true forces add, false forces remove'],
    tags: ['dom', 'classList', 'toggle', 'force'],
  },
  {
    id: 'js-dom-035',
    category: 'DOM Manipulation',
    difficulty: 'hard',
    title: 'Conditional Class Toggle',
    text: 'Add "error" class if value is empty, otherwise add "valid" class.',
    setup: 'const value = "test"; const el = { classList: { classes: [], add(c) { this.classes.push(c); } } };',
    setupCode: 'const value = "test"; const el = { classList: { classes: [], add(c) { this.classes.push(c); } } };',
    expected: { classList: { classes: ['valid'] } },
    sample: 'el.classList.add(value === "" ? "error" : "valid"); el',
    hints: ['Use ternary operator', 'Check if value is empty string'],
    tags: ['dom', 'classList', 'conditional'],
  },

  // ========================================
  // EVENTS - addEventListener
  // ========================================
  {
    id: 'js-dom-036',
    category: 'Events',
    difficulty: 'easy',
    title: 'Add Click Listener',
    text: 'Add a click event listener that sets clicked to true.',
    setup: 'let clicked = false; const el = { addEventListener(type, handler) { if(type === "click") handler(); } };',
    setupCode: 'let clicked = false; const el = { addEventListener(type, handler) { if(type === "click") handler(); } };',
    expected: true,
    sample: 'el.addEventListener("click", () => { clicked = true; }); clicked',
    hints: ['First argument is event type', 'Second argument is callback function'],
    tags: ['events', 'addEventListener', 'click'],
  },
  {
    id: 'js-dom-037',
    category: 'Events',
    difficulty: 'easy',
    title: 'Mouse Enter Event',
    text: 'Add a mouseenter event listener that sets hovered to true.',
    setup: 'let hovered = false; const el = { addEventListener(type, handler) { if(type === "mouseenter") handler(); } };',
    setupCode: 'let hovered = false; const el = { addEventListener(type, handler) { if(type === "mouseenter") handler(); } };',
    expected: true,
    sample: 'el.addEventListener("mouseenter", () => { hovered = true; }); hovered',
    hints: ['Use "mouseenter" event type', 'Fires when mouse enters element'],
    tags: ['events', 'addEventListener', 'mouse'],
  },
  {
    id: 'js-dom-038',
    category: 'Events',
    difficulty: 'easy',
    title: 'Keyboard Event',
    text: 'Add a keydown event listener that captures the key pressed.',
    setup: 'let pressedKey = ""; const el = { addEventListener(type, handler) { if(type === "keydown") handler({ key: "Enter" }); } };',
    setupCode: 'let pressedKey = ""; const el = { addEventListener(type, handler) { if(type === "keydown") handler({ key: "Enter" }); } };',
    expected: 'Enter',
    sample: 'el.addEventListener("keydown", (e) => { pressedKey = e.key; }); pressedKey',
    hints: ['Event object has key property', 'Use arrow function with event parameter'],
    tags: ['events', 'addEventListener', 'keyboard'],
  },
  {
    id: 'js-dom-039',
    category: 'Events',
    difficulty: 'easy',
    title: 'Form Submit Event',
    text: 'Add a submit event listener that prevents default behavior.',
    setup: 'let prevented = false; const form = { addEventListener(type, handler) { if(type === "submit") handler({ preventDefault() { prevented = true; } }); } };',
    setupCode: 'let prevented = false; const form = { addEventListener(type, handler) { if(type === "submit") handler({ preventDefault() { prevented = true; } }); } };',
    expected: true,
    sample: 'form.addEventListener("submit", (e) => { e.preventDefault(); }); prevented',
    hints: ['Call e.preventDefault()', 'Stops form from submitting normally'],
    tags: ['events', 'addEventListener', 'form', 'preventDefault'],
  },
  {
    id: 'js-dom-040',
    category: 'Events',
    difficulty: 'medium',
    title: 'Input Event Handler',
    text: 'Track input value changes in real-time.',
    setup: 'let inputValue = ""; const input = { addEventListener(type, handler) { if(type === "input") handler({ target: { value: "Hello" } }); } };',
    setupCode: 'let inputValue = ""; const input = { addEventListener(type, handler) { if(type === "input") handler({ target: { value: "Hello" } }); } };',
    expected: 'Hello',
    sample: 'input.addEventListener("input", (e) => { inputValue = e.target.value; }); inputValue',
    hints: ['Use "input" event for real-time tracking', 'Access value via e.target.value'],
    tags: ['events', 'addEventListener', 'input'],
  },
  {
    id: 'js-dom-041',
    category: 'Events',
    difficulty: 'medium',
    title: 'Remove Event Listener',
    text: 'Add and then remove an event listener. Return removed status.',
    setup: 'const handler = () => {}; let removed = false; const el = { addEventListener() {}, removeEventListener(type, fn) { if(fn === handler) removed = true; } };',
    setupCode: 'const handler = () => {}; let removed = false; const el = { addEventListener() {}, removeEventListener(type, fn) { if(fn === handler) removed = true; } };',
    expected: true,
    sample: 'el.addEventListener("click", handler); el.removeEventListener("click", handler); removed',
    hints: ['Store handler in a variable', 'Must pass same function reference to remove'],
    tags: ['events', 'removeEventListener'],
  },
  {
    id: 'js-dom-042',
    category: 'Events',
    difficulty: 'medium',
    title: 'Once Event Option',
    text: 'Add an event listener that only fires once.',
    setup: 'let count = 0; const el = { addEventListener(type, handler, options) { if(options?.once) { handler(); } else { handler(); handler(); } } };',
    setupCode: 'let count = 0; const el = { addEventListener(type, handler, options) { if(options?.once) { handler(); } else { handler(); handler(); } } };',
    expected: 1,
    sample: 'el.addEventListener("click", () => { count++; }, { once: true }); count',
    hints: ['Third argument is options object', 'Use { once: true }'],
    tags: ['events', 'addEventListener', 'options'],
  },
  {
    id: 'js-dom-043',
    category: 'Events',
    difficulty: 'medium',
    title: 'Focus and Blur Events',
    text: 'Track focus state of an input element.',
    setup: 'let focused = false; const input = { addEventListener(type, handler) { if(type === "focus") handler(); if(type === "blur") setTimeout(() => handler(), 0); } };',
    setupCode: 'let focused = false; const input = { addEventListener(type, handler) { if(type === "focus") handler(); if(type === "blur") setTimeout(() => handler(), 0); } };',
    expected: true,
    sample: 'input.addEventListener("focus", () => { focused = true; }); focused',
    hints: ['Use "focus" event', 'Fires when element receives focus'],
    tags: ['events', 'addEventListener', 'focus'],
  },
  {
    id: 'js-dom-044',
    category: 'Events',
    difficulty: 'hard',
    title: 'Debounced Event Handler',
    text: 'Create a debounced handler that delays execution by 100ms.',
    setup: 'let lastCall = 0; const debounce = (fn, delay) => { let timeout; return (...args) => { clearTimeout(timeout); timeout = setTimeout(() => fn(...args), delay); return delay; }; };',
    setupCode: 'let lastCall = 0; const debounce = (fn, delay) => { let timeout; return (...args) => { clearTimeout(timeout); timeout = setTimeout(() => fn(...args), delay); return delay; }; };',
    expected: 100,
    sample: 'const handler = debounce(() => { lastCall = Date.now(); }, 100); handler()',
    hints: ['Debounce delays function execution', 'Resets timer on each call'],
    tags: ['events', 'debounce', 'performance'],
  },
  {
    id: 'js-dom-045',
    category: 'Events',
    difficulty: 'hard',
    title: 'Throttled Event Handler',
    text: 'Create a throttled handler that limits execution to once per 100ms.',
    setup: 'const throttle = (fn, limit) => { let inThrottle = false; return (...args) => { if (!inThrottle) { fn(...args); inThrottle = true; setTimeout(() => inThrottle = false, limit); return true; } return false; }; };',
    setupCode: 'const throttle = (fn, limit) => { let inThrottle = false; return (...args) => { if (!inThrottle) { fn(...args); inThrottle = true; setTimeout(() => inThrottle = false, limit); return true; } return false; }; };',
    expected: true,
    sample: 'const handler = throttle(() => {}, 100); handler()',
    hints: ['Throttle limits execution rate', 'First call executes immediately'],
    tags: ['events', 'throttle', 'performance'],
  },

  // ========================================
  // EVENTS - Event Delegation
  // ========================================
  {
    id: 'js-dom-046',
    category: 'Events',
    difficulty: 'medium',
    title: 'Basic Event Delegation',
    text: 'Use event delegation to handle clicks on list items.',
    setup: 'let clickedItem = ""; const ul = { addEventListener(type, handler) { if(type === "click") handler({ target: { tagName: "LI", textContent: "Item 2" } }); } };',
    setupCode: 'let clickedItem = ""; const ul = { addEventListener(type, handler) { if(type === "click") handler({ target: { tagName: "LI", textContent: "Item 2" } }); } };',
    expected: 'Item 2',
    sample: 'ul.addEventListener("click", (e) => { if(e.target.tagName === "LI") clickedItem = e.target.textContent; }); clickedItem',
    hints: ['Check e.target.tagName', 'Listen on parent, filter by target'],
    tags: ['events', 'delegation', 'patterns'],
  },
  {
    id: 'js-dom-047',
    category: 'Events',
    difficulty: 'medium',
    title: 'Delegation with Matches',
    text: 'Use matches() to check if clicked element matches a selector.',
    setup: 'let matched = false; const container = { addEventListener(type, handler) { if(type === "click") handler({ target: { matches: (sel) => sel === ".btn" } }); } };',
    setupCode: 'let matched = false; const container = { addEventListener(type, handler) { if(type === "click") handler({ target: { matches: (sel) => sel === ".btn" } }); } };',
    expected: true,
    sample: 'container.addEventListener("click", (e) => { if(e.target.matches(".btn")) matched = true; }); matched',
    hints: ['Use element.matches() method', 'Pass CSS selector to matches()'],
    tags: ['events', 'delegation', 'matches'],
  },
  {
    id: 'js-dom-048',
    category: 'Events',
    difficulty: 'medium',
    title: 'Closest Ancestor Delegation',
    text: 'Find the closest ancestor matching a selector when clicking nested elements.',
    setup: 'let foundCard = null; const container = { addEventListener(type, handler) { if(type === "click") handler({ target: { closest: (sel) => sel === ".card" ? { id: "card-1" } : null } }); } };',
    setupCode: 'let foundCard = null; const container = { addEventListener(type, handler) { if(type === "click") handler({ target: { closest: (sel) => sel === ".card" ? { id: "card-1" } : null } }); } };',
    expected: { id: 'card-1' },
    sample: 'container.addEventListener("click", (e) => { foundCard = e.target.closest(".card"); }); foundCard',
    hints: ['Use closest() to find ancestor', 'Returns null if no match found'],
    tags: ['events', 'delegation', 'closest'],
  },
  {
    id: 'js-dom-049',
    category: 'Events',
    difficulty: 'hard',
    title: 'Dynamic Element Handling',
    text: 'Handle clicks on dynamically added elements using delegation.',
    setup: 'const clicks = []; const parent = { addEventListener(type, handler) { handler({ target: { dataset: { action: "delete" }, closest: () => ({ id: "item-5" }) } }); } };',
    setupCode: 'const clicks = []; const parent = { addEventListener(type, handler) { handler({ target: { dataset: { action: "delete" }, closest: () => ({ id: "item-5" }) } }); } };',
    expected: [{ action: 'delete', itemId: 'item-5' }],
    sample: 'parent.addEventListener("click", (e) => { if(e.target.dataset.action) clicks.push({ action: e.target.dataset.action, itemId: e.target.closest("[id]").id }); }); clicks',
    hints: ['Use data attributes for actions', 'Combine dataset with closest()'],
    tags: ['events', 'delegation', 'dynamic'],
  },
  {
    id: 'js-dom-050',
    category: 'Events',
    difficulty: 'hard',
    title: 'Multiple Action Delegation',
    text: 'Handle multiple action types (edit, delete, view) with single listener.',
    setup: 'const actions = { edit: 0, delete: 0, view: 0 }; const container = { addEventListener(type, handler) { handler({ target: { dataset: { action: "edit" } } }); handler({ target: { dataset: { action: "delete" } } }); } };',
    setupCode: 'const actions = { edit: 0, delete: 0, view: 0 }; const container = { addEventListener(type, handler) { handler({ target: { dataset: { action: "edit" } } }); handler({ target: { dataset: { action: "delete" } } }); } };',
    expected: { edit: 1, delete: 1, view: 0 },
    sample: 'container.addEventListener("click", (e) => { const action = e.target.dataset.action; if(action && actions[action] !== undefined) actions[action]++; }); actions',
    hints: ['Read action from dataset', 'Use computed property access'],
    tags: ['events', 'delegation', 'actions'],
  },

  // ========================================
  // EVENTS - Bubbling and Capturing
  // ========================================
  {
    id: 'js-dom-051',
    category: 'Events',
    difficulty: 'medium',
    title: 'Stop Event Propagation',
    text: 'Stop an event from bubbling up to parent elements.',
    setup: 'let bubbled = true; const child = { addEventListener(type, handler) { handler({ stopPropagation() { bubbled = false; } }); } };',
    setupCode: 'let bubbled = true; const child = { addEventListener(type, handler) { handler({ stopPropagation() { bubbled = false; } }); } };',
    expected: false,
    sample: 'child.addEventListener("click", (e) => { e.stopPropagation(); }); bubbled',
    hints: ['Call e.stopPropagation()', 'Prevents event from reaching parent'],
    tags: ['events', 'propagation', 'bubbling'],
  },
  {
    id: 'js-dom-052',
    category: 'Events',
    difficulty: 'medium',
    title: 'Capture Phase Listener',
    text: 'Add an event listener that fires during capture phase.',
    setup: 'let phase = ""; const el = { addEventListener(type, handler, options) { phase = options === true || options?.capture ? "capture" : "bubble"; } };',
    setupCode: 'let phase = ""; const el = { addEventListener(type, handler, options) { phase = options === true || options?.capture ? "capture" : "bubble"; } };',
    expected: 'capture',
    sample: 'el.addEventListener("click", () => {}, true); phase',
    hints: ['Pass true as third argument', 'Or use { capture: true }'],
    tags: ['events', 'capture', 'propagation'],
  },
  {
    id: 'js-dom-053',
    category: 'Events',
    difficulty: 'medium',
    title: 'Check Event Phase',
    text: 'Determine the current event phase.',
    setup: 'const PHASES = { CAPTURING: 1, AT_TARGET: 2, BUBBLING: 3 }; const event = { eventPhase: 3 };',
    setupCode: 'const PHASES = { CAPTURING: 1, AT_TARGET: 2, BUBBLING: 3 }; const event = { eventPhase: 3 };',
    expected: 'bubbling',
    sample: 'event.eventPhase === PHASES.BUBBLING ? "bubbling" : event.eventPhase === PHASES.CAPTURING ? "capturing" : "at_target"',
    hints: ['eventPhase is a number', '1=capturing, 2=at target, 3=bubbling'],
    tags: ['events', 'phase', 'propagation'],
  },
  {
    id: 'js-dom-054',
    category: 'Events',
    difficulty: 'hard',
    title: 'Stop Immediate Propagation',
    text: 'Stop other listeners on the same element from being called.',
    setup: 'let count = 0; const el = { handlers: [], addEventListener(type, handler) { this.handlers.push(handler); }, fire(e) { for(const h of this.handlers) { h(e); if(e.stopped) break; } } };',
    setupCode: 'let count = 0; const el = { handlers: [], addEventListener(type, handler) { this.handlers.push(handler); }, fire(e) { for(const h of this.handlers) { h(e); if(e.stopped) break; } } };',
    expected: 1,
    sample: 'el.addEventListener("click", (e) => { count++; e.stopImmediatePropagation(); e.stopped = true; }); el.addEventListener("click", () => { count++; }); el.fire({}); count',
    hints: ['Use stopImmediatePropagation()', 'Prevents other handlers on same element'],
    tags: ['events', 'propagation', 'immediate'],
  },
  {
    id: 'js-dom-055',
    category: 'Events',
    difficulty: 'hard',
    title: 'Event Target vs CurrentTarget',
    text: 'Distinguish between the clicked element and the listening element.',
    setup: 'const event = { target: { id: "inner-btn" }, currentTarget: { id: "outer-div" } };',
    setupCode: 'const event = { target: { id: "inner-btn" }, currentTarget: { id: "outer-div" } };',
    expected: { clicked: 'inner-btn', listener: 'outer-div' },
    sample: '({ clicked: event.target.id, listener: event.currentTarget.id })',
    hints: ['target is the actual clicked element', 'currentTarget is where listener is attached'],
    tags: ['events', 'target', 'currentTarget'],
  },

  // ========================================
  // BROWSER APIs - localStorage/sessionStorage
  // ========================================
  {
    id: 'js-dom-056',
    category: 'Browser APIs',
    difficulty: 'easy',
    title: 'Set Local Storage Item',
    text: 'Store a value in localStorage with key "username".',
    setup: 'const localStorage = { data: {}, setItem(key, value) { this.data[key] = value; } };',
    setupCode: 'const localStorage = { data: {}, setItem(key, value) { this.data[key] = value; } };',
    expected: { data: { username: 'john_doe' } },
    sample: 'localStorage.setItem("username", "john_doe"); localStorage',
    hints: ['Use setItem(key, value)', 'Values are stored as strings'],
    tags: ['localStorage', 'storage', 'setItem'],
  },
  {
    id: 'js-dom-057',
    category: 'Browser APIs',
    difficulty: 'easy',
    title: 'Get Local Storage Item',
    text: 'Retrieve the value stored with key "theme".',
    setup: 'const localStorage = { getItem(key) { return key === "theme" ? "dark" : null; } };',
    setupCode: 'const localStorage = { getItem(key) { return key === "theme" ? "dark" : null; } };',
    expected: 'dark',
    sample: 'localStorage.getItem("theme")',
    hints: ['Use getItem(key)', 'Returns null if key not found'],
    tags: ['localStorage', 'storage', 'getItem'],
  },
  {
    id: 'js-dom-058',
    category: 'Browser APIs',
    difficulty: 'easy',
    title: 'Remove Local Storage Item',
    text: 'Remove the item with key "token" from localStorage.',
    setup: 'const localStorage = { data: { token: "abc123", user: "john" }, removeItem(key) { delete this.data[key]; } };',
    setupCode: 'const localStorage = { data: { token: "abc123", user: "john" }, removeItem(key) { delete this.data[key]; } };',
    expected: { data: { user: 'john' } },
    sample: 'localStorage.removeItem("token"); localStorage',
    hints: ['Use removeItem(key)', 'Only removes specified key'],
    tags: ['localStorage', 'storage', 'removeItem'],
  },
  {
    id: 'js-dom-059',
    category: 'Browser APIs',
    difficulty: 'easy',
    title: 'Clear All Storage',
    text: 'Clear all items from localStorage.',
    setup: 'const localStorage = { data: { a: "1", b: "2", c: "3" }, clear() { this.data = {}; } };',
    setupCode: 'const localStorage = { data: { a: "1", b: "2", c: "3" }, clear() { this.data = {}; } };',
    expected: { data: {} },
    sample: 'localStorage.clear(); localStorage',
    hints: ['Use clear() method', 'Removes all stored items'],
    tags: ['localStorage', 'storage', 'clear'],
  },
  {
    id: 'js-dom-060',
    category: 'Browser APIs',
    difficulty: 'medium',
    title: 'Store Object in Storage',
    text: 'Store a user object in localStorage (requires serialization).',
    setup: 'const localStorage = { data: {}, setItem(key, value) { this.data[key] = value; } }; const user = { name: "Alice", age: 25 };',
    setupCode: 'const localStorage = { data: {}, setItem(key, value) { this.data[key] = value; } }; const user = { name: "Alice", age: 25 };',
    expected: { data: { user: '{"name":"Alice","age":25}' } },
    sample: 'localStorage.setItem("user", JSON.stringify(user)); localStorage',
    hints: ['Use JSON.stringify()', 'localStorage only stores strings'],
    tags: ['localStorage', 'storage', 'JSON'],
  },
  {
    id: 'js-dom-061',
    category: 'Browser APIs',
    difficulty: 'medium',
    title: 'Retrieve and Parse Object',
    text: 'Get a stored JSON string and parse it back to an object.',
    setup: 'const localStorage = { getItem(key) { return key === "settings" ? \'{"theme":"dark","fontSize":14}\' : null; } };',
    setupCode: 'const localStorage = { getItem(key) { return key === "settings" ? \'{"theme":"dark","fontSize":14}\' : null; } };',
    expected: { theme: 'dark', fontSize: 14 },
    sample: 'JSON.parse(localStorage.getItem("settings"))',
    hints: ['Use JSON.parse()', 'Handle null case in real apps'],
    tags: ['localStorage', 'storage', 'JSON'],
  },
  {
    id: 'js-dom-062',
    category: 'Browser APIs',
    difficulty: 'medium',
    title: 'Check Storage Length',
    text: 'Get the number of items stored in localStorage.',
    setup: 'const localStorage = { length: 5 };',
    setupCode: 'const localStorage = { length: 5 };',
    expected: 5,
    sample: 'localStorage.length',
    hints: ['Use length property', 'Returns number of stored items'],
    tags: ['localStorage', 'storage', 'length'],
  },
  {
    id: 'js-dom-063',
    category: 'Browser APIs',
    difficulty: 'medium',
    title: 'Iterate Storage Keys',
    text: 'Get the key at index 0 in localStorage.',
    setup: 'const localStorage = { key(index) { return ["theme", "user", "token"][index]; } };',
    setupCode: 'const localStorage = { key(index) { return ["theme", "user", "token"][index]; } };',
    expected: 'theme',
    sample: 'localStorage.key(0)',
    hints: ['Use key(index) method', 'Returns key name at given index'],
    tags: ['localStorage', 'storage', 'iteration'],
  },
  {
    id: 'js-dom-064',
    category: 'Browser APIs',
    difficulty: 'hard',
    title: 'Storage with Expiration',
    text: 'Store data with an expiration timestamp and check if expired.',
    setup: 'const now = Date.now(); const stored = { value: "data", expires: now + 3600000 };',
    setupCode: 'const now = Date.now(); const stored = { value: "data", expires: now + 3600000 };',
    expected: false,
    sample: 'stored.expires < now',
    hints: ['Compare expiration with current time', 'Use Date.now() for comparison'],
    tags: ['localStorage', 'storage', 'expiration'],
  },
  {
    id: 'js-dom-065',
    category: 'Browser APIs',
    difficulty: 'hard',
    title: 'Storage Event Listener',
    text: 'Detect when localStorage changes in another tab.',
    setup: 'let changed = null; const window = { addEventListener(type, handler) { if(type === "storage") handler({ key: "theme", newValue: "light", oldValue: "dark" }); } };',
    setupCode: 'let changed = null; const window = { addEventListener(type, handler) { if(type === "storage") handler({ key: "theme", newValue: "light", oldValue: "dark" }); } };',
    expected: { key: 'theme', from: 'dark', to: 'light' },
    sample: 'window.addEventListener("storage", (e) => { changed = { key: e.key, from: e.oldValue, to: e.newValue }; }); changed',
    hints: ['Listen for "storage" event on window', 'Event has key, oldValue, newValue'],
    tags: ['localStorage', 'storage', 'events'],
  },

  // ========================================
  // BROWSER APIs - Fetch API
  // ========================================
  {
    id: 'js-dom-066',
    category: 'Browser APIs',
    difficulty: 'easy',
    title: 'Basic Fetch Request',
    text: 'Make a GET request to an API endpoint.',
    setup: 'const fetch = (url) => Promise.resolve({ url, ok: true, status: 200 });',
    setupCode: 'const fetch = (url) => Promise.resolve({ url, ok: true, status: 200 });',
    expected: { url: 'https://api.example.com/data', ok: true, status: 200 },
    sample: 'await fetch("https://api.example.com/data")',
    hints: ['fetch returns a Promise', 'Use await or .then()'],
    tags: ['fetch', 'api', 'GET'],
  },
  {
    id: 'js-dom-067',
    category: 'Browser APIs',
    difficulty: 'easy',
    title: 'Parse JSON Response',
    text: 'Fetch data and parse the JSON response.',
    setup: 'const fetch = () => Promise.resolve({ json: () => Promise.resolve({ id: 1, name: "Test" }) });',
    setupCode: 'const fetch = () => Promise.resolve({ json: () => Promise.resolve({ id: 1, name: "Test" }) });',
    expected: { id: 1, name: 'Test' },
    sample: 'await fetch("https://api.example.com/item").then(r => r.json())',
    hints: ['Call .json() on response', 'json() also returns a Promise'],
    tags: ['fetch', 'api', 'JSON'],
  },
  {
    id: 'js-dom-068',
    category: 'Browser APIs',
    difficulty: 'medium',
    title: 'POST Request with Body',
    text: 'Make a POST request with JSON body.',
    setup: 'const fetch = (url, options) => Promise.resolve({ url, method: options?.method, body: options?.body, headers: options?.headers });',
    setupCode: 'const fetch = (url, options) => Promise.resolve({ url, method: options?.method, body: options?.body, headers: options?.headers });',
    expected: { url: 'https://api.example.com/users', method: 'POST', body: '{"name":"John"}', headers: { 'Content-Type': 'application/json' } },
    sample: 'await fetch("https://api.example.com/users", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ name: "John" }) })',
    hints: ['Set method to "POST"', 'Stringify body and set Content-Type header'],
    tags: ['fetch', 'api', 'POST'],
  },
  {
    id: 'js-dom-069',
    category: 'Browser APIs',
    difficulty: 'medium',
    title: 'Check Response Status',
    text: 'Check if a fetch request was successful using ok property.',
    setup: 'const response = { ok: false, status: 404, statusText: "Not Found" };',
    setupCode: 'const response = { ok: false, status: 404, statusText: "Not Found" };',
    expected: 'Error: 404 Not Found',
    sample: 'response.ok ? "Success" : `Error: ${response.status} ${response.statusText}`',
    hints: ['Check response.ok first', 'ok is true for status 200-299'],
    tags: ['fetch', 'api', 'errors'],
  },
  {
    id: 'js-dom-070',
    category: 'Browser APIs',
    difficulty: 'medium',
    title: 'Fetch with Headers',
    text: 'Make a request with authorization header.',
    setup: 'const fetch = (url, options) => Promise.resolve({ authHeader: options?.headers?.Authorization });',
    setupCode: 'const fetch = (url, options) => Promise.resolve({ authHeader: options?.headers?.Authorization });',
    expected: { authHeader: 'Bearer token123' },
    sample: 'await fetch("https://api.example.com/protected", { headers: { Authorization: "Bearer token123" } })',
    hints: ['Pass headers in options object', 'Use Authorization header for tokens'],
    tags: ['fetch', 'api', 'headers', 'auth'],
  },
  {
    id: 'js-dom-071',
    category: 'Browser APIs',
    difficulty: 'medium',
    title: 'Handle Fetch Errors',
    text: 'Catch network errors from fetch.',
    setup: 'const fetch = () => Promise.reject(new Error("Network error"));',
    setupCode: 'const fetch = () => Promise.reject(new Error("Network error"));',
    expected: 'Network error',
    sample: 'await fetch("https://api.example.com").catch(e => e.message)',
    hints: ['Use .catch() for errors', 'Network failures reject the promise'],
    tags: ['fetch', 'api', 'errors'],
  },
  {
    id: 'js-dom-072',
    category: 'Browser APIs',
    difficulty: 'hard',
    title: 'Abort Fetch Request',
    text: 'Create an AbortController and use its signal to abort a fetch.',
    setup: 'const AbortController = class { constructor() { this.signal = { aborted: false }; } abort() { this.signal.aborted = true; } };',
    setupCode: 'const AbortController = class { constructor() { this.signal = { aborted: false }; } abort() { this.signal.aborted = true; } };',
    expected: true,
    sample: 'const controller = new AbortController(); controller.abort(); controller.signal.aborted',
    hints: ['Create AbortController instance', 'Call abort() to cancel request'],
    tags: ['fetch', 'api', 'abort'],
  },
  {
    id: 'js-dom-073',
    category: 'Browser APIs',
    difficulty: 'hard',
    title: 'Fetch with Timeout',
    text: 'Implement a fetch with timeout using AbortController.',
    setup: 'const AbortController = class { constructor() { this.signal = { aborted: false }; } abort() { this.signal.aborted = true; } }; const fetchWithTimeout = (url, timeout) => { const controller = new AbortController(); setTimeout(() => controller.abort(), timeout); return { signal: controller.signal }; };',
    setupCode: 'const AbortController = class { constructor() { this.signal = { aborted: false }; } abort() { this.signal.aborted = true; } }; const fetchWithTimeout = (url, timeout) => { const controller = new AbortController(); setTimeout(() => controller.abort(), timeout); return { signal: controller.signal }; };',
    expected: false,
    sample: 'fetchWithTimeout("https://api.example.com", 5000).signal.aborted',
    hints: ['Combine AbortController with setTimeout', 'Abort after timeout period'],
    tags: ['fetch', 'api', 'timeout', 'abort'],
  },
  {
    id: 'js-dom-074',
    category: 'Browser APIs',
    difficulty: 'hard',
    title: 'Parallel Fetch Requests',
    text: 'Fetch multiple endpoints in parallel using Promise.all.',
    setup: 'const fetch = (url) => Promise.resolve({ url, data: url.split("/").pop() }); const urls = ["https://api.example.com/a", "https://api.example.com/b", "https://api.example.com/c"];',
    setupCode: 'const fetch = (url) => Promise.resolve({ url, data: url.split("/").pop() }); const urls = ["https://api.example.com/a", "https://api.example.com/b", "https://api.example.com/c"];',
    expected: ['a', 'b', 'c'],
    sample: 'await Promise.all(urls.map(url => fetch(url))).then(responses => responses.map(r => r.data))',
    hints: ['Use Promise.all with map', 'All requests run simultaneously'],
    tags: ['fetch', 'api', 'Promise.all', 'parallel'],
  },

  // ========================================
  // BROWSER APIs - FormData
  // ========================================
  {
    id: 'js-dom-075',
    category: 'Browser APIs',
    difficulty: 'easy',
    title: 'Create FormData',
    text: 'Create a new FormData instance and append a field.',
    setup: 'const FormData = class { constructor() { this.data = {}; } append(key, value) { this.data[key] = value; } };',
    setupCode: 'const FormData = class { constructor() { this.data = {}; } append(key, value) { this.data[key] = value; } };',
    expected: { data: { username: 'john' } },
    sample: 'const fd = new FormData(); fd.append("username", "john"); fd',
    hints: ['Use new FormData()', 'Call append() to add fields'],
    tags: ['FormData', 'forms', 'append'],
  },
  {
    id: 'js-dom-076',
    category: 'Browser APIs',
    difficulty: 'easy',
    title: 'Get FormData Value',
    text: 'Retrieve a value from FormData.',
    setup: 'const formData = { get(key) { const data = { email: "test@example.com" }; return data[key] || null; } };',
    setupCode: 'const formData = { get(key) { const data = { email: "test@example.com" }; return data[key] || null; } };',
    expected: 'test@example.com',
    sample: 'formData.get("email")',
    hints: ['Use get() method', 'Returns null if key not found'],
    tags: ['FormData', 'forms', 'get'],
  },
  {
    id: 'js-dom-077',
    category: 'Browser APIs',
    difficulty: 'medium',
    title: 'FormData from Form Element',
    text: 'Create FormData from an existing form element.',
    setup: 'const form = { elements: [{ name: "user", value: "alice" }, { name: "pass", value: "secret" }] }; const FormData = class { constructor(f) { this.data = {}; if(f) f.elements.forEach(e => this.data[e.name] = e.value); } };',
    setupCode: 'const form = { elements: [{ name: "user", value: "alice" }, { name: "pass", value: "secret" }] }; const FormData = class { constructor(f) { this.data = {}; if(f) f.elements.forEach(e => this.data[e.name] = e.value); } };',
    expected: { data: { user: 'alice', pass: 'secret' } },
    sample: 'new FormData(form)',
    hints: ['Pass form element to constructor', 'Automatically captures all form fields'],
    tags: ['FormData', 'forms', 'constructor'],
  },
  {
    id: 'js-dom-078',
    category: 'Browser APIs',
    difficulty: 'medium',
    title: 'Check if FormData Has Key',
    text: 'Check if a key exists in FormData.',
    setup: 'const formData = { has(key) { return ["name", "email", "age"].includes(key); } };',
    setupCode: 'const formData = { has(key) { return ["name", "email", "age"].includes(key); } };',
    expected: true,
    sample: 'formData.has("email")',
    hints: ['Use has() method', 'Returns boolean'],
    tags: ['FormData', 'forms', 'has'],
  },
  {
    id: 'js-dom-079',
    category: 'Browser APIs',
    difficulty: 'medium',
    title: 'Delete FormData Entry',
    text: 'Remove a field from FormData.',
    setup: 'const formData = { data: { a: "1", b: "2", c: "3" }, delete(key) { delete this.data[key]; } };',
    setupCode: 'const formData = { data: { a: "1", b: "2", c: "3" }, delete(key) { delete this.data[key]; } };',
    expected: { data: { a: '1', c: '3' } },
    sample: 'formData.delete("b"); formData',
    hints: ['Use delete() method', 'Removes specified key'],
    tags: ['FormData', 'forms', 'delete'],
  },
  {
    id: 'js-dom-080',
    category: 'Browser APIs',
    difficulty: 'hard',
    title: 'Iterate FormData Entries',
    text: 'Convert FormData entries to an array of [key, value] pairs.',
    setup: 'const formData = { entries() { return [["name", "John"], ["age", "30"], ["city", "NYC"]][Symbol.iterator](); } };',
    setupCode: 'const formData = { entries() { return [["name", "John"], ["age", "30"], ["city", "NYC"]][Symbol.iterator](); } };',
    expected: [['name', 'John'], ['age', '30'], ['city', 'NYC']],
    sample: '[...formData.entries()]',
    hints: ['Use entries() method', 'Spread into array'],
    tags: ['FormData', 'forms', 'entries', 'iteration'],
  },
  {
    id: 'js-dom-081',
    category: 'Browser APIs',
    difficulty: 'hard',
    title: 'FormData to Object',
    text: 'Convert FormData to a plain JavaScript object.',
    setup: 'const formData = { entries() { return [["firstName", "Jane"], ["lastName", "Doe"]][Symbol.iterator](); } };',
    setupCode: 'const formData = { entries() { return [["firstName", "Jane"], ["lastName", "Doe"]][Symbol.iterator](); } };',
    expected: { firstName: 'Jane', lastName: 'Doe' },
    sample: 'Object.fromEntries(formData.entries())',
    hints: ['Use Object.fromEntries()', 'Pass entries iterator'],
    tags: ['FormData', 'forms', 'conversion'],
  },

  // ========================================
  // BROWSER APIs - URLSearchParams
  // ========================================
  {
    id: 'js-dom-082',
    category: 'Browser APIs',
    difficulty: 'easy',
    title: 'Create URLSearchParams',
    text: 'Create URLSearchParams from a query string.',
    setup: 'const URLSearchParams = class { constructor(str) { this.params = {}; str.replace("?", "").split("&").forEach(p => { const [k, v] = p.split("="); this.params[k] = v; }); } get(k) { return this.params[k]; } };',
    setupCode: 'const URLSearchParams = class { constructor(str) { this.params = {}; str.replace("?", "").split("&").forEach(p => { const [k, v] = p.split("="); this.params[k] = v; }); } get(k) { return this.params[k]; } };',
    expected: 'bar',
    sample: 'new URLSearchParams("?foo=bar&baz=qux").get("foo")',
    hints: ['Pass query string to constructor', 'Use get() to retrieve values'],
    tags: ['URLSearchParams', 'url', 'query'],
  },
  {
    id: 'js-dom-083',
    category: 'Browser APIs',
    difficulty: 'easy',
    title: 'Append Search Param',
    text: 'Add a new parameter to URLSearchParams.',
    setup: 'const params = { data: { page: "1" }, append(key, value) { this.data[key] = value; } };',
    setupCode: 'const params = { data: { page: "1" }, append(key, value) { this.data[key] = value; } };',
    expected: { data: { page: '1', limit: '10' } },
    sample: 'params.append("limit", "10"); params',
    hints: ['Use append() method', 'Both key and value are strings'],
    tags: ['URLSearchParams', 'url', 'append'],
  },
  {
    id: 'js-dom-084',
    category: 'Browser APIs',
    difficulty: 'easy',
    title: 'Convert Params to String',
    text: 'Convert URLSearchParams back to a query string.',
    setup: 'const params = { toString() { return "name=John&age=25"; } };',
    setupCode: 'const params = { toString() { return "name=John&age=25"; } };',
    expected: 'name=John&age=25',
    sample: 'params.toString()',
    hints: ['Use toString() method', 'Returns URL-encoded string'],
    tags: ['URLSearchParams', 'url', 'toString'],
  },
  {
    id: 'js-dom-085',
    category: 'Browser APIs',
    difficulty: 'medium',
    title: 'Set Search Param',
    text: 'Set (replace) a parameter value.',
    setup: 'const params = { data: { sort: "asc", filter: "active" }, set(key, value) { this.data[key] = value; } };',
    setupCode: 'const params = { data: { sort: "asc", filter: "active" }, set(key, value) { this.data[key] = value; } };',
    expected: { data: { sort: 'desc', filter: 'active' } },
    sample: 'params.set("sort", "desc"); params',
    hints: ['Use set() to replace value', 'Unlike append, set replaces existing'],
    tags: ['URLSearchParams', 'url', 'set'],
  },
  {
    id: 'js-dom-086',
    category: 'Browser APIs',
    difficulty: 'medium',
    title: 'Get All Param Values',
    text: 'Get all values for a parameter that appears multiple times.',
    setup: 'const params = { getAll(key) { return key === "tag" ? ["javascript", "web", "frontend"] : []; } };',
    setupCode: 'const params = { getAll(key) { return key === "tag" ? ["javascript", "web", "frontend"] : []; } };',
    expected: ['javascript', 'web', 'frontend'],
    sample: 'params.getAll("tag")',
    hints: ['Use getAll() for multiple values', 'Returns array of all values'],
    tags: ['URLSearchParams', 'url', 'getAll'],
  },
  {
    id: 'js-dom-087',
    category: 'Browser APIs',
    difficulty: 'medium',
    title: 'Delete Search Param',
    text: 'Remove a parameter from the URL.',
    setup: 'const params = { data: { page: "1", sort: "asc", filter: "all" }, delete(key) { delete this.data[key]; } };',
    setupCode: 'const params = { data: { page: "1", sort: "asc", filter: "all" }, delete(key) { delete this.data[key]; } };',
    expected: { data: { page: '1', filter: 'all' } },
    sample: 'params.delete("sort"); params',
    hints: ['Use delete() method', 'Removes all values for that key'],
    tags: ['URLSearchParams', 'url', 'delete'],
  },
  {
    id: 'js-dom-088',
    category: 'Browser APIs',
    difficulty: 'hard',
    title: 'Build URL with Params',
    text: 'Construct a full URL with query parameters.',
    setup: 'const base = "https://api.example.com/search"; const URLSearchParams = class { constructor(obj) { this.obj = obj; } toString() { return Object.entries(this.obj).map(([k,v]) => `${k}=${encodeURIComponent(v)}`).join("&"); } };',
    setupCode: 'const base = "https://api.example.com/search"; const URLSearchParams = class { constructor(obj) { this.obj = obj; } toString() { return Object.entries(this.obj).map(([k,v]) => `${k}=${encodeURIComponent(v)}`).join("&"); } };',
    expected: 'https://api.example.com/search?q=hello%20world&page=1',
    sample: '`${base}?${new URLSearchParams({ q: "hello world", page: "1" })}`',
    hints: ['Combine base URL with params', 'URLSearchParams handles encoding'],
    tags: ['URLSearchParams', 'url', 'construction'],
  },
  {
    id: 'js-dom-089',
    category: 'Browser APIs',
    difficulty: 'hard',
    title: 'Parse URL and Modify Params',
    text: 'Extract search params from a URL and add a new parameter.',
    setup: 'const URL = class { constructor(url) { this.searchParams = { data: { id: "123" }, set(k, v) { this.data[k] = v; }, toString() { return Object.entries(this.data).map(([k,v]) => `${k}=${v}`).join("&"); } }; this.origin = "https://example.com"; this.pathname = "/api"; } toString() { return `${this.origin}${this.pathname}?${this.searchParams}`; } };',
    setupCode: 'const URL = class { constructor(url) { this.searchParams = { data: { id: "123" }, set(k, v) { this.data[k] = v; }, toString() { return Object.entries(this.data).map(([k,v]) => `${k}=${v}`).join("&"); } }; this.origin = "https://example.com"; this.pathname = "/api"; } toString() { return `${this.origin}${this.pathname}?${this.searchParams}`; } };',
    expected: 'https://example.com/api?id=123&token=abc',
    sample: 'const url = new URL("https://example.com/api?id=123"); url.searchParams.set("token", "abc"); url.toString()',
    hints: ['URL object has searchParams property', 'Modify params then convert back'],
    tags: ['URLSearchParams', 'URL', 'parsing'],
  },

  // ========================================
  // BROWSER APIs - IntersectionObserver
  // ========================================
  {
    id: 'js-dom-090',
    category: 'Browser APIs',
    difficulty: 'medium',
    title: 'Create IntersectionObserver',
    text: 'Create an IntersectionObserver to detect when elements enter the viewport.',
    setup: 'const IntersectionObserver = class { constructor(callback, options) { this.callback = callback; this.options = options; this.observing = []; } observe(el) { this.observing.push(el); } };',
    setupCode: 'const IntersectionObserver = class { constructor(callback, options) { this.callback = callback; this.options = options; this.observing = []; } observe(el) { this.observing.push(el); } };',
    expected: true,
    sample: 'const observer = new IntersectionObserver((entries) => {}); typeof observer.observe === "function"',
    hints: ['Pass callback as first argument', 'Options are optional second argument'],
    tags: ['IntersectionObserver', 'visibility', 'scroll'],
  },
  {
    id: 'js-dom-091',
    category: 'Browser APIs',
    difficulty: 'medium',
    title: 'Observe an Element',
    text: 'Start observing an element for intersection.',
    setup: 'const el = { id: "target" }; const observer = { observing: [], observe(element) { this.observing.push(element); } };',
    setupCode: 'const el = { id: "target" }; const observer = { observing: [], observe(element) { this.observing.push(element); } };',
    expected: { observing: [{ id: 'target' }] },
    sample: 'observer.observe(el); observer',
    hints: ['Call observe() with element', 'Observer will track the element'],
    tags: ['IntersectionObserver', 'observe'],
  },
  {
    id: 'js-dom-092',
    category: 'Browser APIs',
    difficulty: 'medium',
    title: 'Unobserve Element',
    text: 'Stop observing a specific element.',
    setup: 'const el = { id: "target" }; const observer = { observing: [{ id: "target" }, { id: "other" }], unobserve(element) { this.observing = this.observing.filter(e => e.id !== element.id); } };',
    setupCode: 'const el = { id: "target" }; const observer = { observing: [{ id: "target" }, { id: "other" }], unobserve(element) { this.observing = this.observing.filter(e => e.id !== element.id); } };',
    expected: { observing: [{ id: 'other' }] },
    sample: 'observer.unobserve(el); observer',
    hints: ['Use unobserve() method', 'Stops tracking specific element'],
    tags: ['IntersectionObserver', 'unobserve'],
  },
  {
    id: 'js-dom-093',
    category: 'Browser APIs',
    difficulty: 'hard',
    title: 'IntersectionObserver with Threshold',
    text: 'Create an observer that fires at 50% visibility.',
    setup: 'const IntersectionObserver = class { constructor(callback, options) { this.threshold = options?.threshold; } };',
    setupCode: 'const IntersectionObserver = class { constructor(callback, options) { this.threshold = options?.threshold; } };',
    expected: 0.5,
    sample: 'new IntersectionObserver(() => {}, { threshold: 0.5 }).threshold',
    hints: ['Set threshold in options', '0.5 means 50% visible'],
    tags: ['IntersectionObserver', 'threshold', 'options'],
  },
  {
    id: 'js-dom-094',
    category: 'Browser APIs',
    difficulty: 'hard',
    title: 'Handle Intersection Entry',
    text: 'Check if an observed element is currently intersecting.',
    setup: 'const entry = { target: { id: "lazy-img" }, isIntersecting: true, intersectionRatio: 0.75 };',
    setupCode: 'const entry = { target: { id: "lazy-img" }, isIntersecting: true, intersectionRatio: 0.75 };',
    expected: { visible: true, ratio: 0.75, elementId: 'lazy-img' },
    sample: '({ visible: entry.isIntersecting, ratio: entry.intersectionRatio, elementId: entry.target.id })',
    hints: ['isIntersecting is a boolean', 'intersectionRatio is 0 to 1'],
    tags: ['IntersectionObserver', 'entry', 'visibility'],
  },
  {
    id: 'js-dom-095',
    category: 'Browser APIs',
    difficulty: 'hard',
    title: 'Lazy Load Images',
    text: 'Implement lazy loading by setting src when element becomes visible.',
    setup: 'const images = [{ dataset: { src: "image1.jpg" }, src: "" }, { dataset: { src: "image2.jpg" }, src: "" }]; const loadImage = (entry) => { if(entry.isIntersecting) entry.target.src = entry.target.dataset.src; }; const entries = [{ isIntersecting: true, target: images[0] }];',
    setupCode: 'const images = [{ dataset: { src: "image1.jpg" }, src: "" }, { dataset: { src: "image2.jpg" }, src: "" }]; const loadImage = (entry) => { if(entry.isIntersecting) entry.target.src = entry.target.dataset.src; }; const entries = [{ isIntersecting: true, target: images[0] }];',
    expected: [{ dataset: { src: 'image1.jpg' }, src: 'image1.jpg' }, { dataset: { src: 'image2.jpg' }, src: '' }],
    sample: 'entries.forEach(loadImage); images',
    hints: ['Check isIntersecting first', 'Copy data-src to src attribute'],
    tags: ['IntersectionObserver', 'lazy-loading', 'images'],
  },

  // ========================================
  // BROWSER APIs - MutationObserver
  // ========================================
  {
    id: 'js-dom-096',
    category: 'Browser APIs',
    difficulty: 'medium',
    title: 'Create MutationObserver',
    text: 'Create a MutationObserver to watch for DOM changes.',
    setup: 'const MutationObserver = class { constructor(callback) { this.callback = callback; } observe(target, options) { this.target = target; this.options = options; } };',
    setupCode: 'const MutationObserver = class { constructor(callback) { this.callback = callback; } observe(target, options) { this.target = target; this.options = options; } };',
    expected: true,
    sample: 'const observer = new MutationObserver((mutations) => {}); typeof observer.observe === "function"',
    hints: ['Pass callback to constructor', 'Callback receives mutations array'],
    tags: ['MutationObserver', 'dom', 'changes'],
  },
  {
    id: 'js-dom-097',
    category: 'Browser APIs',
    difficulty: 'medium',
    title: 'Observe Child Changes',
    text: 'Configure MutationObserver to watch for added/removed children.',
    setup: 'const target = { id: "container" }; const observer = { config: null, observe(el, options) { this.config = options; } };',
    setupCode: 'const target = { id: "container" }; const observer = { config: null, observe(el, options) { this.config = options; } };',
    expected: { config: { childList: true } },
    sample: 'observer.observe(target, { childList: true }); observer',
    hints: ['Use childList: true option', 'Watches for child additions/removals'],
    tags: ['MutationObserver', 'childList'],
  },
  {
    id: 'js-dom-098',
    category: 'Browser APIs',
    difficulty: 'medium',
    title: 'Observe Attribute Changes',
    text: 'Watch for changes to element attributes.',
    setup: 'const target = { id: "element" }; const observer = { config: null, observe(el, options) { this.config = options; } };',
    setupCode: 'const target = { id: "element" }; const observer = { config: null, observe(el, options) { this.config = options; } };',
    expected: { config: { attributes: true, attributeFilter: ['class', 'style'] } },
    sample: 'observer.observe(target, { attributes: true, attributeFilter: ["class", "style"] }); observer',
    hints: ['Use attributes: true', 'attributeFilter limits which attributes'],
    tags: ['MutationObserver', 'attributes'],
  },
  {
    id: 'js-dom-099',
    category: 'Browser APIs',
    difficulty: 'hard',
    title: 'Observe Subtree Changes',
    text: 'Watch for changes in all descendant elements.',
    setup: 'const target = { id: "root" }; const observer = { config: null, observe(el, options) { this.config = options; } };',
    setupCode: 'const target = { id: "root" }; const observer = { config: null, observe(el, options) { this.config = options; } };',
    expected: { config: { childList: true, subtree: true } },
    sample: 'observer.observe(target, { childList: true, subtree: true }); observer',
    hints: ['Add subtree: true option', 'Watches entire subtree, not just direct children'],
    tags: ['MutationObserver', 'subtree'],
  },
  {
    id: 'js-dom-100',
    category: 'Browser APIs',
    difficulty: 'hard',
    title: 'Process Mutation Records',
    text: 'Extract added nodes from mutation records.',
    setup: 'const mutations = [{ type: "childList", addedNodes: [{ id: "new1" }, { id: "new2" }], removedNodes: [] }, { type: "childList", addedNodes: [{ id: "new3" }], removedNodes: [{ id: "old1" }] }];',
    setupCode: 'const mutations = [{ type: "childList", addedNodes: [{ id: "new1" }, { id: "new2" }], removedNodes: [] }, { type: "childList", addedNodes: [{ id: "new3" }], removedNodes: [{ id: "old1" }] }];',
    expected: [{ id: 'new1' }, { id: 'new2' }, { id: 'new3' }],
    sample: 'mutations.flatMap(m => [...m.addedNodes])',
    hints: ['Each mutation has addedNodes', 'Use flatMap to combine arrays'],
    tags: ['MutationObserver', 'mutations', 'addedNodes'],
  },
  {
    id: 'js-dom-101',
    category: 'Browser APIs',
    difficulty: 'hard',
    title: 'Disconnect Observer',
    text: 'Stop the MutationObserver from watching.',
    setup: 'const observer = { watching: true, disconnect() { this.watching = false; } };',
    setupCode: 'const observer = { watching: true, disconnect() { this.watching = false; } };',
    expected: { watching: false },
    sample: 'observer.disconnect(); observer',
    hints: ['Call disconnect() method', 'Stops all observations'],
    tags: ['MutationObserver', 'disconnect'],
  },

  // ========================================
  // DOM MANIPULATION - Advanced
  // ========================================
  {
    id: 'js-dom-102',
    category: 'DOM Manipulation',
    difficulty: 'easy',
    title: 'Get Element by ID',
    text: 'Select an element using getElementById.',
    setup: 'const document = { getElementById: (id) => id === "header" ? { id: "header", tagName: "HEADER" } : null };',
    setupCode: 'const document = { getElementById: (id) => id === "header" ? { id: "header", tagName: "HEADER" } : null };',
    expected: { id: 'header', tagName: 'HEADER' },
    sample: 'document.getElementById("header")',
    hints: ['Pass ID without # prefix', 'Returns single element or null'],
    tags: ['dom', 'getElementById', 'selectors'],
  },
  {
    id: 'js-dom-103',
    category: 'DOM Manipulation',
    difficulty: 'easy',
    title: 'Get Elements by Class Name',
    text: 'Select all elements with a specific class name.',
    setup: 'const document = { getElementsByClassName: (cls) => cls === "card" ? [{ className: "card" }, { className: "card" }] : [] };',
    setupCode: 'const document = { getElementsByClassName: (cls) => cls === "card" ? [{ className: "card" }, { className: "card" }] : [] };',
    expected: 2,
    sample: 'document.getElementsByClassName("card").length',
    hints: ['Pass class name without dot', 'Returns live HTMLCollection'],
    tags: ['dom', 'getElementsByClassName', 'selectors'],
  },
  {
    id: 'js-dom-104',
    category: 'DOM Manipulation',
    difficulty: 'medium',
    title: 'Get Computed Style',
    text: 'Get the computed color style of an element.',
    setup: 'const el = { id: "box" }; const getComputedStyle = (element) => ({ color: "rgb(255, 0, 0)", fontSize: "16px" });',
    setupCode: 'const el = { id: "box" }; const getComputedStyle = (element) => ({ color: "rgb(255, 0, 0)", fontSize: "16px" });',
    expected: 'rgb(255, 0, 0)',
    sample: 'getComputedStyle(el).color',
    hints: ['Use getComputedStyle function', 'Returns CSSStyleDeclaration object'],
    tags: ['dom', 'getComputedStyle', 'styles'],
  },
  {
    id: 'js-dom-105',
    category: 'DOM Manipulation',
    difficulty: 'medium',
    title: 'Set Inline Style',
    text: 'Set the background color of an element using inline style.',
    setup: 'const el = { style: { backgroundColor: "" } };',
    setupCode: 'const el = { style: { backgroundColor: "" } };',
    expected: { style: { backgroundColor: 'blue' } },
    sample: 'el.style.backgroundColor = "blue"; el',
    hints: ['Access style property', 'Use camelCase for CSS properties'],
    tags: ['dom', 'style', 'inline'],
  },
  {
    id: 'js-dom-106',
    category: 'DOM Manipulation',
    difficulty: 'medium',
    title: 'Get Bounding Rectangle',
    text: 'Get the position and dimensions of an element.',
    setup: 'const el = { getBoundingClientRect: () => ({ top: 100, left: 50, width: 200, height: 150, bottom: 250, right: 250 }) };',
    setupCode: 'const el = { getBoundingClientRect: () => ({ top: 100, left: 50, width: 200, height: 150, bottom: 250, right: 250 }) };',
    expected: { top: 100, left: 50, width: 200, height: 150 },
    sample: 'const rect = el.getBoundingClientRect(); ({ top: rect.top, left: rect.left, width: rect.width, height: rect.height })',
    hints: ['Use getBoundingClientRect()', 'Returns position relative to viewport'],
    tags: ['dom', 'getBoundingClientRect', 'dimensions'],
  },
  {
    id: 'js-dom-107',
    category: 'DOM Manipulation',
    difficulty: 'hard',
    title: 'Create Document Fragment',
    text: 'Create a document fragment and append multiple elements efficiently.',
    setup: 'const document = { createDocumentFragment: () => ({ children: [], appendChild(el) { this.children.push(el); return el; } }), createElement: (tag) => ({ tagName: tag.toUpperCase() }) };',
    setupCode: 'const document = { createDocumentFragment: () => ({ children: [], appendChild(el) { this.children.push(el); return el; } }), createElement: (tag) => ({ tagName: tag.toUpperCase() }) };',
    expected: { children: [{ tagName: 'DIV' }, { tagName: 'DIV' }, { tagName: 'DIV' }] },
    sample: 'const frag = document.createDocumentFragment(); for(let i = 0; i < 3; i++) frag.appendChild(document.createElement("div")); frag',
    hints: ['Fragment is a lightweight container', 'Append multiple elements before adding to DOM'],
    tags: ['dom', 'createDocumentFragment', 'performance'],
  },
  {
    id: 'js-dom-108',
    category: 'Events',
    difficulty: 'hard',
    title: 'Custom Event Dispatch',
    text: 'Create and dispatch a custom event with data.',
    setup: 'const CustomEvent = class { constructor(type, options) { this.type = type; this.detail = options?.detail; } }; let received = null; const el = { dispatchEvent(event) { received = event; return true; } };',
    setupCode: 'const CustomEvent = class { constructor(type, options) { this.type = type; this.detail = options?.detail; } }; let received = null; const el = { dispatchEvent(event) { received = event; return true; } };',
    expected: { type: 'userAction', detail: { action: 'click', id: 42 } },
    sample: 'el.dispatchEvent(new CustomEvent("userAction", { detail: { action: "click", id: 42 } })); received',
    hints: ['Use CustomEvent constructor', 'Pass data in detail property'],
    tags: ['events', 'CustomEvent', 'dispatchEvent'],
  },
  {
    id: 'js-dom-109',
    category: 'Browser APIs',
    difficulty: 'medium',
    title: 'Request Animation Frame',
    text: 'Schedule a callback for the next repaint.',
    setup: 'let scheduled = null; const requestAnimationFrame = (callback) => { scheduled = callback; return 123; };',
    setupCode: 'let scheduled = null; const requestAnimationFrame = (callback) => { scheduled = callback; return 123; };',
    expected: 123,
    sample: 'requestAnimationFrame((timestamp) => { console.log("Frame at", timestamp); })',
    hints: ['Returns a request ID', 'Callback receives timestamp'],
    tags: ['requestAnimationFrame', 'animation', 'performance'],
  },
  {
    id: 'js-dom-110',
    category: 'Browser APIs',
    difficulty: 'hard',
    title: 'Cancel Animation Frame',
    text: 'Cancel a scheduled animation frame.',
    setup: 'const frames = { 123: true, 456: true }; const cancelAnimationFrame = (id) => { delete frames[id]; };',
    setupCode: 'const frames = { 123: true, 456: true }; const cancelAnimationFrame = (id) => { delete frames[id]; };',
    expected: { '456': true },
    sample: 'cancelAnimationFrame(123); frames',
    hints: ['Pass the request ID', 'Prevents callback from being called'],
    tags: ['cancelAnimationFrame', 'animation', 'cleanup'],
  },
];

export default javascriptProblems;
