/**
 * Swift Coding Drills Problems
 *
 * Comprehensive collection of Swift problems covering:
 * - Array Methods (10 problems)
 * - String Methods (10 problems)
 * - Dictionary Methods (10 problems)
 * - Set Operations (10 problems)
 * - Optional Handling (10 problems)
 * - Array Operations (40 problems) - map, filter, reduce, compactMap, flatMap
 * - Dictionary Operations (35 problems) - mapValues, filter, merge, compactMapValues
 * - String Operations (35 problems) - String methods, Substring, Character
 * - Optionals (35 problems) - ?, ??, if let, guard let, optional chaining
 * - Collections (35 problems) - Set operations, sorted, reversed, enumerated
 * - Closures (35 problems) - trailing closures, escaping, autoclosure, capture lists
 * - Protocols (30 problems) - protocol extensions, associated types, Self
 * - Generics (30 problems) - type constraints, where clauses, associated types
 * - Enums (30 problems) - associated values, raw values, CaseIterable
 * - Structs vs Classes (30 problems) - value vs reference, mutating, copy-on-write
 * - Error Handling (30 problems) - throws, try, catch, Result type
 * - Concurrency (30 problems) - async/await, actors, Task, MainActor
 * - Property Wrappers (25 problems) - @State, @Published, custom wrappers
 * - Key Paths (25 problems) - keyPath expressions, dynamic member lookup
 * - Pattern Matching (30 problems) - switch, if case, for case, pattern binding
 * - Regular Expressions (25 problems) - Regex, matches, firstMatch
 *
 * Total: 550 problems (50 original + 500 new)
 * Distribution: Approximately 180 easy, 220 medium, 150 hard
 */

import type { Problem } from '../types';

export const swiftProblems: Problem[] = [
  // ============================================================
  // Array Methods (10 problems: 4 easy, 4 medium, 2 hard)
  // ============================================================

  {
    id: 'swift-array-001',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Filter Even Numbers',
    text: 'Filter the array to keep only even numbers.',
    setup: 'let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]',
    setupCode: 'let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]',
    expected: [2, 4, 6, 8, 10],
    sample: 'numbers.filter { $0 % 2 == 0 }',
    hints: ['Use filter with a closure', '$0 refers to each element in the closure'],
    validPatterns: [/\.filter\s*\{.*%\s*2\s*==\s*0.*\}/],
    tags: ['filter', 'arrays', 'closure'],
  },

  {
    id: 'swift-array-002',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Map to Squares',
    text: 'Transform each number in the array to its square.',
    setup: 'let numbers = [1, 2, 3, 4, 5]',
    setupCode: 'let numbers = [1, 2, 3, 4, 5]',
    expected: [1, 4, 9, 16, 25],
    sample: 'numbers.map { $0 * $0 }',
    hints: ['Use map to transform each element', 'Return the square of each number'],
    validPatterns: [/\.map\s*\{.*\*.*\}/],
    tags: ['map', 'arrays', 'transform'],
  },

  {
    id: 'swift-array-003',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Reduce to Sum',
    text: 'Calculate the sum of all numbers using reduce.',
    setup: 'let numbers = [1, 2, 3, 4, 5]',
    setupCode: 'let numbers = [1, 2, 3, 4, 5]',
    expected: 15,
    sample: 'numbers.reduce(0, +)',
    hints: [
      'reduce takes an initial value and a combining closure',
      'You can use the + operator directly',
    ],
    validPatterns: [/\.reduce\s*\(\s*0\s*,\s*\+\s*\)/, /\.reduce\s*\(\s*0\s*\)\s*\{.*\+.*\}/],
    tags: ['reduce', 'arrays', 'aggregation'],
  },

  {
    id: 'swift-array-004',
    category: 'Array Methods',
    difficulty: 'easy',
    title: 'Check Contains Element',
    text: 'Check if the array contains the number 5.',
    setup: 'let numbers = [1, 2, 3, 4, 5, 6, 7]',
    setupCode: 'let numbers = [1, 2, 3, 4, 5, 6, 7]',
    expected: true,
    sample: 'numbers.contains(5)',
    hints: ['contains returns a Bool', 'Works with Equatable types'],
    validPatterns: [/\.contains\s*\(\s*5\s*\)/],
    tags: ['contains', 'arrays', 'search'],
  },

  {
    id: 'swift-array-005',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Sort Array Ascending',
    text: 'Sort the array in ascending order.',
    setup: 'let numbers = [5, 2, 8, 1, 9, 3]',
    setupCode: 'let numbers = [5, 2, 8, 1, 9, 3]',
    expected: [1, 2, 3, 5, 8, 9],
    sample: 'numbers.sorted()',
    hints: ['sorted() returns a new sorted array', 'Default sorting is ascending'],
    validPatterns: [/\.sorted\s*\(\s*\)/],
    tags: ['sorted', 'arrays', 'order'],
  },

  {
    id: 'swift-array-006',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Reverse Array',
    text: 'Reverse the order of elements in the array.',
    setup: 'let numbers = [1, 2, 3, 4, 5]',
    setupCode: 'let numbers = [1, 2, 3, 4, 5]',
    expected: [5, 4, 3, 2, 1],
    sample: 'Array(numbers.reversed())',
    hints: ['reversed() returns a ReversedCollection', 'Wrap in Array() to get an Array'],
    validPatterns: [/\.reversed\s*\(\s*\)/, /Array\s*\(\s*numbers\.reversed\s*\(\s*\)\s*\)/],
    tags: ['reversed', 'arrays', 'order'],
  },

  {
    id: 'swift-array-007',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Get First Element',
    text: 'Get the first element of the array safely.',
    setup: 'let fruits = ["apple", "banana", "cherry"]',
    setupCode: 'let fruits = ["apple", "banana", "cherry"]',
    expected: 'apple',
    sample: 'fruits.first',
    hints: ['first is a property that returns an optional', 'Returns nil for empty arrays'],
    validPatterns: [/\.first(?!\()/],
    tags: ['first', 'arrays', 'access'],
  },

  {
    id: 'swift-array-008',
    category: 'Array Methods',
    difficulty: 'medium',
    title: 'Get Last Element',
    text: 'Get the last element of the array safely.',
    setup: 'let fruits = ["apple", "banana", "cherry"]',
    setupCode: 'let fruits = ["apple", "banana", "cherry"]',
    expected: 'cherry',
    sample: 'fruits.last',
    hints: ['last is a property that returns an optional', 'Returns nil for empty arrays'],
    validPatterns: [/\.last(?!\()/],
    tags: ['last', 'arrays', 'access'],
  },

  {
    id: 'swift-array-009',
    category: 'Array Methods',
    difficulty: 'hard',
    title: 'Reduce to Dictionary',
    text: 'Create a dictionary counting occurrences of each element.',
    setup: 'let letters = ["a", "b", "a", "c", "b", "a"]',
    setupCode: 'let letters = ["a", "b", "a", "c", "b", "a"]',
    expected: { a: 3, b: 2, c: 1 },
    sample: 'letters.reduce(into: [:]) { counts, letter in counts[letter, default: 0] += 1 }',
    hints: [
      'reduce(into:) allows mutation of the accumulator',
      'More efficient for building collections',
    ],
    validPatterns: [/\.reduce\s*\(\s*into:\s*\[:\]\s*\)\s*\{/],
    tags: ['reduce', 'arrays', 'dictionary'],
  },

  {
    id: 'swift-array-010',
    category: 'Array Methods',
    difficulty: 'hard',
    title: 'Sort By Custom Criteria',
    text: 'Sort strings by their length in ascending order.',
    setup: 'let words = ["cat", "elephant", "dog", "bird"]',
    setupCode: 'let words = ["cat", "elephant", "dog", "bird"]',
    expected: ['cat', 'dog', 'bird', 'elephant'],
    sample: 'words.sorted { $0.count < $1.count }',
    hints: [
      'sorted(by:) takes a comparison closure',
      'Return true if first element should come before second',
    ],
    validPatterns: [
      /\.sorted\s*\{.*\.count\s*<.*\.count.*\}/,
      /\.sorted\s*\(\s*by:\s*\{.*\.count.*\}\s*\)/,
    ],
    tags: ['sorted', 'arrays', 'custom sort'],
  },

  // ============================================================
  // String Methods (10 problems: 4 easy, 4 medium, 2 hard)
  // ============================================================

  {
    id: 'swift-string-001',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'String Length',
    text: 'Get the number of characters in the string.',
    setup: 'let message = "Hello, Swift!"',
    setupCode: 'let message = "Hello, Swift!"',
    expected: 13,
    sample: 'message.count',
    hints: ['Use the count property for String length', 'count returns the number of characters'],
    validPatterns: [/\.count(?!\()/],
    tags: ['count', 'string', 'length'],
  },

  {
    id: 'swift-string-002',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Convert to Lowercase',
    text: 'Convert the string to all lowercase letters.',
    setup: 'let message = "Hello, SWIFT!"',
    setupCode: 'let message = "Hello, SWIFT!"',
    expected: 'hello, swift!',
    sample: 'message.lowercased()',
    hints: ['lowercased() returns a new lowercase string', 'Does not modify the original string'],
    validPatterns: [/\.lowercased\s*\(\s*\)/],
    tags: ['lowercased', 'string', 'case'],
  },

  {
    id: 'swift-string-003',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Convert to Uppercase',
    text: 'Convert the string to all uppercase letters.',
    setup: 'let message = "Hello, Swift!"',
    setupCode: 'let message = "Hello, Swift!"',
    expected: 'HELLO, SWIFT!',
    sample: 'message.uppercased()',
    hints: ['uppercased() returns a new uppercase string', 'Does not modify the original string'],
    validPatterns: [/\.uppercased\s*\(\s*\)/],
    tags: ['uppercased', 'string', 'case'],
  },

  {
    id: 'swift-string-004',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Check String Contains',
    text: 'Check if the string contains the word "Swift".',
    setup: 'let message = "Hello, Swift!"',
    setupCode: 'let message = "Hello, Swift!"',
    expected: true,
    sample: 'message.contains("Swift")',
    hints: ['contains returns a Bool', 'Case-sensitive by default'],
    validPatterns: [/\.contains\s*\(\s*"Swift"\s*\)/],
    tags: ['contains', 'string', 'search'],
  },

  {
    id: 'swift-string-005',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Split String by Delimiter',
    text: 'Split the string into an array using comma as delimiter.',
    setup: 'let csv = "apple,banana,cherry,date"',
    setupCode: 'let csv = "apple,banana,cherry,date"',
    expected: ['apple', 'banana', 'cherry', 'date'],
    sample: 'csv.split(separator: ",").map(String.init)',
    hints: ['split returns an array of Substring', 'Map to String if you need String array'],
    validPatterns: [
      /\.split\s*\(\s*separator:\s*","\s*\)/,
      /\.components\s*\(\s*separatedBy:\s*","\s*\)/,
    ],
    tags: ['split', 'string', 'tokenize'],
  },

  {
    id: 'swift-string-006',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Check String Prefix',
    text: 'Check if the string starts with "Hello".',
    setup: 'let message = "Hello, World!"',
    setupCode: 'let message = "Hello, World!"',
    expected: true,
    sample: 'message.hasPrefix("Hello")',
    hints: [
      'hasPrefix checks the beginning of the string',
      'Returns true if string starts with the prefix',
    ],
    validPatterns: [/\.hasPrefix\s*\(\s*"Hello"\s*\)/],
    tags: ['hasPrefix', 'string', 'prefix'],
  },

  {
    id: 'swift-string-007',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Check String Suffix',
    text: 'Check if the string ends with "World!".',
    setup: 'let message = "Hello, World!"',
    setupCode: 'let message = "Hello, World!"',
    expected: true,
    sample: 'message.hasSuffix("World!")',
    hints: [
      'hasSuffix checks the end of the string',
      'Returns true if string ends with the suffix',
    ],
    validPatterns: [/\.hasSuffix\s*\(\s*"World!"\s*\)/],
    tags: ['hasSuffix', 'string', 'suffix'],
  },

  {
    id: 'swift-string-008',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Join Array to String',
    text: 'Join the array elements into a single string separated by ", ".',
    setup: 'let fruits = ["apple", "banana", "cherry"]',
    setupCode: 'let fruits = ["apple", "banana", "cherry"]',
    expected: 'apple, banana, cherry',
    sample: 'fruits.joined(separator: ", ")',
    hints: ['joined(separator:) concatenates array elements', 'Works on arrays of strings'],
    validPatterns: [/\.joined\s*\(\s*separator:\s*", "\s*\)/],
    tags: ['joined', 'string', 'concatenate'],
  },

  {
    id: 'swift-string-009',
    category: 'String Methods',
    difficulty: 'hard',
    title: 'String Indices',
    text: 'Get the character at index 4 of the string.',
    setup: 'let message = "Hello, Swift!"',
    setupCode: 'let message = "Hello, Swift!"',
    expected: 'o',
    sample: 'message[message.index(message.startIndex, offsetBy: 4)]',
    hints: [
      'Swift strings use String.Index, not integers',
      'Use index(_:offsetBy:) to calculate positions',
    ],
    validPatterns: [/message\.index\s*\(\s*message\.startIndex\s*,\s*offsetBy:\s*4\s*\)/],
    tags: ['index', 'string', 'access'],
  },

  {
    id: 'swift-string-010',
    category: 'String Methods',
    difficulty: 'hard',
    title: 'Substring Range',
    text: 'Extract the first 5 characters of the string.',
    setup: 'let message = "Hello, World!"',
    setupCode: 'let message = "Hello, World!"',
    expected: 'Hello',
    sample: 'String(message.prefix(5))',
    hints: ['prefix() returns the first n characters', 'Convert Substring to String if needed'],
    validPatterns: [/\.prefix\s*\(\s*5\s*\)/],
    tags: ['prefix', 'string', 'substring'],
  },

  // ============================================================
  // Dictionary Methods (10 problems: 4 easy, 4 medium, 2 hard)
  // ============================================================

  {
    id: 'swift-dictionary-001',
    category: 'Dictionary Methods',
    difficulty: 'easy',
    title: 'Get All Keys',
    text: 'Get an array of all keys from the dictionary.',
    setup: 'let scores = ["Alice": 95, "Bob": 87, "Charlie": 92]',
    setupCode: 'let scores = ["Alice": 95, "Bob": 87, "Charlie": 92]',
    expected: ['Alice', 'Bob', 'Charlie'],
    sample: 'Array(scores.keys)',
    hints: ['keys property returns a Keys collection', 'Wrap in Array() to get an Array'],
    validPatterns: [/Array\s*\(\s*scores\.keys\s*\)/, /scores\.keys/],
    tags: ['keys', 'dictionary', 'access'],
  },

  {
    id: 'swift-dictionary-002',
    category: 'Dictionary Methods',
    difficulty: 'easy',
    title: 'Get All Values',
    text: 'Get an array of all values from the dictionary.',
    setup: 'let scores = ["Alice": 95, "Bob": 87, "Charlie": 92]',
    setupCode: 'let scores = ["Alice": 95, "Bob": 87, "Charlie": 92]',
    expected: [95, 87, 92],
    sample: 'Array(scores.values)',
    hints: ['values property returns a Values collection', 'Wrap in Array() to get an Array'],
    validPatterns: [/Array\s*\(\s*scores\.values\s*\)/, /scores\.values/],
    tags: ['values', 'dictionary', 'access'],
  },

  {
    id: 'swift-dictionary-003',
    category: 'Dictionary Methods',
    difficulty: 'easy',
    title: 'Get Value by Key',
    text: 'Get the value for key "Alice" from the dictionary.',
    setup: 'let scores = ["Alice": 95, "Bob": 87, "Charlie": 92]',
    setupCode: 'let scores = ["Alice": 95, "Bob": 87, "Charlie": 92]',
    expected: 95,
    sample: 'scores["Alice"]',
    hints: ['Use subscript notation with the key', 'Returns an optional value'],
    validPatterns: [/scores\s*\[\s*"Alice"\s*\]/],
    tags: ['subscript', 'dictionary', 'access'],
  },

  {
    id: 'swift-dictionary-004',
    category: 'Dictionary Methods',
    difficulty: 'easy',
    title: 'Get Value with Default',
    text: 'Get the value for key "David" with a default value of 0.',
    setup: 'let scores = ["Alice": 95, "Bob": 87]',
    setupCode: 'let scores = ["Alice": 95, "Bob": 87]',
    expected: 0,
    sample: 'scores["David", default: 0]',
    hints: ['Use subscript with default parameter', 'Returns the default if key is not found'],
    validPatterns: [/scores\s*\[\s*"David"\s*,\s*default:\s*0\s*\]/],
    tags: ['subscript', 'dictionary', 'default'],
  },

  {
    id: 'swift-dictionary-005',
    category: 'Dictionary Methods',
    difficulty: 'medium',
    title: 'Update Dictionary Value',
    text: 'Update the value for key "Alice" to 100 and return the old value.',
    setup: 'var scores = ["Alice": 95, "Bob": 87]',
    setupCode: 'var scores = ["Alice": 95, "Bob": 87]',
    expected: 95,
    sample: 'scores.updateValue(100, forKey: "Alice")',
    hints: ['updateValue returns the old value as optional', 'Returns nil if key did not exist'],
    validPatterns: [/\.updateValue\s*\(\s*100\s*,\s*forKey:\s*"Alice"\s*\)/],
    tags: ['updateValue', 'dictionary', 'modify'],
  },

  {
    id: 'swift-dictionary-006',
    category: 'Dictionary Methods',
    difficulty: 'medium',
    title: 'Remove Value by Key',
    text: 'Remove the entry for key "Bob" and return the removed value.',
    setup: 'var scores = ["Alice": 95, "Bob": 87, "Charlie": 92]',
    setupCode: 'var scores = ["Alice": 95, "Bob": 87, "Charlie": 92]',
    expected: 87,
    sample: 'scores.removeValue(forKey: "Bob")',
    hints: [
      'removeValue returns the removed value as optional',
      'Returns nil if key did not exist',
    ],
    validPatterns: [/\.removeValue\s*\(\s*forKey:\s*"Bob"\s*\)/],
    tags: ['removeValue', 'dictionary', 'remove'],
  },

  {
    id: 'swift-dictionary-007',
    category: 'Dictionary Methods',
    difficulty: 'medium',
    title: 'Check Key Exists',
    text: 'Check if the dictionary contains the key "Alice".',
    setup: 'let scores = ["Alice": 95, "Bob": 87]',
    setupCode: 'let scores = ["Alice": 95, "Bob": 87]',
    expected: true,
    sample: 'scores.keys.contains("Alice")',
    hints: ['Check if key exists in keys collection', 'Or check if value is not nil'],
    validPatterns: [
      /\.keys\.contains\s*\(\s*"Alice"\s*\)/,
      /scores\s*\[\s*"Alice"\s*\]\s*!=\s*nil/,
    ],
    tags: ['contains', 'dictionary', 'check'],
  },

  {
    id: 'swift-dictionary-008',
    category: 'Dictionary Methods',
    difficulty: 'medium',
    title: 'Merge Dictionaries',
    text: 'Merge two dictionaries, keeping the values from the second one for duplicate keys.',
    setup: 'var dict1 = ["a": 1, "b": 2]\nlet dict2 = ["b": 3, "c": 4]',
    setupCode: 'var dict1 = ["a": 1, "b": 2]\nlet dict2 = ["b": 3, "c": 4]',
    expected: { a: 1, b: 3, c: 4 },
    sample: 'dict1.merge(dict2) { _, new in new }',
    hints: [
      'merge takes a dictionary and a closure for conflicts',
      'The closure receives (current, new) values',
    ],
    validPatterns: [/\.merge\s*\(\s*dict2\s*\)\s*\{/, /\.merging\s*\(\s*dict2\s*\)\s*\{/],
    tags: ['merge', 'dictionary', 'combine'],
  },

  {
    id: 'swift-dictionary-009',
    category: 'Dictionary Methods',
    difficulty: 'hard',
    title: 'Filter Dictionary',
    text: 'Filter the dictionary to keep only entries where the value is greater than 90.',
    setup: 'let scores = ["Alice": 95, "Bob": 87, "Charlie": 92]',
    setupCode: 'let scores = ["Alice": 95, "Bob": 87, "Charlie": 92]',
    expected: { Alice: 95, Charlie: 92 },
    sample: 'scores.filter { $0.value > 90 }',
    hints: ['filter works on dictionaries too', 'Closure receives key-value pairs'],
    validPatterns: [
      /\.filter\s*\{.*\.value\s*>\s*90.*\}/,
      /\.filter\s*\{.*\$0\.value\s*>\s*90.*\}/,
    ],
    tags: ['filter', 'dictionary', 'predicate'],
  },

  {
    id: 'swift-dictionary-010',
    category: 'Dictionary Methods',
    difficulty: 'hard',
    title: 'Map Dictionary Values',
    text: 'Transform all values in the dictionary by adding 10 to each.',
    setup: 'let scores = ["Alice": 90, "Bob": 80, "Charlie": 85]',
    setupCode: 'let scores = ["Alice": 90, "Bob": 80, "Charlie": 85]',
    expected: { Alice: 100, Bob: 90, Charlie: 95 },
    sample: 'scores.mapValues { $0 + 10 }',
    hints: ['mapValues transforms values while keeping keys', 'Returns a new dictionary'],
    validPatterns: [/\.mapValues\s*\{.*\+\s*10.*\}/],
    tags: ['mapValues', 'dictionary', 'transform'],
  },

  // ============================================================
  // Set Operations (10 problems: 4 easy, 4 medium, 2 hard)
  // ============================================================

  {
    id: 'swift-set-001',
    category: 'Set Operations',
    difficulty: 'easy',
    title: 'Insert Element',
    text: 'Insert the number 4 into the set.',
    setup: 'var numbers: Set = [1, 2, 3]',
    setupCode: 'var numbers: Set = [1, 2, 3]',
    expected: [1, 2, 3, 4],
    sample: 'numbers.insert(4)',
    hints: [
      'insert adds an element to the set',
      'Returns a tuple with (inserted, memberAfterInsert)',
    ],
    validPatterns: [/\.insert\s*\(\s*4\s*\)/],
    tags: ['insert', 'set', 'add'],
  },

  {
    id: 'swift-set-002',
    category: 'Set Operations',
    difficulty: 'easy',
    title: 'Remove Element',
    text: 'Remove the number 2 from the set.',
    setup: 'var numbers: Set = [1, 2, 3]',
    setupCode: 'var numbers: Set = [1, 2, 3]',
    expected: 2,
    sample: 'numbers.remove(2)',
    hints: ['remove returns the removed element or nil', 'Does nothing if element not found'],
    validPatterns: [/\.remove\s*\(\s*2\s*\)/],
    tags: ['remove', 'set', 'delete'],
  },

  {
    id: 'swift-set-003',
    category: 'Set Operations',
    difficulty: 'easy',
    title: 'Check Set Contains',
    text: 'Check if the set contains the number 3.',
    setup: 'let numbers: Set = [1, 2, 3, 4, 5]',
    setupCode: 'let numbers: Set = [1, 2, 3, 4, 5]',
    expected: true,
    sample: 'numbers.contains(3)',
    hints: ['contains returns a Bool', 'O(1) lookup for sets'],
    validPatterns: [/\.contains\s*\(\s*3\s*\)/],
    tags: ['contains', 'set', 'search'],
  },

  {
    id: 'swift-set-004',
    category: 'Set Operations',
    difficulty: 'easy',
    title: 'Union of Sets',
    text: 'Create the union of two sets.',
    setup: 'let setA: Set = [1, 2, 3]\nlet setB: Set = [3, 4, 5]',
    setupCode: 'let setA: Set = [1, 2, 3]\nlet setB: Set = [3, 4, 5]',
    expected: [1, 2, 3, 4, 5],
    sample: 'setA.union(setB)',
    hints: ['union combines elements from both sets', 'Duplicates are automatically removed'],
    validPatterns: [/\.union\s*\(\s*setB\s*\)/, /setA\.union\s*\(/],
    tags: ['union', 'set', 'combine'],
  },

  {
    id: 'swift-set-005',
    category: 'Set Operations',
    difficulty: 'medium',
    title: 'Intersection of Sets',
    text: 'Find the common elements between two sets.',
    setup: 'let setA: Set = [1, 2, 3, 4]\nlet setB: Set = [3, 4, 5, 6]',
    setupCode: 'let setA: Set = [1, 2, 3, 4]\nlet setB: Set = [3, 4, 5, 6]',
    expected: [3, 4],
    sample: 'setA.intersection(setB)',
    hints: ['intersection returns elements present in both sets', 'Returns a new set'],
    validPatterns: [/\.intersection\s*\(\s*setB\s*\)/, /setA\.intersection\s*\(/],
    tags: ['intersection', 'set', 'common'],
  },

  {
    id: 'swift-set-006',
    category: 'Set Operations',
    difficulty: 'medium',
    title: 'Difference of Sets',
    text: 'Find elements in setA that are not in setB.',
    setup: 'let setA: Set = [1, 2, 3, 4]\nlet setB: Set = [3, 4, 5, 6]',
    setupCode: 'let setA: Set = [1, 2, 3, 4]\nlet setB: Set = [3, 4, 5, 6]',
    expected: [1, 2],
    sample: 'setA.subtracting(setB)',
    hints: [
      'subtracting removes elements present in the other set',
      'Order matters: A - B is different from B - A',
    ],
    validPatterns: [/\.subtracting\s*\(\s*setB\s*\)/, /setA\.subtracting\s*\(/],
    tags: ['subtracting', 'set', 'difference'],
  },

  {
    id: 'swift-set-007',
    category: 'Set Operations',
    difficulty: 'medium',
    title: 'Symmetric Difference',
    text: 'Find elements that are in either set but not in both.',
    setup: 'let setA: Set = [1, 2, 3]\nlet setB: Set = [3, 4, 5]',
    setupCode: 'let setA: Set = [1, 2, 3]\nlet setB: Set = [3, 4, 5]',
    expected: [1, 2, 4, 5],
    sample: 'setA.symmetricDifference(setB)',
    hints: [
      'symmetricDifference returns elements unique to each set',
      'Excludes elements present in both',
    ],
    validPatterns: [/\.symmetricDifference\s*\(\s*setB\s*\)/],
    tags: ['symmetricDifference', 'set', 'xor'],
  },

  {
    id: 'swift-set-008',
    category: 'Set Operations',
    difficulty: 'medium',
    title: 'Check Subset',
    text: 'Check if setA is a subset of setB.',
    setup: 'let setA: Set = [1, 2]\nlet setB: Set = [1, 2, 3, 4, 5]',
    setupCode: 'let setA: Set = [1, 2]\nlet setB: Set = [1, 2, 3, 4, 5]',
    expected: true,
    sample: 'setA.isSubset(of: setB)',
    hints: [
      'isSubset returns true if all elements are in the other set',
      'A set is a subset of itself',
    ],
    validPatterns: [/\.isSubset\s*\(\s*of:\s*setB\s*\)/],
    tags: ['isSubset', 'set', 'subset'],
  },

  {
    id: 'swift-set-009',
    category: 'Set Operations',
    difficulty: 'hard',
    title: 'Check Superset',
    text: 'Check if setA is a superset of setB.',
    setup: 'let setA: Set = [1, 2, 3, 4, 5]\nlet setB: Set = [2, 3]',
    setupCode: 'let setA: Set = [1, 2, 3, 4, 5]\nlet setB: Set = [2, 3]',
    expected: true,
    sample: 'setA.isSuperset(of: setB)',
    hints: [
      'isSuperset returns true if it contains all elements of the other set',
      'Opposite of isSubset',
    ],
    validPatterns: [/\.isSuperset\s*\(\s*of:\s*setB\s*\)/],
    tags: ['isSuperset', 'set', 'superset'],
  },

  {
    id: 'swift-set-010',
    category: 'Set Operations',
    difficulty: 'hard',
    title: 'Check Disjoint Sets',
    text: 'Check if two sets have no common elements.',
    setup: 'let setA: Set = [1, 2, 3]\nlet setB: Set = [4, 5, 6]',
    setupCode: 'let setA: Set = [1, 2, 3]\nlet setB: Set = [4, 5, 6]',
    expected: true,
    sample: 'setA.isDisjoint(with: setB)',
    hints: [
      'isDisjoint returns true if sets have no common elements',
      'Empty intersection means disjoint',
    ],
    validPatterns: [/\.isDisjoint\s*\(\s*with:\s*setB\s*\)/],
    tags: ['isDisjoint', 'set', 'disjoint'],
  },

  // ============================================================
  // Optional Handling (10 problems: 4 easy, 4 medium, 2 hard)
  // ============================================================

  {
    id: 'swift-optional-001',
    category: 'Optional Handling',
    difficulty: 'easy',
    title: 'Optional Binding with if let',
    text: 'Safely unwrap the optional name using if let.',
    setup: 'let name: String? = "Alice"',
    setupCode: 'let name: String? = "Alice"',
    expected: 'Alice',
    sample: 'if let unwrapped = name { print(unwrapped) }',
    hints: [
      'if let creates a new constant with the unwrapped value',
      'Code inside the block only runs if optional has a value',
    ],
    validPatterns: [/if\s+let\s+\w+\s*=\s*name/],
    tags: ['if let', 'optional', 'unwrap'],
  },

  {
    id: 'swift-optional-002',
    category: 'Optional Handling',
    difficulty: 'easy',
    title: 'Guard Let for Early Exit',
    text: 'Use guard let to unwrap the optional and exit early if nil.',
    setup: 'let age: Int? = 25',
    setupCode: 'let age: Int? = 25',
    expected: 25,
    sample: 'guard let validAge = age else { return }',
    hints: [
      'guard let requires an else clause with exit',
      'The unwrapped value is available after the guard',
    ],
    validPatterns: [/guard\s+let\s+\w+\s*=\s*age\s+else/],
    tags: ['guard let', 'optional', 'early exit'],
  },

  {
    id: 'swift-optional-003',
    category: 'Optional Handling',
    difficulty: 'easy',
    title: 'Nil Coalescing Operator',
    text: 'Provide a default value of "Unknown" if the name is nil.',
    setup: 'let name: String? = nil',
    setupCode: 'let name: String? = nil',
    expected: 'Unknown',
    sample: 'name ?? "Unknown"',
    hints: [
      '?? is the nil coalescing operator',
      'Returns the left value if non-nil, otherwise the right',
    ],
    validPatterns: [/name\s*\?\?\s*"Unknown"/],
    tags: ['nil coalescing', 'optional', 'default'],
  },

  {
    id: 'swift-optional-004',
    category: 'Optional Handling',
    difficulty: 'easy',
    title: 'Optional Chaining',
    text: 'Safely access the count property of an optional string.',
    setup: 'let message: String? = "Hello"',
    setupCode: 'let message: String? = "Hello"',
    expected: 5,
    sample: 'message?.count',
    hints: ['?. is optional chaining', 'Returns nil if the optional is nil'],
    validPatterns: [/message\?\s*\.count/],
    tags: ['optional chaining', 'optional', 'safe access'],
  },

  {
    id: 'swift-optional-005',
    category: 'Optional Handling',
    difficulty: 'medium',
    title: 'Force Unwrap',
    text: 'Force unwrap the optional to get its value (when you are certain it has a value).',
    setup: 'let number: Int? = 42',
    setupCode: 'let number: Int? = 42',
    expected: 42,
    sample: 'number!',
    hints: ['! force unwraps an optional', 'Crashes if the optional is nil - use with caution'],
    validPatterns: [/number!/],
    tags: ['force unwrap', 'optional', 'unwrap'],
  },

  {
    id: 'swift-optional-006',
    category: 'Optional Handling',
    difficulty: 'medium',
    title: 'Optional Map',
    text: 'Transform the optional value by doubling it if present.',
    setup: 'let number: Int? = 5',
    setupCode: 'let number: Int? = 5',
    expected: 10,
    sample: 'number.map { $0 * 2 }',
    hints: ['map transforms the value if present', 'Returns nil if the optional is nil'],
    validPatterns: [/\.map\s*\{.*\*\s*2.*\}/],
    tags: ['map', 'optional', 'transform'],
  },

  {
    id: 'swift-optional-007',
    category: 'Optional Handling',
    difficulty: 'medium',
    title: 'Optional FlatMap',
    text: 'Parse an optional string to an optional integer.',
    setup: 'let numString: String? = "42"',
    setupCode: 'let numString: String? = "42"',
    expected: 42,
    sample: 'numString.flatMap { Int($0) }',
    hints: [
      'flatMap unwraps nested optionals',
      'Useful when the transform also returns an optional',
    ],
    validPatterns: [/\.flatMap\s*\{.*Int\s*\(\s*\$0\s*\).*\}/],
    tags: ['flatMap', 'optional', 'flatten'],
  },

  {
    id: 'swift-optional-008',
    category: 'Optional Handling',
    difficulty: 'medium',
    title: 'Chained Optional Binding',
    text: 'Unwrap multiple optionals in a single if let statement.',
    setup: 'let firstName: String? = "John"\nlet lastName: String? = "Doe"',
    setupCode: 'let firstName: String? = "John"\nlet lastName: String? = "Doe"',
    expected: 'John Doe',
    sample: 'if let first = firstName, let last = lastName { "\\(first) \\(last)" }',
    hints: [
      'Chain multiple if let conditions with commas',
      'All must be non-nil for the block to execute',
    ],
    validPatterns: [/if\s+let\s+\w+\s*=\s*firstName\s*,\s*let\s+\w+\s*=\s*lastName/],
    tags: ['if let', 'optional', 'chaining'],
  },

  {
    id: 'swift-optional-009',
    category: 'Optional Handling',
    difficulty: 'hard',
    title: 'Nested Optional Chaining',
    text: 'Safely access a deeply nested optional property.',
    setup:
      'struct Address { var city: String? }\nstruct Person { var address: Address? }\nlet person: Person? = Person(address: Address(city: "NYC"))',
    setupCode:
      'struct Address { var city: String? }\nstruct Person { var address: Address? }\nlet person: Person? = Person(address: Address(city: "NYC"))',
    expected: 'NYC',
    sample: 'person?.address?.city',
    hints: [
      'Chain multiple ?. for nested optionals',
      'Returns nil if any part of the chain is nil',
    ],
    validPatterns: [/person\?\s*\.address\?\s*\.city/],
    tags: ['optional chaining', 'optional', 'nested'],
  },

  {
    id: 'swift-optional-010',
    category: 'Optional Handling',
    difficulty: 'hard',
    title: 'Optional with Condition',
    text: 'Unwrap the optional and only proceed if the value is greater than 10.',
    setup: 'let number: Int? = 15',
    setupCode: 'let number: Int? = 15',
    expected: 15,
    sample: 'if let num = number, num > 10 { num }',
    hints: [
      'Add conditions after optional binding with commas',
      'Conditions are checked after successful unwrap',
    ],
    validPatterns: [/if\s+let\s+\w+\s*=\s*number\s*,\s*\w+\s*>\s*10/],
    tags: ['if let', 'optional', 'condition'],
  },

  // ============================================================
  // Array Operations (40 problems: map, filter, reduce, compactMap, flatMap)
  // ============================================================

  {
    id: 'swift-arr-100',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Double Each Element',
    text: 'Use map to double each number in the array.',
    setup: 'let numbers = [1, 2, 3, 4, 5]',
    setupCode: 'let numbers = [1, 2, 3, 4, 5]',
    expected: [2, 4, 6, 8, 10],
    sample: 'numbers.map { $0 * 2 }',
    hints: ['Use map to transform each element', 'Multiply each element by 2'],
    tags: ['map', 'array', 'transform'],
  },

  {
    id: 'swift-arr-101',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Convert to Strings',
    text: 'Use map to convert each number to its string representation.',
    setup: 'let numbers = [1, 2, 3, 4, 5]',
    setupCode: 'let numbers = [1, 2, 3, 4, 5]',
    expected: ['1', '2', '3', '4', '5'],
    sample: 'numbers.map { String($0) }',
    hints: ['Use String() initializer inside map', 'Each number becomes a string'],
    tags: ['map', 'array', 'string conversion'],
  },

  {
    id: 'swift-arr-102',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Filter Positive Numbers',
    text: 'Filter the array to keep only positive numbers.',
    setup: 'let numbers = [-3, -1, 0, 2, 5, -4, 8]',
    setupCode: 'let numbers = [-3, -1, 0, 2, 5, -4, 8]',
    expected: [2, 5, 8],
    sample: 'numbers.filter { $0 > 0 }',
    hints: ['Use filter with a condition', 'Check if element is greater than 0'],
    tags: ['filter', 'array', 'predicate'],
  },

  {
    id: 'swift-arr-103',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Filter Strings by Length',
    text: 'Filter to keep only strings with more than 3 characters.',
    setup: 'let words = ["a", "cat", "hello", "go", "swift"]',
    setupCode: 'let words = ["a", "cat", "hello", "go", "swift"]',
    expected: ['hello', 'swift'],
    sample: 'words.filter { $0.count > 3 }',
    hints: ['Use count property on strings', 'Filter where count > 3'],
    tags: ['filter', 'array', 'string'],
  },

  {
    id: 'swift-arr-104',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Reduce to Product',
    text: 'Calculate the product of all numbers using reduce.',
    setup: 'let numbers = [1, 2, 3, 4, 5]',
    setupCode: 'let numbers = [1, 2, 3, 4, 5]',
    expected: 120,
    sample: 'numbers.reduce(1, *)',
    hints: ['reduce takes initial value and operator', 'Start with 1 for multiplication'],
    tags: ['reduce', 'array', 'product'],
  },

  {
    id: 'swift-arr-105',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Find Maximum',
    text: 'Find the maximum value in the array using reduce.',
    setup: 'let numbers = [3, 7, 2, 9, 4, 1]',
    setupCode: 'let numbers = [3, 7, 2, 9, 4, 1]',
    expected: 9,
    sample: 'numbers.reduce(numbers[0]) { max($0, $1) }',
    hints: ['Use max function inside reduce', 'Or use the max() method directly'],
    tags: ['reduce', 'array', 'max'],
  },

  {
    id: 'swift-arr-106',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'CompactMap Remove Nils',
    text: 'Remove nil values from an array of optionals.',
    setup: 'let values: [Int?] = [1, nil, 3, nil, 5]',
    setupCode: 'let values: [Int?] = [1, nil, 3, nil, 5]',
    expected: [1, 3, 5],
    sample: 'values.compactMap { $0 }',
    hints: ['compactMap removes nil values', 'Returns non-optional array'],
    tags: ['compactMap', 'array', 'optional'],
  },

  {
    id: 'swift-arr-107',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'FlatMap Nested Arrays',
    text: 'Flatten a nested array into a single array.',
    setup: 'let nested = [[1, 2], [3, 4], [5, 6]]',
    setupCode: 'let nested = [[1, 2], [3, 4], [5, 6]]',
    expected: [1, 2, 3, 4, 5, 6],
    sample: 'nested.flatMap { $0 }',
    hints: ['flatMap flattens nested collections', 'Combines all inner arrays'],
    tags: ['flatMap', 'array', 'flatten'],
  },

  {
    id: 'swift-arr-108',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Map with Index',
    text: 'Create array of strings showing each element with its index.',
    setup: 'let fruits = ["apple", "banana", "cherry"]',
    setupCode: 'let fruits = ["apple", "banana", "cherry"]',
    expected: ['0: apple', '1: banana', '2: cherry'],
    sample: 'fruits.enumerated().map { "\\($0.offset): \\($0.element)" }',
    hints: ['Use enumerated() to get index', 'Map over the enumerated sequence'],
    tags: ['map', 'enumerated', 'array'],
  },

  {
    id: 'swift-arr-109',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Filter and Map Combined',
    text: 'Filter even numbers and then square them.',
    setup: 'let numbers = [1, 2, 3, 4, 5, 6]',
    setupCode: 'let numbers = [1, 2, 3, 4, 5, 6]',
    expected: [4, 16, 36],
    sample: 'numbers.filter { $0 % 2 == 0 }.map { $0 * $0 }',
    hints: ['Chain filter and map', 'Filter first, then transform'],
    tags: ['filter', 'map', 'chaining'],
  },

  {
    id: 'swift-arr-110',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Reduce to String',
    text: 'Concatenate all strings with a space separator using reduce.',
    setup: 'let words = ["Hello", "Swift", "World"]',
    setupCode: 'let words = ["Hello", "Swift", "World"]',
    expected: 'Hello Swift World',
    sample: 'words.reduce("") { $0.isEmpty ? $1 : $0 + " " + $1 }',
    hints: ['Handle the first element specially', 'Or use joined(separator:)'],
    tags: ['reduce', 'array', 'string'],
  },

  {
    id: 'swift-arr-111',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'CompactMap Parse Integers',
    text: 'Parse strings to integers, removing invalid ones.',
    setup: 'let strings = ["1", "two", "3", "four", "5"]',
    setupCode: 'let strings = ["1", "two", "3", "four", "5"]',
    expected: [1, 3, 5],
    sample: 'strings.compactMap { Int($0) }',
    hints: ['Int() returns optional', 'compactMap filters out nil results'],
    tags: ['compactMap', 'array', 'parsing'],
  },

  {
    id: 'swift-arr-112',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'FlatMap with Transform',
    text: 'Create pairs of each number with its negative.',
    setup: 'let numbers = [1, 2, 3]',
    setupCode: 'let numbers = [1, 2, 3]',
    expected: [-1, 1, -2, 2, -3, 3],
    sample: 'numbers.flatMap { [-$0, $0] }',
    hints: ['Return an array from the closure', 'flatMap flattens the result'],
    tags: ['flatMap', 'array', 'transform'],
  },

  {
    id: 'swift-arr-113',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Reduce with Initial Collection',
    text: 'Build a reversed array using reduce.',
    setup: 'let numbers = [1, 2, 3, 4, 5]',
    setupCode: 'let numbers = [1, 2, 3, 4, 5]',
    expected: [5, 4, 3, 2, 1],
    sample: 'numbers.reduce([]) { [$1] + $0 }',
    hints: ['Start with empty array', 'Prepend each element'],
    tags: ['reduce', 'array', 'reverse'],
  },

  {
    id: 'swift-arr-114',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Filter with Contains',
    text: 'Filter strings that contain the letter "a".',
    setup: 'let words = ["apple", "hello", "banana", "swift", "cat"]',
    setupCode: 'let words = ["apple", "hello", "banana", "swift", "cat"]',
    expected: ['apple', 'banana', 'cat'],
    sample: 'words.filter { $0.contains("a") }',
    hints: ['Use contains on each string', 'Filter keeps matching elements'],
    tags: ['filter', 'array', 'contains'],
  },

  {
    id: 'swift-arr-115',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Map to Tuple',
    text: 'Map each number to a tuple of (original, squared).',
    setup: 'let numbers = [1, 2, 3, 4]',
    setupCode: 'let numbers = [1, 2, 3, 4]',
    expected: [
      [1, 1],
      [2, 4],
      [3, 9],
      [4, 16],
    ],
    sample: 'numbers.map { ($0, $0 * $0) }',
    hints: ['Return a tuple from map', 'Tuple contains original and square'],
    tags: ['map', 'array', 'tuple'],
  },

  {
    id: 'swift-arr-116',
    category: 'Array Operations',
    difficulty: 'hard',
    title: 'Reduce into Dictionary',
    text: 'Create a dictionary mapping each word to its length.',
    setup: 'let words = ["cat", "elephant", "dog"]',
    setupCode: 'let words = ["cat", "elephant", "dog"]',
    expected: { cat: 3, elephant: 8, dog: 3 },
    sample: 'words.reduce(into: [:]) { $0[$1] = $1.count }',
    hints: ['Use reduce(into:) for mutation', 'Dictionary key is word, value is count'],
    tags: ['reduce', 'array', 'dictionary'],
  },

  {
    id: 'swift-arr-117',
    category: 'Array Operations',
    difficulty: 'hard',
    title: 'CompactMap with Optional Chaining',
    text: 'Extract first characters from optional strings.',
    setup: 'let names: [String?] = ["Alice", nil, "Bob", nil, "Charlie"]',
    setupCode: 'let names: [String?] = ["Alice", nil, "Bob", nil, "Charlie"]',
    expected: ['A', 'B', 'C'],
    sample: 'names.compactMap { $0?.first }.map { String($0) }',
    hints: ['Use optional chaining with first', 'compactMap handles the nils'],
    tags: ['compactMap', 'optional chaining', 'array'],
  },

  {
    id: 'swift-arr-118',
    category: 'Array Operations',
    difficulty: 'hard',
    title: 'FlatMap Nested Optionals',
    text: 'Flatten array of optional arrays into single array.',
    setup: 'let data: [[Int]?] = [[1, 2], nil, [3, 4], nil, [5]]',
    setupCode: 'let data: [[Int]?] = [[1, 2], nil, [3, 4], nil, [5]]',
    expected: [1, 2, 3, 4, 5],
    sample: 'data.compactMap { $0 }.flatMap { $0 }',
    hints: ['First remove nils with compactMap', 'Then flatten with flatMap'],
    tags: ['flatMap', 'compactMap', 'array'],
  },

  {
    id: 'swift-arr-119',
    category: 'Array Operations',
    difficulty: 'hard',
    title: 'Reduce to Grouped Dictionary',
    text: 'Group numbers by whether they are even or odd.',
    setup: 'let numbers = [1, 2, 3, 4, 5, 6, 7, 8]',
    setupCode: 'let numbers = [1, 2, 3, 4, 5, 6, 7, 8]',
    expected: { even: [2, 4, 6, 8], odd: [1, 3, 5, 7] },
    sample: 'Dictionary(grouping: numbers) { $0 % 2 == 0 ? "even" : "odd" }',
    hints: ['Use Dictionary(grouping:by:)', 'Return key based on condition'],
    tags: ['reduce', 'dictionary', 'grouping'],
  },

  {
    id: 'swift-arr-120',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Map to Boolean',
    text: 'Map each number to true if even, false if odd.',
    setup: 'let numbers = [1, 2, 3, 4, 5]',
    setupCode: 'let numbers = [1, 2, 3, 4, 5]',
    expected: [false, true, false, true, false],
    sample: 'numbers.map { $0 % 2 == 0 }',
    hints: ['Return boolean expression from map', 'Check if divisible by 2'],
    tags: ['map', 'array', 'boolean'],
  },

  {
    id: 'swift-arr-121',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Filter Non-Empty Strings',
    text: 'Filter out empty strings from the array.',
    setup: 'let strings = ["hello", "", "world", "", "swift"]',
    setupCode: 'let strings = ["hello", "", "world", "", "swift"]',
    expected: ['hello', 'world', 'swift'],
    sample: 'strings.filter { !$0.isEmpty }',
    hints: ['Use isEmpty property', 'Negate to keep non-empty'],
    tags: ['filter', 'array', 'string'],
  },

  {
    id: 'swift-arr-122',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Reduce Count Elements',
    text: 'Count elements greater than 5 using reduce.',
    setup: 'let numbers = [3, 7, 2, 9, 4, 8, 1]',
    setupCode: 'let numbers = [3, 7, 2, 9, 4, 8, 1]',
    expected: 3,
    sample: 'numbers.reduce(0) { $0 + ($1 > 5 ? 1 : 0) }',
    hints: ['Add 1 for each matching element', 'Use ternary operator'],
    tags: ['reduce', 'array', 'count'],
  },

  {
    id: 'swift-arr-123',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Map Absolute Values',
    text: 'Convert all numbers to their absolute values.',
    setup: 'let numbers = [-3, 5, -2, 8, -1]',
    setupCode: 'let numbers = [-3, 5, -2, 8, -1]',
    expected: [3, 5, 2, 8, 1],
    sample: 'numbers.map { abs($0) }',
    hints: ['Use abs() function', 'Returns positive value'],
    tags: ['map', 'array', 'abs'],
  },

  {
    id: 'swift-arr-124',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Filter by Multiple Conditions',
    text: 'Filter numbers between 5 and 15 inclusive.',
    setup: 'let numbers = [2, 7, 12, 3, 18, 9, 5, 15]',
    setupCode: 'let numbers = [2, 7, 12, 3, 18, 9, 5, 15]',
    expected: [7, 12, 9, 5, 15],
    sample: 'numbers.filter { $0 >= 5 && $0 <= 15 }',
    hints: ['Combine conditions with &&', 'Check both bounds'],
    tags: ['filter', 'array', 'range'],
  },

  {
    id: 'swift-arr-125',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Map with Conditional',
    text: 'Map numbers to "even" or "odd" strings.',
    setup: 'let numbers = [1, 2, 3, 4, 5]',
    setupCode: 'let numbers = [1, 2, 3, 4, 5]',
    expected: ['odd', 'even', 'odd', 'even', 'odd'],
    sample: 'numbers.map { $0 % 2 == 0 ? "even" : "odd" }',
    hints: ['Use ternary operator in map', 'Return string based on condition'],
    tags: ['map', 'array', 'conditional'],
  },

  {
    id: 'swift-arr-126',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Reduce Find Minimum',
    text: 'Find the minimum value using reduce.',
    setup: 'let numbers = [5, 3, 9, 1, 7]',
    setupCode: 'let numbers = [5, 3, 9, 1, 7]',
    expected: 1,
    sample: 'numbers.reduce(numbers[0]) { min($0, $1) }',
    hints: ['Use min function', 'Start with first element'],
    tags: ['reduce', 'array', 'min'],
  },

  {
    id: 'swift-arr-127',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'CompactMap URL Parsing',
    text: 'Parse valid URLs from strings, filtering invalid ones.',
    setup: 'let strings = ["https://apple.com", "invalid", "https://swift.org"]',
    setupCode: 'let strings = ["https://apple.com", "invalid", "https://swift.org"]',
    expected: ['https://apple.com', 'https://swift.org'],
    sample: 'strings.compactMap { URL(string: $0) }.map { $0.absoluteString }',
    hints: ['URL(string:) returns optional', 'compactMap filters nil'],
    tags: ['compactMap', 'array', 'URL'],
  },

  {
    id: 'swift-arr-128',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'FlatMap String to Characters',
    text: 'Flatten strings to array of all characters.',
    setup: 'let words = ["Hi", "Swift"]',
    setupCode: 'let words = ["Hi", "Swift"]',
    expected: ['H', 'i', 'S', 'w', 'i', 'f', 't'],
    sample: 'words.flatMap { Array($0) }',
    hints: ['Convert string to array of characters', 'flatMap combines them'],
    tags: ['flatMap', 'array', 'character'],
  },

  {
    id: 'swift-arr-129',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Reduce Boolean All',
    text: 'Check if all numbers are positive using reduce.',
    setup: 'let numbers = [1, 2, 3, 4, 5]',
    setupCode: 'let numbers = [1, 2, 3, 4, 5]',
    expected: true,
    sample: 'numbers.reduce(true) { $0 && $1 > 0 }',
    hints: ['Start with true', 'AND with each check'],
    tags: ['reduce', 'array', 'all'],
  },

  {
    id: 'swift-arr-130',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Filter First N Elements',
    text: 'Get first 3 elements that are greater than 2.',
    setup: 'let numbers = [1, 3, 2, 5, 4, 6, 7]',
    setupCode: 'let numbers = [1, 3, 2, 5, 4, 6, 7]',
    expected: [3, 5, 4],
    sample: 'Array(numbers.filter { $0 > 2 }.prefix(3))',
    hints: ['Filter first then take prefix', 'prefix limits count'],
    tags: ['filter', 'prefix', 'array'],
  },

  {
    id: 'swift-arr-131',
    category: 'Array Operations',
    difficulty: 'hard',
    title: 'Map Reduce Pipeline',
    text: 'Square each number then sum them all.',
    setup: 'let numbers = [1, 2, 3, 4]',
    setupCode: 'let numbers = [1, 2, 3, 4]',
    expected: 30,
    sample: 'numbers.map { $0 * $0 }.reduce(0, +)',
    hints: ['Chain map and reduce', 'Map to squares, reduce to sum'],
    tags: ['map', 'reduce', 'pipeline'],
  },

  {
    id: 'swift-arr-132',
    category: 'Array Operations',
    difficulty: 'hard',
    title: 'CompactMap and Filter',
    text: 'Parse integers and keep only even ones.',
    setup: 'let strings = ["1", "2", "three", "4", "five", "6"]',
    setupCode: 'let strings = ["1", "2", "three", "4", "five", "6"]',
    expected: [2, 4, 6],
    sample: 'strings.compactMap { Int($0) }.filter { $0 % 2 == 0 }',
    hints: ['compactMap parses and filters nil', 'Then filter for even'],
    tags: ['compactMap', 'filter', 'pipeline'],
  },

  {
    id: 'swift-arr-133',
    category: 'Array Operations',
    difficulty: 'hard',
    title: 'Reduce with Index',
    text: 'Calculate sum of elements multiplied by their index.',
    setup: 'let numbers = [1, 2, 3, 4]',
    setupCode: 'let numbers = [1, 2, 3, 4]',
    expected: 20,
    sample: 'numbers.enumerated().reduce(0) { $0 + $1.offset * $1.element }',
    hints: ['Use enumerated for index', 'Multiply element by offset'],
    tags: ['reduce', 'enumerated', 'array'],
  },

  {
    id: 'swift-arr-134',
    category: 'Array Operations',
    difficulty: 'hard',
    title: 'FlatMap with Filter',
    text: 'Flatten nested arrays and keep only unique elements.',
    setup: 'let nested = [[1, 2, 3], [2, 3, 4], [3, 4, 5]]',
    setupCode: 'let nested = [[1, 2, 3], [2, 3, 4], [3, 4, 5]]',
    expected: [1, 2, 3, 4, 5],
    sample: 'Array(Set(nested.flatMap { $0 })).sorted()',
    hints: ['Flatten first', 'Use Set for uniqueness'],
    tags: ['flatMap', 'set', 'unique'],
  },

  {
    id: 'swift-arr-135',
    category: 'Array Operations',
    difficulty: 'hard',
    title: 'Reduce to Nested Structure',
    text: 'Group consecutive duplicates into subarrays.',
    setup: 'let items = [1, 1, 2, 2, 2, 3, 1, 1]',
    setupCode: 'let items = [1, 1, 2, 2, 2, 3, 1, 1]',
    expected: [[1, 1], [2, 2, 2], [3], [1, 1]],
    sample:
      'items.reduce(into: [[Int]]()) { if $0.last?.last == $1 { $0[$0.count-1].append($1) } else { $0.append([$1]) } }',
    hints: ['Track current group', 'Start new group when value changes'],
    tags: ['reduce', 'grouping', 'array'],
  },

  {
    id: 'swift-arr-136',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Map Add Prefix',
    text: 'Add "Item: " prefix to each string.',
    setup: 'let items = ["Apple", "Banana", "Cherry"]',
    setupCode: 'let items = ["Apple", "Banana", "Cherry"]',
    expected: ['Item: Apple', 'Item: Banana', 'Item: Cherry'],
    sample: 'items.map { "Item: " + $0 }',
    hints: ['Concatenate strings in map', 'Use + operator'],
    tags: ['map', 'string', 'array'],
  },

  {
    id: 'swift-arr-137',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Filter Divisible by 3',
    text: 'Keep only numbers divisible by 3.',
    setup: 'let numbers = [1, 3, 5, 6, 9, 10, 12, 14]',
    setupCode: 'let numbers = [1, 3, 5, 6, 9, 10, 12, 14]',
    expected: [3, 6, 9, 12],
    sample: 'numbers.filter { $0 % 3 == 0 }',
    hints: ['Use modulo operator', 'Check remainder is 0'],
    tags: ['filter', 'array', 'modulo'],
  },

  {
    id: 'swift-arr-138',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Reduce to Average',
    text: 'Calculate the average of all numbers.',
    setup: 'let numbers = [10, 20, 30, 40, 50]',
    setupCode: 'let numbers = [10, 20, 30, 40, 50]',
    expected: 30,
    sample: 'numbers.reduce(0, +) / numbers.count',
    hints: ['Sum with reduce', 'Divide by count'],
    tags: ['reduce', 'array', 'average'],
  },

  {
    id: 'swift-arr-139',
    category: 'Array Operations',
    difficulty: 'hard',
    title: 'Zip and Map',
    text: 'Combine two arrays by adding corresponding elements.',
    setup: 'let a = [1, 2, 3]\nlet b = [10, 20, 30]',
    setupCode: 'let a = [1, 2, 3]\nlet b = [10, 20, 30]',
    expected: [11, 22, 33],
    sample: 'zip(a, b).map { $0 + $1 }',
    hints: ['Use zip to pair elements', 'Map to add pairs'],
    tags: ['zip', 'map', 'array'],
  },

  // ============================================================
  // Dictionary Operations (35 problems: mapValues, filter, merge, compactMapValues)
  // ============================================================

  {
    id: 'swift-dict-100',
    category: 'Dictionary Operations',
    difficulty: 'easy',
    title: 'MapValues Double',
    text: 'Double all values in the dictionary.',
    setup: 'let scores = ["Alice": 10, "Bob": 20, "Charlie": 15]',
    setupCode: 'let scores = ["Alice": 10, "Bob": 20, "Charlie": 15]',
    expected: { Alice: 20, Bob: 40, Charlie: 30 },
    sample: 'scores.mapValues { $0 * 2 }',
    hints: ['mapValues transforms values only', 'Keys remain unchanged'],
    tags: ['mapValues', 'dictionary', 'transform'],
  },

  {
    id: 'swift-dict-101',
    category: 'Dictionary Operations',
    difficulty: 'easy',
    title: 'Filter by Value',
    text: 'Keep only entries where value is greater than 80.',
    setup: 'let grades = ["Math": 85, "English": 72, "Science": 90]',
    setupCode: 'let grades = ["Math": 85, "English": 72, "Science": 90]',
    expected: { Math: 85, Science: 90 },
    sample: 'grades.filter { $0.value > 80 }',
    hints: ['Access value with $0.value', 'Returns filtered dictionary'],
    tags: ['filter', 'dictionary', 'predicate'],
  },

  {
    id: 'swift-dict-102',
    category: 'Dictionary Operations',
    difficulty: 'easy',
    title: 'Dictionary Count',
    text: 'Get the number of key-value pairs.',
    setup: 'let data = ["a": 1, "b": 2, "c": 3, "d": 4]',
    setupCode: 'let data = ["a": 1, "b": 2, "c": 3, "d": 4]',
    expected: 4,
    sample: 'data.count',
    hints: ['count property returns pair count', 'Works like array count'],
    tags: ['count', 'dictionary', 'property'],
  },

  {
    id: 'swift-dict-103',
    category: 'Dictionary Operations',
    difficulty: 'easy',
    title: 'Check Empty Dictionary',
    text: 'Check if the dictionary is empty.',
    setup: 'let empty: [String: Int] = [:]',
    setupCode: 'let empty: [String: Int] = [:]',
    expected: true,
    sample: 'empty.isEmpty',
    hints: ['isEmpty returns boolean', 'True for empty dictionary'],
    tags: ['isEmpty', 'dictionary', 'check'],
  },

  {
    id: 'swift-dict-104',
    category: 'Dictionary Operations',
    difficulty: 'easy',
    title: 'MapValues to String',
    text: 'Convert all integer values to strings.',
    setup: 'let ages = ["Alice": 25, "Bob": 30]',
    setupCode: 'let ages = ["Alice": 25, "Bob": 30]',
    expected: { Alice: '25', Bob: '30' },
    sample: 'ages.mapValues { String($0) }',
    hints: ['Use String() in mapValues', 'Changes value type'],
    tags: ['mapValues', 'dictionary', 'string'],
  },

  {
    id: 'swift-dict-105',
    category: 'Dictionary Operations',
    difficulty: 'medium',
    title: 'Merge with Closure',
    text: 'Merge dictionaries, summing values for duplicate keys.',
    setup: 'var dict1 = ["a": 1, "b": 2]\nlet dict2 = ["b": 3, "c": 4]',
    setupCode: 'var dict1 = ["a": 1, "b": 2]\nlet dict2 = ["b": 3, "c": 4]',
    expected: { a: 1, b: 5, c: 4 },
    sample: 'dict1.merge(dict2) { $0 + $1 }',
    hints: ['Closure handles conflicts', 'Sum current and new value'],
    tags: ['merge', 'dictionary', 'combine'],
  },

  {
    id: 'swift-dict-106',
    category: 'Dictionary Operations',
    difficulty: 'medium',
    title: 'Filter by Key',
    text: 'Keep only entries where key starts with "a".',
    setup: 'let data = ["apple": 1, "banana": 2, "avocado": 3, "cherry": 4]',
    setupCode: 'let data = ["apple": 1, "banana": 2, "avocado": 3, "cherry": 4]',
    expected: { apple: 1, avocado: 3 },
    sample: 'data.filter { $0.key.hasPrefix("a") }',
    hints: ['Access key with $0.key', 'Use hasPrefix for string check'],
    tags: ['filter', 'dictionary', 'key'],
  },

  {
    id: 'swift-dict-107',
    category: 'Dictionary Operations',
    difficulty: 'medium',
    title: 'CompactMapValues',
    text: 'Parse string values to integers, removing failures.',
    setup: 'let data = ["a": "1", "b": "two", "c": "3"]',
    setupCode: 'let data = ["a": "1", "b": "two", "c": "3"]',
    expected: { a: 1, c: 3 },
    sample: 'data.compactMapValues { Int($0) }',
    hints: ['compactMapValues removes nil results', 'Int() returns optional'],
    tags: ['compactMapValues', 'dictionary', 'parsing'],
  },

  {
    id: 'swift-dict-108',
    category: 'Dictionary Operations',
    difficulty: 'medium',
    title: 'Merging New Dictionary',
    text: 'Create new dictionary by merging, keeping newer values.',
    setup: 'let old = ["a": 1, "b": 2]\nlet new = ["b": 20, "c": 30]',
    setupCode: 'let old = ["a": 1, "b": 2]\nlet new = ["b": 20, "c": 30]',
    expected: { a: 1, b: 20, c: 30 },
    sample: 'old.merging(new) { _, new in new }',
    hints: ['merging returns new dictionary', 'Choose new value in closure'],
    tags: ['merging', 'dictionary', 'immutable'],
  },

  {
    id: 'swift-dict-109',
    category: 'Dictionary Operations',
    difficulty: 'medium',
    title: 'MapValues with Calculation',
    text: 'Apply 10% discount to all prices.',
    setup: 'let prices = ["apple": 100, "banana": 50, "orange": 75]',
    setupCode: 'let prices = ["apple": 100, "banana": 50, "orange": 75]',
    expected: { apple: 90, banana: 45, orange: 67 },
    sample: 'prices.mapValues { Int(Double($0) * 0.9) }',
    hints: ['Multiply by 0.9 for 10% off', 'Convert types as needed'],
    tags: ['mapValues', 'dictionary', 'calculation'],
  },

  {
    id: 'swift-dict-110',
    category: 'Dictionary Operations',
    difficulty: 'medium',
    title: 'Filter and Count',
    text: 'Count entries where value is negative.',
    setup: 'let balances = ["Alice": 100, "Bob": -50, "Charlie": -20, "David": 30]',
    setupCode: 'let balances = ["Alice": 100, "Bob": -50, "Charlie": -20, "David": 30]',
    expected: 2,
    sample: 'balances.filter { $0.value < 0 }.count',
    hints: ['Filter negative values', 'Count the result'],
    tags: ['filter', 'count', 'dictionary'],
  },

  {
    id: 'swift-dict-111',
    category: 'Dictionary Operations',
    difficulty: 'medium',
    title: 'Dictionary from Arrays',
    text: 'Create dictionary from two arrays using zip.',
    setup: 'let keys = ["a", "b", "c"]\nlet values = [1, 2, 3]',
    setupCode: 'let keys = ["a", "b", "c"]\nlet values = [1, 2, 3]',
    expected: { a: 1, b: 2, c: 3 },
    sample: 'Dictionary(uniqueKeysWithValues: zip(keys, values))',
    hints: ['Use zip to pair arrays', 'Dictionary initializer takes pairs'],
    tags: ['dictionary', 'zip', 'creation'],
  },

  {
    id: 'swift-dict-112',
    category: 'Dictionary Operations',
    difficulty: 'hard',
    title: 'Nested Dictionary MapValues',
    text: 'Double all nested dictionary values.',
    setup: 'let nested = ["group1": ["a": 1, "b": 2], "group2": ["c": 3]]',
    setupCode: 'let nested = ["group1": ["a": 1, "b": 2], "group2": ["c": 3]]',
    expected: { group1: { a: 2, b: 4 }, group2: { c: 6 } },
    sample: 'nested.mapValues { $0.mapValues { $0 * 2 } }',
    hints: ['Nested mapValues calls', 'Inner mapValues for inner dict'],
    tags: ['mapValues', 'nested', 'dictionary'],
  },

  {
    id: 'swift-dict-113',
    category: 'Dictionary Operations',
    difficulty: 'hard',
    title: 'CompactMapValues Chain',
    text: 'Parse and filter values greater than 5.',
    setup: 'let data = ["a": "3", "b": "10", "c": "invalid", "d": "7"]',
    setupCode: 'let data = ["a": "3", "b": "10", "c": "invalid", "d": "7"]',
    expected: { b: 10, d: 7 },
    sample: 'data.compactMapValues { Int($0) }.filter { $0.value > 5 }',
    hints: ['Parse first with compactMapValues', 'Then filter by value'],
    tags: ['compactMapValues', 'filter', 'dictionary'],
  },

  {
    id: 'swift-dict-114',
    category: 'Dictionary Operations',
    difficulty: 'hard',
    title: 'Invert Dictionary',
    text: 'Swap keys and values in the dictionary.',
    setup: 'let original = ["a": 1, "b": 2, "c": 3]',
    setupCode: 'let original = ["a": 1, "b": 2, "c": 3]',
    expected: { 1: 'a', 2: 'b', 3: 'c' },
    sample: 'Dictionary(uniqueKeysWithValues: original.map { ($0.value, $0.key) })',
    hints: ['Map to swap key/value pairs', 'Create new dictionary'],
    tags: ['dictionary', 'invert', 'transform'],
  },

  {
    id: 'swift-dict-115',
    category: 'Dictionary Operations',
    difficulty: 'easy',
    title: 'Get Sorted Keys',
    text: 'Get all keys sorted alphabetically.',
    setup: 'let data = ["cherry": 3, "apple": 1, "banana": 2]',
    setupCode: 'let data = ["cherry": 3, "apple": 1, "banana": 2]',
    expected: ['apple', 'banana', 'cherry'],
    sample: 'data.keys.sorted()',
    hints: ['Access keys property', 'Call sorted() on it'],
    tags: ['keys', 'sorted', 'dictionary'],
  },

  {
    id: 'swift-dict-116',
    category: 'Dictionary Operations',
    difficulty: 'easy',
    title: 'Get Sorted Values',
    text: 'Get all values sorted in ascending order.',
    setup: 'let scores = ["Alice": 85, "Bob": 92, "Charlie": 78]',
    setupCode: 'let scores = ["Alice": 85, "Bob": 92, "Charlie": 78]',
    expected: [78, 85, 92],
    sample: 'scores.values.sorted()',
    hints: ['Access values property', 'Sort the values'],
    tags: ['values', 'sorted', 'dictionary'],
  },

  {
    id: 'swift-dict-117',
    category: 'Dictionary Operations',
    difficulty: 'medium',
    title: 'Dictionary Reduce Sum',
    text: 'Sum all values in the dictionary.',
    setup: 'let amounts = ["rent": 1000, "food": 300, "transport": 150]',
    setupCode: 'let amounts = ["rent": 1000, "food": 300, "transport": 150]',
    expected: 1450,
    sample: 'amounts.values.reduce(0, +)',
    hints: ['Get values first', 'Reduce with + operator'],
    tags: ['reduce', 'values', 'dictionary'],
  },

  {
    id: 'swift-dict-118',
    category: 'Dictionary Operations',
    difficulty: 'medium',
    title: 'Filter Contains Substring',
    text: 'Keep entries where key contains "e".',
    setup: 'let words = ["hello": 1, "world": 2, "test": 3, "swift": 4]',
    setupCode: 'let words = ["hello": 1, "world": 2, "test": 3, "swift": 4]',
    expected: { hello: 1, test: 3 },
    sample: 'words.filter { $0.key.contains("e") }',
    hints: ['Use contains on key', 'Check for substring'],
    tags: ['filter', 'contains', 'dictionary'],
  },

  {
    id: 'swift-dict-119',
    category: 'Dictionary Operations',
    difficulty: 'hard',
    title: 'Group Array to Dictionary',
    text: 'Group words by their first letter.',
    setup: 'let words = ["apple", "ant", "banana", "bear", "cherry"]',
    setupCode: 'let words = ["apple", "ant", "banana", "bear", "cherry"]',
    expected: { a: ['apple', 'ant'], b: ['banana', 'bear'], c: ['cherry'] },
    sample: 'Dictionary(grouping: words) { String($0.first!) }',
    hints: ['Use Dictionary(grouping:by:)', 'Group by first character'],
    tags: ['grouping', 'dictionary', 'array'],
  },

  {
    id: 'swift-dict-120',
    category: 'Dictionary Operations',
    difficulty: 'easy',
    title: 'Remove All Values',
    text: 'Clear all entries from the dictionary.',
    setup: 'var data = ["a": 1, "b": 2, "c": 3]',
    setupCode: 'var data = ["a": 1, "b": 2, "c": 3]',
    expected: {},
    sample: 'data.removeAll()',
    hints: ['removeAll() clears dictionary', 'Requires var declaration'],
    tags: ['removeAll', 'dictionary', 'clear'],
  },

  {
    id: 'swift-dict-121',
    category: 'Dictionary Operations',
    difficulty: 'medium',
    title: 'First Where Value',
    text: 'Find first entry where value is greater than 50.',
    setup: 'let scores = ["Alice": 45, "Bob": 72, "Charlie": 68]',
    setupCode: 'let scores = ["Alice": 45, "Bob": 72, "Charlie": 68]',
    expected: 72,
    sample: 'scores.first { $0.value > 50 }?.value',
    hints: ['first(where:) finds matching entry', 'Returns optional tuple'],
    tags: ['first', 'dictionary', 'search'],
  },

  {
    id: 'swift-dict-122',
    category: 'Dictionary Operations',
    difficulty: 'medium',
    title: 'Contains Where',
    text: 'Check if any value is negative.',
    setup: 'let balances = ["Alice": 100, "Bob": -20, "Charlie": 50]',
    setupCode: 'let balances = ["Alice": 100, "Bob": -20, "Charlie": 50]',
    expected: true,
    sample: 'balances.contains { $0.value < 0 }',
    hints: ['contains(where:) takes predicate', 'Check value condition'],
    tags: ['contains', 'dictionary', 'predicate'],
  },

  {
    id: 'swift-dict-123',
    category: 'Dictionary Operations',
    difficulty: 'hard',
    title: 'Dictionary to Sorted Array',
    text: 'Convert to array of tuples sorted by value descending.',
    setup: 'let scores = ["Alice": 85, "Bob": 92, "Charlie": 78]',
    setupCode: 'let scores = ["Alice": 85, "Bob": 92, "Charlie": 78]',
    expected: [
      ['Bob', 92],
      ['Alice', 85],
      ['Charlie', 78],
    ],
    sample: 'scores.sorted { $0.value > $1.value }.map { [$0.key, $0.value] }',
    hints: ['Sort by value descending', 'Map to array format'],
    tags: ['sorted', 'dictionary', 'array'],
  },

  {
    id: 'swift-dict-124',
    category: 'Dictionary Operations',
    difficulty: 'hard',
    title: 'Merge Multiple Dictionaries',
    text: 'Merge three dictionaries with sum for conflicts.',
    setup: 'let d1 = ["a": 1]\nlet d2 = ["a": 2, "b": 2]\nlet d3 = ["b": 3, "c": 3]',
    setupCode: 'let d1 = ["a": 1]\nlet d2 = ["a": 2, "b": 2]\nlet d3 = ["b": 3, "c": 3]',
    expected: { a: 3, b: 5, c: 3 },
    sample:
      '[d1, d2, d3].reduce(into: [:]) { result, dict in dict.forEach { result[$0.key, default: 0] += $0.value } }',
    hints: ['Reduce array of dicts', 'Sum values for same keys'],
    tags: ['merge', 'reduce', 'dictionary'],
  },

  {
    id: 'swift-dict-125',
    category: 'Dictionary Operations',
    difficulty: 'easy',
    title: 'MapValues Uppercase',
    text: 'Convert all string values to uppercase.',
    setup: 'let data = ["name": "alice", "city": "boston"]',
    setupCode: 'let data = ["name": "alice", "city": "boston"]',
    expected: { name: 'ALICE', city: 'BOSTON' },
    sample: 'data.mapValues { $0.uppercased() }',
    hints: ['Use uppercased() in mapValues', 'Transforms each value'],
    tags: ['mapValues', 'uppercase', 'dictionary'],
  },

  {
    id: 'swift-dict-126',
    category: 'Dictionary Operations',
    difficulty: 'medium',
    title: 'Dictionary Max Value',
    text: 'Find the entry with maximum value.',
    setup: 'let scores = ["Alice": 85, "Bob": 92, "Charlie": 78]',
    setupCode: 'let scores = ["Alice": 85, "Bob": 92, "Charlie": 78]',
    expected: ['Bob', 92],
    sample: 'scores.max { $0.value < $1.value }.map { [$0.key, $0.value] }',
    hints: ['Use max(by:) with comparison', 'Compare values'],
    tags: ['max', 'dictionary', 'find'],
  },

  {
    id: 'swift-dict-127',
    category: 'Dictionary Operations',
    difficulty: 'medium',
    title: 'Dictionary Min Value',
    text: 'Find the entry with minimum value.',
    setup: 'let prices = ["apple": 150, "banana": 80, "orange": 120]',
    setupCode: 'let prices = ["apple": 150, "banana": 80, "orange": 120]',
    expected: ['banana', 80],
    sample: 'prices.min { $0.value < $1.value }.map { [$0.key, $0.value] }',
    hints: ['Use min(by:) with comparison', 'Compare by value'],
    tags: ['min', 'dictionary', 'find'],
  },

  {
    id: 'swift-dict-128',
    category: 'Dictionary Operations',
    difficulty: 'hard',
    title: 'Transform Keys',
    text: 'Convert all keys to uppercase.',
    setup: 'let data = ["name": 1, "age": 2, "city": 3]',
    setupCode: 'let data = ["name": 1, "age": 2, "city": 3]',
    expected: { NAME: 1, AGE: 2, CITY: 3 },
    sample: 'Dictionary(uniqueKeysWithValues: data.map { ($0.key.uppercased(), $0.value) })',
    hints: ['Map key-value pairs', 'Transform key in tuple'],
    tags: ['dictionary', 'keys', 'transform'],
  },

  {
    id: 'swift-dict-129',
    category: 'Dictionary Operations',
    difficulty: 'hard',
    title: 'Filter Both Key and Value',
    text: 'Keep entries where key length equals value.',
    setup: 'let data = ["cat": 3, "elephant": 5, "dog": 3, "bird": 10]',
    setupCode: 'let data = ["cat": 3, "elephant": 5, "dog": 3, "bird": 10]',
    expected: { cat: 3, dog: 3 },
    sample: 'data.filter { $0.key.count == $0.value }',
    hints: ['Compare key length to value', 'Use count on key'],
    tags: ['filter', 'dictionary', 'condition'],
  },

  {
    id: 'swift-dict-130',
    category: 'Dictionary Operations',
    difficulty: 'easy',
    title: 'Dictionary ForEach',
    text: 'Iterate and collect formatted strings.',
    setup: 'let ages = ["Alice": 25, "Bob": 30]',
    setupCode: 'let ages = ["Alice": 25, "Bob": 30]',
    expected: ['Alice: 25', 'Bob: 30'],
    sample: 'ages.map { "\\($0.key): \\($0.value)" }.sorted()',
    hints: ['Map to formatted strings', 'Sort for consistent order'],
    tags: ['map', 'dictionary', 'format'],
  },

  {
    id: 'swift-dict-131',
    category: 'Dictionary Operations',
    difficulty: 'medium',
    title: 'Reduce to Single Value',
    text: 'Concatenate all keys with comma.',
    setup: 'let data = ["a": 1, "b": 2, "c": 3]',
    setupCode: 'let data = ["a": 1, "b": 2, "c": 3]',
    expected: 'a, b, c',
    sample: 'data.keys.sorted().joined(separator: ", ")',
    hints: ['Get keys and sort', 'Join with separator'],
    tags: ['keys', 'joined', 'dictionary'],
  },

  {
    id: 'swift-dict-132',
    category: 'Dictionary Operations',
    difficulty: 'hard',
    title: 'Nested CompactMapValues',
    text: 'Parse nested optional values.',
    setup: 'let data = ["a": ["x": "1"], "b": ["x": "invalid"], "c": ["x": "3"]]',
    setupCode: 'let data = ["a": ["x": "1"], "b": ["x": "invalid"], "c": ["x": "3"]]',
    expected: { a: 1, c: 3 },
    sample: 'data.compactMapValues { Int($0["x"] ?? "") }',
    hints: ['Access nested value', 'compactMapValues filters nil'],
    tags: ['compactMapValues', 'nested', 'dictionary'],
  },

  {
    id: 'swift-dict-133',
    category: 'Dictionary Operations',
    difficulty: 'medium',
    title: 'AllSatisfy Check',
    text: 'Check if all values are positive.',
    setup: 'let balances = ["Alice": 100, "Bob": 50, "Charlie": 25]',
    setupCode: 'let balances = ["Alice": 100, "Bob": 50, "Charlie": 25]',
    expected: true,
    sample: 'balances.allSatisfy { $0.value > 0 }',
    hints: ['allSatisfy checks all elements', 'Returns boolean'],
    tags: ['allSatisfy', 'dictionary', 'check'],
  },

  {
    id: 'swift-dict-134',
    category: 'Dictionary Operations',
    difficulty: 'hard',
    title: 'Dictionary Partition',
    text: 'Split dictionary into two based on value threshold.',
    setup: 'let scores = ["A": 90, "B": 60, "C": 85, "D": 55]',
    setupCode: 'let scores = ["A": 90, "B": 60, "C": 85, "D": 55]',
    expected: { pass: { A: 90, C: 85 }, fail: { B: 60, D: 55 } },
    sample: '["pass": scores.filter { $0.value >= 70 }, "fail": scores.filter { $0.value < 70 }]',
    hints: ['Filter twice with opposite conditions', 'Create result dictionary'],
    tags: ['filter', 'partition', 'dictionary'],
  },

  // ============================================================
  // String Operations (35 problems: String methods, Substring, Character)
  // ============================================================

  {
    id: 'swift-str-100',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Trim Whitespace',
    text: 'Remove leading and trailing whitespace.',
    setup: 'let text = "   Hello World   "',
    setupCode: 'let text = "   Hello World   "',
    expected: 'Hello World',
    sample: 'text.trimmingCharacters(in: .whitespaces)',
    hints: ['Use trimmingCharacters', 'Pass .whitespaces character set'],
    tags: ['trim', 'string', 'whitespace'],
  },

  {
    id: 'swift-str-101',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Replace Substring',
    text: 'Replace all occurrences of "a" with "o".',
    setup: 'let text = "banana"',
    setupCode: 'let text = "banana"',
    expected: 'bonono',
    sample: 'text.replacingOccurrences(of: "a", with: "o")',
    hints: ['Use replacingOccurrences', 'Specify of and with parameters'],
    tags: ['replace', 'string', 'substring'],
  },

  {
    id: 'swift-str-102',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'String to Array',
    text: 'Convert string to array of characters.',
    setup: 'let text = "Swift"',
    setupCode: 'let text = "Swift"',
    expected: ['S', 'w', 'i', 'f', 't'],
    sample: 'Array(text)',
    hints: ['Use Array() initializer', 'String is a collection of characters'],
    tags: ['array', 'string', 'character'],
  },

  {
    id: 'swift-str-103',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Check Empty String',
    text: 'Check if the string is empty.',
    setup: 'let text = ""',
    setupCode: 'let text = ""',
    expected: true,
    sample: 'text.isEmpty',
    hints: ['isEmpty property returns boolean', 'True for empty string'],
    tags: ['isEmpty', 'string', 'check'],
  },

  {
    id: 'swift-str-104',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Capitalize String',
    text: 'Capitalize the first letter of each word.',
    setup: 'let text = "hello swift world"',
    setupCode: 'let text = "hello swift world"',
    expected: 'Hello Swift World',
    sample: 'text.capitalized',
    hints: ['capitalized property', 'Capitalizes each word'],
    tags: ['capitalized', 'string', 'case'],
  },

  {
    id: 'swift-str-105',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Drop First Characters',
    text: 'Remove the first 3 characters.',
    setup: 'let text = "Hello World"',
    setupCode: 'let text = "Hello World"',
    expected: 'lo World',
    sample: 'String(text.dropFirst(3))',
    hints: ['dropFirst(n) removes n characters', 'Convert result to String'],
    tags: ['dropFirst', 'string', 'substring'],
  },

  {
    id: 'swift-str-106',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Drop Last Characters',
    text: 'Remove the last 5 characters.',
    setup: 'let text = "Hello World"',
    setupCode: 'let text = "Hello World"',
    expected: 'Hello ',
    sample: 'String(text.dropLast(5))',
    hints: ['dropLast(n) removes from end', 'Convert result to String'],
    tags: ['dropLast', 'string', 'substring'],
  },

  {
    id: 'swift-str-107',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Get Suffix',
    text: 'Get the last 5 characters of the string.',
    setup: 'let text = "Hello World"',
    setupCode: 'let text = "Hello World"',
    expected: 'World',
    sample: 'String(text.suffix(5))',
    hints: ['suffix(n) gets last n characters', 'Returns Substring'],
    tags: ['suffix', 'string', 'substring'],
  },

  {
    id: 'swift-str-108',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Find First Index',
    text: 'Find the index of first occurrence of "o".',
    setup: 'let text = "Hello World"',
    setupCode: 'let text = "Hello World"',
    expected: 4,
    sample: 'text.firstIndex(of: "o").map { text.distance(from: text.startIndex, to: $0) }',
    hints: ['firstIndex returns String.Index', 'Convert to integer with distance'],
    tags: ['firstIndex', 'string', 'search'],
  },

  {
    id: 'swift-str-109',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Reverse String',
    text: 'Reverse the characters in the string.',
    setup: 'let text = "Swift"',
    setupCode: 'let text = "Swift"',
    expected: 'tfiwS',
    sample: 'String(text.reversed())',
    hints: ['reversed() reverses collection', 'Convert to String'],
    tags: ['reversed', 'string', 'transform'],
  },

  {
    id: 'swift-str-110',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Pad String',
    text: 'Pad the string with zeros to length 5.',
    setup: 'let text = "42"',
    setupCode: 'let text = "42"',
    expected: '00042',
    sample: 'String(repeating: "0", count: max(0, 5 - text.count)) + text',
    hints: ['Calculate padding needed', 'Prepend repeated characters'],
    tags: ['padding', 'string', 'format'],
  },

  {
    id: 'swift-str-111',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Extract Range',
    text: 'Extract characters from index 2 to 5.',
    setup: 'let text = "Hello World"',
    setupCode: 'let text = "Hello World"',
    expected: 'llo',
    sample:
      'String(text[text.index(text.startIndex, offsetBy: 2)..<text.index(text.startIndex, offsetBy: 5)])',
    hints: ['Create range with String.Index', 'Use offsetBy to calculate'],
    tags: ['range', 'string', 'substring'],
  },

  {
    id: 'swift-str-112',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Split by Multiple Delimiters',
    text: 'Split by comma or semicolon.',
    setup: 'let text = "a,b;c,d;e"',
    setupCode: 'let text = "a,b;c,d;e"',
    expected: ['a', 'b', 'c', 'd', 'e'],
    sample: 'text.components(separatedBy: CharacterSet(charactersIn: ",;"))',
    hints: ['Use CharacterSet for multiple delimiters', 'components(separatedBy:)'],
    tags: ['split', 'string', 'delimiter'],
  },

  {
    id: 'swift-str-113',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Repeat String',
    text: 'Repeat the string 3 times.',
    setup: 'let text = "ab"',
    setupCode: 'let text = "ab"',
    expected: 'ababab',
    sample: 'String(repeating: text, count: 3)',
    hints: ['String(repeating:count:)', 'Creates repeated string'],
    tags: ['repeat', 'string', 'create'],
  },

  {
    id: 'swift-str-114',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Remove Character',
    text: 'Remove all occurrences of letter "l".',
    setup: 'let text = "Hello World"',
    setupCode: 'let text = "Hello World"',
    expected: 'Heo Word',
    sample: 'text.filter { $0 != "l" }',
    hints: ['Filter characters', 'Keep those not equal to "l"'],
    tags: ['filter', 'string', 'character'],
  },

  {
    id: 'swift-str-115',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Count Character Occurrences',
    text: 'Count how many times "o" appears.',
    setup: 'let text = "Hello World"',
    setupCode: 'let text = "Hello World"',
    expected: 2,
    sample: 'text.filter { $0 == "o" }.count',
    hints: ['Filter matching characters', 'Count the result'],
    tags: ['count', 'string', 'character'],
  },

  {
    id: 'swift-str-116',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Word Count',
    text: 'Count the number of words.',
    setup: 'let text = "Hello Swift Programming World"',
    setupCode: 'let text = "Hello Swift Programming World"',
    expected: 4,
    sample: 'text.split(separator: " ").count',
    hints: ['Split by space', 'Count the parts'],
    tags: ['split', 'count', 'words'],
  },

  {
    id: 'swift-str-117',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Is Palindrome',
    text: 'Check if string is a palindrome.',
    setup: 'let text = "racecar"',
    setupCode: 'let text = "racecar"',
    expected: true,
    sample: 'text == String(text.reversed())',
    hints: ['Compare with reversed', 'Same means palindrome'],
    tags: ['palindrome', 'string', 'check'],
  },

  {
    id: 'swift-str-118',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'First Character',
    text: 'Get the first character as String.',
    setup: 'let text = "Swift"',
    setupCode: 'let text = "Swift"',
    expected: 'S',
    sample: 'text.first.map { String($0) }',
    hints: ['first returns optional Character', 'Convert to String'],
    tags: ['first', 'string', 'character'],
  },

  {
    id: 'swift-str-119',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Last Character',
    text: 'Get the last character as String.',
    setup: 'let text = "Swift"',
    setupCode: 'let text = "Swift"',
    expected: 't',
    sample: 'text.last.map { String($0) }',
    hints: ['last returns optional Character', 'Convert to String'],
    tags: ['last', 'string', 'character'],
  },

  {
    id: 'swift-str-120',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Insert at Index',
    text: 'Insert "X" at index 3.',
    setup: 'var text = "Hello"',
    setupCode: 'var text = "Hello"',
    expected: 'HelXlo',
    sample: 'text.insert("X", at: text.index(text.startIndex, offsetBy: 3))',
    hints: ['Use insert(_:at:)', 'Calculate index with offsetBy'],
    tags: ['insert', 'string', 'modify'],
  },

  {
    id: 'swift-str-121',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Remove at Index',
    text: 'Remove character at index 2.',
    setup: 'var text = "Hello"',
    setupCode: 'var text = "Hello"',
    expected: 'Helo',
    sample: 'text.remove(at: text.index(text.startIndex, offsetBy: 2))',
    hints: ['Use remove(at:)', 'Returns removed character'],
    tags: ['remove', 'string', 'modify'],
  },

  {
    id: 'swift-str-122',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Find All Indices',
    text: 'Find all indices where "l" occurs.',
    setup: 'let text = "Hello World"',
    setupCode: 'let text = "Hello World"',
    expected: [2, 3, 9],
    sample: 'text.enumerated().compactMap { $0.element == "l" ? $0.offset : nil }',
    hints: ['Enumerate to get indices', 'Filter matching characters'],
    tags: ['enumerated', 'string', 'search'],
  },

  {
    id: 'swift-str-123',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Camel to Snake Case',
    text: 'Convert camelCase to snake_case.',
    setup: 'let text = "helloSwiftWorld"',
    setupCode: 'let text = "helloSwiftWorld"',
    expected: 'hello_swift_world',
    sample: 'text.map { $0.isUppercase ? "_\\($0.lowercased())" : String($0) }.joined()',
    hints: ['Check for uppercase letters', 'Prefix with underscore and lowercase'],
    tags: ['case', 'string', 'transform'],
  },

  {
    id: 'swift-str-124',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Append String',
    text: 'Append " World" to the string.',
    setup: 'var text = "Hello"',
    setupCode: 'var text = "Hello"',
    expected: 'Hello World',
    sample: 'text += " World"',
    hints: ['Use += operator', 'Or append() method'],
    tags: ['append', 'string', 'concatenate'],
  },

  {
    id: 'swift-str-125',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Range of Substring',
    text: 'Find the range of "World" in the string.',
    setup: 'let text = "Hello World"',
    setupCode: 'let text = "Hello World"',
    expected: true,
    sample: 'text.range(of: "World") != nil',
    hints: ['range(of:) finds substring', 'Returns optional Range'],
    tags: ['range', 'string', 'search'],
  },

  {
    id: 'swift-str-126',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Unicode Scalars',
    text: 'Get array of Unicode scalar values.',
    setup: 'let text = "ABC"',
    setupCode: 'let text = "ABC"',
    expected: [65, 66, 67],
    sample: 'text.unicodeScalars.map { Int($0.value) }',
    hints: ['Access unicodeScalars', 'Map to integer values'],
    tags: ['unicode', 'string', 'scalar'],
  },

  {
    id: 'swift-str-127',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'String from Unicode',
    text: 'Create string from ASCII values.',
    setup: 'let codes = [72, 105]',
    setupCode: 'let codes = [72, 105]',
    expected: 'Hi',
    sample: 'String(codes.compactMap { UnicodeScalar($0) }.map { Character($0) })',
    hints: ['Convert to UnicodeScalar', 'Then to Character'],
    tags: ['unicode', 'string', 'create'],
  },

  {
    id: 'swift-str-128',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Check Numeric String',
    text: 'Check if string contains only digits.',
    setup: 'let text = "12345"',
    setupCode: 'let text = "12345"',
    expected: true,
    sample: 'text.allSatisfy { $0.isNumber }',
    hints: ['Use allSatisfy', 'Check isNumber property'],
    tags: ['allSatisfy', 'string', 'check'],
  },

  {
    id: 'swift-str-129',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Check Alphanumeric',
    text: 'Check if string is alphanumeric only.',
    setup: 'let text = "Swift5"',
    setupCode: 'let text = "Swift5"',
    expected: true,
    sample: 'text.allSatisfy { $0.isLetter || $0.isNumber }',
    hints: ['Check both isLetter and isNumber', 'Use || operator'],
    tags: ['allSatisfy', 'string', 'alphanumeric'],
  },

  {
    id: 'swift-str-130',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Longest Word',
    text: 'Find the longest word in the sentence.',
    setup: 'let text = "The quick brown fox"',
    setupCode: 'let text = "The quick brown fox"',
    expected: 'quick',
    sample: 'text.split(separator: " ").max { $0.count < $1.count }.map(String.init)',
    hints: ['Split into words', 'Find max by count'],
    tags: ['split', 'max', 'string'],
  },

  {
    id: 'swift-str-131',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Compare Strings Ignoring Case',
    text: 'Check if two strings are equal ignoring case.',
    setup: 'let a = "Hello"\nlet b = "HELLO"',
    setupCode: 'let a = "Hello"\nlet b = "HELLO"',
    expected: true,
    sample: 'a.lowercased() == b.lowercased()',
    hints: ['Convert both to same case', 'Then compare'],
    tags: ['compare', 'string', 'case'],
  },

  {
    id: 'swift-str-132',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Remove Vowels',
    text: 'Remove all vowels from the string.',
    setup: 'let text = "Hello World"',
    setupCode: 'let text = "Hello World"',
    expected: 'Hll Wrld',
    sample: 'text.filter { !"aeiouAEIOU".contains($0) }',
    hints: ['Filter out vowels', 'Check against vowel string'],
    tags: ['filter', 'string', 'vowels'],
  },

  {
    id: 'swift-str-133',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Title Case',
    text: 'Convert to title case (first letter of each word uppercase).',
    setup: 'let text = "hello swift world"',
    setupCode: 'let text = "hello swift world"',
    expected: 'Hello Swift World',
    sample:
      'text.split(separator: " ").map { $0.prefix(1).uppercased() + $0.dropFirst().lowercased() }.joined(separator: " ")',
    hints: ['Split into words', 'Capitalize first letter of each'],
    tags: ['title case', 'string', 'transform'],
  },

  {
    id: 'swift-str-134',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Anagram Check',
    text: 'Check if two strings are anagrams.',
    setup: 'let a = "listen"\nlet b = "silent"',
    setupCode: 'let a = "listen"\nlet b = "silent"',
    expected: true,
    sample: 'a.sorted() == b.sorted()',
    hints: ['Sort characters of both', 'Compare sorted arrays'],
    tags: ['anagram', 'string', 'check'],
  },

  // ============================================================
  // Optionals (35 problems: ?, ??, if let, guard let, optional chaining)
  // ============================================================

  {
    id: 'swift-opt-100',
    category: 'Optionals',
    difficulty: 'easy',
    title: 'Nil Coalescing with Number',
    text: 'Return value or default 0 if nil.',
    setup: 'let value: Int? = nil',
    setupCode: 'let value: Int? = nil',
    expected: 0,
    sample: 'value ?? 0',
    hints: ['Use ?? operator', 'Provides default value'],
    tags: ['nil coalescing', 'optional', 'default'],
  },

  {
    id: 'swift-opt-101',
    category: 'Optionals',
    difficulty: 'easy',
    title: 'Optional String Length',
    text: 'Get length of optional string or 0.',
    setup: 'let text: String? = "Hello"',
    setupCode: 'let text: String? = "Hello"',
    expected: 5,
    sample: 'text?.count ?? 0',
    hints: ['Chain with ?.count', 'Use ?? for default'],
    tags: ['optional chaining', 'count', 'optional'],
  },

  {
    id: 'swift-opt-102',
    category: 'Optionals',
    difficulty: 'easy',
    title: 'Check Optional Has Value',
    text: 'Check if optional is not nil.',
    setup: 'let name: String? = "Alice"',
    setupCode: 'let name: String? = "Alice"',
    expected: true,
    sample: 'name != nil',
    hints: ['Compare with nil', 'Use != operator'],
    tags: ['nil check', 'optional', 'boolean'],
  },

  {
    id: 'swift-opt-103',
    category: 'Optionals',
    difficulty: 'easy',
    title: 'Optional Integer Parse',
    text: 'Parse string to integer (returns optional).',
    setup: 'let text = "42"',
    setupCode: 'let text = "42"',
    expected: 42,
    sample: 'Int(text)',
    hints: ['Int() initializer returns optional', 'nil for invalid strings'],
    tags: ['Int', 'parsing', 'optional'],
  },

  {
    id: 'swift-opt-104',
    category: 'Optionals',
    difficulty: 'medium',
    title: 'Chained Nil Coalescing',
    text: 'Try multiple optionals with defaults.',
    setup: 'let a: Int? = nil\nlet b: Int? = nil\nlet c: Int? = 5',
    setupCode: 'let a: Int? = nil\nlet b: Int? = nil\nlet c: Int? = 5',
    expected: 5,
    sample: 'a ?? b ?? c ?? 0',
    hints: ['Chain ?? operators', 'First non-nil wins'],
    tags: ['nil coalescing', 'chain', 'optional'],
  },

  {
    id: 'swift-opt-105',
    category: 'Optionals',
    difficulty: 'medium',
    title: 'Optional Array First',
    text: 'Get first element or nil for empty array.',
    setup: 'let numbers = [1, 2, 3]',
    setupCode: 'let numbers = [1, 2, 3]',
    expected: 1,
    sample: 'numbers.first',
    hints: ['first property is optional', 'Returns nil for empty'],
    tags: ['first', 'array', 'optional'],
  },

  {
    id: 'swift-opt-106',
    category: 'Optionals',
    difficulty: 'medium',
    title: 'Optional Dictionary Access',
    text: 'Get value from dictionary safely.',
    setup: 'let dict = ["a": 1, "b": 2]',
    setupCode: 'let dict = ["a": 1, "b": 2]',
    expected: 1,
    sample: 'dict["a"]',
    hints: ['Dictionary subscript returns optional', 'nil if key missing'],
    tags: ['dictionary', 'subscript', 'optional'],
  },

  {
    id: 'swift-opt-107',
    category: 'Optionals',
    difficulty: 'medium',
    title: 'Optional Method Call',
    text: 'Call method on optional only if non-nil.',
    setup: 'let text: String? = "hello"',
    setupCode: 'let text: String? = "hello"',
    expected: 'HELLO',
    sample: 'text?.uppercased()',
    hints: ['Use ?. for method call', 'Returns optional result'],
    tags: ['optional chaining', 'method', 'optional'],
  },

  {
    id: 'swift-opt-108',
    category: 'Optionals',
    difficulty: 'medium',
    title: 'If Let Multiple',
    text: 'Unwrap two optionals together.',
    setup: 'let x: Int? = 5\nlet y: Int? = 10',
    setupCode: 'let x: Int? = 5\nlet y: Int? = 10',
    expected: 15,
    sample: 'if let a = x, let b = y { a + b } else { nil }',
    hints: ['Chain if let with comma', 'Both must be non-nil'],
    tags: ['if let', 'multiple', 'optional'],
  },

  {
    id: 'swift-opt-109',
    category: 'Optionals',
    difficulty: 'hard',
    title: 'Optional Try',
    text: 'Use try? for failable operation.',
    setup:
      'func parse(_ s: String) throws -> Int { guard let i = Int(s) else { throw NSError() }; return i }',
    setupCode:
      'func parse(_ s: String) throws -> Int { guard let i = Int(s) else { throw NSError() }; return i }',
    expected: 42,
    sample: 'try? parse("42")',
    hints: ['try? converts to optional', 'nil on error'],
    tags: ['try', 'optional', 'error'],
  },

  {
    id: 'swift-opt-110',
    category: 'Optionals',
    difficulty: 'easy',
    title: 'Implicitly Unwrapped Optional',
    text: 'Use implicitly unwrapped optional.',
    setup: 'let name: String! = "Swift"',
    setupCode: 'let name: String! = "Swift"',
    expected: 5,
    sample: 'name.count',
    hints: ['! type auto-unwraps', 'Use when always has value'],
    tags: ['implicitly unwrapped', 'optional', 'type'],
  },

  {
    id: 'swift-opt-111',
    category: 'Optionals',
    difficulty: 'medium',
    title: 'Optional Comparison',
    text: 'Compare optional integers safely.',
    setup: 'let a: Int? = 5\nlet b: Int? = 10',
    setupCode: 'let a: Int? = 5\nlet b: Int? = 10',
    expected: true,
    sample: 'a.flatMap { aVal in b.map { aVal < $0 } } ?? false',
    hints: ['Unwrap both for comparison', 'Handle nil case'],
    tags: ['comparison', 'optional', 'safe'],
  },

  {
    id: 'swift-opt-112',
    category: 'Optionals',
    difficulty: 'hard',
    title: 'Nested Optional Unwrap',
    text: 'Unwrap doubly nested optional.',
    setup: 'let nested: Int?? = 42',
    setupCode: 'let nested: Int?? = 42',
    expected: 42,
    sample: 'nested ?? nil ?? 0',
    hints: ['Double unwrap needed', 'Chain ?? operators'],
    tags: ['nested', 'optional', 'unwrap'],
  },

  {
    id: 'swift-opt-113',
    category: 'Optionals',
    difficulty: 'easy',
    title: 'Optional Boolean',
    text: 'Check optional boolean with default false.',
    setup: 'let flag: Bool? = true',
    setupCode: 'let flag: Bool? = true',
    expected: true,
    sample: 'flag ?? false',
    hints: ['Default to false', 'Use ?? operator'],
    tags: ['boolean', 'optional', 'default'],
  },

  {
    id: 'swift-opt-114',
    category: 'Optionals',
    difficulty: 'medium',
    title: 'Optional Array Element',
    text: 'Safely access array element by index.',
    setup: 'let arr = [1, 2, 3]',
    setupCode: 'let arr = [1, 2, 3]',
    expected: 2,
    sample: 'arr.indices.contains(1) ? arr[1] : nil',
    hints: ['Check index validity first', 'Return nil if out of bounds'],
    tags: ['array', 'safe access', 'optional'],
  },

  {
    id: 'swift-opt-115',
    category: 'Optionals',
    difficulty: 'hard',
    title: 'Optional Protocol Type',
    text: 'Cast optional to protocol type.',
    setup: 'let value: Any? = "Hello"',
    setupCode: 'let value: Any? = "Hello"',
    expected: 5,
    sample: '(value as? String)?.count',
    hints: ['Use as? for optional cast', 'Chain with ?.'],
    tags: ['as', 'cast', 'optional'],
  },

  {
    id: 'swift-opt-116',
    category: 'Optionals',
    difficulty: 'easy',
    title: 'Create Optional',
    text: 'Create an optional containing 10.',
    setup: 'let x = 10',
    setupCode: 'let x = 10',
    expected: 10,
    sample: 'Optional(x)',
    hints: ['Optional() wraps value', 'Creates .some(value)'],
    tags: ['Optional', 'create', 'wrap'],
  },

  {
    id: 'swift-opt-117',
    category: 'Optionals',
    difficulty: 'medium',
    title: 'Filter Optional Array',
    text: 'Filter array of optionals to non-nil values.',
    setup: 'let values: [Int?] = [1, nil, 2, nil, 3]',
    setupCode: 'let values: [Int?] = [1, nil, 2, nil, 3]',
    expected: [1, 2, 3],
    sample: 'values.compactMap { $0 }',
    hints: ['compactMap removes nil', 'Returns non-optional array'],
    tags: ['compactMap', 'array', 'optional'],
  },

  {
    id: 'swift-opt-118',
    category: 'Optionals',
    difficulty: 'hard',
    title: 'Optional Subscript Chain',
    text: 'Access nested array element safely.',
    setup: 'let data: [[Int]?] = [[1, 2], nil, [3, 4]]',
    setupCode: 'let data: [[Int]?] = [[1, 2], nil, [3, 4]]',
    expected: 2,
    sample: 'data[0]?[1]',
    hints: ['Use ?[ for optional subscript', 'Chain for nested access'],
    tags: ['subscript', 'optional chaining', 'nested'],
  },

  {
    id: 'swift-opt-119',
    category: 'Optionals',
    difficulty: 'medium',
    title: 'Guard Let with Return',
    text: 'Use guard let with early return.',
    setup:
      'func getValue() -> Int? { let x: Int? = 42; guard let v = x else { return nil }; return v }',
    setupCode:
      'func getValue() -> Int? { let x: Int? = 42; guard let v = x else { return nil }; return v }',
    expected: 42,
    sample: 'getValue()',
    hints: ['guard let requires else', 'Value available after guard'],
    tags: ['guard let', 'function', 'optional'],
  },

  {
    id: 'swift-opt-120',
    category: 'Optionals',
    difficulty: 'easy',
    title: 'Optional from First Match',
    text: 'Find first even number or nil.',
    setup: 'let numbers = [1, 3, 4, 5, 6]',
    setupCode: 'let numbers = [1, 3, 4, 5, 6]',
    expected: 4,
    sample: 'numbers.first { $0 % 2 == 0 }',
    hints: ['first(where:) returns optional', 'nil if no match'],
    tags: ['first', 'optional', 'search'],
  },

  {
    id: 'swift-opt-121',
    category: 'Optionals',
    difficulty: 'medium',
    title: 'Optional Min',
    text: 'Get minimum from potentially empty array.',
    setup: 'let numbers = [5, 2, 8, 1]',
    setupCode: 'let numbers = [5, 2, 8, 1]',
    expected: 1,
    sample: 'numbers.min()',
    hints: ['min() returns optional', 'nil for empty array'],
    tags: ['min', 'optional', 'array'],
  },

  {
    id: 'swift-opt-122',
    category: 'Optionals',
    difficulty: 'medium',
    title: 'Optional Max',
    text: 'Get maximum from potentially empty array.',
    setup: 'let numbers = [5, 2, 8, 1]',
    setupCode: 'let numbers = [5, 2, 8, 1]',
    expected: 8,
    sample: 'numbers.max()',
    hints: ['max() returns optional', 'nil for empty array'],
    tags: ['max', 'optional', 'array'],
  },

  {
    id: 'swift-opt-123',
    category: 'Optionals',
    difficulty: 'hard',
    title: 'Optional Transform Chain',
    text: 'Parse, double, and convert to string.',
    setup: 'let text: String? = "21"',
    setupCode: 'let text: String? = "21"',
    expected: '42',
    sample: 'text.flatMap { Int($0) }.map { $0 * 2 }.map { String($0) }',
    hints: ['Chain flatMap and map', 'Each step transforms optional'],
    tags: ['flatMap', 'map', 'chain'],
  },

  {
    id: 'swift-opt-124',
    category: 'Optionals',
    difficulty: 'easy',
    title: 'Optional Empty String Check',
    text: 'Return nil for empty string, otherwise the string.',
    setup: 'let text = ""',
    setupCode: 'let text = ""',
    expected: null,
    sample: 'text.isEmpty ? nil : text',
    hints: ['Check isEmpty first', 'Return nil for empty'],
    tags: ['isEmpty', 'optional', 'string'],
  },

  {
    id: 'swift-opt-125',
    category: 'Optionals',
    difficulty: 'hard',
    title: 'Optional KeyPath',
    text: 'Access property via optional key path.',
    setup: 'struct Person { var name: String }; let person: Person? = Person(name: "Alice")',
    setupCode: 'struct Person { var name: String }; let person: Person? = Person(name: "Alice")',
    expected: 'Alice',
    sample: 'person?.name',
    hints: ['Optional chaining with property', 'Returns optional result'],
    tags: ['keyPath', 'optional', 'property'],
  },

  {
    id: 'swift-opt-126',
    category: 'Optionals',
    difficulty: 'medium',
    title: 'Switch on Optional',
    text: 'Pattern match on optional value.',
    setup: 'let value: Int? = 42',
    setupCode: 'let value: Int? = 42',
    expected: 42,
    sample: 'switch value { case .some(let v): v; case .none: 0 }',
    hints: ['Use .some and .none cases', 'Bind value with let'],
    tags: ['switch', 'optional', 'pattern'],
  },

  {
    id: 'swift-opt-127',
    category: 'Optionals',
    difficulty: 'hard',
    title: 'Optional Lazy Evaluation',
    text: 'Use nil coalescing with lazy default.',
    setup: 'func expensive() -> Int { return 999 }\nlet value: Int? = 42',
    setupCode: 'func expensive() -> Int { return 999 }\nlet value: Int? = 42',
    expected: 42,
    sample: 'value ?? expensive()',
    hints: ['Right side only evaluates if needed', 'Short-circuit evaluation'],
    tags: ['lazy', 'nil coalescing', 'optional'],
  },

  {
    id: 'swift-opt-128',
    category: 'Optionals',
    difficulty: 'easy',
    title: 'Optional Random Element',
    text: 'Get random element from array.',
    setup: 'let items = ["a", "b", "c"]',
    setupCode: 'let items = ["a", "b", "c"]',
    expected: true,
    sample: 'items.randomElement() != nil',
    hints: ['randomElement() returns optional', 'nil for empty collection'],
    tags: ['randomElement', 'optional', 'array'],
  },

  {
    id: 'swift-opt-129',
    category: 'Optionals',
    difficulty: 'medium',
    title: 'Optional Reduce',
    text: 'Reduce optional array with default.',
    setup: 'let values: [Int]? = [1, 2, 3, 4]',
    setupCode: 'let values: [Int]? = [1, 2, 3, 4]',
    expected: 10,
    sample: 'values?.reduce(0, +) ?? 0',
    hints: ['Chain reduce on optional', 'Default to 0'],
    tags: ['reduce', 'optional', 'chain'],
  },

  {
    id: 'swift-opt-130',
    category: 'Optionals',
    difficulty: 'hard',
    title: 'Optional Binding in Loop',
    text: 'Iterate while binding optionals.',
    setup: 'var iter = [1, 2, 3].makeIterator()',
    setupCode: 'var iter = [1, 2, 3].makeIterator()',
    expected: [1, 2, 3],
    sample: 'var result: [Int] = []; while let val = iter.next() { result.append(val) }; result',
    hints: ['while let for optional iteration', 'Continues until nil'],
    tags: ['while let', 'loop', 'optional'],
  },

  {
    id: 'swift-opt-131',
    category: 'Optionals',
    difficulty: 'medium',
    title: 'Optional Nil Assignment',
    text: 'Assign only if currently nil.',
    setup: 'var value: Int? = nil',
    setupCode: 'var value: Int? = nil',
    expected: 42,
    sample: 'if value == nil { value = 42 }; value',
    hints: ['Check for nil first', 'Assign conditionally'],
    tags: ['assignment', 'nil', 'optional'],
  },

  {
    id: 'swift-opt-132',
    category: 'Optionals',
    difficulty: 'hard',
    title: 'Optional Zip',
    text: 'Combine two optionals into optional tuple.',
    setup: 'let a: Int? = 1\nlet b: String? = "one"',
    setupCode: 'let a: Int? = 1\nlet b: String? = "one"',
    expected: [1, 'one'],
    sample: 'a.flatMap { aVal in b.map { (aVal, $0) } }',
    hints: ['Use flatMap and map together', 'nil if either is nil'],
    tags: ['zip', 'optional', 'combine'],
  },

  {
    id: 'swift-opt-133',
    category: 'Optionals',
    difficulty: 'easy',
    title: 'Optional Last Element',
    text: 'Get last element of array.',
    setup: 'let items = ["a", "b", "c"]',
    setupCode: 'let items = ["a", "b", "c"]',
    expected: 'c',
    sample: 'items.last',
    hints: ['last property is optional', 'nil for empty'],
    tags: ['last', 'array', 'optional'],
  },

  {
    id: 'swift-opt-134',
    category: 'Optionals',
    difficulty: 'hard',
    title: 'Optional Sequence',
    text: 'Create sequence from optional.',
    setup: 'let value: Int? = 5',
    setupCode: 'let value: Int? = 5',
    expected: [5],
    sample: 'value.map { [$0] } ?? []',
    hints: ['Wrap in array if present', 'Empty array if nil'],
    tags: ['sequence', 'optional', 'array'],
  },

  // ============================================================
  // Collections (35 problems: Set operations, sorted, reversed, enumerated)
  // ============================================================

  {
    id: 'swift-coll-100',
    category: 'Collections',
    difficulty: 'easy',
    title: 'Sorted Descending',
    text: 'Sort array in descending order.',
    setup: 'let numbers = [3, 1, 4, 1, 5, 9]',
    setupCode: 'let numbers = [3, 1, 4, 1, 5, 9]',
    expected: [9, 5, 4, 3, 1, 1],
    sample: 'numbers.sorted(by: >)',
    hints: ['Pass > operator to sorted', 'Sorts high to low'],
    tags: ['sorted', 'descending', 'array'],
  },

  {
    id: 'swift-coll-101',
    category: 'Collections',
    difficulty: 'easy',
    title: 'Enumerated Array',
    text: 'Get array of (index, value) pairs.',
    setup: 'let items = ["a", "b", "c"]',
    setupCode: 'let items = ["a", "b", "c"]',
    expected: [
      [0, 'a'],
      [1, 'b'],
      [2, 'c'],
    ],
    sample: 'items.enumerated().map { [$0.offset, $0.element] }',
    hints: ['enumerated() adds indices', 'Access offset and element'],
    tags: ['enumerated', 'array', 'index'],
  },

  {
    id: 'swift-coll-102',
    category: 'Collections',
    difficulty: 'easy',
    title: 'Reversed Collection',
    text: 'Reverse the array order.',
    setup: 'let items = [1, 2, 3, 4, 5]',
    setupCode: 'let items = [1, 2, 3, 4, 5]',
    expected: [5, 4, 3, 2, 1],
    sample: 'Array(items.reversed())',
    hints: ['reversed() returns ReversedCollection', 'Convert to Array'],
    tags: ['reversed', 'array', 'order'],
  },

  {
    id: 'swift-coll-103',
    category: 'Collections',
    difficulty: 'easy',
    title: 'Set from Array',
    text: 'Create set to remove duplicates.',
    setup: 'let items = [1, 2, 2, 3, 3, 3]',
    setupCode: 'let items = [1, 2, 2, 3, 3, 3]',
    expected: [1, 2, 3],
    sample: 'Array(Set(items)).sorted()',
    hints: ['Set removes duplicates', 'Sort for consistent order'],
    tags: ['set', 'unique', 'array'],
  },

  {
    id: 'swift-coll-104',
    category: 'Collections',
    difficulty: 'easy',
    title: 'Shuffled Array',
    text: 'Randomly shuffle the array.',
    setup: 'let items = [1, 2, 3, 4, 5]',
    setupCode: 'let items = [1, 2, 3, 4, 5]',
    expected: true,
    sample: 'items.shuffled().count == items.count',
    hints: ['shuffled() returns new array', 'Same elements, random order'],
    tags: ['shuffled', 'array', 'random'],
  },

  {
    id: 'swift-coll-105',
    category: 'Collections',
    difficulty: 'medium',
    title: 'Sorted by Property',
    text: 'Sort structs by a property.',
    setup:
      'struct Person { var name: String; var age: Int }\nlet people = [Person(name: "Bob", age: 30), Person(name: "Alice", age: 25)]',
    setupCode:
      'struct Person { var name: String; var age: Int }\nlet people = [Person(name: "Bob", age: 30), Person(name: "Alice", age: 25)]',
    expected: ['Alice', 'Bob'],
    sample: 'people.sorted { $0.age < $1.age }.map { $0.name }',
    hints: ['Sort with custom comparator', 'Compare property values'],
    tags: ['sorted', 'struct', 'property'],
  },

  {
    id: 'swift-coll-106',
    category: 'Collections',
    difficulty: 'medium',
    title: 'Prefix While',
    text: 'Take elements while condition is true.',
    setup: 'let numbers = [2, 4, 6, 7, 8, 10]',
    setupCode: 'let numbers = [2, 4, 6, 7, 8, 10]',
    expected: [2, 4, 6],
    sample: 'Array(numbers.prefix(while: { $0 % 2 == 0 }))',
    hints: ['prefix(while:) takes until false', 'Stops at first failure'],
    tags: ['prefix', 'while', 'collection'],
  },

  {
    id: 'swift-coll-107',
    category: 'Collections',
    difficulty: 'medium',
    title: 'Drop While',
    text: 'Skip elements while condition is true.',
    setup: 'let numbers = [2, 4, 6, 7, 8, 10]',
    setupCode: 'let numbers = [2, 4, 6, 7, 8, 10]',
    expected: [7, 8, 10],
    sample: 'Array(numbers.drop(while: { $0 % 2 == 0 }))',
    hints: ['drop(while:) skips until false', 'Takes rest after'],
    tags: ['drop', 'while', 'collection'],
  },

  {
    id: 'swift-coll-108',
    category: 'Collections',
    difficulty: 'medium',
    title: 'Partition Array',
    text: 'Split array at first element greater than 5.',
    setup: 'let numbers = [1, 3, 5, 7, 9, 2, 4]',
    setupCode: 'let numbers = [1, 3, 5, 7, 9, 2, 4]',
    expected: [
      [1, 3, 5],
      [7, 9, 2, 4],
    ],
    sample: '[Array(numbers.prefix(while: { $0 <= 5 })), Array(numbers.drop(while: { $0 <= 5 }))]',
    hints: ['Use prefix and drop together', 'Same condition for both'],
    tags: ['partition', 'prefix', 'drop'],
  },

  {
    id: 'swift-coll-109',
    category: 'Collections',
    difficulty: 'medium',
    title: 'Enumerated Filter',
    text: 'Keep elements at even indices.',
    setup: 'let items = ["a", "b", "c", "d", "e"]',
    setupCode: 'let items = ["a", "b", "c", "d", "e"]',
    expected: ['a', 'c', 'e'],
    sample: 'items.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }',
    hints: ['Enumerate for indices', 'Filter by offset'],
    tags: ['enumerated', 'filter', 'index'],
  },

  {
    id: 'swift-coll-110',
    category: 'Collections',
    difficulty: 'hard',
    title: 'Sorted Stable',
    text: 'Sort by length, preserving original order for equal lengths.',
    setup: 'let words = ["cat", "bat", "elephant", "dog", "ant"]',
    setupCode: 'let words = ["cat", "bat", "elephant", "dog", "ant"]',
    expected: ['cat', 'bat', 'dog', 'ant', 'elephant'],
    sample:
      'words.enumerated().sorted { ($0.element.count, $0.offset) < ($1.element.count, $1.offset) }.map { $0.element }',
    hints: ['Include original index in sort', 'Tuple comparison preserves order'],
    tags: ['sorted', 'stable', 'enumerated'],
  },

  {
    id: 'swift-coll-111',
    category: 'Collections',
    difficulty: 'easy',
    title: 'Contains Element',
    text: 'Check if set contains element.',
    setup: 'let numbers: Set = [1, 2, 3, 4, 5]',
    setupCode: 'let numbers: Set = [1, 2, 3, 4, 5]',
    expected: true,
    sample: 'numbers.contains(3)',
    hints: ['Set contains is O(1)', 'Very fast lookup'],
    tags: ['contains', 'set', 'lookup'],
  },

  {
    id: 'swift-coll-112',
    category: 'Collections',
    difficulty: 'medium',
    title: 'Set Symmetric Difference',
    text: 'Find elements in either set but not both.',
    setup: 'let a: Set = [1, 2, 3, 4]\nlet b: Set = [3, 4, 5, 6]',
    setupCode: 'let a: Set = [1, 2, 3, 4]\nlet b: Set = [3, 4, 5, 6]',
    expected: [1, 2, 5, 6],
    sample: 'a.symmetricDifference(b).sorted()',
    hints: ['symmetricDifference excludes common', 'XOR operation'],
    tags: ['symmetricDifference', 'set', 'xor'],
  },

  {
    id: 'swift-coll-113',
    category: 'Collections',
    difficulty: 'medium',
    title: 'Array Stride',
    text: 'Get every third element.',
    setup: 'let items = [1, 2, 3, 4, 5, 6, 7, 8, 9]',
    setupCode: 'let items = [1, 2, 3, 4, 5, 6, 7, 8, 9]',
    expected: [1, 4, 7],
    sample: 'stride(from: 0, to: items.count, by: 3).map { items[$0] }',
    hints: ['Use stride for step iteration', 'Map indices to elements'],
    tags: ['stride', 'array', 'step'],
  },

  {
    id: 'swift-coll-114',
    category: 'Collections',
    difficulty: 'hard',
    title: 'Zip and Reduce',
    text: 'Calculate dot product of two arrays.',
    setup: 'let a = [1, 2, 3]\nlet b = [4, 5, 6]',
    setupCode: 'let a = [1, 2, 3]\nlet b = [4, 5, 6]',
    expected: 32,
    sample: 'zip(a, b).reduce(0) { $0 + $1.0 * $1.1 }',
    hints: ['Zip pairs elements', 'Reduce sums products'],
    tags: ['zip', 'reduce', 'dotProduct'],
  },

  {
    id: 'swift-coll-115',
    category: 'Collections',
    difficulty: 'easy',
    title: 'Indices Property',
    text: 'Get the range of valid indices.',
    setup: 'let items = ["a", "b", "c", "d"]',
    setupCode: 'let items = ["a", "b", "c", "d"]',
    expected: [0, 1, 2, 3],
    sample: 'Array(items.indices)',
    hints: ['indices property gives range', 'Convert to Array'],
    tags: ['indices', 'array', 'range'],
  },

  {
    id: 'swift-coll-116',
    category: 'Collections',
    difficulty: 'medium',
    title: 'Split Collection',
    text: 'Split array at elements equal to 0.',
    setup: 'let items = [1, 2, 0, 3, 4, 0, 5]',
    setupCode: 'let items = [1, 2, 0, 3, 4, 0, 5]',
    expected: [[1, 2], [3, 4], [5]],
    sample: 'items.split(separator: 0).map(Array.init)',
    hints: ['split removes separator', 'Returns SubSequences'],
    tags: ['split', 'separator', 'collection'],
  },

  {
    id: 'swift-coll-117',
    category: 'Collections',
    difficulty: 'hard',
    title: 'Chunked Collection',
    text: 'Split array into chunks of 3.',
    setup: 'let items = [1, 2, 3, 4, 5, 6, 7, 8]',
    setupCode: 'let items = [1, 2, 3, 4, 5, 6, 7, 8]',
    expected: [
      [1, 2, 3],
      [4, 5, 6],
      [7, 8],
    ],
    sample:
      'stride(from: 0, to: items.count, by: 3).map { Array(items[$0..<min($0+3, items.count)]) }',
    hints: ['Use stride for chunk starts', 'Slice with range'],
    tags: ['chunk', 'stride', 'collection'],
  },

  {
    id: 'swift-coll-118',
    category: 'Collections',
    difficulty: 'easy',
    title: 'First Index of',
    text: 'Find index of first occurrence.',
    setup: 'let items = ["a", "b", "c", "b", "d"]',
    setupCode: 'let items = ["a", "b", "c", "b", "d"]',
    expected: 1,
    sample: 'items.firstIndex(of: "b")',
    hints: ['firstIndex(of:) finds position', 'Returns optional index'],
    tags: ['firstIndex', 'search', 'array'],
  },

  {
    id: 'swift-coll-119',
    category: 'Collections',
    difficulty: 'medium',
    title: 'Last Index of',
    text: 'Find index of last occurrence.',
    setup: 'let items = ["a", "b", "c", "b", "d"]',
    setupCode: 'let items = ["a", "b", "c", "b", "d"]',
    expected: 3,
    sample: 'items.lastIndex(of: "b")',
    hints: ['lastIndex(of:) finds last', 'Searches from end'],
    tags: ['lastIndex', 'search', 'array'],
  },

  {
    id: 'swift-coll-120',
    category: 'Collections',
    difficulty: 'easy',
    title: 'Remove Duplicates Ordered',
    text: 'Remove duplicates preserving order.',
    setup: 'let items = [1, 2, 1, 3, 2, 4]',
    setupCode: 'let items = [1, 2, 1, 3, 2, 4]',
    expected: [1, 2, 3, 4],
    sample: 'items.reduce(into: [Int]()) { if !$0.contains($1) { $0.append($1) } }',
    hints: ['Track seen elements', 'Append if not seen'],
    tags: ['unique', 'ordered', 'reduce'],
  },

  {
    id: 'swift-coll-121',
    category: 'Collections',
    difficulty: 'medium',
    title: 'Adjacent Pairs',
    text: 'Create pairs of adjacent elements.',
    setup: 'let items = [1, 2, 3, 4, 5]',
    setupCode: 'let items = [1, 2, 3, 4, 5]',
    expected: [
      [1, 2],
      [2, 3],
      [3, 4],
      [4, 5],
    ],
    sample: 'zip(items, items.dropFirst()).map { [$0, $1] }',
    hints: ['Zip with dropFirst', 'Creates overlapping pairs'],
    tags: ['zip', 'adjacent', 'pairs'],
  },

  {
    id: 'swift-coll-122',
    category: 'Collections',
    difficulty: 'hard',
    title: 'Running Total',
    text: 'Calculate cumulative sum at each position.',
    setup: 'let numbers = [1, 2, 3, 4, 5]',
    setupCode: 'let numbers = [1, 2, 3, 4, 5]',
    expected: [1, 3, 6, 10, 15],
    sample: 'numbers.reduce(into: [Int]()) { $0.append(($0.last ?? 0) + $1) }',
    hints: ['Track running sum', 'Append accumulated value'],
    tags: ['reduce', 'cumulative', 'sum'],
  },

  {
    id: 'swift-coll-123',
    category: 'Collections',
    difficulty: 'medium',
    title: 'Interleave Arrays',
    text: 'Merge two arrays alternating elements.',
    setup: 'let a = [1, 3, 5]\nlet b = [2, 4, 6]',
    setupCode: 'let a = [1, 3, 5]\nlet b = [2, 4, 6]',
    expected: [1, 2, 3, 4, 5, 6],
    sample: 'zip(a, b).flatMap { [$0, $1] }',
    hints: ['Zip pairs elements', 'FlatMap to interleave'],
    tags: ['zip', 'flatMap', 'interleave'],
  },

  {
    id: 'swift-coll-124',
    category: 'Collections',
    difficulty: 'hard',
    title: 'Window Sliding',
    text: 'Create sliding window of size 3.',
    setup: 'let items = [1, 2, 3, 4, 5]',
    setupCode: 'let items = [1, 2, 3, 4, 5]',
    expected: [
      [1, 2, 3],
      [2, 3, 4],
      [3, 4, 5],
    ],
    sample: '(0...(items.count-3)).map { Array(items[$0..<$0+3]) }',
    hints: ['Iterate valid start positions', 'Slice with range'],
    tags: ['sliding', 'window', 'array'],
  },

  {
    id: 'swift-coll-125',
    category: 'Collections',
    difficulty: 'easy',
    title: 'All Satisfy Condition',
    text: 'Check if all elements are positive.',
    setup: 'let numbers = [1, 2, 3, 4, 5]',
    setupCode: 'let numbers = [1, 2, 3, 4, 5]',
    expected: true,
    sample: 'numbers.allSatisfy { $0 > 0 }',
    hints: ['allSatisfy checks all elements', 'Returns boolean'],
    tags: ['allSatisfy', 'check', 'collection'],
  },

  {
    id: 'swift-coll-126',
    category: 'Collections',
    difficulty: 'medium',
    title: 'None Satisfy',
    text: 'Check if no elements are negative.',
    setup: 'let numbers = [1, 2, 3, 4, 5]',
    setupCode: 'let numbers = [1, 2, 3, 4, 5]',
    expected: true,
    sample: '!numbers.contains { $0 < 0 }',
    hints: ['Negate contains(where:)', 'True if none match'],
    tags: ['contains', 'none', 'check'],
  },

  {
    id: 'swift-coll-127',
    category: 'Collections',
    difficulty: 'hard',
    title: 'Group Consecutive',
    text: 'Group consecutive equal elements.',
    setup: 'let items = [1, 1, 2, 2, 2, 3, 1]',
    setupCode: 'let items = [1, 1, 2, 2, 2, 3, 1]',
    expected: [[1, 1], [2, 2, 2], [3], [1]],
    sample:
      'items.reduce(into: [[Int]]()) { $0.last?.last == $1 ? $0[$0.count-1].append($1) : $0.append([$1]) }',
    hints: ['Compare with last group', 'Start new group on change'],
    tags: ['group', 'consecutive', 'reduce'],
  },

  {
    id: 'swift-coll-128',
    category: 'Collections',
    difficulty: 'easy',
    title: 'Swap Elements',
    text: 'Swap elements at indices 1 and 3.',
    setup: 'var items = [1, 2, 3, 4, 5]',
    setupCode: 'var items = [1, 2, 3, 4, 5]',
    expected: [1, 4, 3, 2, 5],
    sample: 'items.swapAt(1, 3)',
    hints: ['swapAt mutates array', 'Exchanges two elements'],
    tags: ['swapAt', 'mutate', 'array'],
  },

  {
    id: 'swift-coll-129',
    category: 'Collections',
    difficulty: 'medium',
    title: 'Rotate Array',
    text: 'Rotate array left by 2 positions.',
    setup: 'let items = [1, 2, 3, 4, 5]',
    setupCode: 'let items = [1, 2, 3, 4, 5]',
    expected: [3, 4, 5, 1, 2],
    sample: 'Array(items.dropFirst(2)) + Array(items.prefix(2))',
    hints: ['Split and recombine', 'Drop first, append prefix'],
    tags: ['rotate', 'array', 'transform'],
  },

  {
    id: 'swift-coll-130',
    category: 'Collections',
    difficulty: 'hard',
    title: 'Difference Between Arrays',
    text: 'Find elements in first array not in second.',
    setup: 'let a = [1, 2, 3, 4, 5]\nlet b = [2, 4]',
    setupCode: 'let a = [1, 2, 3, 4, 5]\nlet b = [2, 4]',
    expected: [1, 3, 5],
    sample: 'a.filter { !Set(b).contains($0) }',
    hints: ['Convert b to Set for O(1) lookup', 'Filter elements not in Set'],
    tags: ['difference', 'set', 'filter'],
  },

  {
    id: 'swift-coll-131',
    category: 'Collections',
    difficulty: 'easy',
    title: 'Element Count',
    text: 'Count occurrences of each element.',
    setup: 'let items = ["a", "b", "a", "c", "a", "b"]',
    setupCode: 'let items = ["a", "b", "a", "c", "a", "b"]',
    expected: { a: 3, b: 2, c: 1 },
    sample: 'items.reduce(into: [:]) { $0[$1, default: 0] += 1 }',
    hints: ['Use reduce into dictionary', 'Increment count for each'],
    tags: ['count', 'frequency', 'dictionary'],
  },

  {
    id: 'swift-coll-132',
    category: 'Collections',
    difficulty: 'medium',
    title: 'Most Frequent Element',
    text: 'Find the most common element.',
    setup: 'let items = [1, 2, 2, 3, 2, 4, 2]',
    setupCode: 'let items = [1, 2, 2, 3, 2, 4, 2]',
    expected: 2,
    sample: 'items.reduce(into: [:]) { $0[$1, default: 0] += 1 }.max { $0.value < $1.value }?.key',
    hints: ['Count frequencies first', 'Find max by value'],
    tags: ['frequency', 'max', 'collection'],
  },

  {
    id: 'swift-coll-133',
    category: 'Collections',
    difficulty: 'hard',
    title: 'Cartesian Product',
    text: 'Generate all pairs from two arrays.',
    setup: 'let a = [1, 2]\nlet b = ["x", "y"]',
    setupCode: 'let a = [1, 2]\nlet b = ["x", "y"]',
    expected: [
      [1, 'x'],
      [1, 'y'],
      [2, 'x'],
      [2, 'y'],
    ],
    sample: 'a.flatMap { aVal in b.map { [aVal, $0] } }',
    hints: ['Nested flatMap and map', 'Each element pairs with all'],
    tags: ['cartesian', 'product', 'flatMap'],
  },

  {
    id: 'swift-coll-134',
    category: 'Collections',
    difficulty: 'medium',
    title: 'Sorted by Multiple Keys',
    text: 'Sort by length, then alphabetically.',
    setup: 'let words = ["cat", "ant", "bear", "dog"]',
    setupCode: 'let words = ["cat", "ant", "bear", "dog"]',
    expected: ['ant', 'cat', 'dog', 'bear'],
    sample: 'words.sorted { ($0.count, $0) < ($1.count, $1) }',
    hints: ['Use tuple comparison', 'First by count, then by value'],
    tags: ['sorted', 'multiple', 'tuple'],
  },

  // ============================================================
  // Closures (35 problems: trailing closures, escaping, autoclosure, capture lists)
  // ============================================================

  {
    id: 'swift-clos-100',
    category: 'Closures',
    difficulty: 'easy',
    title: 'Basic Closure',
    text: 'Create a closure that adds two numbers.',
    setup: 'let add: (Int, Int) -> Int',
    setupCode: 'let add: (Int, Int) -> Int',
    expected: 5,
    sample: 'let add = { (a: Int, b: Int) -> Int in a + b }; add(2, 3)',
    hints: ['Define parameter types', 'Return type after ->'],
    tags: ['closure', 'basic', 'function'],
  },

  {
    id: 'swift-clos-101',
    category: 'Closures',
    difficulty: 'easy',
    title: 'Shorthand Closure',
    text: 'Use shorthand argument names in closure.',
    setup: 'let numbers = [1, 2, 3, 4, 5]',
    setupCode: 'let numbers = [1, 2, 3, 4, 5]',
    expected: [2, 4, 6, 8, 10],
    sample: 'numbers.map { $0 * 2 }',
    hints: ['$0, $1, etc are shorthand', 'No parameter list needed'],
    tags: ['shorthand', 'closure', '$0'],
  },

  {
    id: 'swift-clos-102',
    category: 'Closures',
    difficulty: 'easy',
    title: 'Trailing Closure',
    text: 'Use trailing closure syntax.',
    setup: 'let numbers = [1, 2, 3]',
    setupCode: 'let numbers = [1, 2, 3]',
    expected: [1, 4, 9],
    sample: 'numbers.map { $0 * $0 }',
    hints: ['Closure after parentheses', 'Cleaner syntax'],
    tags: ['trailing', 'closure', 'syntax'],
  },

  {
    id: 'swift-clos-103',
    category: 'Closures',
    difficulty: 'easy',
    title: 'Closure Type Annotation',
    text: 'Assign closure to typed variable.',
    setup: 'let multiply: (Int, Int) -> Int',
    setupCode: 'let multiply: (Int, Int) -> Int',
    expected: 12,
    sample: 'let multiply: (Int, Int) -> Int = { $0 * $1 }; multiply(3, 4)',
    hints: ['Type annotation before =', 'Closure body after ='],
    tags: ['type', 'closure', 'annotation'],
  },

  {
    id: 'swift-clos-104',
    category: 'Closures',
    difficulty: 'medium',
    title: 'Capture Value',
    text: 'Create closure that captures external value.',
    setup: 'let multiplier = 3',
    setupCode: 'let multiplier = 3',
    expected: 15,
    sample: 'let multiplier = 3; let multiply = { (n: Int) in n * multiplier }; multiply(5)',
    hints: ['Closures capture surrounding context', 'Value captured by reference'],
    tags: ['capture', 'closure', 'context'],
  },

  {
    id: 'swift-clos-105',
    category: 'Closures',
    difficulty: 'medium',
    title: 'Capture List',
    text: 'Use capture list to capture value.',
    setup: 'var counter = 0',
    setupCode: 'var counter = 0',
    expected: 0,
    sample: 'var counter = 0; let closure = { [counter] in counter }; counter = 10; closure()',
    hints: ['[counter] captures current value', 'Creates copy at capture time'],
    tags: ['capture list', 'closure', 'value'],
  },

  {
    id: 'swift-clos-106',
    category: 'Closures',
    difficulty: 'medium',
    title: 'Closure as Parameter',
    text: 'Pass closure as function parameter.',
    setup: 'func apply(_ n: Int, _ f: (Int) -> Int) -> Int { f(n) }',
    setupCode: 'func apply(_ n: Int, _ f: (Int) -> Int) -> Int { f(n) }',
    expected: 25,
    sample: 'func apply(_ n: Int, _ f: (Int) -> Int) -> Int { f(n) }; apply(5) { $0 * $0 }',
    hints: ['Function takes closure parameter', 'Trailing closure syntax'],
    tags: ['parameter', 'closure', 'function'],
  },

  {
    id: 'swift-clos-107',
    category: 'Closures',
    difficulty: 'medium',
    title: 'Return Closure',
    text: 'Create function that returns a closure.',
    setup: 'func makeMultiplier(_ n: Int) -> (Int) -> Int',
    setupCode: 'func makeMultiplier(_ n: Int) -> (Int) -> Int',
    expected: 15,
    sample: 'func makeMultiplier(_ n: Int) -> (Int) -> Int { { $0 * n } }; makeMultiplier(3)(5)',
    hints: ['Return type is closure type', 'Returned closure captures n'],
    tags: ['return', 'closure', 'factory'],
  },

  {
    id: 'swift-clos-108',
    category: 'Closures',
    difficulty: 'hard',
    title: 'Escaping Closure',
    text: 'Store closure for later execution.',
    setup: 'var stored: (() -> Int)?',
    setupCode: 'var stored: (() -> Int)?',
    expected: 42,
    sample:
      'var stored: (() -> Int)?; func store(_ f: @escaping () -> Int) { stored = f }; store { 42 }; stored?()',
    hints: ['@escaping allows storage', 'Closure outlives function'],
    tags: ['escaping', 'closure', 'storage'],
  },

  {
    id: 'swift-clos-109',
    category: 'Closures',
    difficulty: 'hard',
    title: 'Autoclosure',
    text: 'Use autoclosure for delayed evaluation.',
    setup: 'func logIf(_ condition: Bool, _ message: @autoclosure () -> String) -> String?',
    setupCode: 'func logIf(_ condition: Bool, _ message: @autoclosure () -> String) -> String?',
    expected: 'Error!',
    sample:
      'func logIf(_ condition: Bool, _ message: @autoclosure () -> String) -> String? { condition ? message() : nil }; logIf(true, "Error!")',
    hints: ['@autoclosure wraps expression', 'Evaluated only when called'],
    tags: ['autoclosure', 'lazy', 'closure'],
  },

  {
    id: 'swift-clos-110',
    category: 'Closures',
    difficulty: 'easy',
    title: 'Closure with No Parameters',
    text: 'Create void closure.',
    setup: 'let greet: () -> String',
    setupCode: 'let greet: () -> String',
    expected: 'Hello',
    sample: 'let greet: () -> String = { "Hello" }; greet()',
    hints: ['Empty parentheses for no params', 'Still need () to call'],
    tags: ['void', 'closure', 'basic'],
  },

  {
    id: 'swift-clos-111',
    category: 'Closures',
    difficulty: 'medium',
    title: 'Closure with Multiple Trailing',
    text: 'Use multiple trailing closures.',
    setup: 'func combine(a: () -> Int, b: () -> Int) -> Int { a() + b() }',
    setupCode: 'func combine(a: () -> Int, b: () -> Int) -> Int { a() + b() }',
    expected: 7,
    sample: 'func combine(a: () -> Int, b: () -> Int) -> Int { a() + b() }; combine { 3 } b: { 4 }',
    hints: ['First trailing unlabeled', 'Subsequent have labels'],
    tags: ['multiple', 'trailing', 'closure'],
  },

  {
    id: 'swift-clos-112',
    category: 'Closures',
    difficulty: 'hard',
    title: 'Weak Self Capture',
    text: 'Capture self weakly to avoid retain cycle.',
    setup:
      'class Counter { var count = 0; lazy var increment: () -> Int = { [weak self] in (self?.count ?? 0) + 1 } }',
    setupCode:
      'class Counter { var count = 0; lazy var increment: () -> Int = { [weak self] in (self?.count ?? 0) + 1 } }',
    expected: 1,
    sample:
      'class Counter { var count = 0; lazy var increment: () -> Int = { [weak self] in (self?.count ?? 0) + 1 } }; Counter().increment()',
    hints: ['[weak self] prevents retain cycle', 'self becomes optional'],
    tags: ['weak', 'capture', 'memory'],
  },

  {
    id: 'swift-clos-113',
    category: 'Closures',
    difficulty: 'hard',
    title: 'Unowned Self Capture',
    text: 'Capture self unowned when guaranteed to exist.',
    setup:
      'class Timer { var seconds = 10; lazy var tick: () -> Int = { [unowned self] in self.seconds - 1 } }',
    setupCode:
      'class Timer { var seconds = 10; lazy var tick: () -> Int = { [unowned self] in self.seconds - 1 } }',
    expected: 9,
    sample:
      'class Timer { var seconds = 10; lazy var tick: () -> Int = { [unowned self] in self.seconds - 1 } }; Timer().tick()',
    hints: ['[unowned self] no retain', 'Crashes if self is nil'],
    tags: ['unowned', 'capture', 'memory'],
  },

  {
    id: 'swift-clos-114',
    category: 'Closures',
    difficulty: 'medium',
    title: 'Closure Composition',
    text: 'Compose two closures into one.',
    setup: 'let double = { $0 * 2 }\nlet addOne = { $0 + 1 }',
    setupCode: 'let double = { $0 * 2 }\nlet addOne = { $0 + 1 }',
    expected: 7,
    sample:
      'let double = { $0 * 2 }; let addOne = { $0 + 1 }; let composed = { addOne(double($0)) }; composed(3)',
    hints: ['Create closure calling both', 'Order matters'],
    tags: ['composition', 'closure', 'combine'],
  },

  {
    id: 'swift-clos-115',
    category: 'Closures',
    difficulty: 'easy',
    title: 'Implicit Return',
    text: 'Single expression closure with implicit return.',
    setup: 'let numbers = [1, 2, 3]',
    setupCode: 'let numbers = [1, 2, 3]',
    expected: [3, 6, 9],
    sample: 'numbers.map { $0 * 3 }',
    hints: ['Single expression auto-returns', 'No return keyword needed'],
    tags: ['implicit', 'return', 'closure'],
  },

  {
    id: 'swift-clos-116',
    category: 'Closures',
    difficulty: 'medium',
    title: 'Closure with Guard',
    text: 'Use guard inside closure.',
    setup: 'let strings = ["1", "two", "3"]',
    setupCode: 'let strings = ["1", "two", "3"]',
    expected: [1, 3],
    sample: 'strings.compactMap { guard let n = Int($0) else { return nil }; return n }',
    hints: ['guard with else return', 'Early exit for invalid'],
    tags: ['guard', 'closure', 'optional'],
  },

  {
    id: 'swift-clos-117',
    category: 'Closures',
    difficulty: 'hard',
    title: 'Recursive Closure',
    text: 'Create recursive closure for factorial.',
    setup: 'var factorial: ((Int) -> Int)!',
    setupCode: 'var factorial: ((Int) -> Int)!',
    expected: 120,
    sample:
      'var factorial: ((Int) -> Int)!; factorial = { $0 <= 1 ? 1 : $0 * factorial($0 - 1) }; factorial(5)',
    hints: ['Declare var first', 'Reference itself in body'],
    tags: ['recursive', 'closure', 'factorial'],
  },

  {
    id: 'swift-clos-118',
    category: 'Closures',
    difficulty: 'easy',
    title: 'Operator as Closure',
    text: 'Use operator as closure argument.',
    setup: 'let numbers = [1, 2, 3, 4, 5]',
    setupCode: 'let numbers = [1, 2, 3, 4, 5]',
    expected: 15,
    sample: 'numbers.reduce(0, +)',
    hints: ['Operators are functions', 'Can pass directly'],
    tags: ['operator', 'closure', 'reduce'],
  },

  {
    id: 'swift-clos-119',
    category: 'Closures',
    difficulty: 'medium',
    title: 'Closure Type Alias',
    text: 'Use typealias for closure type.',
    setup: 'typealias IntTransform = (Int) -> Int',
    setupCode: 'typealias IntTransform = (Int) -> Int',
    expected: 10,
    sample:
      'typealias IntTransform = (Int) -> Int; let double: IntTransform = { $0 * 2 }; double(5)',
    hints: ['typealias names closure type', 'Improves readability'],
    tags: ['typealias', 'closure', 'type'],
  },

  {
    id: 'swift-clos-120',
    category: 'Closures',
    difficulty: 'hard',
    title: 'Closure with Inout',
    text: 'Create closure that modifies inout parameter.',
    setup: 'var value = 5',
    setupCode: 'var value = 5',
    expected: 10,
    sample: 'var value = 5; let double: (inout Int) -> Void = { $0 *= 2 }; double(&value); value',
    hints: ['inout allows mutation', 'Pass with & prefix'],
    tags: ['inout', 'closure', 'mutate'],
  },

  {
    id: 'swift-clos-121',
    category: 'Closures',
    difficulty: 'medium',
    title: 'Closure Default Value',
    text: 'Function with closure having default value.',
    setup: 'func transform(_ n: Int, using f: (Int) -> Int = { $0 }) -> Int { f(n) }',
    setupCode: 'func transform(_ n: Int, using f: (Int) -> Int = { $0 }) -> Int { f(n) }',
    expected: 5,
    sample:
      'func transform(_ n: Int, using f: (Int) -> Int = { $0 }) -> Int { f(n) }; transform(5)',
    hints: ['Default closure returns input', 'Optional transform'],
    tags: ['default', 'closure', 'parameter'],
  },

  {
    id: 'swift-clos-122',
    category: 'Closures',
    difficulty: 'easy',
    title: 'Sort with Closure',
    text: 'Sort array using custom closure.',
    setup: 'let numbers = [3, 1, 4, 1, 5]',
    setupCode: 'let numbers = [3, 1, 4, 1, 5]',
    expected: [5, 4, 3, 1, 1],
    sample: 'numbers.sorted { $0 > $1 }',
    hints: ['Comparison closure', 'Return true if first before second'],
    tags: ['sorted', 'closure', 'comparison'],
  },

  {
    id: 'swift-clos-123',
    category: 'Closures',
    difficulty: 'hard',
    title: 'Memoizing Closure',
    text: 'Create closure that caches results.',
    setup: 'var cache: [Int: Int] = [:]',
    setupCode: 'var cache: [Int: Int] = [:]',
    expected: 100,
    sample:
      'var cache: [Int: Int] = [:]; let square = { (n: Int) -> Int in if let cached = cache[n] { return cached }; let result = n * n; cache[n] = result; return result }; square(10)',
    hints: ['Check cache first', 'Store computed results'],
    tags: ['memoization', 'closure', 'cache'],
  },

  {
    id: 'swift-clos-124',
    category: 'Closures',
    difficulty: 'medium',
    title: 'Curried Closure',
    text: 'Create curried addition closure.',
    setup: 'let add: (Int) -> (Int) -> Int',
    setupCode: 'let add: (Int) -> (Int) -> Int',
    expected: 7,
    sample: 'let add: (Int) -> (Int) -> Int = { a in { b in a + b } }; add(3)(4)',
    hints: ['Returns another closure', 'Each takes one argument'],
    tags: ['currying', 'closure', 'function'],
  },

  {
    id: 'swift-clos-125',
    category: 'Closures',
    difficulty: 'hard',
    title: 'Throwing Closure',
    text: 'Create closure that can throw errors.',
    setup: 'enum MyError: Error { case invalid }',
    setupCode: 'enum MyError: Error { case invalid }',
    expected: 5,
    sample:
      'enum MyError: Error { case invalid }; let parse: (String) throws -> Int = { guard let n = Int($0) else { throw MyError.invalid }; return n }; try? parse("5")',
    hints: ['throws in closure type', 'Use try when calling'],
    tags: ['throws', 'closure', 'error'],
  },

  {
    id: 'swift-clos-126',
    category: 'Closures',
    difficulty: 'easy',
    title: 'Filter with Closure',
    text: 'Filter using predicate closure.',
    setup: 'let words = ["apple", "banana", "cherry", "date"]',
    setupCode: 'let words = ["apple", "banana", "cherry", "date"]',
    expected: ['apple', 'date'],
    sample: 'words.filter { $0.count <= 5 }',
    hints: ['Predicate returns Bool', 'True keeps element'],
    tags: ['filter', 'closure', 'predicate'],
  },

  {
    id: 'swift-clos-127',
    category: 'Closures',
    difficulty: 'medium',
    title: 'First Where Closure',
    text: 'Find first element matching condition.',
    setup: 'let numbers = [1, 3, 5, 6, 7, 8]',
    setupCode: 'let numbers = [1, 3, 5, 6, 7, 8]',
    expected: 6,
    sample: 'numbers.first { $0 % 2 == 0 }',
    hints: ['first(where:) finds match', 'Returns optional'],
    tags: ['first', 'closure', 'search'],
  },

  {
    id: 'swift-clos-128',
    category: 'Closures',
    difficulty: 'hard',
    title: 'Async Closure',
    text: 'Create async closure.',
    setup: 'let asyncDouble: (Int) async -> Int',
    setupCode: 'let asyncDouble: (Int) async -> Int',
    expected: 10,
    sample: 'let asyncDouble: (Int) async -> Int = { $0 * 2 }; await asyncDouble(5)',
    hints: ['async in closure type', 'Use await to call'],
    tags: ['async', 'closure', 'concurrency'],
  },

  {
    id: 'swift-clos-129',
    category: 'Closures',
    difficulty: 'medium',
    title: 'Contains Where Closure',
    text: 'Check if any element matches condition.',
    setup: 'let numbers = [1, 2, 3, 4, 5]',
    setupCode: 'let numbers = [1, 2, 3, 4, 5]',
    expected: true,
    sample: 'numbers.contains { $0 > 3 }',
    hints: ['contains(where:) checks any', 'Short-circuits on match'],
    tags: ['contains', 'closure', 'check'],
  },

  {
    id: 'swift-clos-130',
    category: 'Closures',
    difficulty: 'easy',
    title: 'ForEach Closure',
    text: 'Iterate with forEach closure.',
    setup: 'let items = [1, 2, 3]',
    setupCode: 'let items = [1, 2, 3]',
    expected: [2, 4, 6],
    sample: 'var result: [Int] = []; [1, 2, 3].forEach { result.append($0 * 2) }; result',
    hints: ['forEach executes for each', 'No return value'],
    tags: ['forEach', 'closure', 'iterate'],
  },

  {
    id: 'swift-clos-131',
    category: 'Closures',
    difficulty: 'hard',
    title: 'Sendable Closure',
    text: 'Create Sendable closure for concurrency.',
    setup: 'let value = 42',
    setupCode: 'let value = 42',
    expected: 42,
    sample: 'let value = 42; let closure: @Sendable () -> Int = { value }; closure()',
    hints: ['@Sendable for thread safety', 'Must not capture mutable state'],
    tags: ['Sendable', 'closure', 'concurrency'],
  },

  // ============================================================
  // Protocols (30 problems: protocol extensions, associated types, Self)
  // ============================================================

  {
    id: 'swift-proto-100',
    category: 'Protocols',
    difficulty: 'easy',
    title: 'Basic Protocol',
    text: 'Define and conform to a simple protocol.',
    setup: 'protocol Greetable { var greeting: String { get } }',
    setupCode: 'protocol Greetable { var greeting: String { get } }',
    expected: 'Hello',
    sample:
      'protocol Greetable { var greeting: String { get } }; struct Greeter: Greetable { var greeting = "Hello" }; Greeter().greeting',
    hints: ['Protocol defines requirements', 'Struct conforms with implementation'],
    tags: ['protocol', 'conform', 'basic'],
  },

  {
    id: 'swift-proto-101',
    category: 'Protocols',
    difficulty: 'easy',
    title: 'Protocol Method',
    text: 'Protocol with method requirement.',
    setup: 'protocol Calculable { func calculate() -> Int }',
    setupCode: 'protocol Calculable { func calculate() -> Int }',
    expected: 10,
    sample:
      'protocol Calculable { func calculate() -> Int }; struct Doubler: Calculable { var value: Int; func calculate() -> Int { value * 2 } }; Doubler(value: 5).calculate()',
    hints: ['Methods can be required', 'Implementation in conforming type'],
    tags: ['protocol', 'method', 'requirement'],
  },

  {
    id: 'swift-proto-102',
    category: 'Protocols',
    difficulty: 'easy',
    title: 'Protocol Extension Default',
    text: 'Provide default implementation in extension.',
    setup: 'protocol Describable { var description: String { get } }',
    setupCode: 'protocol Describable { var description: String { get } }',
    expected: 'Default',
    sample:
      'protocol Describable { var description: String { get } }; extension Describable { var description: String { "Default" } }; struct Item: Describable {}; Item().description',
    hints: ['Extension provides default', 'Conformers can override'],
    tags: ['protocol', 'extension', 'default'],
  },

  {
    id: 'swift-proto-103',
    category: 'Protocols',
    difficulty: 'medium',
    title: 'Protocol Inheritance',
    text: 'Create protocol that inherits from another.',
    setup: 'protocol Named { var name: String { get } }',
    setupCode: 'protocol Named { var name: String { get } }',
    expected: 'Alice-25',
    sample:
      'protocol Named { var name: String { get } }; protocol Aged: Named { var age: Int { get } }; struct Person: Aged { var name: String; var age: Int }; let p = Person(name: "Alice", age: 25); "\\(p.name)-\\(p.age)"',
    hints: ['Protocol can inherit', 'Must satisfy all requirements'],
    tags: ['protocol', 'inheritance', 'compose'],
  },

  {
    id: 'swift-proto-104',
    category: 'Protocols',
    difficulty: 'medium',
    title: 'Protocol Composition',
    text: 'Use multiple protocols together.',
    setup: 'protocol A { var a: Int { get } }\nprotocol B { var b: Int { get } }',
    setupCode: 'protocol A { var a: Int { get } }\nprotocol B { var b: Int { get } }',
    expected: 3,
    sample:
      'protocol A { var a: Int { get } }; protocol B { var b: Int { get } }; func sum(_ item: A & B) -> Int { item.a + item.b }; struct AB: A, B { var a = 1; var b = 2 }; sum(AB())',
    hints: ['Use & for composition', 'Must conform to all'],
    tags: ['protocol', 'composition', 'and'],
  },

  {
    id: 'swift-proto-105',
    category: 'Protocols',
    difficulty: 'medium',
    title: 'Associated Type',
    text: 'Protocol with associated type.',
    setup: 'protocol Container { associatedtype Item; var items: [Item] { get } }',
    setupCode: 'protocol Container { associatedtype Item; var items: [Item] { get } }',
    expected: [1, 2, 3],
    sample:
      'protocol Container { associatedtype Item; var items: [Item] { get } }; struct IntBox: Container { var items: [Int] }; IntBox(items: [1, 2, 3]).items',
    hints: ['associatedtype is placeholder', 'Concrete type inferred'],
    tags: ['associatedtype', 'protocol', 'generic'],
  },

  {
    id: 'swift-proto-106',
    category: 'Protocols',
    difficulty: 'hard',
    title: 'Self Requirement',
    text: 'Protocol using Self for return type.',
    setup: 'protocol Copyable { func copy() -> Self }',
    setupCode: 'protocol Copyable { func copy() -> Self }',
    expected: 5,
    sample:
      'protocol Copyable { func copy() -> Self }; struct Value: Copyable { var n: Int; func copy() -> Value { Value(n: n) } }; Value(n: 5).copy().n',
    hints: ['Self refers to conforming type', 'Enables type-safe copying'],
    tags: ['Self', 'protocol', 'type'],
  },

  {
    id: 'swift-proto-107',
    category: 'Protocols',
    difficulty: 'hard',
    title: 'Protocol with Where Clause',
    text: 'Constrain extension with where clause.',
    setup: 'protocol Summable { associatedtype Element: Numeric; var elements: [Element] { get } }',
    setupCode:
      'protocol Summable { associatedtype Element: Numeric; var elements: [Element] { get } }',
    expected: 6,
    sample:
      'protocol Summable { associatedtype Element: Numeric; var elements: [Element] { get } }; extension Summable { func sum() -> Element { elements.reduce(0, +) } }; struct Numbers: Summable { var elements: [Int] }; Numbers(elements: [1, 2, 3]).sum()',
    hints: ['where adds constraints', 'Extension only applies when met'],
    tags: ['where', 'protocol', 'constraint'],
  },

  {
    id: 'swift-proto-108',
    category: 'Protocols',
    difficulty: 'easy',
    title: 'Equatable Protocol',
    text: 'Conform to Equatable.',
    setup: 'struct Point: Equatable { var x: Int; var y: Int }',
    setupCode: 'struct Point: Equatable { var x: Int; var y: Int }',
    expected: true,
    sample:
      'struct Point: Equatable { var x: Int; var y: Int }; Point(x: 1, y: 2) == Point(x: 1, y: 2)',
    hints: ['Equatable enables ==', 'Auto-synthesized for structs'],
    tags: ['Equatable', 'protocol', 'equality'],
  },

  {
    id: 'swift-proto-109',
    category: 'Protocols',
    difficulty: 'easy',
    title: 'Hashable Protocol',
    text: 'Conform to Hashable.',
    setup: 'struct ID: Hashable { var value: Int }',
    setupCode: 'struct ID: Hashable { var value: Int }',
    expected: true,
    sample:
      'struct ID: Hashable { var value: Int }; let set: Set = [ID(value: 1), ID(value: 2)]; set.contains(ID(value: 1))',
    hints: ['Hashable enables Set/Dictionary', 'Auto-synthesized for structs'],
    tags: ['Hashable', 'protocol', 'hash'],
  },

  {
    id: 'swift-proto-110',
    category: 'Protocols',
    difficulty: 'medium',
    title: 'Comparable Protocol',
    text: 'Conform to Comparable for sorting.',
    setup:
      'struct Score: Comparable { var points: Int; static func < (lhs: Score, rhs: Score) -> Bool { lhs.points < rhs.points } }',
    setupCode:
      'struct Score: Comparable { var points: Int; static func < (lhs: Score, rhs: Score) -> Bool { lhs.points < rhs.points } }',
    expected: [10, 20, 30],
    sample:
      'struct Score: Comparable { var points: Int; static func < (lhs: Score, rhs: Score) -> Bool { lhs.points < rhs.points } }; [Score(points: 20), Score(points: 10), Score(points: 30)].sorted().map { $0.points }',
    hints: ['Implement < operator', 'Enables sorting'],
    tags: ['Comparable', 'protocol', 'sort'],
  },

  {
    id: 'swift-proto-111',
    category: 'Protocols',
    difficulty: 'medium',
    title: 'CustomStringConvertible',
    text: 'Provide custom string representation.',
    setup:
      'struct Person: CustomStringConvertible { var name: String; var description: String { "Person: \\(name)" } }',
    setupCode:
      'struct Person: CustomStringConvertible { var name: String; var description: String { "Person: \\(name)" } }',
    expected: 'Person: Alice',
    sample:
      'struct Person: CustomStringConvertible { var name: String; var description: String { "Person: \\(name)" } }; String(describing: Person(name: "Alice"))',
    hints: ['Implement description property', 'Used by print and String()'],
    tags: ['CustomStringConvertible', 'protocol', 'string'],
  },

  {
    id: 'swift-proto-112',
    category: 'Protocols',
    difficulty: 'hard',
    title: 'Protocol Existential',
    text: 'Use protocol as type (existential).',
    setup: 'protocol Runnable { func run() -> String }',
    setupCode: 'protocol Runnable { func run() -> String }',
    expected: ['A', 'B'],
    sample:
      'protocol Runnable { func run() -> String }; struct A: Runnable { func run() -> String { "A" } }; struct B: Runnable { func run() -> String { "B" } }; let items: [any Runnable] = [A(), B()]; items.map { $0.run() }',
    hints: ['any keyword for existential', 'Can hold any conforming type'],
    tags: ['existential', 'protocol', 'any'],
  },

  {
    id: 'swift-proto-113',
    category: 'Protocols',
    difficulty: 'hard',
    title: 'Opaque Return Type',
    text: 'Return some Protocol type.',
    setup: 'protocol Shape { func area() -> Double }',
    setupCode: 'protocol Shape { func area() -> Double }',
    expected: 28.27,
    sample:
      'protocol Shape { func area() -> Double }; struct Circle: Shape { var radius: Double; func area() -> Double { 3.14159 * radius * radius } }; func makeShape() -> some Shape { Circle(radius: 3) }; round(makeShape().area() * 100) / 100',
    hints: ['some hides concrete type', 'Must return same type'],
    tags: ['some', 'opaque', 'protocol'],
  },

  {
    id: 'swift-proto-114',
    category: 'Protocols',
    difficulty: 'medium',
    title: 'Protocol Static Method',
    text: 'Protocol with static method requirement.',
    setup: 'protocol Factory { static func create() -> Self }',
    setupCode: 'protocol Factory { static func create() -> Self }',
    expected: 'default',
    sample:
      'protocol Factory { static func create() -> Self }; struct Item: Factory { var name: String; static func create() -> Item { Item(name: "default") } }; Item.create().name',
    hints: ['static methods on type', 'Self for return type'],
    tags: ['static', 'protocol', 'factory'],
  },

  {
    id: 'swift-proto-115',
    category: 'Protocols',
    difficulty: 'easy',
    title: 'Protocol Property Requirement',
    text: 'Protocol with gettable and settable property.',
    setup: 'protocol Nameable { var name: String { get set } }',
    setupCode: 'protocol Nameable { var name: String { get set } }',
    expected: 'Bob',
    sample:
      'protocol Nameable { var name: String { get set } }; struct Entity: Nameable { var name: String }; var e = Entity(name: "Alice"); e.name = "Bob"; e.name',
    hints: ['get set allows mutation', 'get only is read-only'],
    tags: ['property', 'protocol', 'getter setter'],
  },

  {
    id: 'swift-proto-116',
    category: 'Protocols',
    difficulty: 'hard',
    title: 'Protocol Witness',
    text: 'Protocol with associated type constraint.',
    setup:
      'protocol Stackable { associatedtype Element; mutating func push(_ e: Element); mutating func pop() -> Element? }',
    setupCode:
      'protocol Stackable { associatedtype Element; mutating func push(_ e: Element); mutating func pop() -> Element? }',
    expected: 3,
    sample:
      'protocol Stackable { associatedtype Element; mutating func push(_ e: Element); mutating func pop() -> Element? }; struct Stack<T>: Stackable { var items: [T] = []; mutating func push(_ e: T) { items.append(e) }; mutating func pop() -> T? { items.popLast() } }; var s = Stack<Int>(); s.push(3); s.pop()',
    hints: ['Generic type satisfies associated', 'Mutating for struct methods'],
    tags: ['associatedtype', 'generic', 'protocol'],
  },

  {
    id: 'swift-proto-117',
    category: 'Protocols',
    difficulty: 'medium',
    title: 'Codable Protocol',
    text: 'Use Codable for JSON encoding.',
    setup: 'struct User: Codable { var name: String; var age: Int }',
    setupCode: 'struct User: Codable { var name: String; var age: Int }',
    expected: true,
    sample:
      'struct User: Codable { var name: String; var age: Int }; let user = User(name: "Alice", age: 30); let data = try? JSONEncoder().encode(user); data != nil',
    hints: ['Codable = Encodable & Decodable', 'Auto-synthesized for structs'],
    tags: ['Codable', 'JSON', 'protocol'],
  },

  {
    id: 'swift-proto-118',
    category: 'Protocols',
    difficulty: 'hard',
    title: 'Protocol Extension Constrained',
    text: 'Extension only for specific element type.',
    setup: 'protocol Collection { associatedtype Element; var elements: [Element] { get } }',
    setupCode: 'protocol Collection { associatedtype Element; var elements: [Element] { get } }',
    expected: 6,
    sample:
      'protocol MyCollection { associatedtype Element; var elements: [Element] { get } }; extension MyCollection where Element == Int { func sum() -> Int { elements.reduce(0, +) } }; struct IntList: MyCollection { var elements: [Int] }; IntList(elements: [1, 2, 3]).sum()',
    hints: ['where Element == Int', 'Extension only for Int'],
    tags: ['extension', 'where', 'protocol'],
  },

  {
    id: 'swift-proto-119',
    category: 'Protocols',
    difficulty: 'medium',
    title: 'Identifiable Protocol',
    text: 'Conform to Identifiable.',
    setup: 'struct Item: Identifiable { var id: Int; var name: String }',
    setupCode: 'struct Item: Identifiable { var id: Int; var name: String }',
    expected: 1,
    sample:
      'struct Item: Identifiable { var id: Int; var name: String }; Item(id: 1, name: "Test").id',
    hints: ['Identifiable requires id', 'Used in SwiftUI lists'],
    tags: ['Identifiable', 'protocol', 'id'],
  },

  {
    id: 'swift-proto-120',
    category: 'Protocols',
    difficulty: 'easy',
    title: 'CaseIterable Protocol',
    text: 'Get all cases of enum.',
    setup: 'enum Direction: CaseIterable { case north, south, east, west }',
    setupCode: 'enum Direction: CaseIterable { case north, south, east, west }',
    expected: 4,
    sample:
      'enum Direction: CaseIterable { case north, south, east, west }; Direction.allCases.count',
    hints: ['CaseIterable provides allCases', 'Array of all enum cases'],
    tags: ['CaseIterable', 'enum', 'protocol'],
  },

  {
    id: 'swift-proto-121',
    category: 'Protocols',
    difficulty: 'hard',
    title: 'Protocol Metatype',
    text: 'Use protocol metatype as parameter.',
    setup: 'protocol Printable { static var label: String { get } }',
    setupCode: 'protocol Printable { static var label: String { get } }',
    expected: 'MyType',
    sample:
      'protocol Printable { static var label: String { get } }; struct MyType: Printable { static var label = "MyType" }; func getLabel<T: Printable>(_ type: T.Type) -> String { type.label }; getLabel(MyType.self)',
    hints: ['T.Type is metatype', '.self gets type'],
    tags: ['metatype', 'protocol', 'type'],
  },

  {
    id: 'swift-proto-122',
    category: 'Protocols',
    difficulty: 'medium',
    title: 'RawRepresentable',
    text: 'Protocol for raw value conversion.',
    setup: 'enum Status: Int { case active = 1, inactive = 0 }',
    setupCode: 'enum Status: Int { case active = 1, inactive = 0 }',
    expected: 1,
    sample: 'enum Status: Int { case active = 1, inactive = 0 }; Status.active.rawValue',
    hints: ['RawRepresentable auto-conformed', 'rawValue returns underlying'],
    tags: ['RawRepresentable', 'enum', 'rawValue'],
  },

  {
    id: 'swift-proto-123',
    category: 'Protocols',
    difficulty: 'hard',
    title: 'ExpressibleByArrayLiteral',
    text: 'Make type initializable with array literal.',
    setup:
      'struct Stack<T>: ExpressibleByArrayLiteral { var items: [T]; init(arrayLiteral elements: T...) { items = elements } }',
    setupCode:
      'struct Stack<T>: ExpressibleByArrayLiteral { var items: [T]; init(arrayLiteral elements: T...) { items = elements } }',
    expected: [1, 2, 3],
    sample:
      'struct Stack<T>: ExpressibleByArrayLiteral { var items: [T]; init(arrayLiteral elements: T...) { items = elements } }; let s: Stack = [1, 2, 3]; s.items',
    hints: ['Implement init(arrayLiteral:)', 'Enables [] literal syntax'],
    tags: ['ExpressibleByArrayLiteral', 'protocol', 'literal'],
  },

  {
    id: 'swift-proto-124',
    category: 'Protocols',
    difficulty: 'medium',
    title: 'Sequence Protocol',
    text: 'Make type work with for-in.',
    setup:
      'struct Countdown: Sequence { var start: Int; func makeIterator() -> AnyIterator<Int> { var n = start; return AnyIterator { defer { n -= 1 }; return n > 0 ? n : nil } } }',
    setupCode:
      'struct Countdown: Sequence { var start: Int; func makeIterator() -> AnyIterator<Int> { var n = start; return AnyIterator { defer { n -= 1 }; return n > 0 ? n : nil } } }',
    expected: [3, 2, 1],
    sample:
      'struct Countdown: Sequence { var start: Int; func makeIterator() -> AnyIterator<Int> { var n = start; return AnyIterator { defer { n -= 1 }; return n > 0 ? n : nil } } }; Array(Countdown(start: 3))',
    hints: ['Implement makeIterator()', 'Iterator returns nil when done'],
    tags: ['Sequence', 'Iterator', 'protocol'],
  },

  // ============================================================
  // Generics (30 problems: type constraints, where clauses, associated types)
  // ============================================================

  {
    id: 'swift-gen-100',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Function',
    text: 'Create generic swap function.',
    setup: 'func swap<T>(_ a: inout T, _ b: inout T)',
    setupCode: 'func swap<T>(_ a: inout T, _ b: inout T)',
    expected: [2, 1],
    sample:
      'func mySwap<T>(_ a: inout T, _ b: inout T) { let temp = a; a = b; b = temp }; var x = 1, y = 2; mySwap(&x, &y); [x, y]',
    hints: ['T is type parameter', 'Works with any type'],
    tags: ['generic', 'function', 'swap'],
  },

  {
    id: 'swift-gen-101',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Struct',
    text: 'Create generic wrapper struct.',
    setup: 'struct Box<T> { var value: T }',
    setupCode: 'struct Box<T> { var value: T }',
    expected: 42,
    sample: 'struct Box<T> { var value: T }; Box(value: 42).value',
    hints: ['Type parameter after name', 'T inferred from usage'],
    tags: ['generic', 'struct', 'box'],
  },

  {
    id: 'swift-gen-102',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic with Constraint',
    text: 'Generic function requiring Equatable.',
    setup: 'func findIndex<T: Equatable>(of value: T, in array: [T]) -> Int?',
    setupCode: 'func findIndex<T: Equatable>(of value: T, in array: [T]) -> Int?',
    expected: 2,
    sample:
      'func findIndex<T: Equatable>(of value: T, in array: [T]) -> Int? { array.firstIndex(of: value) }; findIndex(of: 3, in: [1, 2, 3, 4])',
    hints: ['T: Equatable constrains T', 'Enables == comparison'],
    tags: ['generic', 'constraint', 'Equatable'],
  },

  {
    id: 'swift-gen-103',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Multiple Type Parameters',
    text: 'Generic function with two type parameters.',
    setup: 'func pair<A, B>(_ a: A, _ b: B) -> (A, B)',
    setupCode: 'func pair<A, B>(_ a: A, _ b: B) -> (A, B)',
    expected: [1, 'one'],
    sample:
      'func pair<A, B>(_ a: A, _ b: B) -> (A, B) { (a, b) }; let p = pair(1, "one"); [p.0, p.1] as [Any]',
    hints: ['Multiple parameters in angle brackets', 'Each can be different type'],
    tags: ['generic', 'multiple', 'tuple'],
  },

  {
    id: 'swift-gen-104',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Generic Where Clause',
    text: 'Use where clause for constraint.',
    setup: 'func allEqual<T>(_ items: [T]) -> Bool where T: Equatable',
    setupCode: 'func allEqual<T>(_ items: [T]) -> Bool where T: Equatable',
    expected: true,
    sample:
      'func allEqual<T>(_ items: [T]) -> Bool where T: Equatable { items.dropFirst().allSatisfy { $0 == items.first } }; allEqual([1, 1, 1])',
    hints: ['where adds constraints', 'More flexible than inline'],
    tags: ['generic', 'where', 'constraint'],
  },

  {
    id: 'swift-gen-105',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Generic Protocol Constraint',
    text: 'Constrain to protocol with associated type.',
    setup: 'func sum<C: Collection>(_ c: C) -> C.Element where C.Element: Numeric',
    setupCode: 'func sum<C: Collection>(_ c: C) -> C.Element where C.Element: Numeric',
    expected: 10,
    sample:
      'func sum<C: Collection>(_ c: C) -> C.Element where C.Element: Numeric { c.reduce(0, +) }; sum([1, 2, 3, 4])',
    hints: ['C.Element accesses associated type', 'Numeric enables + and 0'],
    tags: ['generic', 'Collection', 'Element'],
  },

  {
    id: 'swift-gen-106',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Generic Extension',
    text: 'Extend generic type conditionally.',
    setup: 'extension Array where Element: Numeric { func sum() -> Element { reduce(0, +) } }',
    setupCode: 'extension Array where Element: Numeric { func sum() -> Element { reduce(0, +) } }',
    expected: 15,
    sample:
      'extension Array where Element: Numeric { func sum() -> Element { reduce(0, +) } }; [1, 2, 3, 4, 5].sum()',
    hints: ['where constrains Element', 'Method only for Numeric'],
    tags: ['generic', 'extension', 'where'],
  },

  {
    id: 'swift-gen-107',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Associated Type Constraint',
    text: 'Protocol with constrained associated type.',
    setup:
      'protocol NumericContainer { associatedtype Number: Numeric; var value: Number { get } }',
    setupCode:
      'protocol NumericContainer { associatedtype Number: Numeric; var value: Number { get } }',
    expected: 10,
    sample:
      'protocol NumericContainer { associatedtype Number: Numeric; var value: Number { get } }; struct IntContainer: NumericContainer { var value: Int }; IntContainer(value: 10).value',
    hints: ['associatedtype can have constraint', 'Conforming type must satisfy'],
    tags: ['associatedtype', 'constraint', 'protocol'],
  },

  {
    id: 'swift-gen-108',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Type Alias',
    text: 'Create typealias for generic type.',
    setup: 'typealias StringDict<V> = Dictionary<String, V>',
    setupCode: 'typealias StringDict<V> = Dictionary<String, V>',
    expected: 42,
    sample:
      'typealias StringDict<V> = Dictionary<String, V>; let d: StringDict<Int> = ["answer": 42]; d["answer"]',
    hints: ['typealias can be generic', 'Simplifies common patterns'],
    tags: ['typealias', 'generic', 'dictionary'],
  },

  {
    id: 'swift-gen-109',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Generic Class',
    text: 'Create generic class.',
    setup:
      'class Node<T> { var value: T; var next: Node<T>?; init(_ value: T) { self.value = value } }',
    setupCode:
      'class Node<T> { var value: T; var next: Node<T>?; init(_ value: T) { self.value = value } }',
    expected: 1,
    sample:
      'class Node<T> { var value: T; var next: Node<T>?; init(_ value: T) { self.value = value } }; let n = Node(1); n.next = Node(2); n.value',
    hints: ['Classes can be generic', 'Self-referential with same T'],
    tags: ['generic', 'class', 'linked list'],
  },

  {
    id: 'swift-gen-110',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Generic Same Type Constraint',
    text: 'Require two associated types be equal.',
    setup:
      'func transfer<S: Sequence, C: RangeReplaceableCollection>(_ source: S, to target: inout C) where S.Element == C.Element',
    setupCode:
      'func transfer<S: Sequence, C: RangeReplaceableCollection>(_ source: S, to target: inout C) where S.Element == C.Element',
    expected: [1, 2, 3, 4, 5],
    sample:
      'func transfer<S: Sequence, C: RangeReplaceableCollection>(_ source: S, to target: inout C) where S.Element == C.Element { target.append(contentsOf: source) }; var arr = [1, 2]; transfer([3, 4, 5], to: &arr); arr',
    hints: ['S.Element == C.Element', 'Types must match'],
    tags: ['generic', 'same type', 'where'],
  },

  {
    id: 'swift-gen-111',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Generic Computed Property',
    text: 'Extension with generic computed property.',
    setup: 'extension Array { var middle: Element? { isEmpty ? nil : self[count / 2] } }',
    setupCode: 'extension Array { var middle: Element? { isEmpty ? nil : self[count / 2] } }',
    expected: 3,
    sample:
      'extension Array { var middle: Element? { isEmpty ? nil : self[count / 2] } }; [1, 2, 3, 4, 5].middle',
    hints: ['Element is Arrays generic type', 'Access in extension'],
    tags: ['generic', 'extension', 'property'],
  },

  {
    id: 'swift-gen-112',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Generic Initializer',
    text: 'Struct with generic initializer.',
    setup:
      'struct Converter<T> { var value: T; init<U>(_ source: U, transform: (U) -> T) { value = transform(source) } }',
    setupCode:
      'struct Converter<T> { var value: T; init<U>(_ source: U, transform: (U) -> T) { value = transform(source) } }',
    expected: '42',
    sample:
      'struct Converter<T> { var value: T; init<U>(_ source: U, transform: (U) -> T) { value = transform(source) } }; Converter(42) { String($0) }.value',
    hints: ['Init can have own generic', 'Different from struct generic'],
    tags: ['generic', 'initializer', 'transform'],
  },

  {
    id: 'swift-gen-113',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Default Value',
    text: 'Generic function with default parameter.',
    setup: 'func getValue<T>(_ value: T?, default defaultValue: T) -> T',
    setupCode: 'func getValue<T>(_ value: T?, default defaultValue: T) -> T',
    expected: 0,
    sample:
      'func getValue<T>(_ value: T?, default defaultValue: T) -> T { value ?? defaultValue }; getValue(nil as Int?, default: 0)',
    hints: ['Default uses same type T', 'Like nil coalescing'],
    tags: ['generic', 'default', 'optional'],
  },

  {
    id: 'swift-gen-114',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Generic Subscript',
    text: 'Struct with generic subscript.',
    setup:
      'struct JSON { var data: [String: Any]; subscript<T>(key: String) -> T? { data[key] as? T } }',
    setupCode:
      'struct JSON { var data: [String: Any]; subscript<T>(key: String) -> T? { data[key] as? T } }',
    expected: 42,
    sample:
      'struct JSON { var data: [String: Any]; subscript<T>(key: String) -> T? { data[key] as? T } }; let j = JSON(data: ["n": 42]); j["n"] as Int?',
    hints: ['Subscript can be generic', 'Type inferred from context'],
    tags: ['generic', 'subscript', 'cast'],
  },

  {
    id: 'swift-gen-115',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Generic Protocol Extension',
    text: 'Extend protocol with generic method.',
    setup:
      'extension Collection { func grouped<K: Hashable>(by keyPath: KeyPath<Element, K>) -> [K: [Element]] { Dictionary(grouping: self) { $0[keyPath: keyPath] } } }',
    setupCode:
      'extension Collection { func grouped<K: Hashable>(by keyPath: KeyPath<Element, K>) -> [K: [Element]] { Dictionary(grouping: self) { $0[keyPath: keyPath] } } }',
    expected: 2,
    sample:
      'extension Collection { func grouped<K: Hashable>(by keyPath: KeyPath<Element, K>) -> [K: [Element]] { Dictionary(grouping: self) { $0[keyPath: keyPath] } } }; ["a", "ab", "abc", "b"].grouped(by: \\.count).count',
    hints: ['Generic method in extension', 'K constrained to Hashable'],
    tags: ['generic', 'protocol', 'extension'],
  },

  {
    id: 'swift-gen-116',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Result Type',
    text: 'Function returning generic Result.',
    setup: 'func divide<T: FloatingPoint>(_ a: T, by b: T) -> Result<T, Error>',
    setupCode: 'func divide<T: FloatingPoint>(_ a: T, by b: T) -> Result<T, Error>',
    expected: 2.5,
    sample:
      'enum MathError: Error { case divisionByZero }; func divide<T: FloatingPoint>(_ a: T, by b: T) -> Result<T, Error> { b == 0 ? .failure(MathError.divisionByZero) : .success(a / b) }; try? divide(5.0, by: 2.0).get()',
    hints: ['Result is generic', 'Success type is T'],
    tags: ['generic', 'Result', 'error'],
  },

  {
    id: 'swift-gen-117',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Generic Enum',
    text: 'Create generic enum.',
    setup: 'enum Optional<Wrapped> { case none, some(Wrapped) }',
    setupCode: 'enum MyOptional<Wrapped> { case none, some(Wrapped) }',
    expected: 42,
    sample:
      'enum MyOptional<Wrapped> { case none, some(Wrapped); var value: Wrapped? { if case .some(let v) = self { return v }; return nil } }; MyOptional.some(42).value',
    hints: ['Enum can be generic', 'Associated value uses T'],
    tags: ['generic', 'enum', 'optional'],
  },

  {
    id: 'swift-gen-118',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Generic with Multiple Constraints',
    text: 'Combine multiple protocol constraints.',
    setup: 'func process<T: Hashable & Comparable>(_ items: [T]) -> [T]',
    setupCode: 'func process<T: Hashable & Comparable>(_ items: [T]) -> [T]',
    expected: [1, 2, 3],
    sample:
      'func process<T: Hashable & Comparable>(_ items: [T]) -> [T] { Array(Set(items)).sorted() }; process([3, 1, 2, 1, 3])',
    hints: ['Use & to combine', 'T must satisfy all'],
    tags: ['generic', 'multiple', 'constraint'],
  },

  {
    id: 'swift-gen-119',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Generic Type Inference',
    text: 'Let compiler infer generic type.',
    setup: 'func identity<T>(_ value: T) -> T { value }',
    setupCode: 'func identity<T>(_ value: T) -> T { value }',
    expected: 'hello',
    sample: 'func identity<T>(_ value: T) -> T { value }; identity("hello")',
    hints: ['T inferred from argument', 'No explicit type needed'],
    tags: ['generic', 'inference', 'type'],
  },

  // ============================================================
  // Enums (30 problems: associated values, raw values, CaseIterable)
  // ============================================================

  {
    id: 'swift-enum-100',
    category: 'Enums',
    difficulty: 'easy',
    title: 'Basic Enum',
    text: 'Create and use simple enum.',
    setup: 'enum Direction { case north, south, east, west }',
    setupCode: 'enum Direction { case north, south, east, west }',
    expected: true,
    sample: 'enum Direction { case north, south, east, west }; Direction.north == .north',
    hints: ['Cases define values', 'Use dot syntax'],
    tags: ['enum', 'basic', 'case'],
  },

  {
    id: 'swift-enum-101',
    category: 'Enums',
    difficulty: 'easy',
    title: 'Enum Raw Value',
    text: 'Enum with string raw values.',
    setup: 'enum Status: String { case active = "ACTIVE", inactive = "INACTIVE" }',
    setupCode: 'enum Status: String { case active = "ACTIVE", inactive = "INACTIVE" }',
    expected: 'ACTIVE',
    sample:
      'enum Status: String { case active = "ACTIVE", inactive = "INACTIVE" }; Status.active.rawValue',
    hints: ['Specify raw type after name', 'Access with .rawValue'],
    tags: ['enum', 'rawValue', 'string'],
  },

  {
    id: 'swift-enum-102',
    category: 'Enums',
    difficulty: 'easy',
    title: 'Enum Int Raw Value',
    text: 'Enum with auto-incrementing int values.',
    setup: 'enum Priority: Int { case low = 1, medium, high }',
    setupCode: 'enum Priority: Int { case low = 1, medium, high }',
    expected: 3,
    sample: 'enum Priority: Int { case low = 1, medium, high }; Priority.high.rawValue',
    hints: ['Int enums auto-increment', 'First value sets start'],
    tags: ['enum', 'rawValue', 'int'],
  },

  {
    id: 'swift-enum-103',
    category: 'Enums',
    difficulty: 'medium',
    title: 'Enum Associated Value',
    text: 'Enum with associated values.',
    setup: 'enum Result { case success(Int), failure(String) }',
    setupCode: 'enum Result { case success(Int), failure(String) }',
    expected: 42,
    sample:
      'enum Result { case success(Int), failure(String) }; let r = Result.success(42); if case .success(let v) = r { v } else { 0 }',
    hints: ['Cases can have associated data', 'Extract with if case'],
    tags: ['enum', 'associated', 'value'],
  },

  {
    id: 'swift-enum-104',
    category: 'Enums',
    difficulty: 'medium',
    title: 'Enum Method',
    text: 'Add method to enum.',
    setup: 'enum Coin: Int { case penny = 1, nickel = 5, dime = 10, quarter = 25 }',
    setupCode: 'enum Coin: Int { case penny = 1, nickel = 5, dime = 10, quarter = 25 }',
    expected: 25,
    sample:
      'enum Coin: Int { case penny = 1, nickel = 5, dime = 10, quarter = 25; func value() -> Int { rawValue } }; Coin.quarter.value()',
    hints: ['Enums can have methods', 'Access self and rawValue'],
    tags: ['enum', 'method', 'function'],
  },

  {
    id: 'swift-enum-105',
    category: 'Enums',
    difficulty: 'medium',
    title: 'Enum Computed Property',
    text: 'Add computed property to enum.',
    setup: 'enum Size { case small, medium, large }',
    setupCode: 'enum Size { case small, medium, large }',
    expected: 'M',
    sample:
      'enum Size { case small, medium, large; var label: String { switch self { case .small: return "S"; case .medium: return "M"; case .large: return "L" } } }; Size.medium.label',
    hints: ['Computed property with switch', 'Return based on case'],
    tags: ['enum', 'computed', 'property'],
  },

  {
    id: 'swift-enum-106',
    category: 'Enums',
    difficulty: 'easy',
    title: 'CaseIterable Enum',
    text: 'Iterate all enum cases.',
    setup: 'enum Color: CaseIterable { case red, green, blue }',
    setupCode: 'enum Color: CaseIterable { case red, green, blue }',
    expected: ['red', 'green', 'blue'],
    sample:
      'enum Color: String, CaseIterable { case red, green, blue }; Color.allCases.map { $0.rawValue }',
    hints: ['CaseIterable provides allCases', 'Array of all cases'],
    tags: ['enum', 'CaseIterable', 'iterate'],
  },

  {
    id: 'swift-enum-107',
    category: 'Enums',
    difficulty: 'hard',
    title: 'Recursive Enum',
    text: 'Create indirect enum for recursion.',
    setup: 'indirect enum Tree<T> { case leaf(T), node(Tree, Tree) }',
    setupCode: 'indirect enum Tree<T> { case leaf(T), node(Tree, Tree) }',
    expected: 6,
    sample:
      'indirect enum Tree<T> { case leaf(T), node(Tree, Tree); func sum() -> T where T: Numeric { switch self { case .leaf(let v): return v; case .node(let l, let r): return l.sum() + r.sum() } } }; Tree.node(.leaf(1), .node(.leaf(2), .leaf(3))).sum()',
    hints: ['indirect enables recursion', 'Self-referential cases'],
    tags: ['enum', 'indirect', 'recursive'],
  },

  {
    id: 'swift-enum-108',
    category: 'Enums',
    difficulty: 'medium',
    title: 'Enum Init from Raw',
    text: 'Create enum from raw value.',
    setup: 'enum Grade: String { case a = "A", b = "B", c = "C", f = "F" }',
    setupCode: 'enum Grade: String { case a = "A", b = "B", c = "C", f = "F" }',
    expected: true,
    sample:
      'enum Grade: String { case a = "A", b = "B", c = "C", f = "F" }; Grade(rawValue: "A") == .a',
    hints: ['init(rawValue:) returns optional', 'nil if no match'],
    tags: ['enum', 'init', 'rawValue'],
  },

  {
    id: 'swift-enum-109',
    category: 'Enums',
    difficulty: 'hard',
    title: 'Enum Associated Multiple',
    text: 'Extract multiple associated values.',
    setup:
      'enum Response { case success(code: Int, data: String), error(code: Int, message: String) }',
    setupCode:
      'enum Response { case success(code: Int, data: String), error(code: Int, message: String) }',
    expected: 'OK',
    sample:
      'enum Response { case success(code: Int, data: String), error(code: Int, message: String) }; let r = Response.success(code: 200, data: "OK"); if case .success(_, let data) = r { data } else { "" }',
    hints: ['Multiple named values', 'Use _ to ignore some'],
    tags: ['enum', 'associated', 'multiple'],
  },

  {
    id: 'swift-enum-110',
    category: 'Enums',
    difficulty: 'easy',
    title: 'Enum Switch',
    text: 'Switch on enum value.',
    setup: 'enum Light { case red, yellow, green }',
    setupCode: 'enum Light { case red, yellow, green }',
    expected: 'Go',
    sample:
      'enum Light { case red, yellow, green }; let light = Light.green; switch light { case .red: "Stop"; case .yellow: "Caution"; case .green: "Go" }',
    hints: ['Switch must be exhaustive', 'Cover all cases'],
    tags: ['enum', 'switch', 'pattern'],
  },

  {
    id: 'swift-enum-111',
    category: 'Enums',
    difficulty: 'medium',
    title: 'Enum Mutating Method',
    text: 'Mutating method to change case.',
    setup: 'enum Toggle { case on, off }',
    setupCode: 'enum Toggle { case on, off }',
    expected: true,
    sample:
      'enum Toggle { case on, off; mutating func toggle() { self = self == .on ? .off : .on } }; var t = Toggle.off; t.toggle(); t == .on',
    hints: ['mutating allows self change', 'Assign new case to self'],
    tags: ['enum', 'mutating', 'toggle'],
  },

  {
    id: 'swift-enum-112',
    category: 'Enums',
    difficulty: 'hard',
    title: 'Enum Pattern Matching Where',
    text: 'Switch with where clause.',
    setup: 'enum Number { case integer(Int), decimal(Double) }',
    setupCode: 'enum Number { case integer(Int), decimal(Double) }',
    expected: 'positive int',
    sample:
      'enum Number { case integer(Int), decimal(Double) }; let n = Number.integer(5); switch n { case .integer(let i) where i > 0: "positive int"; case .integer: "non-positive int"; case .decimal: "decimal" }',
    hints: ['where adds condition', 'More specific cases first'],
    tags: ['enum', 'switch', 'where'],
  },

  {
    id: 'swift-enum-113',
    category: 'Enums',
    difficulty: 'easy',
    title: 'Enum Static Property',
    text: 'Static property on enum.',
    setup: 'enum Config { static let defaultTimeout = 30 }',
    setupCode: 'enum Config { static let defaultTimeout = 30 }',
    expected: 30,
    sample: 'enum Config { static let defaultTimeout = 30 }; Config.defaultTimeout',
    hints: ['No cases, just static', 'Used as namespace'],
    tags: ['enum', 'static', 'namespace'],
  },

  {
    id: 'swift-enum-114',
    category: 'Enums',
    difficulty: 'medium',
    title: 'Enum Comparable',
    text: 'Make enum comparable.',
    setup: 'enum Size: Comparable { case small, medium, large }',
    setupCode: 'enum Size: Comparable { case small, medium, large }',
    expected: true,
    sample: 'enum Size: Comparable { case small, medium, large }; Size.small < Size.large',
    hints: ['Conform to Comparable', 'Order by declaration'],
    tags: ['enum', 'Comparable', 'order'],
  },

  {
    id: 'swift-enum-115',
    category: 'Enums',
    difficulty: 'hard',
    title: 'Enum with Closure',
    text: 'Enum case with closure associated value.',
    setup: 'enum Operation { case add, custom((Int, Int) -> Int) }',
    setupCode: 'enum Operation { case add, custom((Int, Int) -> Int) }',
    expected: 6,
    sample:
      'enum Operation { case add, custom((Int, Int) -> Int); func apply(_ a: Int, _ b: Int) -> Int { switch self { case .add: return a + b; case .custom(let f): return f(a, b) } } }; Operation.custom { $0 * $1 }.apply(2, 3)',
    hints: ['Closures as associated values', 'Execute in method'],
    tags: ['enum', 'closure', 'associated'],
  },

  {
    id: 'swift-enum-116',
    category: 'Enums',
    difficulty: 'medium',
    title: 'Enum Hashable',
    text: 'Use enum in Set.',
    setup: 'enum Tag: Hashable { case priority(Int), label(String) }',
    setupCode: 'enum Tag: Hashable { case priority(Int), label(String) }',
    expected: 2,
    sample:
      'enum Tag: Hashable { case priority(Int), label(String) }; Set([Tag.priority(1), Tag.label("urgent"), Tag.priority(1)]).count',
    hints: ['Auto Hashable for simple cases', 'Set removes duplicates'],
    tags: ['enum', 'Hashable', 'Set'],
  },

  {
    id: 'swift-enum-117',
    category: 'Enums',
    difficulty: 'easy',
    title: 'Enum Codable',
    text: 'JSON encode/decode enum.',
    setup: 'enum Status: String, Codable { case active, inactive }',
    setupCode: 'enum Status: String, Codable { case active, inactive }',
    expected: true,
    sample:
      'enum Status: String, Codable { case active, inactive }; let data = try? JSONEncoder().encode(Status.active); data != nil',
    hints: ['Raw value enums auto Codable', 'Encodes as raw value'],
    tags: ['enum', 'Codable', 'JSON'],
  },

  {
    id: 'swift-enum-118',
    category: 'Enums',
    difficulty: 'hard',
    title: 'Enum Protocol Conformance',
    text: 'Enum conforming to protocol.',
    setup: 'protocol Describable { var description: String { get } }',
    setupCode: 'protocol Describable { var description: String { get } }',
    expected: 'Error: Not found',
    sample:
      'protocol Describable { var description: String { get } }; enum AppError: Describable { case notFound, unauthorized; var description: String { switch self { case .notFound: return "Error: Not found"; case .unauthorized: return "Error: Unauthorized" } } }; AppError.notFound.description',
    hints: ['Enum can conform to protocols', 'Implement with switch'],
    tags: ['enum', 'protocol', 'conformance'],
  },

  {
    id: 'swift-enum-119',
    category: 'Enums',
    difficulty: 'medium',
    title: 'Enum Default Case',
    text: 'Switch with default case.',
    setup: 'enum Response: Int { case ok = 200, created = 201, badRequest = 400, notFound = 404 }',
    setupCode:
      'enum Response: Int { case ok = 200, created = 201, badRequest = 400, notFound = 404 }',
    expected: 'Other',
    sample:
      'enum Response: Int { case ok = 200, created = 201, badRequest = 400, notFound = 404 }; func describe(_ r: Response) -> String { switch r { case .ok: return "Success"; case .notFound: return "Not Found"; default: return "Other" } }; describe(.created)',
    hints: ['default catches remaining', 'Useful for partial handling'],
    tags: ['enum', 'switch', 'default'],
  },
];

export default swiftProblems;
