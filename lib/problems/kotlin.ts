/**
 * Kotlin Coding Drills Problems
 *
 * Comprehensive collection of Kotlin problems covering:
 * - List Operations (15+ problems)
 * - Collection Functions (20+ problems)
 * - String Operations (10+ problems)
 * - Map Operations (10+ problems)
 * - Null Safety (8+ problems)
 * - Scope Functions (10+ problems)
 * - Sequences (5+ problems)
 */

import type { Problem } from '../types';

export const kotlinProblems: Problem[] = [
  // ============================================================
  // List Operations
  // ============================================================

  {
    id: 'kotlin-list-001',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Create Immutable List',
    text: 'Create an immutable list containing 1, 2, 3 using `listOf()`.',
    setup: '// Create an immutable list',
    setupCode: '// Create an immutable list',
    expected: [1, 2, 3],
    sample: 'listOf(1, 2, 3)',
    hints: [
      'listOf() creates an immutable List',
      'Cannot add or remove elements from immutable lists',
    ],
    validPatterns: [/listOf\s*\(\s*1\s*,\s*2\s*,\s*3\s*\)/],
    tags: ['listOf', 'immutable', 'create'],
  },

  {
    id: 'kotlin-list-002',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Create Mutable List',
    text: 'Create a mutable list containing "a", "b", "c" using `mutableListOf()`.',
    setup: '// Create a mutable list',
    setupCode: '// Create a mutable list',
    expected: ['a', 'b', 'c'],
    sample: 'mutableListOf("a", "b", "c")',
    hints: ['mutableListOf() creates a MutableList', 'Can add, remove, and modify elements'],
    validPatterns: [/mutableListOf\s*\(\s*"a"\s*,\s*"b"\s*,\s*"c"\s*\)/],
    tags: ['mutableListOf', 'mutable', 'create'],
  },

  {
    id: 'kotlin-list-003',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Add Element to List',
    text: 'Add the number 4 to the end of the mutable list.',
    setup: 'val nums = mutableListOf(1, 2, 3)',
    setupCode: 'val nums = mutableListOf(1, 2, 3)',
    expected: [1, 2, 3, 4],
    sample: 'nums.add(4) // nums is now [1, 2, 3, 4]',
    hints: ['Use add() to append an element', 'add() modifies the list in place'],
    validPatterns: [/\.add\s*\(\s*4\s*\)/],
    tags: ['add', 'mutable', 'append'],
  },

  {
    id: 'kotlin-list-004',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Add Element at Index',
    text: 'Insert the number 99 at index 1 in the mutable list.',
    setup: 'val nums = mutableListOf(1, 2, 3)',
    setupCode: 'val nums = mutableListOf(1, 2, 3)',
    expected: [1, 99, 2, 3],
    sample: 'nums.add(1, 99) // nums is now [1, 99, 2, 3]',
    hints: ['Use add(index, element) to insert at a position', 'Elements shift to the right'],
    validPatterns: [/\.add\s*\(\s*1\s*,\s*99\s*\)/],
    tags: ['add', 'index', 'insert'],
  },

  {
    id: 'kotlin-list-005',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Get Element by Index',
    text: 'Get the element at index 2 from the list.',
    setup: 'val fruits = listOf("apple", "banana", "cherry", "date")',
    setupCode: 'val fruits = listOf("apple", "banana", "cherry", "date")',
    expected: 'cherry',
    sample: 'fruits[2] // returns "cherry"',
    hints: ['Use bracket notation fruits[index]', 'Indices start at 0'],
    validPatterns: [/fruits\s*\[\s*2\s*\]/],
    tags: ['get', 'index', 'access'],
  },

  {
    id: 'kotlin-list-006',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Get Element Safely',
    text: 'Get the element at index 10 safely, returning null if out of bounds.',
    setup: 'val nums = listOf(1, 2, 3)',
    setupCode: 'val nums = listOf(1, 2, 3)',
    expected: null,
    sample: 'nums.getOrNull(10) // returns null',
    hints: [
      'Use getOrNull() for safe access',
      'Returns null instead of throwing IndexOutOfBoundsException',
    ],
    validPatterns: [/\.getOrNull\s*\(\s*10\s*\)/],
    tags: ['getOrNull', 'safe', 'null-safety'],
  },

  {
    id: 'kotlin-list-007',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Get First Element',
    text: 'Get the first element of the list.',
    setup: 'val nums = listOf(10, 20, 30)',
    setupCode: 'val nums = listOf(10, 20, 30)',
    expected: 10,
    sample: 'nums.first() // returns 10',
    hints: ['Use first() to get the first element', 'Throws NoSuchElementException on empty list'],
    validPatterns: [/\.first\s*\(\s*\)/],
    tags: ['first', 'access'],
  },

  {
    id: 'kotlin-list-008',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Get Last Element',
    text: 'Get the last element of the list.',
    setup: 'val nums = listOf(10, 20, 30)',
    setupCode: 'val nums = listOf(10, 20, 30)',
    expected: 30,
    sample: 'nums.last() // returns 30',
    hints: ['Use last() to get the last element', 'Throws NoSuchElementException on empty list'],
    validPatterns: [/\.last\s*\(\s*\)/],
    tags: ['last', 'access'],
  },

  {
    id: 'kotlin-list-009',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Get List Size',
    text: 'Get the number of elements in the list.',
    setup: 'val nums = listOf(1, 2, 3, 4, 5)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5)',
    expected: 5,
    sample: 'nums.size // returns 5',
    hints: ['Use size property (not a method)', 'Returns Int'],
    validPatterns: [/\.size(?!\()/],
    tags: ['size', 'length', 'count'],
  },

  {
    id: 'kotlin-list-010',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Check if List is Empty',
    text: 'Check if the list is empty.',
    setup: 'val nums = listOf<Int>()',
    setupCode: 'val nums = listOf<Int>()',
    expected: true,
    sample: 'nums.isEmpty() // returns true',
    hints: ['Use isEmpty() to check for empty list', 'Use isNotEmpty() for the opposite'],
    validPatterns: [/\.isEmpty\s*\(\s*\)/],
    tags: ['isEmpty', 'check', 'validation'],
  },

  {
    id: 'kotlin-list-011',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Check Contains Element',
    text: 'Check if the list contains the number 3.',
    setup: 'val nums = listOf(1, 2, 3, 4, 5)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5)',
    expected: true,
    sample: '3 in nums // or nums.contains(3)',
    hints: ['Use `in` operator or contains()', 'Both return Boolean'],
    validPatterns: [/3\s+in\s+nums/, /\.contains\s*\(\s*3\s*\)/],
    tags: ['contains', 'in', 'search'],
  },

  {
    id: 'kotlin-list-012',
    category: 'List Operations',
    difficulty: 'easy',
    title: 'Find Index of Element',
    text: 'Find the index of "cherry" in the list.',
    setup: 'val fruits = listOf("apple", "banana", "cherry", "date")',
    setupCode: 'val fruits = listOf("apple", "banana", "cherry", "date")',
    expected: 2,
    sample: 'fruits.indexOf("cherry") // returns 2',
    hints: ['Use indexOf() to find position', 'Returns -1 if not found'],
    validPatterns: [/\.indexOf\s*\(\s*"cherry"\s*\)/],
    tags: ['indexOf', 'search', 'position'],
  },

  {
    id: 'kotlin-list-013',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Get Sublist',
    text: 'Get a sublist from index 1 to 4 (exclusive).',
    setup: 'val nums = listOf(10, 20, 30, 40, 50, 60)',
    setupCode: 'val nums = listOf(10, 20, 30, 40, 50, 60)',
    expected: [20, 30, 40],
    sample: 'nums.subList(1, 4) // returns [20, 30, 40]',
    hints: ['Use subList(fromIndex, toIndex)', 'toIndex is exclusive'],
    validPatterns: [/\.subList\s*\(\s*1\s*,\s*4\s*\)/],
    tags: ['subList', 'slice', 'range'],
  },

  {
    id: 'kotlin-list-014',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Take First N Elements',
    text: 'Take the first 3 elements from the list.',
    setup: 'val nums = listOf(1, 2, 3, 4, 5)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5)',
    expected: [1, 2, 3],
    sample: 'nums.take(3) // returns [1, 2, 3]',
    hints: ['Use take(n) to get first n elements', 'Returns a new list'],
    validPatterns: [/\.take\s*\(\s*3\s*\)/],
    tags: ['take', 'slice', 'first'],
  },

  {
    id: 'kotlin-list-015',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Drop First N Elements',
    text: 'Skip the first 2 elements and get the rest.',
    setup: 'val nums = listOf(1, 2, 3, 4, 5)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5)',
    expected: [3, 4, 5],
    sample: 'nums.drop(2) // returns [3, 4, 5]',
    hints: ['Use drop(n) to skip first n elements', 'Returns a new list'],
    validPatterns: [/\.drop\s*\(\s*2\s*\)/],
    tags: ['drop', 'skip', 'slice'],
  },

  {
    id: 'kotlin-list-016',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Reverse List',
    text: 'Create a reversed copy of the list.',
    setup: 'val nums = listOf(1, 2, 3, 4, 5)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5)',
    expected: [5, 4, 3, 2, 1],
    sample: 'nums.reversed() // returns [5, 4, 3, 2, 1]',
    hints: ['Use reversed() to get a reversed copy', 'Original list is unchanged'],
    validPatterns: [/\.reversed\s*\(\s*\)/],
    tags: ['reversed', 'order', 'copy'],
  },

  {
    id: 'kotlin-list-017',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Sort List',
    text: 'Create a sorted copy of the list.',
    setup: 'val nums = listOf(5, 2, 8, 1, 9)',
    setupCode: 'val nums = listOf(5, 2, 8, 1, 9)',
    expected: [1, 2, 5, 8, 9],
    sample: 'nums.sorted() // returns [1, 2, 5, 8, 9]',
    hints: ['Use sorted() to get a sorted copy', 'Original list is unchanged'],
    validPatterns: [/\.sorted\s*\(\s*\)/],
    tags: ['sorted', 'order', 'copy'],
  },

  {
    id: 'kotlin-list-018',
    category: 'List Operations',
    difficulty: 'medium',
    title: 'Sort Descending',
    text: 'Create a copy of the list sorted in descending order.',
    setup: 'val nums = listOf(5, 2, 8, 1, 9)',
    setupCode: 'val nums = listOf(5, 2, 8, 1, 9)',
    expected: [9, 8, 5, 2, 1],
    sample: 'nums.sortedDescending() // returns [9, 8, 5, 2, 1]',
    hints: ['Use sortedDescending() for reverse order', 'Also: sorted().reversed()'],
    validPatterns: [/\.sortedDescending\s*\(\s*\)/, /\.sorted\s*\(\s*\)\.reversed\s*\(\s*\)/],
    tags: ['sortedDescending', 'order', 'descending'],
  },

  // ============================================================
  // Collection Functions (filter, map, etc.)
  // ============================================================

  {
    id: 'kotlin-collection-001',
    category: 'Collection Functions',
    difficulty: 'easy',
    title: 'Filter Even Numbers',
    text: 'Filter to keep only even numbers.',
    setup: 'val nums = listOf(1, 2, 3, 4, 5, 6)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5, 6)',
    expected: [2, 4, 6],
    sample: 'nums.filter { it % 2 == 0 }',
    hints: ['Use filter { predicate }', '`it` refers to each element'],
    validPatterns: [/\.filter\s*\{.*%\s*2\s*==\s*0.*\}/],
    tags: ['filter', 'predicate', 'lambda'],
  },

  {
    id: 'kotlin-collection-002',
    category: 'Collection Functions',
    difficulty: 'easy',
    title: 'Filter Not',
    text: 'Filter to exclude numbers greater than 3.',
    setup: 'val nums = listOf(1, 2, 3, 4, 5)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5)',
    expected: [1, 2, 3],
    sample: 'nums.filterNot { it > 3 }',
    hints: ['Use filterNot for negated predicate', 'Equivalent to filter { it <= 3 }'],
    validPatterns: [/\.filterNot\s*\{.*>\s*3.*\}/, /\.filter\s*\{.*<=\s*3.*\}/],
    tags: ['filterNot', 'predicate', 'exclude'],
  },

  {
    id: 'kotlin-collection-003',
    category: 'Collection Functions',
    difficulty: 'easy',
    title: 'Map to Squares',
    text: 'Transform each number to its square.',
    setup: 'val nums = listOf(1, 2, 3, 4, 5)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5)',
    expected: [1, 4, 9, 16, 25],
    sample: 'nums.map { it * it }',
    hints: ['Use map { transform }', 'Returns a new list with transformed elements'],
    validPatterns: [/\.map\s*\{.*\*.*\}/],
    tags: ['map', 'transform', 'lambda'],
  },

  {
    id: 'kotlin-collection-004',
    category: 'Collection Functions',
    difficulty: 'easy',
    title: 'Map to Uppercase',
    text: 'Transform all strings to uppercase.',
    setup: 'val words = listOf("hello", "world", "kotlin")',
    setupCode: 'val words = listOf("hello", "world", "kotlin")',
    expected: ['HELLO', 'WORLD', 'KOTLIN'],
    sample: 'words.map { it.uppercase() }',
    hints: ['Use map with uppercase()', 'uppercase() replaces deprecated toUpperCase()'],
    validPatterns: [/\.map\s*\{.*\.uppercase\s*\(\s*\).*\}/],
    tags: ['map', 'uppercase', 'transform'],
  },

  {
    id: 'kotlin-collection-005',
    category: 'Collection Functions',
    difficulty: 'medium',
    title: 'Map with Index',
    text: 'Create pairs of (index, value) for each element.',
    setup: 'val chars = listOf("a", "b", "c")',
    setupCode: 'val chars = listOf("a", "b", "c")',
    expected: [
      [0, 'a'],
      [1, 'b'],
      [2, 'c'],
    ],
    sample: 'chars.mapIndexed { index, value -> listOf(index, value) }',
    hints: ['Use mapIndexed for index access', 'Lambda receives (index, element)'],
    validPatterns: [/\.mapIndexed\s*\{/],
    tags: ['mapIndexed', 'index', 'transform'],
  },

  {
    id: 'kotlin-collection-006',
    category: 'Collection Functions',
    difficulty: 'medium',
    title: 'FlatMap Nested Lists',
    text: 'Flatten a list of lists into a single list.',
    setup: 'val nested = listOf(listOf(1, 2), listOf(3, 4), listOf(5, 6))',
    setupCode: 'val nested = listOf(listOf(1, 2), listOf(3, 4), listOf(5, 6))',
    expected: [1, 2, 3, 4, 5, 6],
    sample: 'nested.flatten() // or nested.flatMap { it }',
    hints: [
      'Use flatten() for simple flattening',
      'flatMap allows transformation while flattening',
    ],
    validPatterns: [/\.flatten\s*\(\s*\)/, /\.flatMap\s*\{\s*it\s*\}/],
    tags: ['flatten', 'flatMap', 'nested'],
  },

  {
    id: 'kotlin-collection-007',
    category: 'Collection Functions',
    difficulty: 'medium',
    title: 'Reduce to Sum',
    text: 'Calculate the sum using reduce.',
    setup: 'val nums = listOf(1, 2, 3, 4, 5)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5)',
    expected: 15,
    sample: 'nums.reduce { acc, n -> acc + n } // or nums.sum()',
    hints: ['reduce combines elements sequentially', 'sum() is more idiomatic for this case'],
    validPatterns: [/\.reduce\s*\{/, /\.sum\s*\(\s*\)/],
    tags: ['reduce', 'sum', 'aggregation'],
  },

  {
    id: 'kotlin-collection-008',
    category: 'Collection Functions',
    difficulty: 'medium',
    title: 'Fold with Initial Value',
    text: 'Calculate sum starting from 100 using fold.',
    setup: 'val nums = listOf(1, 2, 3, 4, 5)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5)',
    expected: 115,
    sample: 'nums.fold(100) { acc, n -> acc + n }',
    hints: ['fold takes initial value', 'Unlike reduce, works on empty lists'],
    validPatterns: [/\.fold\s*\(\s*100\s*\)\s*\{/],
    tags: ['fold', 'accumulator', 'aggregation'],
  },

  {
    id: 'kotlin-collection-009',
    category: 'Collection Functions',
    difficulty: 'easy',
    title: 'Find Maximum',
    text: 'Find the maximum value in the list.',
    setup: 'val nums = listOf(3, 7, 2, 9, 5)',
    setupCode: 'val nums = listOf(3, 7, 2, 9, 5)',
    expected: 9,
    sample: 'nums.max() // returns 9',
    hints: [
      'Use max() for maximum value',
      'Returns null on empty list in older Kotlin, throws in 1.7+',
    ],
    validPatterns: [/\.max\s*\(\s*\)/, /\.maxOrNull\s*\(\s*\)/],
    tags: ['max', 'aggregation', 'find'],
  },

  {
    id: 'kotlin-collection-010',
    category: 'Collection Functions',
    difficulty: 'easy',
    title: 'Find Minimum',
    text: 'Find the minimum value in the list.',
    setup: 'val nums = listOf(3, 7, 2, 9, 5)',
    setupCode: 'val nums = listOf(3, 7, 2, 9, 5)',
    expected: 2,
    sample: 'nums.min() // returns 2',
    hints: ['Use min() for minimum value', 'Use minOrNull() for null-safe version'],
    validPatterns: [/\.min\s*\(\s*\)/, /\.minOrNull\s*\(\s*\)/],
    tags: ['min', 'aggregation', 'find'],
  },

  {
    id: 'kotlin-collection-011',
    category: 'Collection Functions',
    difficulty: 'medium',
    title: 'Max By Property',
    text: 'Find the string with the maximum length.',
    setup: 'val words = listOf("cat", "elephant", "dog")',
    setupCode: 'val words = listOf("cat", "elephant", "dog")',
    expected: 'elephant',
    sample: 'words.maxBy { it.length } // returns "elephant"',
    hints: ['Use maxBy with a selector', 'Returns the element, not the property value'],
    validPatterns: [/\.maxBy\s*\{.*\.length.*\}/, /\.maxByOrNull\s*\{.*\.length.*\}/],
    tags: ['maxBy', 'selector', 'aggregation'],
  },

  {
    id: 'kotlin-collection-012',
    category: 'Collection Functions',
    difficulty: 'easy',
    title: 'Any Match',
    text: 'Check if any number is greater than 10.',
    setup: 'val nums = listOf(5, 8, 12, 3, 7)',
    setupCode: 'val nums = listOf(5, 8, 12, 3, 7)',
    expected: true,
    sample: 'nums.any { it > 10 }',
    hints: ['any returns true if at least one matches', 'Short-circuits on first match'],
    validPatterns: [/\.any\s*\{.*>\s*10.*\}/],
    tags: ['any', 'predicate', 'check'],
  },

  {
    id: 'kotlin-collection-013',
    category: 'Collection Functions',
    difficulty: 'easy',
    title: 'All Match',
    text: 'Check if all numbers are positive.',
    setup: 'val nums = listOf(1, 2, 3, 4, 5)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5)',
    expected: true,
    sample: 'nums.all { it > 0 }',
    hints: ['all returns true if ALL elements match', 'Returns true for empty list'],
    validPatterns: [/\.all\s*\{.*>\s*0.*\}/],
    tags: ['all', 'predicate', 'check'],
  },

  {
    id: 'kotlin-collection-014',
    category: 'Collection Functions',
    difficulty: 'easy',
    title: 'None Match',
    text: 'Check if no number is negative.',
    setup: 'val nums = listOf(1, 2, 3, 4, 5)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5)',
    expected: true,
    sample: 'nums.none { it < 0 }',
    hints: ['none returns true if NO element matches', 'Opposite of any'],
    validPatterns: [/\.none\s*\{.*<\s*0.*\}/],
    tags: ['none', 'predicate', 'check'],
  },

  {
    id: 'kotlin-collection-015',
    category: 'Collection Functions',
    difficulty: 'medium',
    title: 'Find First Match',
    text: 'Find the first even number.',
    setup: 'val nums = listOf(1, 3, 4, 5, 6)',
    setupCode: 'val nums = listOf(1, 3, 4, 5, 6)',
    expected: 4,
    sample: 'nums.find { it % 2 == 0 } // or nums.first { it % 2 == 0 }',
    hints: ['find returns first match or null', 'first { } throws if no match'],
    validPatterns: [/\.find\s*\{.*%\s*2\s*==\s*0.*\}/, /\.first\s*\{.*%\s*2\s*==\s*0.*\}/],
    tags: ['find', 'first', 'search'],
  },

  {
    id: 'kotlin-collection-016',
    category: 'Collection Functions',
    difficulty: 'easy',
    title: 'Count Matching Elements',
    text: 'Count how many numbers are greater than 3.',
    setup: 'val nums = listOf(1, 2, 3, 4, 5, 6)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5, 6)',
    expected: 3,
    sample: 'nums.count { it > 3 }',
    hints: ['count { predicate } counts matches', 'count() without predicate returns size'],
    validPatterns: [/\.count\s*\{.*>\s*3.*\}/],
    tags: ['count', 'predicate', 'aggregation'],
  },

  {
    id: 'kotlin-collection-017',
    category: 'Collection Functions',
    difficulty: 'easy',
    title: 'Get Distinct Elements',
    text: 'Remove duplicates from the list.',
    setup: 'val nums = listOf(1, 2, 2, 3, 3, 3, 4)',
    setupCode: 'val nums = listOf(1, 2, 2, 3, 3, 3, 4)',
    expected: [1, 2, 3, 4],
    sample: 'nums.distinct()',
    hints: ['distinct() removes duplicates', 'Preserves original order'],
    validPatterns: [/\.distinct\s*\(\s*\)/],
    tags: ['distinct', 'unique', 'deduplicate'],
  },

  {
    id: 'kotlin-collection-018',
    category: 'Collection Functions',
    difficulty: 'medium',
    title: 'Group By Property',
    text: 'Group strings by their length.',
    setup: 'val words = listOf("cat", "dog", "elephant", "rat", "giraffe")',
    setupCode: 'val words = listOf("cat", "dog", "elephant", "rat", "giraffe")',
    expected: { 3: ['cat', 'dog', 'rat'], 7: ['giraffe'], 8: ['elephant'] },
    sample: 'words.groupBy { it.length }',
    hints: ['groupBy returns Map<K, List<T>>', 'Key is the result of the selector'],
    validPatterns: [/\.groupBy\s*\{.*\.length.*\}/],
    tags: ['groupBy', 'map', 'categorize'],
  },

  {
    id: 'kotlin-collection-019',
    category: 'Collection Functions',
    difficulty: 'medium',
    title: 'Partition List',
    text: 'Partition list into (evens, odds).',
    setup: 'val nums = listOf(1, 2, 3, 4, 5, 6)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5, 6)',
    expected: [
      [2, 4, 6],
      [1, 3, 5],
    ],
    sample: 'val (evens, odds) = nums.partition { it % 2 == 0 }',
    hints: [
      'partition returns Pair<List, List>',
      'First list contains matches, second contains non-matches',
    ],
    validPatterns: [/\.partition\s*\{.*%\s*2\s*==\s*0.*\}/],
    tags: ['partition', 'split', 'pair'],
  },

  {
    id: 'kotlin-collection-020',
    category: 'Collection Functions',
    difficulty: 'medium',
    title: 'Associate to Map',
    text: 'Create a map from name to name length.',
    setup: 'val names = listOf("Alice", "Bob", "Charlie")',
    setupCode: 'val names = listOf("Alice", "Bob", "Charlie")',
    expected: { Alice: 5, Bob: 3, Charlie: 7 },
    sample: 'names.associateWith { it.length }',
    hints: ['associateWith creates Map<T, V>', 'Element becomes key, lambda result becomes value'],
    validPatterns: [/\.associateWith\s*\{.*\.length.*\}/],
    tags: ['associateWith', 'map', 'transform'],
  },

  {
    id: 'kotlin-collection-021',
    category: 'Collection Functions',
    difficulty: 'medium',
    title: 'Join to String',
    text: 'Join list elements with " - " separator.',
    setup: 'val words = listOf("apple", "banana", "cherry")',
    setupCode: 'val words = listOf("apple", "banana", "cherry")',
    expected: 'apple - banana - cherry',
    sample: 'words.joinToString(" - ")',
    hints: ['joinToString creates a single string', 'Can customize prefix, suffix, and more'],
    validPatterns: [/\.joinToString\s*\(\s*" - "\s*\)/],
    tags: ['joinToString', 'concatenate', 'string'],
  },

  {
    id: 'kotlin-collection-022',
    category: 'Collection Functions',
    difficulty: 'medium',
    title: 'Zip Two Lists',
    text: 'Combine two lists into pairs.',
    setup: 'val names = listOf("Alice", "Bob")\nval ages = listOf(25, 30)',
    setupCode: 'val names = listOf("Alice", "Bob")\nval ages = listOf(25, 30)',
    expected: [
      ['Alice', 25],
      ['Bob', 30],
    ],
    sample: 'names.zip(ages) // returns [(Alice, 25), (Bob, 30)]',
    hints: ['zip pairs elements from two lists', 'Stops at shorter list length'],
    validPatterns: [/\.zip\s*\(\s*ages\s*\)/],
    tags: ['zip', 'pair', 'combine'],
  },

  // ============================================================
  // String Operations
  // ============================================================

  {
    id: 'kotlin-string-001',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'String Length',
    text: 'Get the length of the string.',
    setup: 'val str = "Hello World"',
    setupCode: 'val str = "Hello World"',
    expected: 11,
    sample: 'str.length // returns 11',
    hints: ['Use length property', 'Includes spaces'],
    validPatterns: [/\.length(?!\()/],
    tags: ['length', 'property', 'basics'],
  },

  {
    id: 'kotlin-string-002',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Uppercase',
    text: 'Convert the string to uppercase.',
    setup: 'val str = "hello"',
    setupCode: 'val str = "hello"',
    expected: 'HELLO',
    sample: 'str.uppercase() // returns "HELLO"',
    hints: ['Use uppercase()', 'Replaces deprecated toUpperCase()'],
    validPatterns: [/\.uppercase\s*\(\s*\)/],
    tags: ['uppercase', 'case', 'transform'],
  },

  {
    id: 'kotlin-string-003',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Lowercase',
    text: 'Convert the string to lowercase.',
    setup: 'val str = "HELLO"',
    setupCode: 'val str = "HELLO"',
    expected: 'hello',
    sample: 'str.lowercase() // returns "hello"',
    hints: ['Use lowercase()', 'Replaces deprecated toLowerCase()'],
    validPatterns: [/\.lowercase\s*\(\s*\)/],
    tags: ['lowercase', 'case', 'transform'],
  },

  {
    id: 'kotlin-string-004',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Trim Whitespace',
    text: 'Remove leading and trailing whitespace.',
    setup: 'val str = "   Hello World   "',
    setupCode: 'val str = "   Hello World   "',
    expected: 'Hello World',
    sample: 'str.trim() // returns "Hello World"',
    hints: ['trim() removes leading/trailing whitespace', 'Use trimStart()/trimEnd() for one side'],
    validPatterns: [/\.trim\s*\(\s*\)/],
    tags: ['trim', 'whitespace', 'clean'],
  },

  {
    id: 'kotlin-string-005',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Split String',
    text: 'Split the string by comma.',
    setup: 'val str = "apple,banana,cherry"',
    setupCode: 'val str = "apple,banana,cherry"',
    expected: ['apple', 'banana', 'cherry'],
    sample: 'str.split(",") // returns [apple, banana, cherry]',
    hints: ['split returns List<String>', 'Can split by regex or string'],
    validPatterns: [/\.split\s*\(\s*","\s*\)/],
    tags: ['split', 'tokenize', 'parse'],
  },

  {
    id: 'kotlin-string-006',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Substring',
    text: 'Extract substring from index 0 to 5 (exclusive).',
    setup: 'val str = "Hello World"',
    setupCode: 'val str = "Hello World"',
    expected: 'Hello',
    sample: 'str.substring(0, 5) // or str.take(5)',
    hints: ['substring(start, end) - end is exclusive', 'take(n) is more idiomatic for prefix'],
    validPatterns: [/\.substring\s*\(\s*0\s*,\s*5\s*\)/, /\.take\s*\(\s*5\s*\)/],
    tags: ['substring', 'extract', 'slice'],
  },

  {
    id: 'kotlin-string-007',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Replace Characters',
    text: 'Replace all spaces with underscores.',
    setup: 'val str = "Hello World Kotlin"',
    setupCode: 'val str = "Hello World Kotlin"',
    expected: 'Hello_World_Kotlin',
    sample: 'str.replace(" ", "_")',
    hints: ['replace replaces all occurrences', 'Can use regex with Regex()'],
    validPatterns: [/\.replace\s*\(\s*" "\s*,\s*"_"\s*\)/],
    tags: ['replace', 'substitution', 'transform'],
  },

  {
    id: 'kotlin-string-008',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Check Starts With',
    text: 'Check if the string starts with "Hello".',
    setup: 'val str = "Hello World"',
    setupCode: 'val str = "Hello World"',
    expected: true,
    sample: 'str.startsWith("Hello")',
    hints: ['startsWith is case-sensitive', 'Can pass ignoreCase = true'],
    validPatterns: [/\.startsWith\s*\(\s*"Hello"\s*\)/],
    tags: ['startsWith', 'prefix', 'check'],
  },

  {
    id: 'kotlin-string-009',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Check Ends With',
    text: 'Check if the string ends with "World".',
    setup: 'val str = "Hello World"',
    setupCode: 'val str = "Hello World"',
    expected: true,
    sample: 'str.endsWith("World")',
    hints: ['endsWith is case-sensitive', 'Can pass ignoreCase = true'],
    validPatterns: [/\.endsWith\s*\(\s*"World"\s*\)/],
    tags: ['endsWith', 'suffix', 'check'],
  },

  {
    id: 'kotlin-string-010',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Check Contains',
    text: 'Check if the string contains "World".',
    setup: 'val str = "Hello World"',
    setupCode: 'val str = "Hello World"',
    expected: true,
    sample: '"World" in str // or str.contains("World")',
    hints: ['Use `in` operator or contains()', 'Both are case-sensitive by default'],
    validPatterns: [/"World"\s+in\s+str/, /str\.contains\s*\(\s*"World"\s*\)/],
    tags: ['contains', 'in', 'search'],
  },

  {
    id: 'kotlin-string-011',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'String Template',
    text: 'Create a string "Name: Alice, Age: 25" using string template.',
    setup: 'val name = "Alice"\nval age = 25',
    setupCode: 'val name = "Alice"\nval age = 25',
    expected: 'Name: Alice, Age: 25',
    sample: '"Name: $name, Age: $age"',
    hints: ['Use $ for variable interpolation', 'Use ${expr} for expressions'],
    validPatterns: [/"\$name.*\$age"/, /"\$\{name\}.*\$\{age\}"/],
    tags: ['template', 'interpolation', 'format'],
  },

  {
    id: 'kotlin-string-012',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Multiline String',
    text: 'Create a trimmed multiline string.',
    setup: '// Create multiline text',
    setupCode: '// Create multiline text',
    expected: 'Line 1\nLine 2\nLine 3',
    sample: '"""\n    |Line 1\n    |Line 2\n    |Line 3\n    """.trimMargin()',
    hints: ['Triple quotes for raw strings', 'trimMargin() removes leading whitespace'],
    validPatterns: [/"""[\s\S]*"""\s*\.trimMargin\s*\(\s*\)/],
    tags: ['multiline', 'rawString', 'trimMargin'],
  },

  // ============================================================
  // Map Operations
  // ============================================================

  {
    id: 'kotlin-map-001',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Create Immutable Map',
    text: 'Create an immutable map with "a" to 1, "b" to 2.',
    setup: '// Create an immutable map',
    setupCode: '// Create an immutable map',
    expected: { a: 1, b: 2 },
    sample: 'mapOf("a" to 1, "b" to 2)',
    hints: ['Use `to` infix function for pairs', 'mapOf creates immutable Map'],
    validPatterns: [/mapOf\s*\(\s*"a"\s+to\s+1\s*,\s*"b"\s+to\s+2\s*\)/],
    tags: ['mapOf', 'immutable', 'create'],
  },

  {
    id: 'kotlin-map-002',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Create Mutable Map',
    text: 'Create a mutable map with "x" to 10, "y" to 20.',
    setup: '// Create a mutable map',
    setupCode: '// Create a mutable map',
    expected: { x: 10, y: 20 },
    sample: 'mutableMapOf("x" to 10, "y" to 20)',
    hints: ['mutableMapOf creates MutableMap', 'Can add, remove, modify entries'],
    validPatterns: [/mutableMapOf\s*\(\s*"x"\s+to\s+10\s*,\s*"y"\s+to\s+20\s*\)/],
    tags: ['mutableMapOf', 'mutable', 'create'],
  },

  {
    id: 'kotlin-map-003',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Get Value by Key',
    text: 'Get the value for key "name".',
    setup: 'val map = mapOf("name" to "Alice", "city" to "NYC")',
    setupCode: 'val map = mapOf("name" to "Alice", "city" to "NYC")',
    expected: 'Alice',
    sample: 'map["name"] // returns "Alice"',
    hints: ['Use bracket notation', 'Returns null if key not found'],
    validPatterns: [/map\s*\[\s*"name"\s*\]/],
    tags: ['get', 'access', 'bracket'],
  },

  {
    id: 'kotlin-map-004',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Get Value with Default',
    text: 'Get value for key "age" with default 0.',
    setup: 'val map = mapOf("name" to "Alice")',
    setupCode: 'val map = mapOf("name" to "Alice")',
    expected: 0,
    sample: 'map.getOrDefault("age", 0)',
    hints: ['getOrDefault returns default if key missing', 'More readable than ?: operator'],
    validPatterns: [/\.getOrDefault\s*\(\s*"age"\s*,\s*0\s*\)/],
    tags: ['getOrDefault', 'default', 'safe'],
  },

  {
    id: 'kotlin-map-005',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Check Key Exists',
    text: 'Check if key "name" exists in the map.',
    setup: 'val map = mapOf("name" to "Alice", "city" to "NYC")',
    setupCode: 'val map = mapOf("name" to "Alice", "city" to "NYC")',
    expected: true,
    sample: '"name" in map // or map.containsKey("name")',
    hints: ['Use `in` operator or containsKey()', 'Both return Boolean'],
    validPatterns: [/"name"\s+in\s+map/, /\.containsKey\s*\(\s*"name"\s*\)/],
    tags: ['in', 'containsKey', 'check'],
  },

  {
    id: 'kotlin-map-006',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Get All Keys',
    text: 'Get all keys from the map.',
    setup: 'val map = mapOf("a" to 1, "b" to 2, "c" to 3)',
    setupCode: 'val map = mapOf("a" to 1, "b" to 2, "c" to 3)',
    expected: ['a', 'b', 'c'],
    sample: 'map.keys // returns Set of keys',
    hints: ['keys property returns Set<K>', 'Convert to list with .toList()'],
    validPatterns: [/\.keys(?!\()/],
    tags: ['keys', 'property', 'access'],
  },

  {
    id: 'kotlin-map-007',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Get All Values',
    text: 'Get all values from the map.',
    setup: 'val map = mapOf("a" to 1, "b" to 2, "c" to 3)',
    setupCode: 'val map = mapOf("a" to 1, "b" to 2, "c" to 3)',
    expected: [1, 2, 3],
    sample: 'map.values // returns Collection of values',
    hints: ['values property returns Collection<V>', 'Convert to list with .toList()'],
    validPatterns: [/\.values(?!\()/],
    tags: ['values', 'property', 'access'],
  },

  {
    id: 'kotlin-map-008',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Put Entry in MutableMap',
    text: 'Add entry "score" to 100 in the mutable map.',
    setup: 'val map = mutableMapOf("name" to "Alice")',
    setupCode: 'val map = mutableMapOf("name" to "Alice")',
    expected: { name: 'Alice', score: 100 },
    sample: 'map["score"] = 100',
    hints: ['Use bracket notation for assignment', 'Also: map.put("score", 100)'],
    validPatterns: [/map\s*\[\s*"score"\s*\]\s*=\s*100/, /\.put\s*\(\s*"score"\s*,\s*100\s*\)/],
    tags: ['put', 'assign', 'mutable'],
  },

  {
    id: 'kotlin-map-009',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Filter Map by Value',
    text: 'Filter to keep only entries with value greater than 5.',
    setup: 'val map = mapOf("a" to 3, "b" to 7, "c" to 2, "d" to 9)',
    setupCode: 'val map = mapOf("a" to 3, "b" to 7, "c" to 2, "d" to 9)',
    expected: { b: 7, d: 9 },
    sample: 'map.filter { it.value > 5 }',
    hints: ['filter on Map uses Map.Entry', 'Access it.key and it.value'],
    validPatterns: [/\.filter\s*\{.*\.value\s*>\s*5.*\}/],
    tags: ['filter', 'value', 'predicate'],
  },

  {
    id: 'kotlin-map-010',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Map Values',
    text: 'Double all values in the map.',
    setup: 'val map = mapOf("a" to 1, "b" to 2, "c" to 3)',
    setupCode: 'val map = mapOf("a" to 1, "b" to 2, "c" to 3)',
    expected: { a: 2, b: 4, c: 6 },
    sample: 'map.mapValues { it.value * 2 }',
    hints: ['mapValues transforms values keeping keys', 'Returns a new Map'],
    validPatterns: [/\.mapValues\s*\{.*\.value\s*\*\s*2.*\}/],
    tags: ['mapValues', 'transform', 'map'],
  },

  // ============================================================
  // Null Safety
  // ============================================================

  {
    id: 'kotlin-null-001',
    category: 'Null Safety',
    difficulty: 'easy',
    title: 'Safe Call Operator',
    text: 'Get the length of the string safely (may be null).',
    setup: 'val str: String? = "Hello"',
    setupCode: 'val str: String? = "Hello"',
    expected: 5,
    sample: 'str?.length // returns 5 (or null if str is null)',
    hints: ['?. is the safe call operator', 'Returns null if receiver is null'],
    validPatterns: [/\?\.\s*length/],
    tags: ['safeCall', '?.', 'null-safety'],
  },

  {
    id: 'kotlin-null-002',
    category: 'Null Safety',
    difficulty: 'easy',
    title: 'Elvis Operator',
    text: 'Get the string length or 0 if null.',
    setup: 'val str: String? = null',
    setupCode: 'val str: String? = null',
    expected: 0,
    sample: 'str?.length ?: 0',
    hints: ['?: is the Elvis operator', 'Returns right side if left is null'],
    validPatterns: [/\?\.\s*length\s*\?:\s*0/],
    tags: ['elvis', '?:', 'null-safety'],
  },

  {
    id: 'kotlin-null-003',
    category: 'Null Safety',
    difficulty: 'easy',
    title: 'Not-Null Assertion',
    text: 'Assert the string is not null and get its length.',
    setup: 'val str: String? = "Hello"',
    setupCode: 'val str: String? = "Hello"',
    expected: 5,
    sample: 'str!!.length // throws NPE if null',
    hints: ['!! is the not-null assertion operator', 'Use only when certain value is not null'],
    validPatterns: [/!!\s*\.\s*length/],
    tags: ['notNull', '!!', 'assertion'],
  },

  {
    id: 'kotlin-null-004',
    category: 'Null Safety',
    difficulty: 'medium',
    title: 'Let for Null Check',
    text: 'Execute code only if value is not null using let.',
    setup: 'val name: String? = "Alice"',
    setupCode: 'val name: String? = "Alice"',
    expected: 'ALICE',
    sample: 'name?.let { it.uppercase() }',
    hints: ['?.let executes block only if non-null', 'it refers to the non-null value'],
    validPatterns: [/\?\.let\s*\{.*\.uppercase\s*\(\s*\).*\}/],
    tags: ['let', 'safeCall', 'scope-function'],
  },

  {
    id: 'kotlin-null-005',
    category: 'Null Safety',
    difficulty: 'medium',
    title: 'Safe Cast',
    text: 'Safely cast to String (returns null if cast fails).',
    setup: 'val obj: Any = "Hello"',
    setupCode: 'val obj: Any = "Hello"',
    expected: 'Hello',
    sample: 'obj as? String',
    hints: ['as? is the safe cast operator', 'Returns null instead of throwing ClassCastException'],
    validPatterns: [/as\?\s*String/],
    tags: ['safeCast', 'as?', 'type'],
  },

  {
    id: 'kotlin-null-006',
    category: 'Null Safety',
    difficulty: 'easy',
    title: 'Check for Null',
    text: 'Check if the value is null.',
    setup: 'val value: String? = null',
    setupCode: 'val value: String? = null',
    expected: true,
    sample: 'value == null',
    hints: ['Simple null check with ==', 'Smart cast applies after null check'],
    validPatterns: [/value\s*==\s*null/],
    tags: ['null', 'check', 'equals'],
  },

  {
    id: 'kotlin-null-007',
    category: 'Null Safety',
    difficulty: 'medium',
    title: 'RequireNotNull',
    text: 'Require the value to be non-null with a message.',
    setup: 'val name: String? = "Alice"',
    setupCode: 'val name: String? = "Alice"',
    expected: 'Alice',
    sample: 'requireNotNull(name) { "Name cannot be null" }',
    hints: ['requireNotNull throws IllegalArgumentException if null', 'Returns non-null value'],
    validPatterns: [/requireNotNull\s*\(\s*name\s*\)/],
    tags: ['requireNotNull', 'validation', 'assert'],
  },

  {
    id: 'kotlin-null-008',
    category: 'Null Safety',
    difficulty: 'medium',
    title: 'Filter Not Null',
    text: 'Remove null values from the list.',
    setup: 'val nums: List<Int?> = listOf(1, null, 2, null, 3)',
    setupCode: 'val nums: List<Int?> = listOf(1, null, 2, null, 3)',
    expected: [1, 2, 3],
    sample: 'nums.filterNotNull()',
    hints: ['filterNotNull removes nulls', 'Returns List<T> instead of List<T?>'],
    validPatterns: [/\.filterNotNull\s*\(\s*\)/],
    tags: ['filterNotNull', 'list', 'null-safety'],
  },

  // ============================================================
  // Scope Functions
  // ============================================================

  {
    id: 'kotlin-scope-001',
    category: 'Scope Functions',
    difficulty: 'medium',
    title: 'Let for Transformation',
    text: 'Transform the number to its string representation using let.',
    setup: 'val num = 42',
    setupCode: 'val num = 42',
    expected: 'Number: 42',
    sample: 'num.let { "Number: $it" }',
    hints: ['let returns the lambda result', 'it refers to the receiver'],
    validPatterns: [/\.let\s*\{.*\$it.*\}/],
    tags: ['let', 'transform', 'scope-function'],
  },

  {
    id: 'kotlin-scope-002',
    category: 'Scope Functions',
    difficulty: 'medium',
    title: 'Run for Configuration',
    text: 'Create a StringBuilder and append "Hello World" using run.',
    setup: '// Use run to configure StringBuilder',
    setupCode: '// Use run to configure StringBuilder',
    expected: 'Hello World',
    sample: 'StringBuilder().run { append("Hello World"); toString() }',
    hints: ['run uses this as context object', 'Returns the lambda result'],
    validPatterns: [/\.run\s*\{/],
    tags: ['run', 'configuration', 'scope-function'],
  },

  {
    id: 'kotlin-scope-003',
    category: 'Scope Functions',
    difficulty: 'medium',
    title: 'With for Multiple Operations',
    text: 'Get name length and uppercase using with.',
    setup: 'val name = "Alice"',
    setupCode: 'val name = "Alice"',
    expected: [5, 'ALICE'],
    sample: 'with(name) { listOf(length, uppercase()) }',
    hints: ['with is not an extension function', 'Useful for multiple operations on same object'],
    validPatterns: [/with\s*\(\s*name\s*\)\s*\{/],
    tags: ['with', 'context', 'scope-function'],
  },

  {
    id: 'kotlin-scope-004',
    category: 'Scope Functions',
    difficulty: 'medium',
    title: 'Apply for Object Configuration',
    text: 'Create and configure a MutableList using apply.',
    setup: '// Create list with elements using apply',
    setupCode: '// Create list with elements using apply',
    expected: [1, 2, 3],
    sample: 'mutableListOf<Int>().apply { add(1); add(2); add(3) }',
    hints: ['apply returns the receiver object', 'Perfect for object initialization'],
    validPatterns: [/\.apply\s*\{/],
    tags: ['apply', 'initialization', 'scope-function'],
  },

  {
    id: 'kotlin-scope-005',
    category: 'Scope Functions',
    difficulty: 'medium',
    title: 'Also for Side Effects',
    text: 'Process value and log it using also.',
    setup: 'val num = 42',
    setupCode: 'val num = 42',
    expected: 42,
    sample: 'num.also { println("Value: $it") } // returns num',
    hints: ['also returns the receiver', 'Use for side effects like logging'],
    validPatterns: [/\.also\s*\{/],
    tags: ['also', 'sideEffect', 'scope-function'],
  },

  {
    id: 'kotlin-scope-006',
    category: 'Scope Functions',
    difficulty: 'medium',
    title: 'TakeIf Conditional',
    text: 'Get the number only if it is positive, else null.',
    setup: 'val num = 42',
    setupCode: 'val num = 42',
    expected: 42,
    sample: 'num.takeIf { it > 0 }',
    hints: ['takeIf returns receiver if predicate is true', 'Returns null otherwise'],
    validPatterns: [/\.takeIf\s*\{.*>\s*0.*\}/],
    tags: ['takeIf', 'conditional', 'filter'],
  },

  {
    id: 'kotlin-scope-007',
    category: 'Scope Functions',
    difficulty: 'medium',
    title: 'TakeUnless Conditional',
    text: 'Get the string only if it is not blank.',
    setup: 'val str = "Hello"',
    setupCode: 'val str = "Hello"',
    expected: 'Hello',
    sample: 'str.takeUnless { it.isBlank() }',
    hints: ['takeUnless is opposite of takeIf', 'Returns receiver if predicate is false'],
    validPatterns: [/\.takeUnless\s*\{.*\.isBlank\s*\(\s*\).*\}/],
    tags: ['takeUnless', 'conditional', 'filter'],
  },

  {
    id: 'kotlin-scope-008',
    category: 'Scope Functions',
    difficulty: 'hard',
    title: 'Chained Scope Functions',
    text: 'Process a nullable string: trim, filter non-empty, uppercase.',
    setup: 'val input: String? = "  hello  "',
    setupCode: 'val input: String? = "  hello  "',
    expected: 'HELLO',
    sample: 'input?.trim()?.takeIf { it.isNotEmpty() }?.uppercase()',
    hints: ['Chain scope functions with safe calls', 'Each step handles null safely'],
    validPatterns: [/\?\.trim\s*\(\s*\)\s*\?\.takeIf.*\?\.uppercase\s*\(\s*\)/],
    tags: ['chaining', 'scope-function', 'null-safety'],
  },

  // ============================================================
  // Sequences
  // ============================================================

  {
    id: 'kotlin-sequence-001',
    category: 'Sequences',
    difficulty: 'medium',
    title: 'Create Sequence from List',
    text: 'Convert the list to a sequence.',
    setup: 'val nums = listOf(1, 2, 3, 4, 5)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5)',
    expected: 'Sequence',
    sample: 'nums.asSequence()',
    hints: [
      'asSequence() creates lazy sequence',
      'Sequences are lazy - process one element at a time',
    ],
    validPatterns: [/\.asSequence\s*\(\s*\)/],
    tags: ['asSequence', 'lazy', 'convert'],
  },

  {
    id: 'kotlin-sequence-002',
    category: 'Sequences',
    difficulty: 'medium',
    title: 'Generate Sequence',
    text: 'Generate a sequence of numbers starting from 1.',
    setup: '// Generate infinite sequence',
    setupCode: '// Generate infinite sequence',
    expected: [1, 2, 3, 4, 5],
    sample: 'generateSequence(1) { it + 1 }.take(5).toList()',
    hints: [
      'generateSequence creates infinite sequence',
      'Must use terminal operation like take()',
    ],
    validPatterns: [/generateSequence\s*\(\s*1\s*\)\s*\{.*\+\s*1.*\}/],
    tags: ['generateSequence', 'infinite', 'lazy'],
  },

  {
    id: 'kotlin-sequence-003',
    category: 'Sequences',
    difficulty: 'medium',
    title: 'Sequence Filter and Map',
    text: 'Filter even numbers and double them using sequence.',
    setup: 'val nums = listOf(1, 2, 3, 4, 5, 6)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5, 6)',
    expected: [4, 8, 12],
    sample: 'nums.asSequence().filter { it % 2 == 0 }.map { it * 2 }.toList()',
    hints: ['Sequence operations are lazy', 'toList() is a terminal operation'],
    validPatterns: [/\.asSequence\s*\(\s*\)\.filter.*\.map.*\.toList\s*\(\s*\)/],
    tags: ['sequence', 'filter', 'map', 'lazy'],
  },

  {
    id: 'kotlin-sequence-004',
    category: 'Sequences',
    difficulty: 'medium',
    title: 'Sequence of Values',
    text: 'Create a sequence containing specific values.',
    setup: '// Create a sequence of 1, 2, 3',
    setupCode: '// Create a sequence of 1, 2, 3',
    expected: [1, 2, 3],
    sample: 'sequenceOf(1, 2, 3).toList()',
    hints: ['sequenceOf creates a finite sequence', 'Similar to listOf but lazy'],
    validPatterns: [/sequenceOf\s*\(\s*1\s*,\s*2\s*,\s*3\s*\)/],
    tags: ['sequenceOf', 'create', 'finite'],
  },

  {
    id: 'kotlin-sequence-005',
    category: 'Sequences',
    difficulty: 'hard',
    title: 'Chunked Sequence',
    text: 'Split the sequence into chunks of size 2.',
    setup: 'val nums = listOf(1, 2, 3, 4, 5)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5)',
    expected: [[1, 2], [3, 4], [5]],
    sample: 'nums.chunked(2)',
    hints: ['chunked splits into fixed-size chunks', 'Last chunk may be smaller'],
    validPatterns: [/\.chunked\s*\(\s*2\s*\)/],
    tags: ['chunked', 'split', 'batch'],
  },

  {
    id: 'kotlin-sequence-006',
    category: 'Sequences',
    difficulty: 'hard',
    title: 'Windowed Sequence',
    text: 'Create sliding windows of size 3.',
    setup: 'val nums = listOf(1, 2, 3, 4, 5)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5)',
    expected: [
      [1, 2, 3],
      [2, 3, 4],
      [3, 4, 5],
    ],
    sample: 'nums.windowed(3)',
    hints: ['windowed creates sliding windows', 'Default step is 1'],
    validPatterns: [/\.windowed\s*\(\s*3\s*\)/],
    tags: ['windowed', 'sliding', 'window'],
  },

  // ============================================================
  // Additional Kotlin Idioms
  // ============================================================

  {
    id: 'kotlin-idiom-001',
    category: 'Kotlin Idioms',
    difficulty: 'easy',
    title: 'Data Class',
    text: 'Create a data class Person with name and age.',
    setup: '// Define a data class',
    setupCode: '// Define a data class',
    expected: 'data class Person(val name: String, val age: Int)',
    sample: 'data class Person(val name: String, val age: Int)',
    hints: [
      'data class auto-generates equals, hashCode, toString, copy',
      'Properties in primary constructor',
    ],
    validPatterns: [
      /data\s+class\s+Person\s*\(\s*val\s+name:\s*String\s*,\s*val\s+age:\s*Int\s*\)/,
    ],
    tags: ['dataClass', 'model', 'idiom'],
  },

  {
    id: 'kotlin-idiom-002',
    category: 'Kotlin Idioms',
    difficulty: 'medium',
    title: 'Destructuring Declaration',
    text: 'Destructure a Pair into two variables.',
    setup: 'val pair = "Alice" to 25',
    setupCode: 'val pair = "Alice" to 25',
    expected: ['Alice', 25],
    sample: 'val (name, age) = pair',
    hints: ['Destructuring works with data classes and Pairs', 'Uses componentN() functions'],
    validPatterns: [/val\s*\(\s*\w+\s*,\s*\w+\s*\)\s*=\s*pair/],
    tags: ['destructuring', 'pair', 'idiom'],
  },

  {
    id: 'kotlin-idiom-003',
    category: 'Kotlin Idioms',
    difficulty: 'medium',
    title: 'When Expression',
    text: 'Use when to map number 1-3 to words.',
    setup: 'val num = 2',
    setupCode: 'val num = 2',
    expected: 'two',
    sample: 'when (num) { 1 -> "one"; 2 -> "two"; 3 -> "three"; else -> "unknown" }',
    hints: ['when is like switch but more powerful', 'Can be used as expression'],
    validPatterns: [/when\s*\(\s*num\s*\)\s*\{/],
    tags: ['when', 'pattern-matching', 'idiom'],
  },

  {
    id: 'kotlin-idiom-004',
    category: 'Kotlin Idioms',
    difficulty: 'medium',
    title: 'Extension Function',
    text: 'Create an extension function to double an Int.',
    setup: '// Define extension function',
    setupCode: '// Define extension function',
    expected: 'fun Int.double() = this * 2',
    sample: 'fun Int.double() = this * 2; 5.double() // returns 10',
    hints: ['Extension functions add methods to existing classes', 'this refers to the receiver'],
    validPatterns: [/fun\s+Int\.double\s*\(\s*\)/],
    tags: ['extension', 'function', 'idiom'],
  },

  {
    id: 'kotlin-idiom-005',
    category: 'Kotlin Idioms',
    difficulty: 'hard',
    title: 'Inline Class (Value Class)',
    text: 'Create a value class for Email.',
    setup: '// Define value class for type safety',
    setupCode: '// Define value class for type safety',
    expected: '@JvmInline value class Email(val value: String)',
    sample: '@JvmInline value class Email(val value: String)',
    hints: ['Value classes provide type safety without overhead', 'Requires @JvmInline annotation'],
    validPatterns: [/@JvmInline\s+value\s+class\s+Email\s*\(\s*val\s+value:\s*String\s*\)/],
    tags: ['valueClass', 'inline', 'type-safety'],
  },

  {
    id: 'kotlin-idiom-006',
    category: 'Kotlin Idioms',
    difficulty: 'medium',
    title: 'Sealed Class',
    text: 'Create a sealed class Result with Success and Error subclasses.',
    setup: '// Define sealed class hierarchy',
    setupCode: '// Define sealed class hierarchy',
    expected: 'sealed class Result',
    sample:
      'sealed class Result { data class Success(val data: String): Result(); data class Error(val msg: String): Result() }',
    hints: [
      'Sealed classes restrict inheritance',
      'Useful for representing restricted hierarchies',
    ],
    validPatterns: [/sealed\s+class\s+Result/],
    tags: ['sealed', 'hierarchy', 'idiom'],
  },

  {
    id: 'kotlin-idiom-007',
    category: 'Kotlin Idioms',
    difficulty: 'easy',
    title: 'Range Check',
    text: 'Check if number is in range 1 to 10.',
    setup: 'val num = 5',
    setupCode: 'val num = 5',
    expected: true,
    sample: 'num in 1..10',
    hints: ['Use `in` with range operator', '1..10 includes both endpoints'],
    validPatterns: [/num\s+in\s+1\s*\.\.\s*10/],
    tags: ['range', 'in', 'check'],
  },

  {
    id: 'kotlin-idiom-008',
    category: 'Kotlin Idioms',
    difficulty: 'medium',
    title: 'Range Loop',
    text: 'Create a list of numbers 1 to 5 using range.',
    setup: '// Use range to create list',
    setupCode: '// Use range to create list',
    expected: [1, 2, 3, 4, 5],
    sample: '(1..5).toList()',
    hints: ['Ranges are iterable', 'Can use downTo for descending'],
    validPatterns: [/\(\s*1\s*\.\.\s*5\s*\)\.toList\s*\(\s*\)/],
    tags: ['range', 'loop', 'list'],
  },

  {
    id: 'kotlin-idiom-009',
    category: 'Kotlin Idioms',
    difficulty: 'medium',
    title: 'Lazy Property',
    text: 'Create a lazy property that computes value on first access.',
    setup: '// Define lazy property',
    setupCode: '// Define lazy property',
    expected: 'val expensive by lazy { computeValue() }',
    sample: 'val expensive by lazy { computeValue() }',
    hints: ['lazy delegates computation until first access', 'Thread-safe by default'],
    validPatterns: [/val\s+\w+\s+by\s+lazy\s*\{/],
    tags: ['lazy', 'delegation', 'property'],
  },

  {
    id: 'kotlin-idiom-010',
    category: 'Kotlin Idioms',
    difficulty: 'easy',
    title: 'Single Expression Function',
    text: 'Create a function that returns the square of a number.',
    setup: '// Define single-expression function',
    setupCode: '// Define single-expression function',
    expected: 'fun square(n: Int) = n * n',
    sample: 'fun square(n: Int) = n * n',
    hints: ['Omit braces and return for single expressions', 'Return type can be inferred'],
    validPatterns: [/fun\s+square\s*\(\s*n:\s*Int\s*\)\s*=\s*n\s*\*\s*n/],
    tags: ['function', 'expression', 'concise'],
  },

  // ============================================================
  // Additional Collection Functions
  // ============================================================

  {
    id: 'kotlin-collection-023',
    category: 'Collection Functions',
    difficulty: 'easy',
    title: 'Filter by Index',
    text: 'Keep only elements at even indices (0, 2, 4, ...).',
    setup: 'val letters = listOf("a", "b", "c", "d", "e", "f")',
    setupCode: 'val letters = listOf("a", "b", "c", "d", "e", "f")',
    expected: ['a', 'c', 'e'],
    sample: 'letters.filterIndexed { index, _ -> index % 2 == 0 }',
    hints: [
      'filterIndexed provides access to both index and element',
      'Use _ to ignore unused parameters',
    ],
    validPatterns: [/\.filterIndexed\s*\{.*index.*%\s*2\s*==\s*0.*\}/],
    tags: ['filterIndexed', 'index', 'predicate'],
  },

  {
    id: 'kotlin-collection-024',
    category: 'Collection Functions',
    difficulty: 'easy',
    title: 'Sum of Property',
    text: 'Calculate the sum of all string lengths.',
    setup: 'val words = listOf("apple", "banana", "cherry")',
    setupCode: 'val words = listOf("apple", "banana", "cherry")',
    expected: 17,
    sample: 'words.sumOf { it.length }',
    hints: ['sumOf transforms and sums in one operation', 'More efficient than map + sum'],
    validPatterns: [/\.sumOf\s*\{.*\.length.*\}/],
    tags: ['sumOf', 'aggregation', 'transform'],
  },

  {
    id: 'kotlin-collection-025',
    category: 'Collection Functions',
    difficulty: 'medium',
    title: 'FlatMap with Transformation',
    text: 'For each word, produce a list of its characters.',
    setup: 'val words = listOf("hi", "bye")',
    setupCode: 'val words = listOf("hi", "bye")',
    expected: ['h', 'i', 'b', 'y', 'e'],
    sample: 'words.flatMap { it.toList() }',
    hints: [
      'flatMap transforms and flattens simultaneously',
      'toList() on String gives List<Char>',
    ],
    validPatterns: [/\.flatMap\s*\{.*\.toList\s*\(\s*\).*\}/],
    tags: ['flatMap', 'transform', 'flatten'],
  },

  {
    id: 'kotlin-collection-026',
    category: 'Collection Functions',
    difficulty: 'medium',
    title: 'Fold to Build String',
    text: 'Build a comma-separated string using fold.',
    setup: 'val nums = listOf(1, 2, 3)',
    setupCode: 'val nums = listOf(1, 2, 3)',
    expected: '1, 2, 3',
    sample: 'nums.fold("") { acc, n -> if (acc.isEmpty()) "$n" else "$acc, $n" }',
    hints: ['fold allows building any result type', 'First parameter is initial accumulator value'],
    validPatterns: [/\.fold\s*\(\s*""\s*\)\s*\{/],
    tags: ['fold', 'accumulator', 'string'],
  },

  {
    id: 'kotlin-collection-027',
    category: 'Collection Functions',
    difficulty: 'easy',
    title: 'Group By First Letter',
    text: 'Group words by their first character.',
    setup: 'val words = listOf("apple", "apricot", "banana", "blueberry")',
    setupCode: 'val words = listOf("apple", "apricot", "banana", "blueberry")',
    expected: { a: ['apple', 'apricot'], b: ['banana', 'blueberry'] },
    sample: 'words.groupBy { it.first() }',
    hints: ['groupBy creates Map<K, List<T>>', 'first() returns the first character'],
    validPatterns: [/\.groupBy\s*\{.*\.first\s*\(\s*\).*\}/],
    tags: ['groupBy', 'categorize', 'first'],
  },

  {
    id: 'kotlin-collection-028',
    category: 'Collection Functions',
    difficulty: 'medium',
    title: 'Partition by Threshold',
    text: 'Partition numbers into passing (>= 60) and failing (< 60).',
    setup: 'val scores = listOf(85, 42, 60, 55, 90, 38)',
    setupCode: 'val scores = listOf(85, 42, 60, 55, 90, 38)',
    expected: [
      [85, 60, 90],
      [42, 55, 38],
    ],
    sample: 'val (passing, failing) = scores.partition { it >= 60 }',
    hints: ['partition returns Pair of matching and non-matching', 'Can destructure the result'],
    validPatterns: [/\.partition\s*\{.*>=\s*60.*\}/],
    tags: ['partition', 'split', 'threshold'],
  },

  // ============================================================
  // Additional String Functions
  // ============================================================

  {
    id: 'kotlin-string-013',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'SubstringBefore Delimiter',
    text: 'Get the part of the email before the @ symbol.',
    setup: 'val email = "user@example.com"',
    setupCode: 'val email = "user@example.com"',
    expected: 'user',
    sample: 'email.substringBefore("@")',
    hints: [
      'substringBefore returns portion before first occurrence',
      'Returns original string if delimiter not found',
    ],
    validPatterns: [/\.substringBefore\s*\(\s*"@"\s*\)/],
    tags: ['substringBefore', 'parse', 'extract'],
  },

  {
    id: 'kotlin-string-014',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'SubstringAfter Delimiter',
    text: 'Get the domain part of the email (after @).',
    setup: 'val email = "user@example.com"',
    setupCode: 'val email = "user@example.com"',
    expected: 'example.com',
    sample: 'email.substringAfter("@")',
    hints: [
      'substringAfter returns portion after first occurrence',
      'Useful for parsing structured strings',
    ],
    validPatterns: [/\.substringAfter\s*\(\s*"@"\s*\)/],
    tags: ['substringAfter', 'parse', 'extract'],
  },

  {
    id: 'kotlin-string-015',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'PadStart',
    text: 'Pad the number string to 5 characters with leading zeros.',
    setup: 'val num = "42"',
    setupCode: 'val num = "42"',
    expected: '00042',
    sample: "num.padStart(5, '0')",
    hints: ['padStart adds characters at the beginning', 'Second parameter is the pad character'],
    validPatterns: [/\.padStart\s*\(\s*5\s*,\s*'0'\s*\)/],
    tags: ['padStart', 'format', 'padding'],
  },

  {
    id: 'kotlin-string-016',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'PadEnd',
    text: 'Pad the string to 10 characters with trailing dots.',
    setup: 'val text = "Hello"',
    setupCode: 'val text = "Hello"',
    expected: 'Hello.....',
    sample: "text.padEnd(10, '.')",
    hints: ['padEnd adds characters at the end', 'Useful for creating fixed-width output'],
    validPatterns: [/\.padEnd\s*\(\s*10\s*,\s*'.'\s*\)/],
    tags: ['padEnd', 'format', 'padding'],
  },

  {
    id: 'kotlin-string-017',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Replace with Regex',
    text: 'Replace all digits with X.',
    setup: 'val text = "Phone: 123-456-7890"',
    setupCode: 'val text = "Phone: 123-456-7890"',
    expected: 'Phone: XXX-XXX-XXXX',
    sample: 'text.replace(Regex("\\\\d"), "X")',
    hints: ['Use Regex() for pattern-based replacement', '\\d matches any digit'],
    validPatterns: [/\.replace\s*\(\s*Regex\s*\(.*\\d.*\)\s*,\s*"X"\s*\)/],
    tags: ['replace', 'regex', 'pattern'],
  },

  {
    id: 'kotlin-string-018',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Split with Limit',
    text: 'Split the path by "/" but only get the first 3 parts.',
    setup: 'val path = "/home/user/documents/file.txt"',
    setupCode: 'val path = "/home/user/documents/file.txt"',
    expected: ['', 'home', 'user/documents/file.txt'],
    sample: 'path.split("/", limit = 3)',
    hints: [
      'limit parameter restricts the number of splits',
      'Remaining string stays in last element',
    ],
    validPatterns: [/\.split\s*\(\s*"\/"\s*,\s*limit\s*=\s*3\s*\)/],
    tags: ['split', 'limit', 'parse'],
  },

  // ============================================================
  // Additional Sequence Operations
  // ============================================================

  {
    id: 'kotlin-sequence-007',
    category: 'Sequences',
    difficulty: 'easy',
    title: 'Take from Sequence',
    text: 'Take the first 5 elements from an infinite sequence of integers.',
    setup: '// Generate and take from sequence',
    setupCode: '// Generate and take from sequence',
    expected: [0, 1, 2, 3, 4],
    sample: 'generateSequence(0) { it + 1 }.take(5).toList()',
    hints: ['take() is lazy and returns a Sequence', 'toList() is the terminal operation'],
    validPatterns: [/generateSequence.*\.take\s*\(\s*5\s*\)\.toList\s*\(\s*\)/],
    tags: ['take', 'sequence', 'lazy'],
  },

  {
    id: 'kotlin-sequence-008',
    category: 'Sequences',
    difficulty: 'easy',
    title: 'Drop from Sequence',
    text: 'Skip the first 3 elements and take the next 3.',
    setup: 'val nums = (1..10).asSequence()',
    setupCode: 'val nums = (1..10).asSequence()',
    expected: [4, 5, 6],
    sample: 'nums.drop(3).take(3).toList()',
    hints: ['drop() skips elements lazily', 'Combine with take() for slicing'],
    validPatterns: [/\.drop\s*\(\s*3\s*\)\.take\s*\(\s*3\s*\)\.toList\s*\(\s*\)/],
    tags: ['drop', 'take', 'sequence'],
  },

  {
    id: 'kotlin-sequence-009',
    category: 'Sequences',
    difficulty: 'medium',
    title: 'TakeWhile Sequence',
    text: 'Take elements while they are less than 5.',
    setup: 'val nums = listOf(1, 2, 3, 5, 4, 2, 1)',
    setupCode: 'val nums = listOf(1, 2, 3, 5, 4, 2, 1)',
    expected: [1, 2, 3],
    sample: 'nums.takeWhile { it < 5 }',
    hints: ['takeWhile stops at first false', 'Does not include elements after stopping'],
    validPatterns: [/\.takeWhile\s*\{.*<\s*5.*\}/],
    tags: ['takeWhile', 'conditional', 'sequence'],
  },

  {
    id: 'kotlin-sequence-010',
    category: 'Sequences',
    difficulty: 'medium',
    title: 'DropWhile Sequence',
    text: 'Drop elements while they are less than 5.',
    setup: 'val nums = listOf(1, 2, 3, 5, 4, 2, 1)',
    setupCode: 'val nums = listOf(1, 2, 3, 5, 4, 2, 1)',
    expected: [5, 4, 2, 1],
    sample: 'nums.dropWhile { it < 5 }',
    hints: ['dropWhile skips until predicate is false', 'Then includes all remaining elements'],
    validPatterns: [/\.dropWhile\s*\{.*<\s*5.*\}/],
    tags: ['dropWhile', 'conditional', 'sequence'],
  },

  {
    id: 'kotlin-sequence-011',
    category: 'Sequences',
    difficulty: 'hard',
    title: 'Generate Fibonacci Sequence',
    text: 'Generate the first 8 Fibonacci numbers using generateSequence.',
    setup: '// Generate Fibonacci sequence',
    setupCode: '// Generate Fibonacci sequence',
    expected: [1, 1, 2, 3, 5, 8, 13, 21],
    sample:
      'generateSequence(Pair(1, 1)) { Pair(it.second, it.first + it.second) }.map { it.first }.take(8).toList()',
    hints: [
      'Use a Pair to track (current, next) values',
      'generateSequence with seed and transform function',
    ],
    validPatterns: [/generateSequence\s*\(\s*Pair\s*\(.*\).*\.take\s*\(\s*8\s*\)/],
    tags: ['generateSequence', 'fibonacci', 'algorithm'],
  },

  // ============================================================
  // Additional Null Safety
  // ============================================================

  {
    id: 'kotlin-null-009',
    category: 'Null Safety',
    difficulty: 'easy',
    title: 'Elvis with Return',
    text: 'Return "Unknown" if name is null.',
    setup: 'val name: String? = null',
    setupCode: 'val name: String? = null',
    expected: 'Unknown',
    sample: 'name ?: "Unknown"',
    hints: ['Elvis operator provides default value', 'Right side executes only if left is null'],
    validPatterns: [/name\s*\?:\s*"Unknown"/],
    tags: ['elvis', 'default', 'null-safety'],
  },

  {
    id: 'kotlin-null-010',
    category: 'Null Safety',
    difficulty: 'medium',
    title: 'Chained Safe Calls',
    text: 'Get the length of the city name safely (person, address, city may be null).',
    setup:
      'data class Address(val city: String?)\ndata class Person(val address: Address?)\nval person: Person? = Person(Address("NYC"))',
    setupCode:
      'data class Address(val city: String?)\ndata class Person(val address: Address?)\nval person: Person? = Person(Address("NYC"))',
    expected: 3,
    sample: 'person?.address?.city?.length',
    hints: ['Chain safe calls for nested nullable access', 'Returns null if any is null'],
    validPatterns: [/person\?\.\s*address\?\.\s*city\?\.\s*length/],
    tags: ['safeCall', 'chaining', 'null-safety'],
  },

  {
    id: 'kotlin-null-011',
    category: 'Null Safety',
    difficulty: 'medium',
    title: 'Let with Also',
    text: 'If name is not null, log it and convert to uppercase.',
    setup: 'val name: String? = "Alice"',
    setupCode: 'val name: String? = "Alice"',
    expected: 'ALICE',
    sample: 'name?.also { println("Processing: $it") }?.uppercase()',
    hints: ['Combine also for side effects', 'also returns the receiver for chaining'],
    validPatterns: [/\?\.also\s*\{.*\}\s*\?\.\s*uppercase\s*\(\s*\)/],
    tags: ['also', 'let', 'chaining'],
  },

  {
    id: 'kotlin-null-012',
    category: 'Null Safety',
    difficulty: 'hard',
    title: 'Run on Nullable',
    text: 'If value is not null, compute its square plus 10.',
    setup: 'val value: Int? = 5',
    setupCode: 'val value: Int? = 5',
    expected: 35,
    sample: 'value?.run { this * this + 10 }',
    hints: ['run uses this as context', 'Returns lambda result or null'],
    validPatterns: [/\?\.run\s*\{.*\*.*\+\s*10.*\}/],
    tags: ['run', 'safeCall', 'computation'],
  },

  // ============================================================
  // Additional Scope Functions
  // ============================================================

  {
    id: 'kotlin-scope-009',
    category: 'Scope Functions',
    difficulty: 'easy',
    title: 'Let for Null Check and Transform',
    text: 'If list is not empty, return its size as a string.',
    setup: 'val list = listOf(1, 2, 3)',
    setupCode: 'val list = listOf(1, 2, 3)',
    expected: '3',
    sample: 'list.takeIf { it.isNotEmpty() }?.let { it.size.toString() }',
    hints: ['Combine takeIf with let for conditional transform', 'let returns lambda result'],
    validPatterns: [/\.takeIf\s*\{.*isNotEmpty.*\}\s*\?\.\s*let\s*\{/],
    tags: ['let', 'takeIf', 'conditional'],
  },

  {
    id: 'kotlin-scope-010',
    category: 'Scope Functions',
    difficulty: 'medium',
    title: 'Apply for Builder Pattern',
    text: 'Create and configure a StringBuilder to build "Hello, World!".',
    setup: '// Use apply for builder pattern',
    setupCode: '// Use apply for builder pattern',
    expected: 'Hello, World!',
    sample: 'StringBuilder().apply { append("Hello"); append(", "); append("World!") }.toString()',
    hints: ['apply is perfect for builder patterns', 'this refers to the receiver inside'],
    validPatterns: [/StringBuilder\s*\(\s*\)\.apply\s*\{.*append.*\}\.toString\s*\(\s*\)/],
    tags: ['apply', 'builder', 'configuration'],
  },

  {
    id: 'kotlin-scope-011',
    category: 'Scope Functions',
    difficulty: 'hard',
    title: 'With for Complex Object Operations',
    text: 'Using with, extract multiple properties from a data class.',
    setup:
      'data class User(val name: String, val age: Int, val email: String)\nval user = User("Alice", 30, "alice@example.com")',
    setupCode:
      'data class User(val name: String, val age: Int, val email: String)\nval user = User("Alice", 30, "alice@example.com")',
    expected: 'Alice (30) - alice@example.com',
    sample: 'with(user) { "$name ($age) - $email" }',
    hints: ['with provides clean access to multiple properties', 'Avoids repeating receiver name'],
    validPatterns: [/with\s*\(\s*user\s*\)\s*\{.*\$name.*\$age.*\$email.*\}/],
    tags: ['with', 'properties', 'formatting'],
  },

  {
    id: 'kotlin-scope-012',
    category: 'Scope Functions',
    difficulty: 'medium',
    title: 'Also for Logging',
    text: 'Process a list and log each transformation step.',
    setup: 'val nums = listOf(1, 2, 3)',
    setupCode: 'val nums = listOf(1, 2, 3)',
    expected: [2, 4, 6],
    sample: 'nums.map { it * 2 }.also { println("Doubled: $it") }',
    hints: ['also is perfect for debugging/logging', 'Does not modify the chain result'],
    validPatterns: [/\.also\s*\{.*println.*\}/],
    tags: ['also', 'logging', 'debug'],
  },

  {
    id: 'kotlin-scope-013',
    category: 'Scope Functions',
    difficulty: 'hard',
    title: 'Run for Result Computation',
    text: 'Compute the average of a list, returning 0.0 if empty.',
    setup: 'val nums = listOf(10, 20, 30)',
    setupCode: 'val nums = listOf(10, 20, 30)',
    expected: 20.0,
    sample: 'nums.run { if (isEmpty()) 0.0 else sum().toDouble() / size }',
    hints: ['run computes and returns a result', 'this refers to the list inside'],
    validPatterns: [/\.run\s*\{.*isEmpty\s*\(\s*\).*sum\s*\(\s*\).*\/\s*size.*\}/],
    tags: ['run', 'computation', 'average'],
  },

  // ============================================================
  // String Operations - Advanced (25 new problems)
  // ============================================================

  // --- EASY (8 problems) ---

  {
    id: 'kotlin-str-001',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Basic String Template',
    text: 'Create the greeting "Hello, John!" using string template with the given name.',
    setup: 'val name = "John"',
    setupCode: 'val name = "John"',
    expected: 'Hello, John!',
    sample: '"Hello, $name!"',
    hints: ['Use $ to interpolate variables', 'No braces needed for simple variable names'],
    validPatterns: [/"Hello,\s*\$name!"/],
    tags: ['template', 'interpolation', 'basics'],
  },

  {
    id: 'kotlin-str-002',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Template with Expression',
    text: 'Create the string "Sum: 15" using string template with an expression.',
    setup: 'val a = 10\nval b = 5',
    setupCode: 'val a = 10\nval b = 5',
    expected: 'Sum: 15',
    sample: '"Sum: ${a + b}"',
    hints: ['Use ${} for expressions', 'Any valid Kotlin expression works inside'],
    validPatterns: [/"Sum:\s*\$\{a\s*\+\s*b\}"/],
    tags: ['template', 'expression', 'interpolation'],
  },

  {
    id: 'kotlin-str-003',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Raw String Basics',
    text: 'Create a raw string containing a Windows path: C:\\Users\\Name without escaping.',
    setup: '// Create raw string for path',
    setupCode: '// Create raw string for path',
    expected: 'C:\\Users\\Name',
    sample: '"""C:\\Users\\Name"""',
    hints: ['Triple quotes create raw strings', 'No escape sequences needed in raw strings'],
    validPatterns: [/"""C:\\Users\\Name"""/],
    tags: ['rawString', 'tripleQuote', 'escape'],
  },

  {
    id: 'kotlin-str-004',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Remove Surrounding Characters',
    text: 'Remove the surrounding quotes from the string.',
    setup: 'val quoted = "\\"Hello World\\""',
    setupCode: 'val quoted = "\\"Hello World\\""',
    expected: 'Hello World',
    sample: 'quoted.removeSurrounding("\\"")',
    hints: [
      'removeSurrounding removes prefix and suffix if both match',
      'Only removes if both ends match',
    ],
    validPatterns: [/\.removeSurrounding\s*\(\s*"[^"]*"\s*\)/],
    tags: ['removeSurrounding', 'trim', 'parse'],
  },

  {
    id: 'kotlin-str-005',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Join List to String',
    text: 'Join the list elements with " - " separator.',
    setup: 'val items = listOf("apple", "banana", "cherry")',
    setupCode: 'val items = listOf("apple", "banana", "cherry")',
    expected: 'apple - banana - cherry',
    sample: 'items.joinToString(" - ")',
    hints: ['joinToString combines list elements', 'Separator is the first parameter'],
    validPatterns: [/\.joinToString\s*\(\s*" - "\s*\)/],
    tags: ['joinToString', 'join', 'format'],
  },

  {
    id: 'kotlin-str-006',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Get Character at Index',
    text: 'Get the character at index 4 from the string.',
    setup: 'val text = "Kotlin"',
    setupCode: 'val text = "Kotlin"',
    expected: 'i',
    sample: "text[4] // returns 'i'",
    hints: ['Use bracket notation for char access', 'Returns Char, not String'],
    validPatterns: [/text\s*\[\s*4\s*\]/],
    tags: ['character', 'index', 'access'],
  },

  {
    id: 'kotlin-str-007',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Repeat String',
    text: 'Repeat the string 3 times.',
    setup: 'val str = "ab"',
    setupCode: 'val str = "ab"',
    expected: 'ababab',
    sample: 'str.repeat(3)',
    hints: ['repeat() duplicates the string n times', 'Returns a new string'],
    validPatterns: [/\.repeat\s*\(\s*3\s*\)/],
    tags: ['repeat', 'duplicate', 'transform'],
  },

  {
    id: 'kotlin-str-008',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Remove Prefix',
    text: 'Remove the "https://" prefix from the URL.',
    setup: 'val url = "https://example.com"',
    setupCode: 'val url = "https://example.com"',
    expected: 'example.com',
    sample: 'url.removePrefix("https://")',
    hints: [
      'removePrefix only removes if string starts with prefix',
      'Returns original if no match',
    ],
    validPatterns: [/\.removePrefix\s*\(\s*"https:\/\/"\s*\)/],
    tags: ['removePrefix', 'trim', 'parse'],
  },

  // --- MEDIUM (12 problems) ---

  {
    id: 'kotlin-str-009',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'StringBuilder Append Chain',
    text: 'Build the string "Hello World!" using StringBuilder with chained appends.',
    setup: '// Use StringBuilder',
    setupCode: '// Use StringBuilder',
    expected: 'Hello World!',
    sample: 'StringBuilder().append("Hello").append(" ").append("World!").toString()',
    hints: ['StringBuilder is mutable and efficient', 'append() returns the builder for chaining'],
    validPatterns: [/StringBuilder\s*\(\s*\)\.append.*\.toString\s*\(\s*\)/],
    tags: ['StringBuilder', 'append', 'efficient'],
  },

  {
    id: 'kotlin-str-010',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'StringBuilder with buildString',
    text: 'Create "Item: Apple, Price: $1.50" using buildString.',
    setup: 'val item = "Apple"\nval price = 1.50',
    setupCode: 'val item = "Apple"\nval price = 1.50',
    expected: 'Item: Apple, Price: $1.50',
    sample: 'buildString { append("Item: ").append(item).append(", Price: $").append(price) }',
    hints: ['buildString is idiomatic Kotlin StringBuilder', 'Returns the built String directly'],
    validPatterns: [/buildString\s*\{[\s\S]*append[\s\S]*\}/],
    tags: ['buildString', 'StringBuilder', 'idiomatic'],
  },

  {
    id: 'kotlin-str-011',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Regex Match Check',
    text: 'Check if the string is a valid email format (contains @ and .).',
    setup: 'val email = "test@example.com"',
    setupCode: 'val email = "test@example.com"',
    expected: true,
    sample: 'email.matches(Regex(".+@.+\\\\..+"))',
    hints: ['matches() checks entire string against regex', 'Regex() creates a pattern object'],
    validPatterns: [/\.matches\s*\(\s*Regex\s*\(.*@.*\)/],
    tags: ['regex', 'matches', 'validation'],
  },

  {
    id: 'kotlin-str-012',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Find All Regex Matches',
    text: 'Find all numbers in the string and return them as a list.',
    setup: 'val text = "Order 123 has 5 items worth $99"',
    setupCode: 'val text = "Order 123 has 5 items worth $99"',
    expected: ['123', '5', '99'],
    sample: 'Regex("\\\\d+").findAll(text).map { it.value }.toList()',
    hints: ['findAll returns Sequence of MatchResult', 'Access matched text via value property'],
    validPatterns: [/Regex\s*\(.*\\d.*\)\.findAll.*\.map.*\.toList\s*\(\s*\)/],
    tags: ['regex', 'findAll', 'extract'],
  },

  {
    id: 'kotlin-str-013',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Split with Regex',
    text: 'Split the string by any whitespace (spaces, tabs, newlines).',
    setup: 'val text = "Hello\\tWorld\\nKotlin"',
    setupCode: 'val text = "Hello\\tWorld\\nKotlin"',
    expected: ['Hello', 'World', 'Kotlin'],
    sample: 'text.split(Regex("\\\\s+"))',
    hints: ['\\s matches any whitespace', '+ means one or more'],
    validPatterns: [/\.split\s*\(\s*Regex\s*\(.*\\s.*\)\s*\)/],
    tags: ['split', 'regex', 'whitespace'],
  },

  {
    id: 'kotlin-str-014',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Raw String with trimIndent',
    text: 'Create a trimmed multiline JSON-like string.',
    setup: '// Create formatted JSON string',
    setupCode: '// Create formatted JSON string',
    expected: '{\n  "name": "test"\n}',
    sample:
      '"""\n            {\n              "name": "test"\n            }\n            """.trimIndent()',
    hints: ['trimIndent removes common leading whitespace', 'Preserves relative indentation'],
    validPatterns: [/"""[\s\S]*"""\.trimIndent\s*\(\s*\)/],
    tags: ['rawString', 'trimIndent', 'multiline'],
  },

  {
    id: 'kotlin-str-015',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'JoinToString with Transform',
    text: 'Join numbers as uppercase hex strings separated by ":".',
    setup: 'val bytes = listOf(255, 128, 64)',
    setupCode: 'val bytes = listOf(255, 128, 64)',
    expected: 'FF:80:40',
    sample: 'bytes.joinToString(":") { it.toString(16).uppercase() }',
    hints: ['joinToString accepts a transform lambda', 'toString(16) converts to hexadecimal'],
    validPatterns: [/\.joinToString\s*\(\s*":".*\{.*toString\s*\(\s*16\s*\).*uppercase/],
    tags: ['joinToString', 'transform', 'hex'],
  },

  {
    id: 'kotlin-str-016',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'SubstringAfterLast',
    text: 'Extract the file extension from the path.',
    setup: 'val path = "/home/user/document.backup.txt"',
    setupCode: 'val path = "/home/user/document.backup.txt"',
    expected: 'txt',
    sample: 'path.substringAfterLast(".")',
    hints: ['substringAfterLast finds the LAST occurrence', 'Useful for file extensions'],
    validPatterns: [/\.substringAfterLast\s*\(\s*"\."\s*\)/],
    tags: ['substringAfterLast', 'extract', 'parse'],
  },

  {
    id: 'kotlin-str-017',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'SubstringBeforeLast',
    text: 'Get the filename without extension.',
    setup: 'val filename = "document.backup.txt"',
    setupCode: 'val filename = "document.backup.txt"',
    expected: 'document.backup',
    sample: 'filename.substringBeforeLast(".")',
    hints: ['substringBeforeLast finds the LAST occurrence', 'Preserves earlier dots in name'],
    validPatterns: [/\.substringBeforeLast\s*\(\s*"\."\s*\)/],
    tags: ['substringBeforeLast', 'extract', 'filename'],
  },

  {
    id: 'kotlin-str-018',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Lines and Filter',
    text: 'Split text into lines and keep only non-empty ones.',
    setup: 'val text = "Line 1\\n\\nLine 2\\n\\nLine 3"',
    setupCode: 'val text = "Line 1\\n\\nLine 2\\n\\nLine 3"',
    expected: ['Line 1', 'Line 2', 'Line 3'],
    sample: 'text.lines().filter { it.isNotEmpty() }',
    hints: ['lines() splits by line breaks', 'Returns List<String>'],
    validPatterns: [/\.lines\s*\(\s*\)\.filter\s*\{.*isNotEmpty|isNotBlank/],
    tags: ['lines', 'filter', 'text'],
  },

  {
    id: 'kotlin-str-019',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Replace First Occurrence',
    text: 'Replace only the first occurrence of "cat" with "dog".',
    setup: 'val text = "The cat sat on the cat mat"',
    setupCode: 'val text = "The cat sat on the cat mat"',
    expected: 'The dog sat on the cat mat',
    sample: 'text.replaceFirst("cat", "dog")',
    hints: ['replaceFirst only replaces the first match', 'replace() replaces all occurrences'],
    validPatterns: [/\.replaceFirst\s*\(\s*"cat"\s*,\s*"dog"\s*\)/],
    tags: ['replaceFirst', 'replace', 'transform'],
  },

  {
    id: 'kotlin-str-020',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Capitalize Words',
    text: 'Capitalize the first letter of each word.',
    setup: 'val text = "hello world kotlin"',
    setupCode: 'val text = "hello world kotlin"',
    expected: 'Hello World Kotlin',
    sample: 'text.split(" ").joinToString(" ") { it.replaceFirstChar { c -> c.uppercase() } }',
    hints: ['Split, transform each word, rejoin', 'replaceFirstChar transforms first character'],
    validPatterns: [/\.split.*\.joinToString.*replaceFirstChar|capitalize/],
    tags: ['capitalize', 'words', 'transform'],
  },

  // --- HARD (5 problems) ---

  {
    id: 'kotlin-str-021',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Regex Capture Groups',
    text: 'Parse the date string and return a map with year, month, day.',
    setup: 'val date = "2024-03-15"',
    setupCode: 'val date = "2024-03-15"',
    expected: { year: '2024', month: '03', day: '15' },
    sample:
      'Regex("(\\\\d{4})-(\\\\d{2})-(\\\\d{2})").find(date)!!.destructured.let { (y, m, d) -> mapOf("year" to y, "month" to m, "day" to d) }',
    hints: ['Use named groups or destructured', 'find() returns MatchResult with groupValues'],
    validPatterns: [/Regex\s*\(.*\\d\{4\}.*\\d\{2\}.*\\d\{2\}.*\)\.find/],
    tags: ['regex', 'groups', 'destructure'],
  },

  {
    id: 'kotlin-str-022',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Complex String Builder',
    text: 'Build an HTML unordered list from items using buildString.',
    setup: 'val items = listOf("Apple", "Banana", "Cherry")',
    setupCode: 'val items = listOf("Apple", "Banana", "Cherry")',
    expected: '<ul>\n  <li>Apple</li>\n  <li>Banana</li>\n  <li>Cherry</li>\n</ul>',
    sample:
      'buildString {\n    appendLine("<ul>")\n    items.forEach { appendLine("  <li>$it</li>") }\n    append("</ul>")\n}',
    hints: ['appendLine adds newline after content', 'Use string templates inside buildString'],
    validPatterns: [/buildString\s*\{[\s\S]*forEach[\s\S]*<li>[\s\S]*<\/li>[\s\S]*\}/],
    tags: ['buildString', 'html', 'complex'],
  },

  {
    id: 'kotlin-str-023',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Regex Replace with Transform',
    text: 'Double all numbers in the string.',
    setup: 'val text = "I have 5 apples and 3 oranges"',
    setupCode: 'val text = "I have 5 apples and 3 oranges"',
    expected: 'I have 10 apples and 6 oranges',
    sample: 'text.replace(Regex("\\\\d+")) { (it.value.toInt() * 2).toString() }',
    hints: ['replace with Regex accepts a transform lambda', 'MatchResult is passed to the lambda'],
    validPatterns: [/\.replace\s*\(\s*Regex\s*\(.*\\d.*\)\s*\)\s*\{.*toInt\s*\(\s*\)\s*\*\s*2/],
    tags: ['regex', 'replace', 'transform'],
  },

  {
    id: 'kotlin-str-024',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Parse Key-Value Pairs',
    text: 'Parse the query string into a map of key-value pairs.',
    setup: 'val query = "name=John&age=30&city=NYC"',
    setupCode: 'val query = "name=John&age=30&city=NYC"',
    expected: { name: 'John', age: '30', city: 'NYC' },
    sample: 'query.split("&").associate { it.substringBefore("=") to it.substringAfter("=") }',
    hints: ['Split by &, then parse each pair', 'associate creates a Map from pairs'],
    validPatterns: [/\.split\s*\(\s*"&"\s*\)\.associate\s*\{.*substringBefore.*substringAfter/],
    tags: ['parse', 'map', 'queryString'],
  },

  {
    id: 'kotlin-str-025',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Windowed Character Processing',
    text: 'Find all 3-character sequences that contain at least one digit.',
    setup: 'val text = "ab1cd2ef"',
    setupCode: 'val text = "ab1cd2ef"',
    expected: ['b1c', '1cd', 'cd2', 'd2e'],
    sample: 'text.windowed(3).filter { it.any { c -> c.isDigit() } }',
    hints: ['windowed creates sliding windows', 'any checks if predicate matches any element'],
    validPatterns: [/\.windowed\s*\(\s*3\s*\)\.filter\s*\{.*any.*isDigit/],
    tags: ['windowed', 'filter', 'character'],
  },

  // ============================================================
  // Functional Patterns (25 new problems)
  // ============================================================

  // --- EASY (8 problems) ---

  {
    id: 'kotlin-func-001',
    category: 'Functional Patterns',
    difficulty: 'easy',
    title: 'Generate Sequence with Seed',
    text: 'Generate the first 5 powers of 2 starting from 1 using generateSequence.',
    setup: '// Generate: 1, 2, 4, 8, 16',
    setupCode: '// Generate: 1, 2, 4, 8, 16',
    expected: [1, 2, 4, 8, 16],
    sample: 'generateSequence(1) { it * 2 }.take(5).toList()',
    hints: [
      'generateSequence takes a seed and a lambda for the next value',
      'Use take() to limit infinite sequence',
    ],
    validPatterns: [/generateSequence\s*\(\s*1\s*\)\s*\{.*\*\s*2.*\}.*\.take\s*\(\s*5\s*\)/],
    tags: ['generateSequence', 'sequence', 'lazy'],
  },

  {
    id: 'kotlin-func-002',
    category: 'Functional Patterns',
    difficulty: 'easy',
    title: 'Associate List to Map',
    text: 'Create a map from list elements to their lengths using associate.',
    setup: 'val words = listOf("cat", "elephant", "dog")',
    setupCode: 'val words = listOf("cat", "elephant", "dog")',
    expected: { cat: 3, elephant: 8, dog: 3 },
    sample: 'words.associate { it to it.length }',
    hints: [
      'associate transforms each element to a key-value pair',
      'Lambda should return a Pair using `to`',
    ],
    validPatterns: [/\.associate\s*\{.*to.*\.length.*\}/],
    tags: ['associate', 'map', 'transform'],
  },

  {
    id: 'kotlin-func-003',
    category: 'Functional Patterns',
    difficulty: 'easy',
    title: 'AssociateBy with Key Selector',
    text: 'Create a map with first character as key and word as value.',
    setup: 'val words = listOf("apple", "banana", "cherry")',
    setupCode: 'val words = listOf("apple", "banana", "cherry")',
    expected: { a: 'apple', b: 'banana', c: 'cherry' },
    sample: 'words.associateBy { it.first() }',
    hints: ['associateBy uses the lambda result as key', 'Element itself becomes the value'],
    validPatterns: [/\.associateBy\s*\{.*\.first\s*\(\s*\).*\}/],
    tags: ['associateBy', 'map', 'key-selector'],
  },

  {
    id: 'kotlin-func-004',
    category: 'Functional Patterns',
    difficulty: 'easy',
    title: 'Partition List by Predicate',
    text: 'Partition numbers into (less than 5, greater or equal to 5).',
    setup: 'val nums = listOf(1, 7, 3, 9, 2, 6, 4, 8)',
    setupCode: 'val nums = listOf(1, 7, 3, 9, 2, 6, 4, 8)',
    expected: [
      [1, 3, 2, 4],
      [7, 9, 6, 8],
    ],
    sample: 'nums.partition { it < 5 }',
    hints: ['partition returns Pair<List, List>', 'First list matches predicate, second does not'],
    validPatterns: [/\.partition\s*\{.*<\s*5.*\}/],
    tags: ['partition', 'split', 'predicate'],
  },

  {
    id: 'kotlin-func-005',
    category: 'Functional Patterns',
    difficulty: 'easy',
    title: 'Chunked into Fixed Size',
    text: 'Split the list into chunks of size 3.',
    setup: 'val nums = listOf(1, 2, 3, 4, 5, 6, 7)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5, 6, 7)',
    expected: [[1, 2, 3], [4, 5, 6], [7]],
    sample: 'nums.chunked(3)',
    hints: ['chunked divides list into fixed-size sublists', 'Last chunk may have fewer elements'],
    validPatterns: [/\.chunked\s*\(\s*3\s*\)/],
    tags: ['chunked', 'batch', 'split'],
  },

  {
    id: 'kotlin-func-006',
    category: 'Functional Patterns',
    difficulty: 'easy',
    title: 'Zip Two Lists with Transform',
    text: 'Combine names and scores into formatted strings.',
    setup: 'val names = listOf("Alice", "Bob", "Charlie")\nval scores = listOf(95, 87, 92)',
    setupCode: 'val names = listOf("Alice", "Bob", "Charlie")\nval scores = listOf(95, 87, 92)',
    expected: ['Alice: 95', 'Bob: 87', 'Charlie: 92'],
    sample: 'names.zip(scores) { name, score -> "$name: $score" }',
    hints: [
      'zip with transform applies a function to each pair',
      'Result length is minimum of both lists',
    ],
    validPatterns: [/\.zip\s*\(\s*scores\s*\)\s*\{.*->.*\}/],
    tags: ['zip', 'transform', 'combine'],
  },

  {
    id: 'kotlin-func-007',
    category: 'Functional Patterns',
    difficulty: 'easy',
    title: 'Destructuring in Lambda',
    text: 'Use destructuring to sum each pair in a list of pairs.',
    setup: 'val pairs = listOf(1 to 2, 3 to 4, 5 to 6)',
    setupCode: 'val pairs = listOf(1 to 2, 3 to 4, 5 to 6)',
    expected: [3, 7, 11],
    sample: 'pairs.map { (a, b) -> a + b }',
    hints: ['Destructure in lambda parameters with (a, b)', 'Works with Pairs and data classes'],
    validPatterns: [/\.map\s*\{\s*\(\s*\w+\s*,\s*\w+\s*\)\s*->/],
    tags: ['destructuring', 'lambda', 'pair'],
  },

  {
    id: 'kotlin-func-008',
    category: 'Functional Patterns',
    difficulty: 'easy',
    title: 'GroupBy with Key Selector',
    text: 'Group numbers by their remainder when divided by 3.',
    setup: 'val nums = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9)',
    expected: { 0: [3, 6, 9], 1: [1, 4, 7], 2: [2, 5, 8] },
    sample: 'nums.groupBy { it % 3 }',
    hints: ['groupBy creates Map<K, List<T>>', 'Key is the lambda result'],
    validPatterns: [/\.groupBy\s*\{.*%\s*3.*\}/],
    tags: ['groupBy', 'categorize', 'map'],
  },

  // --- MEDIUM (12 problems) ---

  {
    id: 'kotlin-func-009',
    category: 'Functional Patterns',
    difficulty: 'medium',
    title: 'Sequence Builder with yield',
    text: 'Create a sequence that yields 1, then 2, then 3 using sequence builder.',
    setup: '// Use sequence { } builder',
    setupCode: '// Use sequence { } builder',
    expected: [1, 2, 3],
    sample: 'sequence { yield(1); yield(2); yield(3) }.toList()',
    hints: [
      'sequence { } creates a sequence using a builder',
      'yield() emits values one at a time',
    ],
    validPatterns: [/sequence\s*\{.*yield\s*\(\s*1\s*\).*yield\s*\(\s*2\s*\).*yield\s*\(\s*3\s*\)/],
    tags: ['sequence', 'yield', 'builder'],
  },

  {
    id: 'kotlin-func-010',
    category: 'Functional Patterns',
    difficulty: 'medium',
    title: 'Sequence Builder with yieldAll',
    text: 'Create a sequence that yields 1, 2 then yields all of [3, 4, 5].',
    setup: '// Use yieldAll to emit a collection',
    setupCode: '// Use yieldAll to emit a collection',
    expected: [1, 2, 3, 4, 5],
    sample: 'sequence { yield(1); yield(2); yieldAll(listOf(3, 4, 5)) }.toList()',
    hints: ['yieldAll emits all elements from an iterable', 'Can mix yield and yieldAll'],
    validPatterns: [/sequence\s*\{.*yieldAll\s*\(/],
    tags: ['sequence', 'yieldAll', 'builder'],
  },

  {
    id: 'kotlin-func-011',
    category: 'Functional Patterns',
    difficulty: 'medium',
    title: 'Windowed with Step',
    text: 'Create sliding windows of size 3 with step 2.',
    setup: 'val nums = listOf(1, 2, 3, 4, 5, 6, 7)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5, 6, 7)',
    expected: [
      [1, 2, 3],
      [3, 4, 5],
      [5, 6, 7],
    ],
    sample: 'nums.windowed(size = 3, step = 2)',
    hints: ['windowed supports custom step size', 'Default step is 1'],
    validPatterns: [/\.windowed\s*\(.*3.*step\s*=\s*2.*\)/, /\.windowed\s*\(\s*3\s*,\s*2\s*\)/],
    tags: ['windowed', 'sliding', 'step'],
  },

  {
    id: 'kotlin-func-012',
    category: 'Functional Patterns',
    difficulty: 'medium',
    title: 'Windowed with Partial Windows',
    text: 'Create windows of size 3 including partial windows at the end.',
    setup: 'val nums = listOf(1, 2, 3, 4, 5)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5)',
    expected: [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5], [5]],
    sample: 'nums.windowed(size = 3, partialWindows = true)',
    hints: ['partialWindows = true includes incomplete windows', 'Useful for edge cases'],
    validPatterns: [/\.windowed\s*\(.*partialWindows\s*=\s*true.*\)/],
    tags: ['windowed', 'partial', 'edge-case'],
  },

  {
    id: 'kotlin-func-013',
    category: 'Functional Patterns',
    difficulty: 'medium',
    title: 'ZipWithNext for Consecutive Pairs',
    text: 'Get consecutive pairs from the list.',
    setup: 'val nums = listOf(1, 2, 3, 4, 5)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5)',
    expected: [
      [1, 2],
      [2, 3],
      [3, 4],
      [4, 5],
    ],
    sample: 'nums.zipWithNext()',
    hints: [
      'zipWithNext pairs each element with its successor',
      'Useful for computing differences',
    ],
    validPatterns: [/\.zipWithNext\s*\(\s*\)/],
    tags: ['zipWithNext', 'consecutive', 'pair'],
  },

  {
    id: 'kotlin-func-014',
    category: 'Functional Patterns',
    difficulty: 'medium',
    title: 'ZipWithNext with Transform',
    text: 'Calculate differences between consecutive numbers.',
    setup: 'val nums = listOf(10, 15, 25, 30, 50)',
    setupCode: 'val nums = listOf(10, 15, 25, 30, 50)',
    expected: [5, 10, 5, 20],
    sample: 'nums.zipWithNext { a, b -> b - a }',
    hints: ['zipWithNext accepts a transform lambda', 'Lambda receives consecutive pairs'],
    validPatterns: [/\.zipWithNext\s*\{.*-.*\}/],
    tags: ['zipWithNext', 'transform', 'difference'],
  },

  {
    id: 'kotlin-func-015',
    category: 'Functional Patterns',
    difficulty: 'medium',
    title: 'GroupBy with Value Transform',
    text: 'Group words by length, keeping only uppercase versions.',
    setup: 'val words = listOf("cat", "dog", "elephant", "ant", "bear")',
    setupCode: 'val words = listOf("cat", "dog", "elephant", "ant", "bear")',
    expected: { 3: ['CAT', 'DOG', 'ANT'], 4: ['BEAR'], 8: ['ELEPHANT'] },
    sample: 'words.groupBy({ it.length }) { it.uppercase() }',
    hints: [
      'groupBy can take a second lambda for value transformation',
      'First lambda is key selector, second is value transform',
    ],
    validPatterns: [/\.groupBy\s*\(\s*\{.*\.length.*\}\s*\)\s*\{.*\.uppercase\s*\(\s*\).*\}/],
    tags: ['groupBy', 'transform', 'valueMapper'],
  },

  {
    id: 'kotlin-func-016',
    category: 'Functional Patterns',
    difficulty: 'medium',
    title: 'AssociateBy with Value Transform',
    text: 'Map person names to their age (keep name as key, age as value).',
    setup:
      'data class Person(val name: String, val age: Int)\nval people = listOf(Person("Alice", 30), Person("Bob", 25))',
    setupCode:
      'data class Person(val name: String, val age: Int)\nval people = listOf(Person("Alice", 30), Person("Bob", 25))',
    expected: { Alice: 30, Bob: 25 },
    sample: 'people.associateBy({ it.name }) { it.age }',
    hints: [
      'associateBy can take two lambdas: key selector and value transform',
      'First lambda selects key, second transforms value',
    ],
    validPatterns: [/\.associateBy\s*\(\s*\{.*\.name.*\}\s*\)\s*\{.*\.age.*\}/],
    tags: ['associateBy', 'transform', 'map'],
  },

  {
    id: 'kotlin-func-017',
    category: 'Functional Patterns',
    difficulty: 'medium',
    title: 'Chunked with Transform',
    text: 'Split into chunks of 2 and sum each chunk.',
    setup: 'val nums = listOf(1, 2, 3, 4, 5, 6)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5, 6)',
    expected: [3, 7, 11],
    sample: 'nums.chunked(2) { it.sum() }',
    hints: ['chunked accepts a transform lambda', 'Lambda receives each chunk as a list'],
    validPatterns: [/\.chunked\s*\(\s*2\s*\)\s*\{.*\.sum\s*\(\s*\).*\}/],
    tags: ['chunked', 'transform', 'aggregation'],
  },

  {
    id: 'kotlin-func-018',
    category: 'Functional Patterns',
    difficulty: 'medium',
    title: 'Extension Function on Collection',
    text: 'Create an extension function to get the second element safely.',
    setup: '// Define extension: fun <T> List<T>.secondOrNull(): T?',
    setupCode: '// Define extension: fun <T> List<T>.secondOrNull(): T?',
    expected: 'fun <T> List<T>.secondOrNull(): T? = getOrNull(1)',
    sample: 'fun <T> List<T>.secondOrNull(): T? = getOrNull(1)',
    hints: ['Extension functions can be generic', 'Use getOrNull for safe access'],
    validPatterns: [/fun\s*<T>\s*List<T>\.secondOrNull\s*\(\s*\)/],
    tags: ['extension', 'generic', 'collection'],
  },

  {
    id: 'kotlin-func-019',
    category: 'Functional Patterns',
    difficulty: 'medium',
    title: 'Generate Terminating Sequence',
    text: 'Generate sequence dividing by 2 until reaching 0.',
    setup: 'val start = 100',
    setupCode: 'val start = 100',
    expected: [100, 50, 25, 12, 6, 3, 1],
    sample: 'generateSequence(start) { if (it > 1) it / 2 else null }.toList()',
    hints: [
      'Return null to terminate the sequence',
      'generateSequence stops when lambda returns null',
    ],
    validPatterns: [/generateSequence\s*\(.*\)\s*\{.*null.*\}/],
    tags: ['generateSequence', 'terminating', 'algorithm'],
  },

  {
    id: 'kotlin-func-020',
    category: 'Functional Patterns',
    difficulty: 'medium',
    title: 'Unzip Pairs',
    text: 'Unzip a list of pairs into two separate lists.',
    setup: 'val pairs = listOf("a" to 1, "b" to 2, "c" to 3)',
    setupCode: 'val pairs = listOf("a" to 1, "b" to 2, "c" to 3)',
    expected: [
      ['a', 'b', 'c'],
      [1, 2, 3],
    ],
    sample: 'pairs.unzip()',
    hints: ['unzip is the inverse of zip', 'Returns Pair<List<A>, List<B>>'],
    validPatterns: [/\.unzip\s*\(\s*\)/],
    tags: ['unzip', 'split', 'pair'],
  },

  // --- HARD (5 problems) ---

  {
    id: 'kotlin-func-021',
    category: 'Functional Patterns',
    difficulty: 'hard',
    title: 'Inline Function with Reified Type',
    text: 'Create an inline function that filters elements by type.',
    setup: '// Define: inline fun <reified T> List<*>.filterByType(): List<T>',
    setupCode: '// Define: inline fun <reified T> List<*>.filterByType(): List<T>',
    expected: 'inline fun <reified T> List<*>.filterByType(): List<T> = filterIsInstance<T>()',
    sample: 'inline fun <reified T> List<*>.filterByType(): List<T> = filterIsInstance<T>()',
    hints: ['reified allows runtime type access', 'Only works with inline functions'],
    validPatterns: [/inline\s+fun\s*<reified\s+T>\s*List<\*>\.filterByType\s*\(\s*\)/],
    tags: ['inline', 'reified', 'type-safe'],
  },

  {
    id: 'kotlin-func-022',
    category: 'Functional Patterns',
    difficulty: 'hard',
    title: 'Sequence Builder for Tree Traversal',
    text: 'Create a sequence that yields tree nodes in pre-order traversal.',
    setup:
      'data class Node(val value: Int, val children: List<Node> = emptyList())\nval tree = Node(1, listOf(Node(2, listOf(Node(4))), Node(3)))',
    setupCode:
      'data class Node(val value: Int, val children: List<Node> = emptyList())\nval tree = Node(1, listOf(Node(2, listOf(Node(4))), Node(3)))',
    expected: [1, 2, 4, 3],
    sample:
      'fun traverse(node: Node): Sequence<Int> = sequence { yield(node.value); node.children.forEach { yieldAll(traverse(it)) } }',
    hints: ['Use recursive sequence builder', 'yieldAll for recursive calls'],
    validPatterns: [/sequence\s*\{.*yield\s*\(.*\.value\s*\).*yieldAll/],
    tags: ['sequence', 'recursion', 'tree'],
  },

  {
    id: 'kotlin-func-023',
    category: 'Functional Patterns',
    difficulty: 'hard',
    title: 'Fold with Index',
    text: 'Calculate weighted sum where weight equals index using foldIndexed.',
    setup: 'val nums = listOf(1, 2, 3, 4, 5)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5)',
    expected: 40,
    sample: 'nums.foldIndexed(0) { index, acc, value -> acc + (index * value) }',
    hints: [
      'foldIndexed provides index in the lambda',
      'Lambda receives (index, accumulator, element)',
    ],
    validPatterns: [/\.foldIndexed\s*\(\s*0\s*\)\s*\{.*index.*acc.*\*.*\}/],
    tags: ['foldIndexed', 'accumulator', 'weighted'],
  },

  {
    id: 'kotlin-func-024',
    category: 'Functional Patterns',
    difficulty: 'hard',
    title: 'Running Fold for Cumulative Sum',
    text: 'Calculate cumulative sums using runningFold.',
    setup: 'val nums = listOf(1, 2, 3, 4, 5)',
    setupCode: 'val nums = listOf(1, 2, 3, 4, 5)',
    expected: [0, 1, 3, 6, 10, 15],
    sample: 'nums.runningFold(0) { acc, n -> acc + n }',
    hints: ['runningFold returns all intermediate results', 'First element is the initial value'],
    validPatterns: [/\.runningFold\s*\(\s*0\s*\)\s*\{.*\+.*\}/],
    tags: ['runningFold', 'cumulative', 'scan'],
  },

  {
    id: 'kotlin-func-025',
    category: 'Functional Patterns',
    difficulty: 'hard',
    title: 'Complex Grouping and Aggregation',
    text: 'Group by category, then calculate sum and average for each group.',
    setup:
      'data class Item(val category: String, val value: Int)\nval items = listOf(Item("A", 10), Item("A", 20), Item("B", 30), Item("B", 40), Item("B", 50))',
    setupCode:
      'data class Item(val category: String, val value: Int)\nval items = listOf(Item("A", 10), Item("A", 20), Item("B", 30), Item("B", 40), Item("B", 50))',
    expected: { A: { sum: 30, avg: 15.0 }, B: { sum: 120, avg: 40.0 } },
    sample:
      'items.groupBy { it.category }.mapValues { (_, items) -> mapOf("sum" to items.sumOf { it.value }, "avg" to items.map { it.value }.average()) }',
    hints: ['Chain groupBy with mapValues', 'Use sumOf and average for aggregations'],
    validPatterns: [/\.groupBy\s*\{.*\.category.*\}.*\.mapValues\s*\{.*sumOf.*average/],
    tags: ['groupBy', 'mapValues', 'aggregation', 'complex'],
  },
];

export default kotlinProblems;
