import type { Problem } from '../types';

export const rustProblems: Problem[] = [
  // ========================================
  // ITERATORS - filter
  // ========================================
  {
    id: 'rust-iter-001',
    category: 'Iterators',
    difficulty: 'easy',
    title: 'Filter Even Numbers',
    text: 'Use the filter method to get only even numbers from the vector.',
    setup: 'let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];',
    setupCode: 'let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];',
    expected: [2, 4, 6, 8, 10],
    sample: 'numbers.iter().filter(|&x| x % 2 == 0).cloned().collect::<Vec<_>>()',
    hints: [
      'Use .iter() to get an iterator',
      'filter takes a closure with a reference',
      'Use .collect() to gather results',
    ],
    validPatterns: [/\.filter\s*\(/, /\.collect\s*::\s*<\s*Vec/],
    tags: ['filter', 'iterators', 'basics'],
  },
  {
    id: 'rust-iter-002',
    category: 'Iterators',
    difficulty: 'easy',
    title: 'Filter Positive Numbers',
    text: 'Filter the vector to get only positive numbers.',
    setup: 'let numbers = vec![-3, -1, 0, 2, 5, -4, 8];',
    setupCode: 'let numbers = vec![-3, -1, 0, 2, 5, -4, 8];',
    expected: [2, 5, 8],
    sample: 'numbers.iter().filter(|&&x| x > 0).cloned().collect::<Vec<_>>()',
    hints: ['Positive numbers are greater than 0', 'Remember filter gives you a reference'],
    validPatterns: [/\.filter\s*\(/, />\s*0/],
    tags: ['filter', 'comparison', 'iterators'],
  },

  // ========================================
  // ITERATORS - map
  // ========================================
  {
    id: 'rust-iter-003',
    category: 'Iterators',
    difficulty: 'easy',
    title: 'Double All Numbers',
    text: 'Use map to double every number in the vector.',
    setup: 'let numbers = vec![1, 2, 3, 4, 5];',
    setupCode: 'let numbers = vec![1, 2, 3, 4, 5];',
    expected: [2, 4, 6, 8, 10],
    sample: 'numbers.iter().map(|x| x * 2).collect::<Vec<_>>()',
    hints: ['map transforms each element', 'Multiply each element by 2'],
    validPatterns: [/\.map\s*\(\s*\|/, /\*\s*2/],
    tags: ['map', 'arithmetic', 'iterators'],
  },
  {
    id: 'rust-iter-004',
    category: 'Iterators',
    difficulty: 'easy',
    title: 'Square All Numbers',
    text: 'Use map to square every number in the vector.',
    setup: 'let numbers = vec![1, 2, 3, 4, 5];',
    setupCode: 'let numbers = vec![1, 2, 3, 4, 5];',
    expected: [1, 4, 9, 16, 25],
    sample: 'numbers.iter().map(|x| x * x).collect::<Vec<_>>()',
    hints: ['Square means multiply by itself', 'Use x * x or x.pow(2)'],
    validPatterns: [/\.map\s*\(\s*\|/, /\*\s*\w+\s*\)|\.pow\s*\(/],
    tags: ['map', 'arithmetic', 'iterators'],
  },
  {
    id: 'rust-iter-005',
    category: 'Iterators',
    difficulty: 'medium',
    title: 'Map to String Lengths',
    text: 'Use map to get the length of each string.',
    setup: 'let words = vec!["hello", "world", "rust", "programming"];',
    setupCode: 'let words = vec!["hello", "world", "rust", "programming"];',
    expected: [5, 5, 4, 11],
    sample: 'words.iter().map(|s| s.len()).collect::<Vec<_>>()',
    hints: ['Use .len() to get string length', 'map transforms to usize'],
    validPatterns: [/\.map\s*\(\s*\|/, /\.len\s*\(\s*\)/],
    tags: ['map', 'strings', 'iterators'],
  },

  // ========================================
  // ITERATORS - fold
  // ========================================
  {
    id: 'rust-iter-006',
    category: 'Iterators',
    difficulty: 'easy',
    title: 'Sum with Fold',
    text: 'Use fold to calculate the sum of all numbers.',
    setup: 'let numbers = vec![1, 2, 3, 4, 5];',
    setupCode: 'let numbers = vec![1, 2, 3, 4, 5];',
    expected: 15,
    sample: 'numbers.iter().fold(0, |acc, x| acc + x)',
    hints: ['fold takes initial value and accumulator function', 'Start with 0, add each element'],
    validPatterns: [/\.fold\s*\(\s*0/, /acc\s*\+/],
    tags: ['fold', 'sum', 'iterators'],
  },
  {
    id: 'rust-iter-007',
    category: 'Iterators',
    difficulty: 'medium',
    title: 'Product with Fold',
    text: 'Use fold to calculate the product of all numbers.',
    setup: 'let numbers = vec![1, 2, 3, 4, 5];',
    setupCode: 'let numbers = vec![1, 2, 3, 4, 5];',
    expected: 120,
    sample: 'numbers.iter().fold(1, |acc, x| acc * x)',
    hints: ['Start with 1 for multiplication', 'Multiply accumulator by each element'],
    validPatterns: [/\.fold\s*\(\s*1/, /acc\s*\*/],
    tags: ['fold', 'product', 'iterators'],
  },
  {
    id: 'rust-iter-008',
    category: 'Iterators',
    difficulty: 'hard',
    title: 'Find Maximum with Fold',
    text: 'Use fold to find the maximum value in the vector.',
    setup: 'let numbers = vec![3, 7, 2, 9, 4, 6];',
    setupCode: 'let numbers = vec![3, 7, 2, 9, 4, 6];',
    expected: 9,
    sample: 'numbers.iter().fold(i32::MIN, |max, &x| if x > max { x } else { max })',
    hints: ['Start with minimum possible value', 'Compare each element to current max'],
    validPatterns: [/\.fold\s*\(/, /if\s+\w+\s*>\s*\w+/],
    tags: ['fold', 'max', 'iterators'],
  },

  // ========================================
  // ITERATORS - collect
  // ========================================
  {
    id: 'rust-iter-009',
    category: 'Iterators',
    difficulty: 'easy',
    title: 'Collect to Vector',
    text: 'Convert a range iterator to a vector.',
    setup: 'let range = 1..6;',
    setupCode: 'let range = 1..6;',
    expected: [1, 2, 3, 4, 5],
    sample: 'range.collect::<Vec<_>>()',
    hints: ['Use turbofish syntax ::<Vec<_>>', 'Or let type inference work'],
    validPatterns: [/\.collect\s*::\s*<\s*Vec/, /\.collect\s*\(\s*\)/],
    tags: ['collect', 'range', 'iterators'],
  },
  {
    id: 'rust-iter-010',
    category: 'Iterators',
    difficulty: 'medium',
    title: 'Collect to HashSet',
    text: 'Collect the vector into a HashSet to remove duplicates.',
    setup: 'let numbers = vec![1, 2, 2, 3, 3, 3, 4];',
    setupCode: 'let numbers = vec![1, 2, 2, 3, 3, 3, 4];',
    expected: [1, 2, 3, 4],
    sample: 'numbers.into_iter().collect::<std::collections::HashSet<_>>()',
    hints: ['HashSet automatically removes duplicates', 'Import std::collections::HashSet'],
    validPatterns: [/\.collect\s*::\s*<.*HashSet/, /HashSet/],
    tags: ['collect', 'hashset', 'iterators'],
  },

  // ========================================
  // ITERATORS - enumerate
  // ========================================
  {
    id: 'rust-iter-011',
    category: 'Iterators',
    difficulty: 'easy',
    title: 'Enumerate Elements',
    text: 'Use enumerate to get (index, value) pairs.',
    setup: 'let letters = vec!["a", "b", "c", "d"];',
    setupCode: 'let letters = vec!["a", "b", "c", "d"];',
    expected: [
      [0, 'a'],
      [1, 'b'],
      [2, 'c'],
      [3, 'd'],
    ],
    sample: 'letters.iter().enumerate().collect::<Vec<_>>()',
    hints: ['enumerate adds index to each element', 'Returns (usize, &T) pairs'],
    validPatterns: [/\.enumerate\s*\(\s*\)/],
    tags: ['enumerate', 'index', 'iterators'],
  },
  {
    id: 'rust-iter-012',
    category: 'Iterators',
    difficulty: 'medium',
    title: 'Find Index with Enumerate',
    text: 'Find the index of the first element greater than 5.',
    setup: 'let numbers = vec![1, 3, 7, 2, 9, 4];',
    setupCode: 'let numbers = vec![1, 3, 7, 2, 9, 4];',
    expected: 2,
    sample: 'numbers.iter().enumerate().find(|(_, &x)| x > 5).map(|(i, _)| i).unwrap()',
    hints: [
      'enumerate gives you the index',
      'Use find to locate the element',
      'Extract just the index',
    ],
    validPatterns: [/\.enumerate\s*\(\s*\)/, /\.find\s*\(/],
    tags: ['enumerate', 'find', 'iterators'],
  },

  // ========================================
  // ITERATORS - zip
  // ========================================
  {
    id: 'rust-iter-013',
    category: 'Iterators',
    difficulty: 'easy',
    title: 'Zip Two Vectors',
    text: 'Combine two vectors into pairs using zip.',
    setup: `let names = vec!["Alice", "Bob", "Charlie"];
let ages = vec![25, 30, 35];`,
    setupCode: `let names = vec!["Alice", "Bob", "Charlie"];
let ages = vec![25, 30, 35];`,
    expected: [
      ['Alice', 25],
      ['Bob', 30],
      ['Charlie', 35],
    ],
    sample: 'names.iter().zip(ages.iter()).collect::<Vec<_>>()',
    hints: ['zip pairs elements from two iterators', 'Stops at shortest iterator'],
    validPatterns: [/\.zip\s*\(/],
    tags: ['zip', 'pairs', 'iterators'],
  },
  {
    id: 'rust-iter-014',
    category: 'Iterators',
    difficulty: 'medium',
    title: 'Zip and Sum',
    text: 'Add corresponding elements from two vectors using zip.',
    setup: `let a = vec![1, 2, 3, 4, 5];
let b = vec![10, 20, 30, 40, 50];`,
    setupCode: `let a = vec![1, 2, 3, 4, 5];
let b = vec![10, 20, 30, 40, 50];`,
    expected: [11, 22, 33, 44, 55],
    sample: 'a.iter().zip(b.iter()).map(|(x, y)| x + y).collect::<Vec<_>>()',
    hints: ['zip pairs the elements', 'map to add each pair'],
    validPatterns: [/\.zip\s*\(/, /\.map\s*\(\s*\|\s*\(\s*\w+\s*,\s*\w+\s*\)\s*\|/],
    tags: ['zip', 'map', 'iterators'],
  },

  // ========================================
  // VECTOR OPERATIONS - push, pop
  // ========================================
  {
    id: 'rust-vec-001',
    category: 'Vector Operations',
    difficulty: 'easy',
    title: 'Push to Vector',
    text: 'Add the number 6 to the end of the vector.',
    setup: 'let mut numbers = vec![1, 2, 3, 4, 5];',
    setupCode: 'let mut numbers = vec![1, 2, 3, 4, 5];',
    expected: [1, 2, 3, 4, 5, 6],
    sample: 'numbers.push(6); numbers',
    hints: ['push adds to the end', 'Vector must be mutable'],
    validPatterns: [/\.push\s*\(\s*6\s*\)/],
    tags: ['push', 'vector', 'basics'],
  },
  {
    id: 'rust-vec-002',
    category: 'Vector Operations',
    difficulty: 'easy',
    title: 'Pop from Vector',
    text: 'Remove and return the last element from the vector.',
    setup: 'let mut numbers = vec![1, 2, 3, 4, 5];',
    setupCode: 'let mut numbers = vec![1, 2, 3, 4, 5];',
    expected: 5,
    sample: 'numbers.pop().unwrap()',
    hints: ['pop returns Option<T>', 'Use unwrap for the value'],
    validPatterns: [/\.pop\s*\(\s*\)/],
    tags: ['pop', 'vector', 'option'],
  },

  // ========================================
  // VECTOR OPERATIONS - len, is_empty
  // ========================================
  {
    id: 'rust-vec-003',
    category: 'Vector Operations',
    difficulty: 'easy',
    title: 'Get Vector Length',
    text: 'Get the number of elements in the vector.',
    setup: 'let numbers = vec![1, 2, 3, 4, 5, 6, 7];',
    setupCode: 'let numbers = vec![1, 2, 3, 4, 5, 6, 7];',
    expected: 7,
    sample: 'numbers.len()',
    hints: ['len() returns usize', 'Does not consume the vector'],
    validPatterns: [/\.len\s*\(\s*\)/],
    tags: ['len', 'vector', 'basics'],
  },
  {
    id: 'rust-vec-004',
    category: 'Vector Operations',
    difficulty: 'easy',
    title: 'Check Empty Vector',
    text: 'Check if the vector is empty.',
    setup: 'let numbers: Vec<i32> = vec![];',
    setupCode: 'let numbers: Vec<i32> = vec![];',
    expected: true,
    sample: 'numbers.is_empty()',
    hints: ['is_empty() returns bool', 'Equivalent to len() == 0'],
    validPatterns: [/\.is_empty\s*\(\s*\)/],
    tags: ['is_empty', 'vector', 'basics'],
  },

  // ========================================
  // VECTOR OPERATIONS - sort, reverse
  // ========================================
  {
    id: 'rust-vec-005',
    category: 'Vector Operations',
    difficulty: 'easy',
    title: 'Sort Vector Ascending',
    text: 'Sort the vector in ascending order.',
    setup: 'let mut numbers = vec![5, 2, 8, 1, 9, 3];',
    setupCode: 'let mut numbers = vec![5, 2, 8, 1, 9, 3];',
    expected: [1, 2, 3, 5, 8, 9],
    sample: 'numbers.sort(); numbers',
    hints: ['sort() modifies in place', 'Vector must be mutable'],
    validPatterns: [/\.sort\s*\(\s*\)/],
    tags: ['sort', 'vector', 'ordering'],
  },
  {
    id: 'rust-vec-006',
    category: 'Vector Operations',
    difficulty: 'medium',
    title: 'Sort Vector Descending',
    text: 'Sort the vector in descending order.',
    setup: 'let mut numbers = vec![5, 2, 8, 1, 9, 3];',
    setupCode: 'let mut numbers = vec![5, 2, 8, 1, 9, 3];',
    expected: [9, 8, 5, 3, 2, 1],
    sample: 'numbers.sort_by(|a, b| b.cmp(a)); numbers',
    hints: ['Use sort_by with reversed comparison', 'Or sort then reverse'],
    validPatterns: [/\.sort_by\s*\(|\.sort\s*\(\s*\).*\.reverse\s*\(\s*\)/],
    tags: ['sort', 'vector', 'descending'],
  },
  {
    id: 'rust-vec-007',
    category: 'Vector Operations',
    difficulty: 'easy',
    title: 'Reverse Vector',
    text: 'Reverse the order of elements in the vector.',
    setup: 'let mut numbers = vec![1, 2, 3, 4, 5];',
    setupCode: 'let mut numbers = vec![1, 2, 3, 4, 5];',
    expected: [5, 4, 3, 2, 1],
    sample: 'numbers.reverse(); numbers',
    hints: ['reverse() modifies in place', 'Vector must be mutable'],
    validPatterns: [/\.reverse\s*\(\s*\)/],
    tags: ['reverse', 'vector', 'ordering'],
  },
  {
    id: 'rust-vec-008',
    category: 'Vector Operations',
    difficulty: 'medium',
    title: 'Sort by Key',
    text: 'Sort the strings by their length.',
    setup: 'let mut words = vec!["elephant", "cat", "dog", "hippopotamus"];',
    setupCode: 'let mut words = vec!["elephant", "cat", "dog", "hippopotamus"];',
    expected: ['cat', 'dog', 'elephant', 'hippopotamus'],
    sample: 'words.sort_by_key(|s| s.len()); words',
    hints: ['Use sort_by_key with a key function', 'len() returns the length'],
    validPatterns: [/\.sort_by_key\s*\(\s*\|/, /\.len\s*\(\s*\)/],
    tags: ['sort_by_key', 'vector', 'strings'],
  },

  // ========================================
  // STRING METHODS - len, chars
  // ========================================
  {
    id: 'rust-string-001',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Get String Length',
    text: 'Get the byte length of the string.',
    setup: 'let text = "Hello, Rust!";',
    setupCode: 'let text = "Hello, Rust!";',
    expected: 12,
    sample: 'text.len()',
    hints: ['len() returns byte count', 'Not character count for UTF-8'],
    validPatterns: [/\.len\s*\(\s*\)/],
    tags: ['len', 'strings', 'basics'],
  },
  {
    id: 'rust-string-002',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Get Character Count',
    text: 'Count the number of characters in the string.',
    setup: 'let text = "Hello";',
    setupCode: 'let text = "Hello";',
    expected: 5,
    sample: 'text.chars().count()',
    hints: ['chars() gives character iterator', 'count() counts elements'],
    validPatterns: [/\.chars\s*\(\s*\)/, /\.count\s*\(\s*\)/],
    tags: ['chars', 'count', 'strings'],
  },
  {
    id: 'rust-string-003',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Collect Characters to Vector',
    text: 'Convert the string into a vector of characters.',
    setup: 'let text = "rust";',
    setupCode: 'let text = "rust";',
    expected: ['r', 'u', 's', 't'],
    sample: 'text.chars().collect::<Vec<_>>()',
    hints: ['chars() returns an iterator', 'collect into Vec<char>'],
    validPatterns: [/\.chars\s*\(\s*\)/, /\.collect\s*::\s*<\s*Vec/],
    tags: ['chars', 'collect', 'strings'],
  },

  // ========================================
  // STRING METHODS - split, contains
  // ========================================
  {
    id: 'rust-string-004',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Split String by Space',
    text: 'Split the string into words by spaces.',
    setup: 'let sentence = "Hello World Rust";',
    setupCode: 'let sentence = "Hello World Rust";',
    expected: ['Hello', 'World', 'Rust'],
    sample: "sentence.split(' ').collect::<Vec<_>>()",
    hints: ['split takes a pattern', 'Collect results into a vector'],
    validPatterns: [/\.split\s*\(/, /\.collect\s*::\s*<\s*Vec/],
    tags: ['split', 'strings', 'basics'],
  },
  {
    id: 'rust-string-005',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Check String Contains',
    text: 'Check if the string contains "Rust".',
    setup: 'let text = "I love Rust programming";',
    setupCode: 'let text = "I love Rust programming";',
    expected: true,
    sample: 'text.contains("Rust")',
    hints: ['contains() returns bool', 'Case-sensitive search'],
    validPatterns: [/\.contains\s*\(\s*["']Rust["']\s*\)/],
    tags: ['contains', 'strings', 'search'],
  },
  {
    id: 'rust-string-006',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Split and Filter Empty',
    text: 'Split by comma and filter out empty strings.',
    setup: 'let text = "a,,b,c,,d";',
    setupCode: 'let text = "a,,b,c,,d";',
    expected: ['a', 'b', 'c', 'd'],
    sample: "text.split(',').filter(|s| !s.is_empty()).collect::<Vec<_>>()",
    hints: ['Split creates empty strings between consecutive delimiters', 'Filter them out'],
    validPatterns: [/\.split\s*\(/, /\.filter\s*\(/, /is_empty/],
    tags: ['split', 'filter', 'strings'],
  },

  // ========================================
  // STRING METHODS - replace, trim
  // ========================================
  {
    id: 'rust-string-007',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Replace Substring',
    text: 'Replace "World" with "Rust" in the string.',
    setup: 'let text = "Hello World";',
    setupCode: 'let text = "Hello World";',
    expected: 'Hello Rust',
    sample: 'text.replace("World", "Rust")',
    hints: ['replace returns a new String', 'Original is unchanged'],
    validPatterns: [/\.replace\s*\(\s*["']World["']\s*,\s*["']Rust["']\s*\)/],
    tags: ['replace', 'strings', 'transformation'],
  },
  {
    id: 'rust-string-008',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Trim Whitespace',
    text: 'Remove leading and trailing whitespace from the string.',
    setup: 'let text = "   Hello World   ";',
    setupCode: 'let text = "   Hello World   ";',
    expected: 'Hello World',
    sample: 'text.trim()',
    hints: ['trim() removes whitespace from both ends', 'Returns a &str'],
    validPatterns: [/\.trim\s*\(\s*\)/],
    tags: ['trim', 'whitespace', 'strings'],
  },
  {
    id: 'rust-string-009',
    category: 'String Methods',
    difficulty: 'medium',
    title: 'Replace All Occurrences',
    text: 'Replace all occurrences of "a" with "o".',
    setup: 'let text = "banana";',
    setupCode: 'let text = "banana";',
    expected: 'bonono',
    sample: 'text.replace("a", "o")',
    hints: ['replace replaces all occurrences by default', 'Returns a new String'],
    validPatterns: [/\.replace\s*\(\s*["']a["']\s*,\s*["']o["']\s*\)/],
    tags: ['replace', 'strings', 'all'],
  },

  // ========================================
  // STRING METHODS - to_uppercase, to_lowercase
  // ========================================
  {
    id: 'rust-string-010',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Convert to Uppercase',
    text: 'Convert the string to uppercase.',
    setup: 'let text = "hello rust";',
    setupCode: 'let text = "hello rust";',
    expected: 'HELLO RUST',
    sample: 'text.to_uppercase()',
    hints: ['to_uppercase() returns a new String', 'Original is unchanged'],
    validPatterns: [/\.to_uppercase\s*\(\s*\)/],
    tags: ['to_uppercase', 'strings', 'case'],
  },
  {
    id: 'rust-string-011',
    category: 'String Methods',
    difficulty: 'easy',
    title: 'Convert to Lowercase',
    text: 'Convert the string to lowercase.',
    setup: 'let text = "HELLO RUST";',
    setupCode: 'let text = "HELLO RUST";',
    expected: 'hello rust',
    sample: 'text.to_lowercase()',
    hints: ['to_lowercase() returns a new String', 'Handles Unicode properly'],
    validPatterns: [/\.to_lowercase\s*\(\s*\)/],
    tags: ['to_lowercase', 'strings', 'case'],
  },

  // ========================================
  // OPTION/RESULT HANDLING - unwrap, expect
  // ========================================
  {
    id: 'rust-option-001',
    category: 'Option/Result Handling',
    difficulty: 'easy',
    title: 'Unwrap Some Value',
    text: 'Extract the value from the Some variant.',
    setup: 'let maybe_num: Option<i32> = Some(42);',
    setupCode: 'let maybe_num: Option<i32> = Some(42);',
    expected: 42,
    sample: 'maybe_num.unwrap()',
    hints: ['unwrap extracts the inner value', 'Panics if None'],
    validPatterns: [/\.unwrap\s*\(\s*\)/],
    tags: ['unwrap', 'option', 'basics'],
  },
  {
    id: 'rust-option-002',
    category: 'Option/Result Handling',
    difficulty: 'easy',
    title: 'Use Expect with Message',
    text: 'Extract the value with a custom panic message.',
    setup: 'let maybe_num: Option<i32> = Some(42);',
    setupCode: 'let maybe_num: Option<i32> = Some(42);',
    expected: 42,
    sample: 'maybe_num.expect("Should have a number")',
    hints: ['expect is like unwrap with a message', 'Better for debugging'],
    validPatterns: [/\.expect\s*\(/],
    tags: ['expect', 'option', 'error-handling'],
  },
  {
    id: 'rust-option-003',
    category: 'Option/Result Handling',
    difficulty: 'easy',
    title: 'Unwrap Or Default',
    text: 'Get the value or return 0 if None.',
    setup: 'let maybe_num: Option<i32> = None;',
    setupCode: 'let maybe_num: Option<i32> = None;',
    expected: 0,
    sample: 'maybe_num.unwrap_or(0)',
    hints: ['unwrap_or provides a default value', 'Does not panic on None'],
    validPatterns: [/\.unwrap_or\s*\(\s*0\s*\)/],
    tags: ['unwrap_or', 'option', 'default'],
  },

  // ========================================
  // OPTION/RESULT HANDLING - map, and_then
  // ========================================
  {
    id: 'rust-option-004',
    category: 'Option/Result Handling',
    difficulty: 'medium',
    title: 'Map Option Value',
    text: 'Double the value inside the Option.',
    setup: 'let maybe_num: Option<i32> = Some(21);',
    setupCode: 'let maybe_num: Option<i32> = Some(21);',
    expected: 42,
    sample: 'maybe_num.map(|x| x * 2).unwrap()',
    hints: ['map transforms the inner value', 'Returns Option<T>'],
    validPatterns: [/\.map\s*\(\s*\|/, /\*\s*2/],
    tags: ['map', 'option', 'transformation'],
  },
  {
    id: 'rust-option-005',
    category: 'Option/Result Handling',
    difficulty: 'medium',
    title: 'Chain Options with and_then',
    text: 'Parse string to number, then double it if successful.',
    setup: 'let text = "21";',
    setupCode: 'let text = "21";',
    expected: 42,
    sample: 'text.parse::<i32>().ok().and_then(|x| Some(x * 2)).unwrap()',
    hints: ['and_then flattens nested Options', 'Closure must return Option'],
    validPatterns: [/\.and_then\s*\(\s*\|/, /\.parse/],
    tags: ['and_then', 'option', 'chaining'],
  },
  {
    id: 'rust-option-006',
    category: 'Option/Result Handling',
    difficulty: 'hard',
    title: 'Option Filter',
    text: 'Keep the value only if it is greater than 10.',
    setup: 'let maybe_num: Option<i32> = Some(15);',
    setupCode: 'let maybe_num: Option<i32> = Some(15);',
    expected: 15,
    sample: 'maybe_num.filter(|&x| x > 10).unwrap()',
    hints: ['filter returns None if predicate is false', 'Closure receives reference'],
    validPatterns: [/\.filter\s*\(\s*\|/, />\s*10/],
    tags: ['filter', 'option', 'conditional'],
  },

  // ========================================
  // OPTION/RESULT HANDLING - ok_or
  // ========================================
  {
    id: 'rust-option-007',
    category: 'Option/Result Handling',
    difficulty: 'medium',
    title: 'Convert Option to Result',
    text: 'Convert the Option to a Result with an error message.',
    setup: 'let maybe_num: Option<i32> = Some(42);',
    setupCode: 'let maybe_num: Option<i32> = Some(42);',
    expected: 42,
    sample: 'maybe_num.ok_or("No value found").unwrap()',
    hints: ['ok_or converts Option to Result', 'None becomes Err'],
    validPatterns: [/\.ok_or\s*\(/],
    tags: ['ok_or', 'option', 'result'],
  },
  {
    id: 'rust-option-008',
    category: 'Option/Result Handling',
    difficulty: 'hard',
    title: 'Result Map Error',
    text: 'Parse the string and convert parse error to custom error.',
    setup: 'let text = "42";',
    setupCode: 'let text = "42";',
    expected: 42,
    sample: 'text.parse::<i32>().map_err(|_| "Invalid number").unwrap()',
    hints: ['map_err transforms the error type', 'Useful for error conversion'],
    validPatterns: [/\.map_err\s*\(\s*\|/, /\.parse/],
    tags: ['map_err', 'result', 'error-handling'],
  },

  // ========================================
  // SLICE OPERATIONS - first, last
  // ========================================
  {
    id: 'rust-slice-001',
    category: 'Slice Operations',
    difficulty: 'easy',
    title: 'Get First Element',
    text: 'Get the first element of the slice.',
    setup: 'let numbers = [1, 2, 3, 4, 5];',
    setupCode: 'let numbers = [1, 2, 3, 4, 5];',
    expected: 1,
    sample: 'numbers.first().unwrap()',
    hints: ['first() returns Option<&T>', 'Returns None for empty slice'],
    validPatterns: [/\.first\s*\(\s*\)/],
    tags: ['first', 'slice', 'basics'],
  },
  {
    id: 'rust-slice-002',
    category: 'Slice Operations',
    difficulty: 'easy',
    title: 'Get Last Element',
    text: 'Get the last element of the slice.',
    setup: 'let numbers = [1, 2, 3, 4, 5];',
    setupCode: 'let numbers = [1, 2, 3, 4, 5];',
    expected: 5,
    sample: 'numbers.last().unwrap()',
    hints: ['last() returns Option<&T>', 'Safe way to get last element'],
    validPatterns: [/\.last\s*\(\s*\)/],
    tags: ['last', 'slice', 'basics'],
  },

  // ========================================
  // SLICE OPERATIONS - get
  // ========================================
  {
    id: 'rust-slice-003',
    category: 'Slice Operations',
    difficulty: 'easy',
    title: 'Safe Index Access',
    text: 'Get the element at index 2 safely.',
    setup: 'let numbers = [10, 20, 30, 40, 50];',
    setupCode: 'let numbers = [10, 20, 30, 40, 50];',
    expected: 30,
    sample: 'numbers.get(2).unwrap()',
    hints: ['get() returns Option<&T>', 'Does not panic on out of bounds'],
    validPatterns: [/\.get\s*\(\s*2\s*\)/],
    tags: ['get', 'slice', 'safe-access'],
  },
  {
    id: 'rust-slice-004',
    category: 'Slice Operations',
    difficulty: 'medium',
    title: 'Get Range of Elements',
    text: 'Get elements from index 1 to 3 (inclusive).',
    setup: 'let numbers = [10, 20, 30, 40, 50];',
    setupCode: 'let numbers = [10, 20, 30, 40, 50];',
    expected: [20, 30, 40],
    sample: 'numbers.get(1..4).unwrap().to_vec()',
    hints: ['get accepts Range types', 'Range end is exclusive'],
    validPatterns: [/\.get\s*\(\s*1\s*\.\.\s*4\s*\)/],
    tags: ['get', 'range', 'slice'],
  },

  // ========================================
  // SLICE OPERATIONS - split_at
  // ========================================
  {
    id: 'rust-slice-005',
    category: 'Slice Operations',
    difficulty: 'medium',
    title: 'Split Slice at Index',
    text: 'Split the slice at index 3 and return the first part.',
    setup: 'let numbers = [1, 2, 3, 4, 5, 6];',
    setupCode: 'let numbers = [1, 2, 3, 4, 5, 6];',
    expected: [1, 2, 3],
    sample: 'let (first, _) = numbers.split_at(3); first.to_vec()',
    hints: ['split_at returns a tuple of two slices', 'Index becomes start of second slice'],
    validPatterns: [/\.split_at\s*\(\s*3\s*\)/],
    tags: ['split_at', 'slice', 'partition'],
  },
  {
    id: 'rust-slice-006',
    category: 'Slice Operations',
    difficulty: 'medium',
    title: 'Split and Get Second Half',
    text: 'Split the slice in half and return the second half.',
    setup: 'let numbers = [1, 2, 3, 4, 5, 6];',
    setupCode: 'let numbers = [1, 2, 3, 4, 5, 6];',
    expected: [4, 5, 6],
    sample: 'let (_, second) = numbers.split_at(numbers.len() / 2); second.to_vec()',
    hints: ['Calculate midpoint with len() / 2', 'Second element of tuple is second half'],
    validPatterns: [/\.split_at\s*\(/, /\.len\s*\(\s*\)\s*\/\s*2/],
    tags: ['split_at', 'slice', 'midpoint'],
  },

  // ========================================
  // SLICE OPERATIONS - chunks
  // ========================================
  {
    id: 'rust-slice-007',
    category: 'Slice Operations',
    difficulty: 'medium',
    title: 'Split into Chunks',
    text: 'Split the slice into chunks of 2 elements.',
    setup: 'let numbers = [1, 2, 3, 4, 5, 6];',
    setupCode: 'let numbers = [1, 2, 3, 4, 5, 6];',
    expected: [
      [1, 2],
      [3, 4],
      [5, 6],
    ],
    sample: 'numbers.chunks(2).map(|c| c.to_vec()).collect::<Vec<_>>()',
    hints: ['chunks() creates an iterator of slices', 'Last chunk may be smaller'],
    validPatterns: [/\.chunks\s*\(\s*2\s*\)/],
    tags: ['chunks', 'slice', 'partition'],
  },
  {
    id: 'rust-slice-008',
    category: 'Slice Operations',
    difficulty: 'hard',
    title: 'Windows Iterator',
    text: 'Create overlapping windows of size 3.',
    setup: 'let numbers = [1, 2, 3, 4, 5];',
    setupCode: 'let numbers = [1, 2, 3, 4, 5];',
    expected: [
      [1, 2, 3],
      [2, 3, 4],
      [3, 4, 5],
    ],
    sample: 'numbers.windows(3).map(|w| w.to_vec()).collect::<Vec<_>>()',
    hints: ['windows() creates sliding windows', 'Each window overlaps with previous'],
    validPatterns: [/\.windows\s*\(\s*3\s*\)/],
    tags: ['windows', 'slice', 'sliding'],
  },

  // ========================================
  // HASHMAP METHODS - insert, get
  // ========================================
  {
    id: 'rust-hashmap-001',
    category: 'HashMap Methods',
    difficulty: 'easy',
    title: 'Insert into HashMap',
    text: 'Insert the key "name" with value "Alice" into the HashMap.',
    setup: 'let mut map: std::collections::HashMap<&str, &str> = std::collections::HashMap::new();',
    setupCode:
      'let mut map: std::collections::HashMap<&str, &str> = std::collections::HashMap::new();',
    expected: { name: 'Alice' },
    sample: 'map.insert("name", "Alice"); map',
    hints: ['insert takes key and value', 'Returns Option with old value if key existed'],
    validPatterns: [/\.insert\s*\(\s*["']name["']\s*,\s*["']Alice["']\s*\)/],
    tags: ['insert', 'hashmap', 'basics'],
  },
  {
    id: 'rust-hashmap-002',
    category: 'HashMap Methods',
    difficulty: 'easy',
    title: 'Get from HashMap',
    text: 'Get the value associated with the key "age".',
    setup: `let mut map = std::collections::HashMap::new();
map.insert("name", "Alice");
map.insert("age", "30");`,
    setupCode: `let mut map = std::collections::HashMap::new();
map.insert("name", "Alice");
map.insert("age", "30");`,
    expected: '30',
    sample: 'map.get("age").unwrap()',
    hints: ['get returns Option<&V>', 'Use unwrap or pattern matching'],
    validPatterns: [/\.get\s*\(\s*["']age["']\s*\)/],
    tags: ['get', 'hashmap', 'lookup'],
  },

  // ========================================
  // HASHMAP METHODS - contains_key, remove
  // ========================================
  {
    id: 'rust-hashmap-003',
    category: 'HashMap Methods',
    difficulty: 'easy',
    title: 'Check Key Exists',
    text: 'Check if the HashMap contains the key "name".',
    setup: `let mut map = std::collections::HashMap::new();
map.insert("name", "Alice");`,
    setupCode: `let mut map = std::collections::HashMap::new();
map.insert("name", "Alice");`,
    expected: true,
    sample: 'map.contains_key("name")',
    hints: ['contains_key returns bool', 'Does not require unwrapping'],
    validPatterns: [/\.contains_key\s*\(\s*["']name["']\s*\)/],
    tags: ['contains_key', 'hashmap', 'check'],
  },
  {
    id: 'rust-hashmap-004',
    category: 'HashMap Methods',
    difficulty: 'medium',
    title: 'Remove from HashMap',
    text: 'Remove the key "age" and return its value.',
    setup: `let mut map = std::collections::HashMap::new();
map.insert("name", "Alice");
map.insert("age", "30");`,
    setupCode: `let mut map = std::collections::HashMap::new();
map.insert("name", "Alice");
map.insert("age", "30");`,
    expected: '30',
    sample: 'map.remove("age").unwrap()',
    hints: ['remove returns Option<V>', 'Key is no longer in map after removal'],
    validPatterns: [/\.remove\s*\(\s*["']age["']\s*\)/],
    tags: ['remove', 'hashmap', 'delete'],
  },

  // ========================================
  // HASHMAP METHODS - keys, values
  // ========================================
  {
    id: 'rust-hashmap-005',
    category: 'HashMap Methods',
    difficulty: 'medium',
    title: 'Get All Keys',
    text: 'Get all keys from the HashMap as a vector.',
    setup: `let mut map = std::collections::HashMap::new();
map.insert("a", 1);
map.insert("b", 2);
map.insert("c", 3);`,
    setupCode: `let mut map = std::collections::HashMap::new();
map.insert("a", 1);
map.insert("b", 2);
map.insert("c", 3);`,
    expected: ['a', 'b', 'c'],
    sample: 'let mut keys: Vec<_> = map.keys().collect(); keys.sort(); keys',
    hints: ['keys() returns an iterator', 'HashMap order is not guaranteed'],
    validPatterns: [/\.keys\s*\(\s*\)/],
    tags: ['keys', 'hashmap', 'iteration'],
  },
  {
    id: 'rust-hashmap-006',
    category: 'HashMap Methods',
    difficulty: 'medium',
    title: 'Get All Values',
    text: 'Get all values from the HashMap as a vector.',
    setup: `let mut map = std::collections::HashMap::new();
map.insert("a", 1);
map.insert("b", 2);
map.insert("c", 3);`,
    setupCode: `let mut map = std::collections::HashMap::new();
map.insert("a", 1);
map.insert("b", 2);
map.insert("c", 3);`,
    expected: [1, 2, 3],
    sample: 'let mut values: Vec<_> = map.values().cloned().collect(); values.sort(); values',
    hints: ['values() returns an iterator', 'Use cloned() to get owned values'],
    validPatterns: [/\.values\s*\(\s*\)/],
    tags: ['values', 'hashmap', 'iteration'],
  },

  // ========================================
  // ADVANCED/HARD PROBLEMS
  // ========================================
  {
    id: 'rust-advanced-001',
    category: 'Iterators',
    difficulty: 'hard',
    title: 'Chain Iterators',
    text: 'Combine two vectors using chain and collect.',
    setup: `let a = vec![1, 2, 3];
let b = vec![4, 5, 6];`,
    setupCode: `let a = vec![1, 2, 3];
let b = vec![4, 5, 6];`,
    expected: [1, 2, 3, 4, 5, 6],
    sample: 'a.iter().chain(b.iter()).cloned().collect::<Vec<_>>()',
    hints: ['chain concatenates two iterators', 'Both iterators must have same Item type'],
    validPatterns: [/\.chain\s*\(/],
    tags: ['chain', 'iterators', 'combine'],
  },
  {
    id: 'rust-advanced-002',
    category: 'Iterators',
    difficulty: 'hard',
    title: 'Filter Map Combo',
    text: 'Parse strings to numbers, keeping only successful parses.',
    setup: 'let strings = vec!["1", "two", "3", "four", "5"];',
    setupCode: 'let strings = vec!["1", "two", "3", "four", "5"];',
    expected: [1, 3, 5],
    sample: 'strings.iter().filter_map(|s| s.parse::<i32>().ok()).collect::<Vec<_>>()',
    hints: ['filter_map filters and transforms in one step', 'Returns only Some values'],
    validPatterns: [/\.filter_map\s*\(\s*\|/],
    tags: ['filter_map', 'parse', 'iterators'],
  },
  {
    id: 'rust-advanced-003',
    category: 'Iterators',
    difficulty: 'hard',
    title: 'Take While',
    text: 'Take elements while they are less than 5.',
    setup: 'let numbers = vec![1, 2, 3, 4, 5, 6, 7, 1, 2];',
    setupCode: 'let numbers = vec![1, 2, 3, 4, 5, 6, 7, 1, 2];',
    expected: [1, 2, 3, 4],
    sample: 'numbers.iter().take_while(|&&x| x < 5).cloned().collect::<Vec<_>>()',
    hints: ['take_while stops at first false', 'Does not continue after'],
    validPatterns: [/\.take_while\s*\(\s*\|/],
    tags: ['take_while', 'iterators', 'conditional'],
  },
  {
    id: 'rust-advanced-004',
    category: 'Iterators',
    difficulty: 'hard',
    title: 'Skip While',
    text: 'Skip elements while they are less than 5.',
    setup: 'let numbers = vec![1, 2, 3, 4, 5, 6, 7, 1, 2];',
    setupCode: 'let numbers = vec![1, 2, 3, 4, 5, 6, 7, 1, 2];',
    expected: [5, 6, 7, 1, 2],
    sample: 'numbers.iter().skip_while(|&&x| x < 5).cloned().collect::<Vec<_>>()',
    hints: ['skip_while skips until first false', 'Then takes everything after'],
    validPatterns: [/\.skip_while\s*\(\s*\|/],
    tags: ['skip_while', 'iterators', 'conditional'],
  },
  {
    id: 'rust-advanced-005',
    category: 'HashMap Methods',
    difficulty: 'hard',
    title: 'Entry API Insert or Modify',
    text: 'Increment the count for "apple" or insert 1 if not present.',
    setup: `let mut counts: std::collections::HashMap<&str, i32> = std::collections::HashMap::new();
counts.insert("banana", 2);`,
    setupCode: `let mut counts: std::collections::HashMap<&str, i32> = std::collections::HashMap::new();
counts.insert("banana", 2);`,
    expected: { banana: 2, apple: 1 },
    sample: '*counts.entry("apple").or_insert(0) += 1; counts',
    hints: ['entry() gives mutable access', 'or_insert returns mutable reference'],
    validPatterns: [/\.entry\s*\(/, /\.or_insert\s*\(/],
    tags: ['entry', 'hashmap', 'advanced'],
  },
  {
    id: 'rust-advanced-006',
    category: 'Iterators',
    difficulty: 'hard',
    title: 'Partition Vector',
    text: 'Partition numbers into even and odd vectors.',
    setup: 'let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8];',
    setupCode: 'let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8];',
    expected: [
      [2, 4, 6, 8],
      [1, 3, 5, 7],
    ],
    sample:
      'let (evens, odds): (Vec<_>, Vec<_>) = numbers.iter().partition(|&&x| x % 2 == 0); vec![evens.into_iter().cloned().collect::<Vec<_>>(), odds.into_iter().cloned().collect::<Vec<_>>()]',
    hints: ['partition splits by predicate', 'Returns tuple of two collections'],
    validPatterns: [/\.partition\s*\(\s*\|/],
    tags: ['partition', 'iterators', 'split'],
  },
  {
    id: 'rust-advanced-007',
    category: 'Iterators',
    difficulty: 'hard',
    title: 'Flatten Nested Vectors',
    text: 'Flatten a vector of vectors into a single vector.',
    setup: 'let nested = vec![vec![1, 2], vec![3, 4], vec![5, 6]];',
    setupCode: 'let nested = vec![vec![1, 2], vec![3, 4], vec![5, 6]];',
    expected: [1, 2, 3, 4, 5, 6],
    sample: 'nested.into_iter().flatten().collect::<Vec<_>>()',
    hints: ['flatten removes one level of nesting', 'Works on iterators of iterators'],
    validPatterns: [/\.flatten\s*\(\s*\)/],
    tags: ['flatten', 'iterators', 'nested'],
  },
  {
    id: 'rust-advanced-008',
    category: 'Iterators',
    difficulty: 'hard',
    title: 'Dedup Consecutive',
    text: 'Remove consecutive duplicate elements.',
    setup: 'let mut numbers = vec![1, 1, 2, 2, 2, 3, 3, 1, 1];',
    setupCode: 'let mut numbers = vec![1, 1, 2, 2, 2, 3, 3, 1, 1];',
    expected: [1, 2, 3, 1],
    sample: 'numbers.dedup(); numbers',
    hints: ['dedup removes consecutive duplicates only', 'Vector must be mutable'],
    validPatterns: [/\.dedup\s*\(\s*\)/],
    tags: ['dedup', 'vector', 'unique'],
  },

  // ========================================
  // ADVANCED ITERATOR PATTERNS - Easy (8)
  // ========================================

  {
    id: 'rust-iter-cycle-basic',
    category: 'Advanced Iterator Patterns',
    difficulty: 'easy',
    title: 'Cycle Through Elements',
    text: 'Use `.cycle()` to repeat the pattern [1, 2, 3] and take 8 elements.',
    setup: 'let pattern = vec![1, 2, 3];',
    setupCode: 'let pattern = vec![1, 2, 3];',
    expected: [1, 2, 3, 1, 2, 3, 1, 2],
    sample: 'pattern.iter().cycle().take(8).cloned().collect::<Vec<_>>()',
    hints: [
      'cycle() repeats the iterator infinitely',
      'Always use take() with cycle() to limit results',
      'cycle() requires the iterator to be Clone',
    ],
    validPatterns: [/\.cycle\s*\(\s*\)/, /\.cycle\s*\(\s*\)\.take\s*\(/],
    tags: ['cycle', 'repeat', 'infinite', 'iterator-adapter'],
  },

  {
    id: 'rust-iter-chain-basic',
    category: 'Advanced Iterator Patterns',
    difficulty: 'easy',
    title: 'Chain Three Iterators',
    text: 'Use `.chain()` twice to combine three vectors into a single sequence.',
    setup: 'let a = vec![1, 2];\nlet b = vec![3, 4];\nlet c = vec![5, 6];',
    setupCode: 'let a = vec![1, 2];\nlet b = vec![3, 4];\nlet c = vec![5, 6];',
    expected: [1, 2, 3, 4, 5, 6],
    sample: 'a.iter().chain(b.iter()).chain(c.iter()).cloned().collect::<Vec<_>>()',
    hints: [
      'chain() concatenates two iterators',
      'You can chain multiple times',
      'All iterators must yield the same type',
    ],
    validPatterns: [/\.chain\s*\(.*\.chain\s*\(/, /\.chain\s*\(/],
    tags: ['chain', 'concatenate', 'iterator-adapter', 'combine'],
  },

  {
    id: 'rust-iter-enumerate-transform',
    category: 'Advanced Iterator Patterns',
    difficulty: 'easy',
    title: 'Enumerate and Transform',
    text: 'Use `.enumerate()` and `.map()` to multiply each element by its index.',
    setup: 'let numbers = vec![10, 20, 30, 40];',
    setupCode: 'let numbers = vec![10, 20, 30, 40];',
    expected: [0, 20, 60, 120],
    sample: 'numbers.iter().enumerate().map(|(i, &x)| i as i32 * x).collect::<Vec<_>>()',
    hints: [
      'enumerate() gives (index, &element) tuples',
      'Cast index to appropriate type if needed',
      'Destructure tuple in closure parameters',
    ],
    validPatterns: [/\.enumerate\s*\(\s*\)\.map\s*\(/, /\.enumerate\s*\(\s*\)/],
    tags: ['enumerate', 'map', 'index', 'iterator-adapter'],
  },

  {
    id: 'rust-iter-skip-take-range',
    category: 'Advanced Iterator Patterns',
    difficulty: 'easy',
    title: 'Skip and Take for Pagination',
    text: 'Implement pagination: get page 2 (0-indexed) with page size 3.',
    setup: 'let items = vec!["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];',
    setupCode: 'let items = vec!["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];',
    expected: ['g', 'h', 'i'],
    sample: 'items.iter().skip(2 * 3).take(3).cloned().collect::<Vec<_>>()',
    hints: [
      'skip(page * page_size) to get to the right page',
      'take(page_size) to limit results',
      'This is a common pagination pattern',
    ],
    validPatterns: [/\.skip\s*\(.*\)\.take\s*\(/, /\.skip\s*\(\s*6\s*\)\.take\s*\(\s*3\s*\)/],
    tags: ['skip', 'take', 'pagination', 'iterator-adapter'],
  },

  {
    id: 'rust-iter-peekable-basic',
    category: 'Advanced Iterator Patterns',
    difficulty: 'easy',
    title: 'Peek at Next Without Consuming',
    text: 'Use `.peekable()` to check the next element without consuming it.',
    setup: 'let numbers = vec![1, 2, 3, 4, 5];',
    setupCode: 'let numbers = vec![1, 2, 3, 4, 5];',
    expected: [1, 2],
    sample: `let mut iter = numbers.iter().peekable();
let first = *iter.peek().unwrap();
let first_consumed = *iter.next().unwrap();
vec![first, first_consumed]`,
    hints: [
      'peekable() wraps iterator with peek capability',
      'peek() returns Option<&&T> without consuming',
      'next() still consumes the element',
    ],
    validPatterns: [/\.peekable\s*\(\s*\)/, /\.peek\s*\(\s*\)/],
    tags: ['peekable', 'peek', 'lookahead', 'iterator-adapter'],
  },

  {
    id: 'rust-iter-rev-enumerate',
    category: 'Advanced Iterator Patterns',
    difficulty: 'easy',
    title: 'Reverse with Original Indices',
    text: 'Enumerate first, then reverse to get elements with their original indices in reverse order.',
    setup: 'let letters = vec!["a", "b", "c", "d"];',
    setupCode: 'let letters = vec!["a", "b", "c", "d"];',
    expected: [
      [3, 'd'],
      [2, 'c'],
      [1, 'b'],
      [0, 'a'],
    ],
    sample: 'letters.iter().enumerate().rev().map(|(i, &s)| (i, s)).collect::<Vec<_>>()',
    hints: [
      'Order of enumerate() and rev() matters',
      'Enumerate first preserves original indices',
      'Vec iterators are double-ended so rev() works',
    ],
    validPatterns: [/\.enumerate\s*\(\s*\)\.rev\s*\(\s*\)/, /\.rev\s*\(\s*\)/],
    tags: ['enumerate', 'rev', 'reverse', 'iterator-adapter'],
  },

  {
    id: 'rust-iter-for-each-basic',
    category: 'Advanced Iterator Patterns',
    difficulty: 'easy',
    title: 'For Each Side Effect',
    text: 'Use `.for_each()` to print each element (simulate by collecting into a mutable vector).',
    setup: 'let numbers = vec![1, 2, 3, 4, 5];\nlet mut result = Vec::new();',
    setupCode: 'let numbers = vec![1, 2, 3, 4, 5];\nlet mut result = Vec::new();',
    expected: [2, 4, 6, 8, 10],
    sample: 'numbers.iter().for_each(|&x| result.push(x * 2)); result',
    hints: [
      'for_each() consumes the iterator with side effects',
      'Does not return anything (returns ())',
      'Useful for actions like printing or pushing',
    ],
    validPatterns: [/\.for_each\s*\(\s*\|/, /for_each\s*\(/],
    tags: ['for_each', 'consuming', 'side-effect', 'iterator'],
  },

  {
    id: 'rust-iter-filter-map-option',
    category: 'Advanced Iterator Patterns',
    difficulty: 'easy',
    title: 'Filter Map with Option',
    text: 'Use `.filter_map()` to extract Some values and discard None.',
    setup: 'let options = vec![Some(1), None, Some(2), None, Some(3)];',
    setupCode: 'let options = vec![Some(1), None, Some(2), None, Some(3)];',
    expected: [1, 2, 3],
    sample: 'options.into_iter().filter_map(|x| x).collect::<Vec<_>>()',
    hints: [
      'filter_map with identity function filters None',
      'Option implements IntoIterator',
      'This is equivalent to .flatten() for Options',
    ],
    validPatterns: [/\.filter_map\s*\(\s*\|x\|\s*x\s*\)/, /\.filter_map\s*\(/],
    tags: ['filter_map', 'Option', 'None', 'iterator-adapter'],
  },

  // ========================================
  // ADVANCED ITERATOR PATTERNS - Medium (12)
  // ========================================

  {
    id: 'rust-iter-skip-while-take-while',
    category: 'Advanced Iterator Patterns',
    difficulty: 'medium',
    title: 'Skip While Then Take While',
    text: 'Skip leading negative numbers, then take numbers until you hit a negative again.',
    setup: 'let numbers = vec![-1, -2, 3, 4, 5, -6, 7, 8];',
    setupCode: 'let numbers = vec![-1, -2, 3, 4, 5, -6, 7, 8];',
    expected: [3, 4, 5],
    sample:
      'numbers.iter().skip_while(|&&x| x < 0).take_while(|&&x| x >= 0).cloned().collect::<Vec<_>>()',
    hints: [
      'skip_while skips while condition is true',
      'take_while takes while condition is true',
      'Both stop checking after first condition change',
    ],
    validPatterns: [/\.skip_while\s*\(.*\)\.take_while\s*\(/, /skip_while.*take_while/],
    tags: ['skip_while', 'take_while', 'predicate', 'iterator-adapter'],
  },

  {
    id: 'rust-iter-fold-hashmap',
    category: 'Advanced Iterator Patterns',
    difficulty: 'medium',
    title: 'Fold into HashMap for Counting',
    text: 'Use `.fold()` to count occurrences of each character.',
    setup: "use std::collections::HashMap;\nlet chars = vec!['a', 'b', 'a', 'c', 'b', 'a'];",
    setupCode: "use std::collections::HashMap;\nlet chars = vec!['a', 'b', 'a', 'c', 'b', 'a'];",
    expected: { a: 3, b: 2, c: 1 },
    sample: `chars.iter().fold(HashMap::new(), |mut acc, &c| {
    *acc.entry(c).or_insert(0) += 1;
    acc
})`,
    hints: [
      'fold can build any collection type',
      'Use entry().or_insert() for safe counting',
      'Return the accumulator at the end of closure',
    ],
    validPatterns: [/\.fold\s*\(\s*HashMap::new\s*\(\s*\)/, /fold.*entry.*or_insert/],
    tags: ['fold', 'HashMap', 'counting', 'consuming'],
  },

  {
    id: 'rust-iter-collect-result',
    category: 'Advanced Iterator Patterns',
    difficulty: 'medium',
    title: 'Collect Results Short-Circuit',
    text: 'Parse numbers from strings, returning Err on first parse failure.',
    setup: 'let strings = vec!["1", "2", "three", "4"];',
    setupCode: 'let strings = vec!["1", "2", "three", "4"];',
    expected: { Err: 'ParseIntError' },
    sample:
      'strings.iter().map(|s| s.parse::<i32>()).collect::<Result<Vec<_>, _>>().map_err(|_| "ParseIntError")',
    hints: [
      'collect can transpose Iterator<Result> to Result<Collection>',
      'Short-circuits on first Err',
      'Returns Ok only if all items succeed',
    ],
    validPatterns: [/collect\s*::\s*<\s*Result\s*<\s*Vec/, /\.collect\s*::\s*<\s*Result/],
    tags: ['collect', 'Result', 'short-circuit', 'error-handling'],
  },

  {
    id: 'rust-iter-partition-result',
    category: 'Advanced Iterator Patterns',
    difficulty: 'medium',
    title: 'Partition Results into Ok and Err',
    text: 'Parse strings, collecting successful parses and failed strings separately.',
    setup: 'let strings = vec!["1", "two", "3", "four", "5"];',
    setupCode: 'let strings = vec!["1", "two", "3", "four", "5"];',
    expected: { ok: [1, 3, 5], err: ['two', 'four'] },
    sample: `let (ok, err): (Vec<_>, Vec<_>) = strings.iter()
    .map(|s| s.parse::<i32>().map_err(|_| *s))
    .partition(Result::is_ok);
let ok: Vec<_> = ok.into_iter().map(|r| r.unwrap()).collect();
let err: Vec<_> = err.into_iter().map(|r| r.unwrap_err()).collect();
(ok, err)`,
    hints: [
      'partition splits by predicate Result::is_ok',
      'Need to unwrap after partitioning',
      'map_err preserves the original string on failure',
    ],
    validPatterns: [/\.partition\s*\(\s*Result::is_ok\s*\)/, /partition.*Result/],
    tags: ['partition', 'Result', 'error-handling', 'iterator-adapter'],
  },

  {
    id: 'rust-iter-scan-running',
    category: 'Advanced Iterator Patterns',
    difficulty: 'medium',
    title: 'Running Maximum with Scan',
    text: 'Use `.scan()` to compute running maximum at each position.',
    setup: 'let numbers = vec![3, 1, 4, 1, 5, 9, 2, 6];',
    setupCode: 'let numbers = vec![3, 1, 4, 1, 5, 9, 2, 6];',
    expected: [3, 3, 4, 4, 5, 9, 9, 9],
    sample:
      'numbers.iter().scan(i32::MIN, |max, &x| { *max = (*max).max(x); Some(*max) }).collect::<Vec<_>>()',
    hints: [
      'scan() maintains state across iterations',
      'First argument is initial state',
      'Use .max() for comparison or if-else',
    ],
    validPatterns: [/\.scan\s*\(\s*i32::MIN/, /\.scan\s*\(.*\.max\s*\(/],
    tags: ['scan', 'running', 'stateful', 'iterator-adapter'],
  },

  {
    id: 'rust-iter-flat-map-expand',
    category: 'Advanced Iterator Patterns',
    difficulty: 'medium',
    title: 'Flat Map to Expand Elements',
    text: 'Use `.flat_map()` to repeat each number n times (where n is the number itself).',
    setup: 'let numbers = vec![1, 2, 3];',
    setupCode: 'let numbers = vec![1, 2, 3];',
    expected: [1, 2, 2, 3, 3, 3],
    sample:
      'numbers.iter().flat_map(|&n| std::iter::repeat(n).take(n as usize)).collect::<Vec<_>>()',
    hints: [
      'flat_map maps then flattens',
      'std::iter::repeat creates infinite iterator',
      'Combine with take() to limit',
    ],
    validPatterns: [/\.flat_map\s*\(/, /flat_map.*repeat.*take/],
    tags: ['flat_map', 'repeat', 'expand', 'iterator-adapter'],
  },

  {
    id: 'rust-iter-inspect-debug',
    category: 'Advanced Iterator Patterns',
    difficulty: 'medium',
    title: 'Debug Pipeline with Inspect',
    text: 'Use `.inspect()` to log values at each stage (collect log messages instead of printing).',
    setup: 'let numbers = vec![1, 2, 3, 4, 5];\nlet mut log = Vec::new();',
    setupCode: 'let numbers = vec![1, 2, 3, 4, 5];\nlet mut log = Vec::new();',
    expected: {
      result: [4, 16],
      log_count: 4,
    },
    sample: `let result: Vec<_> = numbers.iter()
    .inspect(|x| log.push(format!("input: {}", x)))
    .filter(|&&x| x % 2 == 0)
    .inspect(|x| log.push(format!("after filter: {}", x)))
    .map(|&x| x * x)
    .collect();
(result, log.len())`,
    hints: [
      'inspect() is for side effects without modifying',
      'Receives &Item reference',
      'Useful for debugging iterator chains',
    ],
    validPatterns: [/\.inspect\s*\(\s*\|/, /inspect.*filter.*inspect/],
    tags: ['inspect', 'debug', 'side-effect', 'iterator-adapter'],
  },

  {
    id: 'rust-iter-step-by-interleave',
    category: 'Advanced Iterator Patterns',
    difficulty: 'medium',
    title: 'Interleave with Step By',
    text: 'Get elements at odd indices using skip and step_by.',
    setup: 'let numbers = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];',
    setupCode: 'let numbers = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];',
    expected: [1, 3, 5, 7, 9],
    sample: 'numbers.iter().skip(1).step_by(2).cloned().collect::<Vec<_>>()',
    hints: [
      'skip(1) starts at index 1',
      'step_by(2) takes every 2nd element',
      'Combine to get odd indices',
    ],
    validPatterns: [/\.skip\s*\(\s*1\s*\)\.step_by\s*\(\s*2\s*\)/, /step_by\s*\(\s*2\s*\)/],
    tags: ['step_by', 'skip', 'indices', 'iterator-adapter'],
  },

  {
    id: 'rust-iter-zip-unzip',
    category: 'Advanced Iterator Patterns',
    difficulty: 'medium',
    title: 'Unzip Paired Data',
    text: 'Use `.unzip()` to separate a list of tuples into two vectors.',
    setup: 'let pairs = vec![(1, "a"), (2, "b"), (3, "c"), (4, "d")];',
    setupCode: 'let pairs = vec![(1, "a"), (2, "b"), (3, "c"), (4, "d")];',
    expected: { nums: [1, 2, 3, 4], letters: ['a', 'b', 'c', 'd'] },
    sample: 'let (nums, letters): (Vec<_>, Vec<_>) = pairs.into_iter().unzip(); (nums, letters)',
    hints: [
      'unzip is the inverse of zip',
      'Requires type annotation for both collections',
      'Works on iterator of tuples',
    ],
    validPatterns: [/\.unzip\s*\(\s*\)/, /:\s*\(Vec<_>,\s*Vec<_>\)\s*=.*\.unzip/],
    tags: ['unzip', 'zip', 'tuples', 'consuming'],
  },

  {
    id: 'rust-iter-try-fold-early-exit',
    category: 'Advanced Iterator Patterns',
    difficulty: 'medium',
    title: 'Try Fold with Early Exit',
    text: 'Use `.try_fold()` to sum numbers but stop if running sum exceeds 15.',
    setup: 'let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8];',
    setupCode: 'let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8];',
    expected: { Err: 'Sum exceeded 15 at 21' },
    sample: `numbers.iter().try_fold(0, |acc, &x| {
    let sum = acc + x;
    if sum > 15 {
        Err(format!("Sum exceeded 15 at {}", sum))
    } else {
        Ok(sum)
    }
})`,
    hints: [
      'try_fold allows early termination',
      'Return Err to stop iteration',
      'Return Ok(acc) to continue',
    ],
    validPatterns: [/\.try_fold\s*\(/, /try_fold.*Err\s*\(/],
    tags: ['try_fold', 'Result', 'early-exit', 'consuming'],
  },

  {
    id: 'rust-iter-collect-string',
    category: 'Advanced Iterator Patterns',
    difficulty: 'medium',
    title: 'Collect Chars into String',
    text: 'Filter vowels and collect back into a String.',
    setup: 'let text = "Hello World";',
    setupCode: 'let text = "Hello World";',
    expected: 'Hll Wrld',
    sample: 'text.chars().filter(|c| !"aeiouAEIOU".contains(*c)).collect::<String>()',
    hints: [
      'String implements FromIterator<char>',
      'chars() gives char iterator',
      'collect::<String>() joins without separator',
    ],
    validPatterns: [/\.collect\s*::\s*<\s*String\s*>/, /chars\(\).*filter.*collect/],
    tags: ['collect', 'String', 'chars', 'filter'],
  },

  {
    id: 'rust-iter-peekable-group',
    category: 'Advanced Iterator Patterns',
    difficulty: 'medium',
    title: 'Group Consecutive with Peekable',
    text: 'Use `.peekable()` to count consecutive equal elements.',
    setup: "let chars = vec!['a', 'a', 'b', 'b', 'b', 'c'];",
    setupCode: "let chars = vec!['a', 'a', 'b', 'b', 'b', 'c'];",
    expected: [
      ['a', 2],
      ['b', 3],
      ['c', 1],
    ],
    sample: `let mut iter = chars.iter().peekable();
let mut result = Vec::new();
while let Some(&ch) = iter.next() {
    let mut count = 1;
    while iter.peek() == Some(&&ch) {
        iter.next();
        count += 1;
    }
    result.push((ch, count));
}
result`,
    hints: [
      'peekable() lets you look ahead',
      'Use while loop with peek() to count runs',
      'peek() returns Option<&&T>',
    ],
    validPatterns: [/\.peekable\s*\(\s*\)/, /while.*peek\s*\(\s*\)\s*==/],
    tags: ['peekable', 'grouping', 'consecutive', 'iterator-adapter'],
  },

  // ========================================
  // ADVANCED ITERATOR PATTERNS - Hard (5)
  // ========================================

  {
    id: 'rust-iter-custom-fibonacci',
    category: 'Advanced Iterator Patterns',
    difficulty: 'hard',
    title: 'Custom Fibonacci Iterator',
    text: 'Implement a Fibonacci iterator struct that yields the sequence.',
    setup: '// Define Fibonacci struct implementing Iterator',
    setupCode: '// Define Fibonacci struct implementing Iterator',
    expected: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34],
    sample: `struct Fibonacci {
    curr: u64,
    next: u64,
}

impl Fibonacci {
    fn new() -> Self {
        Fibonacci { curr: 0, next: 1 }
    }
}

impl Iterator for Fibonacci {
    type Item = u64;

    fn next(&mut self) -> Option<Self::Item> {
        let current = self.curr;
        self.curr = self.next;
        self.next = current + self.next;
        Some(current)
    }
}

Fibonacci::new().take(10).collect::<Vec<_>>()`,
    hints: [
      'Implement Iterator trait with type Item',
      'Store state for curr and next values',
      'next() updates state and returns current',
    ],
    validPatterns: [/impl\s+Iterator\s+for/, /type\s+Item\s*=/, /fn\s+next\s*\(/],
    tags: ['custom-iterator', 'Iterator', 'fibonacci', 'trait'],
  },

  {
    id: 'rust-iter-rayon-parallel-sum',
    category: 'Advanced Iterator Patterns',
    difficulty: 'hard',
    title: 'Parallel Sum with Rayon',
    text: 'Use rayon parallel iterators to sum a large vector in parallel.',
    setup: 'use rayon::prelude::*;\nlet numbers: Vec<i64> = (1..=1_000_000).collect();',
    setupCode: 'use rayon::prelude::*;\nlet numbers: Vec<i64> = (1..=1_000_000).collect();',
    expected: 500000500000,
    sample: 'numbers.par_iter().sum::<i64>()',
    hints: [
      'rayon::prelude::* brings par_iter into scope',
      'par_iter() creates parallel iterator',
      'sum() works on parallel iterators',
    ],
    validPatterns: [/\.par_iter\s*\(\s*\)\.sum/, /par_iter\(\)/],
    tags: ['rayon', 'parallel', 'sum', 'performance'],
  },

  {
    id: 'rust-iter-rayon-parallel-filter-map',
    category: 'Advanced Iterator Patterns',
    difficulty: 'hard',
    title: 'Parallel Filter Map with Rayon',
    text: 'Use rayon to filter even numbers and square them in parallel.',
    setup: 'use rayon::prelude::*;\nlet numbers: Vec<i64> = (1..=100).collect();',
    setupCode: 'use rayon::prelude::*;\nlet numbers: Vec<i64> = (1..=100).collect();',
    expected: 'Sum of squares of even numbers 1-100',
    sample: 'numbers.par_iter().filter(|&&x| x % 2 == 0).map(|&x| x * x).sum::<i64>()',
    hints: [
      'Parallel iterators support filter and map',
      'Order may differ but result is same',
      'Chain operations as with regular iterators',
    ],
    validPatterns: [/\.par_iter\s*\(\s*\)\.filter/, /par_iter.*filter.*map/],
    tags: ['rayon', 'parallel', 'filter', 'map', 'performance'],
  },

  {
    id: 'rust-iter-complex-pipeline',
    category: 'Advanced Iterator Patterns',
    difficulty: 'hard',
    title: 'Complex Data Processing Pipeline',
    text: 'Parse CSV-like data, filter valid rows, transform, and aggregate.',
    setup: `let data = vec![
    "Alice,30,Engineering",
    "Bob,invalid,Sales",
    "Carol,25,Engineering",
    "Dave,35,Marketing",
    "Eve,28,Engineering",
];`,
    setupCode: `let data = vec![
    "Alice,30,Engineering",
    "Bob,invalid,Sales",
    "Carol,25,Engineering",
    "Dave,35,Marketing",
    "Eve,28,Engineering",
];`,
    expected: { engineering_avg_age: 27, count: 3 },
    sample: `use std::collections::HashMap;

let result: Vec<_> = data.iter()
    .filter_map(|line| {
        let parts: Vec<&str> = line.split(',').collect();
        if parts.len() == 3 {
            parts[1].parse::<i32>().ok().map(|age| (parts[0], age, parts[2]))
        } else {
            None
        }
    })
    .filter(|(_, _, dept)| *dept == "Engineering")
    .collect();

let count = result.len();
let sum: i32 = result.iter().map(|(_, age, _)| age).sum();
let avg = if count > 0 { sum / count as i32 } else { 0 };
(avg, count)`,
    hints: [
      'Use filter_map to parse and filter invalid rows',
      'Split string and destructure result',
      'Chain filter for department',
      'Aggregate with map and sum',
    ],
    validPatterns: [/filter_map.*split.*parse/, /\.filter_map\s*\(.*\.filter\s*\(/],
    tags: ['filter_map', 'complex', 'pipeline', 'parsing', 'aggregation'],
  },

  {
    id: 'rust-iter-windows-patterns',
    category: 'Advanced Iterator Patterns',
    difficulty: 'hard',
    title: 'Find Patterns with Windows',
    text: 'Use `.windows()` to find all indices where three consecutive numbers are increasing.',
    setup: 'let numbers = vec![1, 3, 2, 4, 6, 5, 7, 8, 9, 3];',
    setupCode: 'let numbers = vec![1, 3, 2, 4, 6, 5, 7, 8, 9, 3];',
    expected: [2, 6, 7],
    sample: `numbers.windows(3)
    .enumerate()
    .filter(|(_, w)| w[0] < w[1] && w[1] < w[2])
    .map(|(i, _)| i)
    .collect::<Vec<_>>()`,
    hints: [
      'windows(3) gives overlapping 3-element slices',
      'enumerate() to track starting index',
      'Filter for strictly increasing pattern',
    ],
    validPatterns: [/\.windows\s*\(\s*3\s*\)\.enumerate\s*\(\s*\)/, /windows.*filter.*map/],
    tags: ['windows', 'enumerate', 'pattern', 'sliding-window'],
  },

  // ========================================
  // STRING OPERATIONS - String vs &str (Easy)
  // ========================================
  {
    id: 'rust-str-001',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Convert &str to String',
    text: 'Convert the string slice to an owned String.',
    setup: 'let slice: &str = "hello";',
    setupCode: 'let slice: &str = "hello";',
    expected: 'hello',
    sample: 'slice.to_string()',
    hints: [
      'Use .to_string() or String::from()',
      '&str is borrowed, String is owned',
      '.to_owned() also works',
    ],
    validPatterns: [/\.to_string\s*\(\s*\)/, /String::from\s*\(/, /\.to_owned\s*\(\s*\)/],
    tags: ['string', 'str', 'conversion', 'basics'],
  },
  {
    id: 'rust-str-002',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Convert String to &str',
    text: 'Borrow the String as a string slice.',
    setup: 'let owned = String::from("hello");',
    setupCode: 'let owned = String::from("hello");',
    expected: 'hello',
    sample: 'owned.as_str()',
    hints: [
      'Use .as_str() for explicit conversion',
      'Deref coercion also works: &owned',
      'String automatically derefs to &str',
    ],
    validPatterns: [/\.as_str\s*\(\s*\)/, /&\s*owned/],
    tags: ['string', 'str', 'borrowing', 'basics'],
  },
  {
    id: 'rust-str-003',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Create String with Capacity',
    text: 'Create a new String with pre-allocated capacity for 100 bytes.',
    setup: '// Create a String that can hold at least 100 bytes without reallocating',
    setupCode: '// Create a String that can hold at least 100 bytes without reallocating',
    expected: 0,
    sample: 'let s = String::with_capacity(100); s.len()',
    hints: [
      'String::with_capacity(n) pre-allocates memory',
      'Capacity is not the same as length',
      'Use .capacity() to check allocated size',
    ],
    validPatterns: [/String::with_capacity\s*\(\s*100\s*\)/],
    tags: ['string', 'capacity', 'allocation', 'basics'],
  },

  // ========================================
  // STRING OPERATIONS - push_str, insert, remove (Easy/Medium)
  // ========================================
  {
    id: 'rust-str-004',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Append String with push_str',
    text: 'Append " World" to the existing String.',
    setup: 'let mut s = String::from("Hello");',
    setupCode: 'let mut s = String::from("Hello");',
    expected: 'Hello World',
    sample: 's.push_str(" World"); s',
    hints: [
      'push_str appends a &str to the String',
      'The String must be mutable',
      'This modifies the String in place',
    ],
    validPatterns: [/\.push_str\s*\(\s*["'] World["']\s*\)/],
    tags: ['string', 'push_str', 'append', 'basics'],
  },
  {
    id: 'rust-str-005',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Push Single Character',
    text: 'Add an exclamation mark to the end of the String.',
    setup: 'let mut s = String::from("Hello");',
    setupCode: 'let mut s = String::from("Hello");',
    expected: 'Hello!',
    sample: "s.push('!'); s",
    hints: [
      'push adds a single char to the String',
      'Use single quotes for char literals',
      'Different from push_str which takes &str',
    ],
    validPatterns: [/\.push\s*\(\s*'!'\s*\)/],
    tags: ['string', 'push', 'char', 'basics'],
  },
  {
    id: 'rust-str-006',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Insert String at Position',
    text: 'Insert "beautiful " at byte index 7 (after "Hello, ").',
    setup: 'let mut s = String::from("Hello, world!");',
    setupCode: 'let mut s = String::from("Hello, world!");',
    expected: 'Hello, beautiful world!',
    sample: 's.insert_str(7, "beautiful "); s',
    hints: [
      'insert_str inserts a &str at byte index',
      'Index must be at a valid UTF-8 boundary',
      'Panics if index is out of bounds or not a char boundary',
    ],
    validPatterns: [/\.insert_str\s*\(\s*7\s*,\s*["']beautiful ["']\s*\)/],
    tags: ['string', 'insert_str', 'position', 'medium'],
  },
  {
    id: 'rust-str-007',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Remove Character at Index',
    text: 'Remove the character at byte index 5 (the comma).',
    setup: 'let mut s = String::from("Hello, World");',
    setupCode: 'let mut s = String::from("Hello, World");',
    expected: 'Hello World',
    sample: 's.remove(5); s',
    hints: [
      'remove() removes and returns the char at byte index',
      'Index must be at a valid char boundary',
      'This shifts all bytes after the removed char',
    ],
    validPatterns: [/\.remove\s*\(\s*5\s*\)/],
    tags: ['string', 'remove', 'char', 'medium'],
  },
  {
    id: 'rust-str-008',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Replace First Occurrence',
    text: 'Replace only the first occurrence of "a" with "o".',
    setup: 'let text = "banana";',
    setupCode: 'let text = "banana";',
    expected: 'bonana',
    sample: 'text.replacen("a", "o", 1)',
    hints: [
      'replacen limits the number of replacements',
      'Third argument is the maximum replacements',
      'Returns a new String',
    ],
    validPatterns: [/\.replacen\s*\(\s*["']a["']\s*,\s*["']o["']\s*,\s*1\s*\)/],
    tags: ['string', 'replacen', 'replace', 'medium'],
  },

  // ========================================
  // STRING OPERATIONS - Slicing and Borrowing (Easy/Medium)
  // ========================================
  {
    id: 'rust-str-009',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Slice First Five Bytes',
    text: 'Get the first 5 bytes of the string as a slice.',
    setup: 'let text = "Hello, World!";',
    setupCode: 'let text = "Hello, World!";',
    expected: 'Hello',
    sample: '&text[0..5]',
    hints: [
      'Use range syntax for slicing: [start..end]',
      'Slicing works on byte indices',
      'Be careful with UTF-8 multi-byte characters',
    ],
    validPatterns: [/&\s*text\s*\[\s*0\s*\.\.\s*5\s*\]/, /&\s*text\s*\[\s*\.\.\s*5\s*\]/],
    tags: ['string', 'slice', 'range', 'basics'],
  },
  {
    id: 'rust-str-010',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Slice from Middle to End',
    text: 'Get the substring starting from byte index 7 to the end.',
    setup: 'let text = "Hello, World!";',
    setupCode: 'let text = "Hello, World!";',
    expected: 'World!',
    sample: '&text[7..]',
    hints: [
      'Omit the end index to slice to the end',
      '[7..] means from index 7 to the end',
      'Remember indices are byte-based',
    ],
    validPatterns: [/&\s*text\s*\[\s*7\s*\.\.\s*\]/],
    tags: ['string', 'slice', 'range', 'medium'],
  },
  {
    id: 'rust-str-011',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Safe String Slicing with get',
    text: 'Safely get bytes 0..5 from the string, returning None if invalid.',
    setup: 'let text = "Hello, World!";',
    setupCode: 'let text = "Hello, World!";',
    expected: 'Hello',
    sample: 'text.get(0..5).unwrap()',
    hints: [
      '.get() returns Option<&str> for safe slicing',
      'Returns None if indices are invalid or not char boundaries',
      'Safer than direct indexing which can panic',
    ],
    validPatterns: [/\.get\s*\(\s*0\s*\.\.\s*5\s*\)/],
    tags: ['string', 'get', 'safe', 'option', 'medium'],
  },

  // ========================================
  // STRING OPERATIONS - Char Iteration (Easy/Medium/Hard)
  // ========================================
  {
    id: 'rust-str-012',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Count Vowels with chars',
    text: 'Count the number of vowels (a, e, i, o, u) in the string using iterator chain.',
    setup: 'let text = "Hello World";',
    setupCode: 'let text = "Hello World";',
    expected: 3,
    sample: 'text.chars().filter(|c| "aeiouAEIOU".contains(*c)).count()',
    hints: [
      'Use .chars() to iterate over Unicode characters',
      'Filter chars that match vowels',
      'Use .count() to get the total',
    ],
    validPatterns: [/\.chars\s*\(\s*\)/, /\.filter\s*\(/, /\.count\s*\(\s*\)/],
    tags: ['string', 'chars', 'filter', 'count', 'hard'],
  },
  {
    id: 'rust-str-013',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Reverse String via chars',
    text: 'Reverse the characters in the string.',
    setup: 'let text = "Hello";',
    setupCode: 'let text = "Hello";',
    expected: 'olleH',
    sample: 'text.chars().rev().collect::<String>()',
    hints: [
      '.chars() gives character iterator',
      '.rev() reverses the iterator',
      'Collect into String',
    ],
    validPatterns: [/\.chars\s*\(\s*\)/, /\.rev\s*\(\s*\)/, /\.collect\s*::\s*<\s*String\s*>/],
    tags: ['string', 'chars', 'reverse', 'medium'],
  },
  {
    id: 'rust-str-014',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Enumerate Characters with Indices',
    text: 'Get tuples of (byte_index, char) for each character.',
    setup: 'let text = "Hi!";',
    setupCode: 'let text = "Hi!";',
    expected: [
      [0, 'H'],
      [1, 'i'],
      [2, '!'],
    ],
    sample: 'text.char_indices().collect::<Vec<_>>()',
    hints: [
      '.char_indices() gives (byte_index, char) pairs',
      'Useful when you need both position and character',
      'Byte index may not equal char index for multi-byte chars',
    ],
    validPatterns: [/\.char_indices\s*\(\s*\)/],
    tags: ['string', 'char_indices', 'enumerate', 'medium'],
  },
  {
    id: 'rust-str-015',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Get Nth Character',
    text: 'Get the 3rd character (index 2) from the string.',
    setup: 'let text = "Hello";',
    setupCode: 'let text = "Hello";',
    expected: 'l',
    sample: 'text.chars().nth(2).unwrap()',
    hints: [
      '.nth(n) returns the nth element from iterator',
      'Returns Option<char>',
      'O(n) complexity for strings (no random access)',
    ],
    validPatterns: [/\.chars\s*\(\s*\)/, /\.nth\s*\(\s*2\s*\)/],
    tags: ['string', 'chars', 'nth', 'hard'],
  },

  // ========================================
  // STRING OPERATIONS - Unicode Handling (Medium/Hard)
  // ========================================
  {
    id: 'rust-str-016',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Count Unicode Characters',
    text: 'Count the actual characters in a string with emoji.',
    setup: 'let text = "Hi! \\u{1F44B}\\u{1F3FD}";',
    setupCode: 'let text = "Hi! \\u{1F44B}\\u{1F3FD}";',
    expected: 5,
    sample: 'text.chars().count()',
    hints: [
      '.len() returns bytes, not characters',
      '.chars().count() returns Unicode scalar values',
      'Emoji may be multiple Unicode scalars',
    ],
    validPatterns: [/\.chars\s*\(\s*\)/, /\.count\s*\(\s*\)/],
    tags: ['string', 'unicode', 'chars', 'count', 'medium'],
  },
  {
    id: 'rust-str-017',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Check if String is ASCII',
    text: 'Check if the string contains only ASCII characters.',
    setup: 'let text = "Hello World";',
    setupCode: 'let text = "Hello World";',
    expected: true,
    sample: 'text.is_ascii()',
    hints: [
      '.is_ascii() checks all bytes are ASCII',
      'ASCII is single-byte subset of UTF-8',
      'Returns false if any non-ASCII character exists',
    ],
    validPatterns: [/\.is_ascii\s*\(\s*\)/],
    tags: ['string', 'ascii', 'unicode', 'hard'],
  },
  {
    id: 'rust-str-018',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Iterate Bytes vs Chars',
    text: 'Get the byte length difference between bytes and chars for a Unicode string.',
    setup: 'let text = "cafe\\u{0301}";  // "cafe" with combining accent',
    setupCode: 'let text = "cafe\\u{0301}";  // "cafe" with combining accent',
    expected: 1,
    sample: 'text.len() - text.chars().count()',
    hints: [
      '.len() counts bytes',
      '.chars().count() counts Unicode scalar values',
      'Multi-byte characters create the difference',
    ],
    validPatterns: [/\.len\s*\(\s*\)/, /\.chars\s*\(\s*\)/, /\.count\s*\(\s*\)/],
    tags: ['string', 'unicode', 'bytes', 'hard'],
  },

  // ========================================
  // STRING OPERATIONS - Parsing (Easy/Medium)
  // ========================================
  {
    id: 'rust-str-019',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Parse String to Integer',
    text: 'Parse the string as an i32 integer.',
    setup: 'let text = "42";',
    setupCode: 'let text = "42";',
    expected: 42,
    sample: 'text.parse::<i32>().unwrap()',
    hints: [
      'Use .parse::<T>() with turbofish syntax',
      'Returns Result<T, ParseError>',
      'Type annotation required',
    ],
    validPatterns: [/\.parse\s*::\s*<\s*i32\s*>\s*\(\s*\)/],
    tags: ['string', 'parse', 'integer', 'basics'],
  },
  {
    id: 'rust-str-020',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Parse with Default on Error',
    text: 'Parse the string as i32, returning 0 if parsing fails.',
    setup: 'let text = "not_a_number";',
    setupCode: 'let text = "not_a_number";',
    expected: 0,
    sample: 'text.parse::<i32>().unwrap_or(0)',
    hints: [
      '.unwrap_or(default) provides fallback value',
      'Parsing invalid strings returns Err',
      'No panic on parse failure',
    ],
    validPatterns: [/\.parse\s*::\s*<\s*i32\s*>\s*\(\s*\)/, /\.unwrap_or\s*\(\s*0\s*\)/],
    tags: ['string', 'parse', 'unwrap_or', 'medium'],
  },
  {
    id: 'rust-str-021',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Parse Float from String',
    text: 'Parse the string as a f64 floating point number.',
    setup: 'let text = "3.14159";',
    setupCode: 'let text = "3.14159";',
    // biome-ignore lint/suspicious/noApproximativeNumericConstant: literal parsed value, not Math.PI
    expected: 3.14159,
    sample: 'text.parse::<f64>().unwrap()',
    hints: [
      'Same parse method works for f32 and f64',
      'Handles decimal points and scientific notation',
      'Returns Result like integer parsing',
    ],
    validPatterns: [/\.parse\s*::\s*<\s*f64\s*>\s*\(\s*\)/],
    tags: ['string', 'parse', 'float', 'medium'],
  },

  // ========================================
  // STRING OPERATIONS - Format Macros (Easy/Medium/Hard)
  // ========================================
  {
    id: 'rust-str-022',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Format String with Variables',
    text: 'Create a formatted string with name and age.',
    setup: 'let name = "Alice"; let age = 30;',
    setupCode: 'let name = "Alice"; let age = 30;',
    expected: 'Alice is 30 years old',
    sample: 'format!("{} is {} years old", name, age)',
    hints: [
      'format! macro creates a String',
      '{} is a placeholder for values',
      'Values are inserted in order',
    ],
    validPatterns: [/format!\s*\(/],
    tags: ['string', 'format', 'macro', 'basics'],
  },
  {
    id: 'rust-str-023',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Format with Named Arguments',
    text: 'Create a formatted string using named placeholders.',
    setup: 'let item = "apple"; let count = 5;',
    setupCode: 'let item = "apple"; let count = 5;',
    expected: '5 apples',
    sample: 'format!("{count} {item}s")',
    hints: [
      'Use {name} for named placeholders',
      'Variables in scope can be captured directly',
      'Rust 2021 supports captured identifiers',
    ],
    validPatterns: [/format!\s*\(\s*["']\{count\}|\{item\}/],
    tags: ['string', 'format', 'named', 'medium'],
  },
  {
    id: 'rust-str-024',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Format with Padding and Alignment',
    text: 'Format the number with leading zeros to width 5.',
    setup: 'let num = 42;',
    setupCode: 'let num = 42;',
    expected: '00042',
    sample: 'format!("{:0>5}", num)',
    hints: [
      '{:0>5} pads with 0, right-aligned, width 5',
      '> means right-align, < means left-align',
      'The fill character comes before alignment',
    ],
    validPatterns: [/format!\s*\(\s*["']\{:0>5\}["']/],
    tags: ['string', 'format', 'padding', 'hard'],
  },

  // ========================================
  // STRING OPERATIONS - Concatenation Patterns (Easy/Medium/Hard)
  // ========================================
  {
    id: 'rust-str-025',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Join Vector of Strings',
    text: 'Join the words with a space separator.',
    setup: 'let words = vec!["Hello", "beautiful", "world"];',
    setupCode: 'let words = vec!["Hello", "beautiful", "world"];',
    expected: 'Hello beautiful world',
    sample: 'words.join(" ")',
    hints: [
      '.join() concatenates with separator',
      'Works on slices of &str or String',
      'Returns an owned String',
    ],
    validPatterns: [/\.join\s*\(\s*["'] ["']\s*\)/],
    tags: ['string', 'join', 'concatenation', 'medium'],
  },

  // ========================================
  // OWNERSHIP & BORROWING - Move Semantics
  // ========================================
  {
    id: 'rust-own-200',
    category: 'Ownership & Borrowing',
    difficulty: 'easy',
    title: 'Move String Ownership',
    text: 'Create a new String from s1, demonstrating move semantics.',
    setup: 'let s1 = String::from("hello");',
    setupCode: 'let s1 = String::from("hello");',
    expected: 'hello',
    sample: 'let s2 = s1; s2',
    hints: [
      'Assignment moves ownership for heap types',
      's1 is no longer valid after move',
      'String does not implement Copy',
    ],
    tags: ['ownership', 'move', 'string', 'basics'],
  },
  {
    id: 'rust-own-201',
    category: 'Ownership & Borrowing',
    difficulty: 'easy',
    title: 'Clone to Avoid Move',
    text: 'Create a copy of s1 so both variables remain valid.',
    setup: 'let s1 = String::from("hello");',
    setupCode: 'let s1 = String::from("hello");',
    expected: ['hello', 'hello'],
    sample: 'let s2 = s1.clone(); vec![s1, s2]',
    hints: [
      'Use .clone() for deep copy',
      'Both s1 and s2 are valid after clone',
      'Clone is explicit and can be expensive',
    ],
    tags: ['ownership', 'clone', 'string', 'basics'],
  },
  {
    id: 'rust-own-202',
    category: 'Ownership & Borrowing',
    difficulty: 'easy',
    title: 'Immutable Borrow',
    text: 'Create an immutable reference to the string.',
    setup: 'let s = String::from("hello");',
    setupCode: 'let s = String::from("hello");',
    expected: 'hello',
    sample: 'let r = &s; r.to_string()',
    hints: [
      '& creates an immutable reference',
      'Original owner retains ownership',
      'Multiple immutable borrows allowed',
    ],
    tags: ['borrowing', 'reference', 'immutable', 'basics'],
  },
  {
    id: 'rust-own-203',
    category: 'Ownership & Borrowing',
    difficulty: 'easy',
    title: 'Mutable Borrow',
    text: 'Create a mutable reference and modify the string.',
    setup: 'let mut s = String::from("hello");',
    setupCode: 'let mut s = String::from("hello");',
    expected: 'hello world',
    sample: 'let r = &mut s; r.push_str(" world"); s',
    hints: [
      '&mut creates a mutable reference',
      'Only one mutable borrow at a time',
      'Original must be declared mut',
    ],
    tags: ['borrowing', 'mutable', 'reference', 'basics'],
  },
  {
    id: 'rust-own-204',
    category: 'Ownership & Borrowing',
    difficulty: 'medium',
    title: 'Multiple Immutable Borrows',
    text: 'Create two immutable references and use both.',
    setup: 'let s = String::from("hello");',
    setupCode: 'let s = String::from("hello");',
    expected: 10,
    sample: 'let r1 = &s; let r2 = &s; r1.len() + r2.len()',
    hints: [
      'Multiple immutable borrows are allowed',
      'They can coexist simultaneously',
      'No mutable borrow while immutable exists',
    ],
    tags: ['borrowing', 'immutable', 'multiple', 'medium'],
  },
  {
    id: 'rust-own-205',
    category: 'Ownership & Borrowing',
    difficulty: 'medium',
    title: 'Return Ownership from Function',
    text: 'Write an expression that takes ownership and returns it.',
    setup: 'let s = String::from("hello");',
    setupCode: 'let s = String::from("hello");',
    expected: 'HELLO',
    sample: '(|s: String| s.to_uppercase())(s)',
    hints: [
      'Functions can take and return ownership',
      'Closure takes String by value',
      'Ownership transfers in and out',
    ],
    tags: ['ownership', 'function', 'transfer', 'medium'],
  },
  {
    id: 'rust-own-206',
    category: 'Ownership & Borrowing',
    difficulty: 'medium',
    title: 'Borrow in Function',
    text: 'Calculate string length without taking ownership.',
    setup: 'let s = String::from("hello world");',
    setupCode: 'let s = String::from("hello world");',
    expected: [11, 'hello world'],
    sample:
      'let len = (|s: &String| s.len())(&s); vec![len.to_string(), s].into_iter().collect::<Vec<_>>()',
    hints: [
      'Pass reference to borrow without taking ownership',
      'Function receives &String',
      'Original remains valid after call',
    ],
    tags: ['borrowing', 'function', 'reference', 'medium'],
  },
  {
    id: 'rust-own-207',
    category: 'Ownership & Borrowing',
    difficulty: 'hard',
    title: 'Lifetime Annotation Basic',
    text: 'Return the longer of two string slices with explicit lifetime.',
    setup: 'let s1 = "short"; let s2 = "much longer";',
    setupCode: 'let s1 = "short"; let s2 = "much longer";',
    expected: 'much longer',
    sample:
      "fn longest<'a>(x: &'a str, y: &'a str) -> &'a str { if x.len() > y.len() { x } else { y } } longest(s1, s2)",
    hints: [
      'Lifetime annotation tells compiler how long refs live',
      "Both inputs and output share lifetime 'a",
      'Compiler ensures returned ref is valid',
    ],
    tags: ['lifetime', 'annotation', 'function', 'hard'],
  },
  {
    id: 'rust-own-208',
    category: 'Ownership & Borrowing',
    difficulty: 'hard',
    title: 'Struct with Lifetime',
    text: 'Create a struct that holds a string slice reference.',
    setup: 'let text = String::from("Hello World");',
    setupCode: 'let text = String::from("Hello World");',
    expected: 'Hello World',
    sample:
      "struct Excerpt<'a> { part: &'a str } let e = Excerpt { part: &text }; e.part.to_string()",
    hints: [
      'Structs holding references need lifetime params',
      'Lifetime ensures ref outlives struct',
      "Use <'a> in struct definition",
    ],
    tags: ['lifetime', 'struct', 'reference', 'hard'],
  },
  {
    id: 'rust-own-209',
    category: 'Ownership & Borrowing',
    difficulty: 'medium',
    title: 'Slice from String',
    text: 'Create a slice of the first word from the string.',
    setup: 'let s = String::from("hello world");',
    setupCode: 'let s = String::from("hello world");',
    expected: 'hello',
    sample: '&s[..5]',
    hints: [
      'Slices are references to part of data',
      'Use range syntax [start..end]',
      'String slices are &str type',
    ],
    tags: ['slice', 'string', 'borrowing', 'medium'],
  },
  {
    id: 'rust-own-210',
    category: 'Ownership & Borrowing',
    difficulty: 'easy',
    title: 'Copy Types',
    text: 'Show that integers are copied, not moved.',
    setup: 'let x = 5;',
    setupCode: 'let x = 5;',
    expected: [5, 5],
    sample: 'let y = x; vec![x, y]',
    hints: [
      'Integers implement Copy trait',
      'Assignment copies value, not moves',
      'Both x and y are valid',
    ],
    tags: ['copy', 'integer', 'ownership', 'basics'],
  },
  {
    id: 'rust-own-211',
    category: 'Ownership & Borrowing',
    difficulty: 'medium',
    title: 'Dereference to Access Value',
    text: 'Use dereference to get the value from a reference.',
    setup: 'let x = 5; let r = &x;',
    setupCode: 'let x = 5; let r = &x;',
    expected: 10,
    sample: '*r + 5',
    hints: [
      '* dereferences a reference',
      'Gets the actual value from ref',
      'Required for arithmetic with refs',
    ],
    tags: ['dereference', 'reference', 'borrowing', 'medium'],
  },
  {
    id: 'rust-own-212',
    category: 'Ownership & Borrowing',
    difficulty: 'hard',
    title: 'Mutable Reference in Loop',
    text: 'Modify each element in a vector using mutable references.',
    setup: 'let mut v = vec![1, 2, 3, 4, 5];',
    setupCode: 'let mut v = vec![1, 2, 3, 4, 5];',
    expected: [2, 4, 6, 8, 10],
    sample: 'for x in &mut v { *x *= 2; } v',
    hints: [
      '&mut v iterates with mutable refs',
      '*x dereferences to modify',
      'Each element doubled in place',
    ],
    tags: ['mutable', 'loop', 'dereference', 'hard'],
  },

  // ========================================
  // ITERATOR METHODS - Advanced
  // ========================================
  {
    id: 'rust-iter-213',
    category: 'Iterators',
    difficulty: 'easy',
    title: 'Sum with Iterator',
    text: 'Calculate the sum of all numbers using the sum method.',
    setup: 'let numbers = vec![1, 2, 3, 4, 5];',
    setupCode: 'let numbers = vec![1, 2, 3, 4, 5];',
    expected: 15,
    sample: 'numbers.iter().sum::<i32>()',
    hints: [
      '.sum() consumes iterator and adds all elements',
      'Need type annotation with turbofish',
      'Works on numeric types',
    ],
    tags: ['sum', 'iterator', 'numeric', 'basics'],
  },
  {
    id: 'rust-iter-214',
    category: 'Iterators',
    difficulty: 'easy',
    title: 'Product with Iterator',
    text: 'Calculate the product of all numbers using the product method.',
    setup: 'let numbers = vec![1, 2, 3, 4, 5];',
    setupCode: 'let numbers = vec![1, 2, 3, 4, 5];',
    expected: 120,
    sample: 'numbers.iter().product::<i32>()',
    hints: [
      '.product() multiplies all elements',
      'Similar to sum but for multiplication',
      'Requires type annotation',
    ],
    tags: ['product', 'iterator', 'numeric', 'basics'],
  },
  {
    id: 'rust-iter-215',
    category: 'Iterators',
    difficulty: 'easy',
    title: 'Find First Match',
    text: 'Find the first number greater than 3.',
    setup: 'let numbers = vec![1, 2, 3, 4, 5];',
    setupCode: 'let numbers = vec![1, 2, 3, 4, 5];',
    expected: 4,
    sample: 'numbers.iter().find(|&&x| x > 3).cloned().unwrap()',
    hints: [
      '.find() returns first matching element',
      'Returns Option<&T>',
      'Short-circuits on first match',
    ],
    tags: ['find', 'iterator', 'search', 'basics'],
  },
  {
    id: 'rust-iter-216',
    category: 'Iterators',
    difficulty: 'easy',
    title: 'Position of Element',
    text: 'Find the index of the first element equal to 3.',
    setup: 'let numbers = vec![1, 2, 3, 4, 5];',
    setupCode: 'let numbers = vec![1, 2, 3, 4, 5];',
    expected: 2,
    sample: 'numbers.iter().position(|&x| x == 3).unwrap()',
    hints: [
      '.position() returns index of first match',
      'Returns Option<usize>',
      'Similar to find but returns index',
    ],
    tags: ['position', 'iterator', 'index', 'basics'],
  },
  {
    id: 'rust-iter-217',
    category: 'Iterators',
    difficulty: 'medium',
    title: 'Any Match',
    text: 'Check if any number is greater than 10.',
    setup: 'let numbers = vec![1, 5, 8, 12, 3];',
    setupCode: 'let numbers = vec![1, 5, 8, 12, 3];',
    expected: true,
    sample: 'numbers.iter().any(|&x| x > 10)',
    hints: [
      '.any() returns true if any element matches',
      'Short-circuits on first true',
      'Consumes iterator',
    ],
    tags: ['any', 'iterator', 'predicate', 'medium'],
  },
  {
    id: 'rust-iter-218',
    category: 'Iterators',
    difficulty: 'medium',
    title: 'All Match',
    text: 'Check if all numbers are positive.',
    setup: 'let numbers = vec![1, 5, 8, 12, 3];',
    setupCode: 'let numbers = vec![1, 5, 8, 12, 3];',
    expected: true,
    sample: 'numbers.iter().all(|&x| x > 0)',
    hints: [
      '.all() returns true if all elements match',
      'Short-circuits on first false',
      'Empty iterator returns true',
    ],
    tags: ['all', 'iterator', 'predicate', 'medium'],
  },
  {
    id: 'rust-iter-219',
    category: 'Iterators',
    difficulty: 'medium',
    title: 'Max Element',
    text: 'Find the maximum element in the vector.',
    setup: 'let numbers = vec![3, 7, 2, 9, 4];',
    setupCode: 'let numbers = vec![3, 7, 2, 9, 4];',
    expected: 9,
    sample: 'numbers.iter().max().cloned().unwrap()',
    hints: [
      '.max() returns Option<&T>',
      'Returns None for empty iterator',
      'Elements must implement Ord',
    ],
    tags: ['max', 'iterator', 'comparison', 'medium'],
  },
  {
    id: 'rust-iter-220',
    category: 'Iterators',
    difficulty: 'medium',
    title: 'Min Element',
    text: 'Find the minimum element in the vector.',
    setup: 'let numbers = vec![3, 7, 2, 9, 4];',
    setupCode: 'let numbers = vec![3, 7, 2, 9, 4];',
    expected: 2,
    sample: 'numbers.iter().min().cloned().unwrap()',
    hints: [
      '.min() returns Option<&T>',
      'Returns None for empty iterator',
      'Elements must implement Ord',
    ],
    tags: ['min', 'iterator', 'comparison', 'medium'],
  },
  {
    id: 'rust-iter-221',
    category: 'Iterators',
    difficulty: 'medium',
    title: 'Max By Key',
    text: 'Find the longest string using max_by_key.',
    setup: 'let words = vec!["cat", "elephant", "dog"];',
    setupCode: 'let words = vec!["cat", "elephant", "dog"];',
    expected: 'elephant',
    sample: 'words.iter().max_by_key(|s| s.len()).unwrap()',
    hints: [
      '.max_by_key() compares using key function',
      'Key function maps element to comparable',
      'Useful for custom comparisons',
    ],
    tags: ['max_by_key', 'iterator', 'comparison', 'medium'],
  },
  {
    id: 'rust-iter-222',
    category: 'Iterators',
    difficulty: 'medium',
    title: 'Count Elements',
    text: 'Count how many elements are in the iterator.',
    setup: 'let numbers = vec![1, 2, 3, 4, 5, 6, 7];',
    setupCode: 'let numbers = vec![1, 2, 3, 4, 5, 6, 7];',
    expected: 7,
    sample: 'numbers.iter().count()',
    hints: [
      '.count() consumes iterator and returns length',
      'More general than .len()',
      'Works on any iterator',
    ],
    tags: ['count', 'iterator', 'length', 'medium'],
  },
  {
    id: 'rust-iter-223',
    category: 'Iterators',
    difficulty: 'hard',
    title: 'Reduce to Single Value',
    text: 'Use reduce to find the maximum without initial value.',
    setup: 'let numbers = vec![3, 7, 2, 9, 4];',
    setupCode: 'let numbers = vec![3, 7, 2, 9, 4];',
    expected: 9,
    sample: 'numbers.into_iter().reduce(|a, b| if a > b { a } else { b }).unwrap()',
    hints: [
      '.reduce() like fold but no initial value',
      'Returns Option (None for empty)',
      'First element is initial accumulator',
    ],
    tags: ['reduce', 'iterator', 'accumulator', 'hard'],
  },
  {
    id: 'rust-iter-224',
    category: 'Iterators',
    difficulty: 'hard',
    title: 'Interleave Two Iterators',
    text: 'Interleave elements from two vectors alternately.',
    setup: 'let a = vec![1, 3, 5]; let b = vec![2, 4, 6];',
    setupCode: 'let a = vec![1, 3, 5]; let b = vec![2, 4, 6];',
    expected: [1, 2, 3, 4, 5, 6],
    sample: 'a.iter().zip(b.iter()).flat_map(|(&x, &y)| vec![x, y]).collect::<Vec<_>>()',
    hints: [
      'Zip pairs elements from both',
      'flat_map expands pairs to sequence',
      'Creates interleaved result',
    ],
    tags: ['zip', 'flat_map', 'interleave', 'hard'],
  },

  // ========================================
  // OPTION METHODS
  // ========================================
  {
    id: 'rust-opt-225',
    category: 'Option Methods',
    difficulty: 'easy',
    title: 'Option is_some Check',
    text: 'Check if the Option contains a value.',
    setup: 'let x: Option<i32> = Some(5);',
    setupCode: 'let x: Option<i32> = Some(5);',
    expected: true,
    sample: 'x.is_some()',
    hints: [
      '.is_some() returns true for Some',
      'Does not consume the Option',
      'Opposite of .is_none()',
    ],
    tags: ['option', 'is_some', 'check', 'basics'],
  },
  {
    id: 'rust-opt-226',
    category: 'Option Methods',
    difficulty: 'easy',
    title: 'Option is_none Check',
    text: 'Check if the Option is None.',
    setup: 'let x: Option<i32> = None;',
    setupCode: 'let x: Option<i32> = None;',
    expected: true,
    sample: 'x.is_none()',
    hints: [
      '.is_none() returns true for None',
      'Useful for conditional checks',
      'Does not consume the Option',
    ],
    tags: ['option', 'is_none', 'check', 'basics'],
  },
  {
    id: 'rust-opt-227',
    category: 'Option Methods',
    difficulty: 'easy',
    title: 'Unwrap with Default',
    text: 'Get the value or use the default if None.',
    setup: 'let x: Option<i32> = None;',
    setupCode: 'let x: Option<i32> = None;',
    expected: 42,
    sample: 'x.unwrap_or(42)',
    hints: [
      '.unwrap_or(default) provides fallback',
      'Default is evaluated eagerly',
      'Never panics',
    ],
    tags: ['option', 'unwrap_or', 'default', 'basics'],
  },
  {
    id: 'rust-opt-228',
    category: 'Option Methods',
    difficulty: 'medium',
    title: 'Unwrap Or Else',
    text: 'Get the value or compute a default lazily.',
    setup: 'let x: Option<i32> = None;',
    setupCode: 'let x: Option<i32> = None;',
    expected: 100,
    sample: 'x.unwrap_or_else(|| 10 * 10)',
    hints: [
      '.unwrap_or_else takes a closure',
      'Closure only called if None',
      'Use for expensive default computation',
    ],
    tags: ['option', 'unwrap_or_else', 'lazy', 'medium'],
  },
  {
    id: 'rust-opt-229',
    category: 'Option Methods',
    difficulty: 'medium',
    title: 'Option Map',
    text: 'Transform the value inside Option if Some.',
    setup: 'let x: Option<i32> = Some(5);',
    setupCode: 'let x: Option<i32> = Some(5);',
    expected: 25,
    sample: 'x.map(|v| v * v).unwrap()',
    hints: [
      '.map() transforms Some value',
      'Returns None if input is None',
      'Closure not called for None',
    ],
    tags: ['option', 'map', 'transform', 'medium'],
  },
  {
    id: 'rust-opt-230',
    category: 'Option Methods',
    difficulty: 'medium',
    title: 'Option And Then',
    text: 'Chain Option operations that might fail.',
    setup: 'let x: Option<i32> = Some(4);',
    setupCode: 'let x: Option<i32> = Some(4);',
    expected: 2,
    sample: 'x.and_then(|v| if v >= 0 { Some((v as f64).sqrt() as i32) } else { None }).unwrap()',
    hints: [
      '.and_then() for Option-returning functions',
      'Flattens nested Options',
      'Short-circuits on None',
    ],
    tags: ['option', 'and_then', 'chain', 'medium'],
  },
  {
    id: 'rust-opt-231',
    category: 'Option Methods',
    difficulty: 'medium',
    title: 'Option Or',
    text: 'Return first Some value between two Options.',
    setup: 'let x: Option<i32> = None; let y: Option<i32> = Some(5);',
    setupCode: 'let x: Option<i32> = None; let y: Option<i32> = Some(5);',
    expected: 5,
    sample: 'x.or(y).unwrap()',
    hints: [
      '.or() returns self if Some, else other',
      'Useful for fallback values',
      'Both sides evaluated eagerly',
    ],
    tags: ['option', 'or', 'fallback', 'medium'],
  },
  {
    id: 'rust-opt-232',
    category: 'Option Methods',
    difficulty: 'medium',
    title: 'Option Or Else',
    text: 'Compute fallback Option lazily.',
    setup: 'let x: Option<i32> = None;',
    setupCode: 'let x: Option<i32> = None;',
    expected: 100,
    sample: 'x.or_else(|| Some(100)).unwrap()',
    hints: [
      '.or_else() takes closure returning Option',
      'Closure only called if None',
      'Lazy evaluation for expensive fallbacks',
    ],
    tags: ['option', 'or_else', 'lazy', 'medium'],
  },
  {
    id: 'rust-opt-233',
    category: 'Option Methods',
    difficulty: 'hard',
    title: 'Option Filter',
    text: 'Keep Some only if predicate is true.',
    setup: 'let x: Option<i32> = Some(10);',
    setupCode: 'let x: Option<i32> = Some(10);',
    expected: 10,
    sample: 'x.filter(|&v| v > 5).unwrap()',
    hints: [
      '.filter() returns None if predicate false',
      'Predicate receives reference',
      'Some unchanged if predicate true',
    ],
    tags: ['option', 'filter', 'predicate', 'hard'],
  },
  {
    id: 'rust-opt-234',
    category: 'Option Methods',
    difficulty: 'hard',
    title: 'Option Zip',
    text: 'Combine two Options into Option of tuple.',
    setup: 'let x: Option<i32> = Some(1); let y: Option<&str> = Some("hi");',
    setupCode: 'let x: Option<i32> = Some(1); let y: Option<&str> = Some("hi");',
    expected: [1, 'hi'],
    sample: 'x.zip(y).unwrap()',
    hints: [
      '.zip() combines two Options',
      'Returns Some only if both are Some',
      'Returns None if either is None',
    ],
    tags: ['option', 'zip', 'combine', 'hard'],
  },
  {
    id: 'rust-opt-235',
    category: 'Option Methods',
    difficulty: 'hard',
    title: 'Option Flatten',
    text: 'Flatten nested Option.',
    setup: 'let x: Option<Option<i32>> = Some(Some(5));',
    setupCode: 'let x: Option<Option<i32>> = Some(Some(5));',
    expected: 5,
    sample: 'x.flatten().unwrap()',
    hints: [
      '.flatten() removes one level of nesting',
      'Some(Some(v)) becomes Some(v)',
      'Some(None) or None becomes None',
    ],
    tags: ['option', 'flatten', 'nested', 'hard'],
  },
  {
    id: 'rust-opt-236',
    category: 'Option Methods',
    difficulty: 'easy',
    title: 'Take from Option',
    text: 'Take the value out of Option, leaving None.',
    setup: 'let mut x: Option<i32> = Some(5);',
    setupCode: 'let mut x: Option<i32> = Some(5);',
    expected: [5, true],
    sample: 'let v = x.take().unwrap(); vec![v, x.is_none() as i32]',
    hints: ['.take() moves value out', 'Leaves None in its place', 'Option must be mutable'],
    tags: ['option', 'take', 'mutable', 'basics'],
  },
  {
    id: 'rust-opt-237',
    category: 'Option Methods',
    difficulty: 'medium',
    title: 'Replace in Option',
    text: 'Replace value in Option, returning old value.',
    setup: 'let mut x: Option<i32> = Some(5);',
    setupCode: 'let mut x: Option<i32> = Some(5);',
    expected: [5, 10],
    sample: 'let old = x.replace(10).unwrap(); vec![old, x.unwrap()]',
    hints: [
      '.replace() swaps in new value',
      'Returns old value as Option',
      'Option must be mutable',
    ],
    tags: ['option', 'replace', 'swap', 'medium'],
  },

  // ========================================
  // RESULT METHODS
  // ========================================
  {
    id: 'rust-res-238',
    category: 'Result Methods',
    difficulty: 'easy',
    title: 'Result is_ok Check',
    text: 'Check if the Result is Ok.',
    setup: 'let x: Result<i32, &str> = Ok(5);',
    setupCode: 'let x: Result<i32, &str> = Ok(5);',
    expected: true,
    sample: 'x.is_ok()',
    hints: ['.is_ok() returns true for Ok', 'Does not consume the Result', 'Opposite of .is_err()'],
    tags: ['result', 'is_ok', 'check', 'basics'],
  },
  {
    id: 'rust-res-239',
    category: 'Result Methods',
    difficulty: 'easy',
    title: 'Result is_err Check',
    text: 'Check if the Result is Err.',
    setup: 'let x: Result<i32, &str> = Err("error");',
    setupCode: 'let x: Result<i32, &str> = Err("error");',
    expected: true,
    sample: 'x.is_err()',
    hints: [
      '.is_err() returns true for Err',
      'Useful for error checking',
      'Does not consume the Result',
    ],
    tags: ['result', 'is_err', 'check', 'basics'],
  },
  {
    id: 'rust-res-240',
    category: 'Result Methods',
    difficulty: 'easy',
    title: 'Result Ok Method',
    text: 'Convert Result to Option, discarding error.',
    setup: 'let x: Result<i32, &str> = Ok(5);',
    setupCode: 'let x: Result<i32, &str> = Ok(5);',
    expected: 5,
    sample: 'x.ok().unwrap()',
    hints: ['.ok() converts Ok to Some', 'Err becomes None', 'Error information is discarded'],
    tags: ['result', 'ok', 'option', 'basics'],
  },
  {
    id: 'rust-res-241',
    category: 'Result Methods',
    difficulty: 'easy',
    title: 'Result Err Method',
    text: 'Convert Result to Option of error.',
    setup: 'let x: Result<i32, &str> = Err("error");',
    setupCode: 'let x: Result<i32, &str> = Err("error");',
    expected: 'error',
    sample: 'x.err().unwrap()',
    hints: ['.err() converts Err to Some', 'Ok becomes None', 'Extracts error value'],
    tags: ['result', 'err', 'option', 'basics'],
  },
  {
    id: 'rust-res-242',
    category: 'Result Methods',
    difficulty: 'medium',
    title: 'Result Map',
    text: 'Transform Ok value while preserving Err.',
    setup: 'let x: Result<i32, &str> = Ok(5);',
    setupCode: 'let x: Result<i32, &str> = Ok(5);',
    expected: 25,
    sample: 'x.map(|v| v * v).unwrap()',
    hints: [
      '.map() transforms Ok value',
      'Err passes through unchanged',
      'Closure not called for Err',
    ],
    tags: ['result', 'map', 'transform', 'medium'],
  },
  {
    id: 'rust-res-243',
    category: 'Result Methods',
    difficulty: 'medium',
    title: 'Result Map Err',
    text: 'Transform Err value while preserving Ok.',
    setup: 'let x: Result<i32, i32> = Err(5);',
    setupCode: 'let x: Result<i32, i32> = Err(5);',
    expected: 'Error: 5',
    sample: 'x.map_err(|e| format!("Error: {}", e)).unwrap_err()',
    hints: [
      '.map_err() transforms Err value',
      'Ok passes through unchanged',
      'Useful for error type conversion',
    ],
    tags: ['result', 'map_err', 'error', 'medium'],
  },
  {
    id: 'rust-res-244',
    category: 'Result Methods',
    difficulty: 'medium',
    title: 'Result And Then',
    text: 'Chain Result operations.',
    setup: 'let x: Result<i32, &str> = Ok(2);',
    setupCode: 'let x: Result<i32, &str> = Ok(2);',
    expected: 4,
    sample: 'x.and_then(|v| Ok(v * 2)).unwrap()',
    hints: [
      '.and_then() for Result-returning functions',
      'Flattens nested Results',
      'Short-circuits on Err',
    ],
    tags: ['result', 'and_then', 'chain', 'medium'],
  },
  {
    id: 'rust-res-245',
    category: 'Result Methods',
    difficulty: 'medium',
    title: 'Result Or',
    text: 'Return first Ok between two Results.',
    setup: 'let x: Result<i32, &str> = Err("error"); let y: Result<i32, &str> = Ok(5);',
    setupCode: 'let x: Result<i32, &str> = Err("error"); let y: Result<i32, &str> = Ok(5);',
    expected: 5,
    sample: 'x.or(y).unwrap()',
    hints: [
      '.or() returns self if Ok, else other',
      'Useful for fallback Results',
      'Error type must match',
    ],
    tags: ['result', 'or', 'fallback', 'medium'],
  },
  {
    id: 'rust-res-246',
    category: 'Result Methods',
    difficulty: 'hard',
    title: 'Result Unwrap Or Default',
    text: 'Get Ok value or type default.',
    setup: 'let x: Result<i32, &str> = Err("error");',
    setupCode: 'let x: Result<i32, &str> = Err("error");',
    expected: 0,
    sample: 'x.unwrap_or_default()',
    hints: [
      '.unwrap_or_default() uses Default trait',
      'i32 default is 0',
      'Works for any type implementing Default',
    ],
    tags: ['result', 'unwrap_or_default', 'default', 'hard'],
  },
  {
    id: 'rust-res-247',
    category: 'Result Methods',
    difficulty: 'hard',
    title: 'Transpose Result and Option',
    text: 'Convert Result<Option<T>, E> to Option<Result<T, E>>.',
    setup: 'let x: Result<Option<i32>, &str> = Ok(Some(5));',
    setupCode: 'let x: Result<Option<i32>, &str> = Ok(Some(5));',
    expected: 5,
    sample: 'x.transpose().unwrap().unwrap()',
    hints: [
      '.transpose() swaps Result and Option',
      'Ok(Some(v)) becomes Some(Ok(v))',
      'Ok(None) becomes None',
    ],
    tags: ['result', 'transpose', 'option', 'hard'],
  },

  // ========================================
  // VECTOR OPERATIONS - Advanced
  // ========================================
  {
    id: 'rust-vec-248',
    category: 'Vector Operations',
    difficulty: 'easy',
    title: 'Extend Vector',
    text: 'Extend the vector with elements from another collection.',
    setup: 'let mut v = vec![1, 2, 3];',
    setupCode: 'let mut v = vec![1, 2, 3];',
    expected: [1, 2, 3, 4, 5, 6],
    sample: 'v.extend([4, 5, 6]); v',
    hints: [
      '.extend() adds multiple elements',
      'Takes any IntoIterator',
      'Modifies vector in place',
    ],
    tags: ['vector', 'extend', 'append', 'basics'],
  },
  {
    id: 'rust-vec-249',
    category: 'Vector Operations',
    difficulty: 'easy',
    title: 'Append Vector',
    text: 'Move all elements from another vector.',
    setup: 'let mut v1 = vec![1, 2, 3]; let mut v2 = vec![4, 5, 6];',
    setupCode: 'let mut v1 = vec![1, 2, 3]; let mut v2 = vec![4, 5, 6];',
    expected: [1, 2, 3, 4, 5, 6],
    sample: 'v1.append(&mut v2); v1',
    hints: [
      '.append() moves elements from other vec',
      'Other vec becomes empty',
      'More efficient than extend for Vec',
    ],
    tags: ['vector', 'append', 'move', 'basics'],
  },
  {
    id: 'rust-vec-250',
    category: 'Vector Operations',
    difficulty: 'medium',
    title: 'Retain Elements',
    text: 'Keep only even numbers in the vector.',
    setup: 'let mut v = vec![1, 2, 3, 4, 5, 6, 7, 8];',
    setupCode: 'let mut v = vec![1, 2, 3, 4, 5, 6, 7, 8];',
    expected: [2, 4, 6, 8],
    sample: 'v.retain(|&x| x % 2 == 0); v',
    hints: [
      '.retain() keeps elements matching predicate',
      'Modifies vector in place',
      'More efficient than filter for in-place',
    ],
    tags: ['vector', 'retain', 'filter', 'medium'],
  },
  {
    id: 'rust-vec-251',
    category: 'Vector Operations',
    difficulty: 'medium',
    title: 'Drain Elements',
    text: 'Remove and collect elements from index 1 to 3.',
    setup: 'let mut v = vec![0, 1, 2, 3, 4, 5];',
    setupCode: 'let mut v = vec![0, 1, 2, 3, 4, 5];',
    expected: [
      [1, 2, 3],
      [0, 4, 5],
    ],
    sample: 'let drained: Vec<_> = v.drain(1..4).collect(); vec![drained, v]',
    hints: [
      '.drain() removes and returns elements',
      'Takes range argument',
      'Original vec shrinks',
    ],
    tags: ['vector', 'drain', 'remove', 'medium'],
  },
  {
    id: 'rust-vec-252',
    category: 'Vector Operations',
    difficulty: 'medium',
    title: 'Split Off Vector',
    text: 'Split vector at index 3.',
    setup: 'let mut v = vec![1, 2, 3, 4, 5, 6];',
    setupCode: 'let mut v = vec![1, 2, 3, 4, 5, 6];',
    expected: [
      [1, 2, 3],
      [4, 5, 6],
    ],
    sample: 'let second = v.split_off(3); vec![v, second]',
    hints: ['.split_off() splits at index', 'Returns new vec with tail', 'Original keeps head'],
    tags: ['vector', 'split_off', 'divide', 'medium'],
  },
  {
    id: 'rust-vec-253',
    category: 'Vector Operations',
    difficulty: 'medium',
    title: 'Insert at Index',
    text: 'Insert 99 at index 2.',
    setup: 'let mut v = vec![1, 2, 3, 4, 5];',
    setupCode: 'let mut v = vec![1, 2, 3, 4, 5];',
    expected: [1, 2, 99, 3, 4, 5],
    sample: 'v.insert(2, 99); v',
    hints: ['.insert() adds at specific index', 'Shifts elements right', 'Panics if index > len'],
    tags: ['vector', 'insert', 'index', 'medium'],
  },
  {
    id: 'rust-vec-254',
    category: 'Vector Operations',
    difficulty: 'medium',
    title: 'Remove at Index',
    text: 'Remove and return element at index 2.',
    setup: 'let mut v = vec![1, 2, 3, 4, 5];',
    setupCode: 'let mut v = vec![1, 2, 3, 4, 5];',
    expected: [3, [1, 2, 4, 5]],
    sample: 'let removed = v.remove(2); (removed, v)',
    hints: ['.remove() removes at index', 'Returns removed element', 'Shifts elements left'],
    tags: ['vector', 'remove', 'index', 'medium'],
  },
  {
    id: 'rust-vec-255',
    category: 'Vector Operations',
    difficulty: 'hard',
    title: 'Swap Remove',
    text: 'Remove at index 1 using swap_remove (O(1)).',
    setup: 'let mut v = vec![1, 2, 3, 4, 5];',
    setupCode: 'let mut v = vec![1, 2, 3, 4, 5];',
    expected: [2, [1, 5, 3, 4]],
    sample: 'let removed = v.swap_remove(1); (removed, v)',
    hints: [
      '.swap_remove() swaps with last then pops',
      'O(1) but changes order',
      'Use when order does not matter',
    ],
    tags: ['vector', 'swap_remove', 'performance', 'hard'],
  },
  {
    id: 'rust-vec-256',
    category: 'Vector Operations',
    difficulty: 'hard',
    title: 'Dedup By Key',
    text: 'Remove consecutive duplicates by first character.',
    setup: 'let mut v = vec!["apple", "apricot", "banana", "blueberry", "cherry"];',
    setupCode: 'let mut v = vec!["apple", "apricot", "banana", "blueberry", "cherry"];',
    expected: ['apple', 'banana', 'cherry'],
    sample: 'v.dedup_by_key(|s| s.chars().next().unwrap()); v',
    hints: [
      '.dedup_by_key() compares using key',
      'Only removes consecutive duplicates',
      'First of each group kept',
    ],
    tags: ['vector', 'dedup_by_key', 'unique', 'hard'],
  },
  {
    id: 'rust-vec-257',
    category: 'Vector Operations',
    difficulty: 'easy',
    title: 'Clear Vector',
    text: 'Remove all elements from the vector.',
    setup: 'let mut v = vec![1, 2, 3, 4, 5];',
    setupCode: 'let mut v = vec![1, 2, 3, 4, 5];',
    expected: 0,
    sample: 'v.clear(); v.len()',
    hints: ['.clear() removes all elements', 'Capacity unchanged', 'Vector becomes empty'],
    tags: ['vector', 'clear', 'empty', 'basics'],
  },
  {
    id: 'rust-vec-258',
    category: 'Vector Operations',
    difficulty: 'medium',
    title: 'Truncate Vector',
    text: 'Keep only first 3 elements.',
    setup: 'let mut v = vec![1, 2, 3, 4, 5, 6, 7];',
    setupCode: 'let mut v = vec![1, 2, 3, 4, 5, 6, 7];',
    expected: [1, 2, 3],
    sample: 'v.truncate(3); v',
    hints: [
      '.truncate(n) keeps first n elements',
      'No-op if n >= len',
      'More efficient than drain',
    ],
    tags: ['vector', 'truncate', 'resize', 'medium'],
  },
  {
    id: 'rust-vec-259',
    category: 'Vector Operations',
    difficulty: 'medium',
    title: 'Resize Vector',
    text: 'Resize vector to length 7, filling with 0.',
    setup: 'let mut v = vec![1, 2, 3];',
    setupCode: 'let mut v = vec![1, 2, 3];',
    expected: [1, 2, 3, 0, 0, 0, 0],
    sample: 'v.resize(7, 0); v',
    hints: ['.resize() changes length', 'Fills with value if growing', 'Truncates if shrinking'],
    tags: ['vector', 'resize', 'fill', 'medium'],
  },

  // ========================================
  // HASHMAP/HASHSET
  // ========================================
  {
    id: 'rust-hash-260',
    category: 'HashMap/HashSet',
    difficulty: 'easy',
    title: 'Create HashMap from Tuples',
    text: 'Create a HashMap from vector of tuples.',
    setup: 'let pairs = vec![("a", 1), ("b", 2), ("c", 3)];',
    setupCode: 'let pairs = vec![("a", 1), ("b", 2), ("c", 3)];',
    expected: { a: 1, b: 2, c: 3 },
    sample: 'pairs.into_iter().collect::<std::collections::HashMap<_, _>>()',
    hints: [
      'HashMap implements FromIterator',
      'Collects (key, value) tuples',
      'Duplicate keys: last wins',
    ],
    tags: ['hashmap', 'collect', 'tuples', 'basics'],
  },
  {
    id: 'rust-hash-261',
    category: 'HashMap/HashSet',
    difficulty: 'medium',
    title: 'Entry API Or Insert',
    text: 'Insert value only if key does not exist.',
    setup: 'use std::collections::HashMap; let mut map = HashMap::new(); map.insert("a", 1);',
    setupCode: 'use std::collections::HashMap; let mut map = HashMap::new(); map.insert("a", 1);',
    expected: { a: 1, b: 2 },
    sample: 'map.entry("a").or_insert(100); map.entry("b").or_insert(2); map',
    hints: [
      '.entry() gives entry API',
      '.or_insert() inserts if vacant',
      'Returns mutable ref to value',
    ],
    tags: ['hashmap', 'entry', 'or_insert', 'medium'],
  },
  {
    id: 'rust-hash-262',
    category: 'HashMap/HashSet',
    difficulty: 'medium',
    title: 'Entry API Or Insert With',
    text: 'Insert computed value only if key missing.',
    setup: 'use std::collections::HashMap; let mut map: HashMap<&str, String> = HashMap::new();',
    setupCode:
      'use std::collections::HashMap; let mut map: HashMap<&str, String> = HashMap::new();',
    expected: 'HELLO',
    sample:
      'map.entry("greeting").or_insert_with(|| "hello".to_uppercase()); map.get("greeting").unwrap().clone()',
    hints: [
      '.or_insert_with() takes closure',
      'Closure only called if vacant',
      'Use for expensive computations',
    ],
    tags: ['hashmap', 'entry', 'or_insert_with', 'medium'],
  },
  {
    id: 'rust-hash-263',
    category: 'HashMap/HashSet',
    difficulty: 'hard',
    title: 'Entry API And Modify',
    text: 'Modify existing value or insert default.',
    setup: 'use std::collections::HashMap; let mut map = HashMap::new(); map.insert("count", 5);',
    setupCode:
      'use std::collections::HashMap; let mut map = HashMap::new(); map.insert("count", 5);',
    expected: 6,
    sample: 'map.entry("count").and_modify(|v| *v += 1).or_insert(0); *map.get("count").unwrap()',
    hints: [
      '.and_modify() modifies if occupied',
      'Chain with .or_insert() for default',
      'Common pattern for counters',
    ],
    tags: ['hashmap', 'entry', 'and_modify', 'hard'],
  },
  {
    id: 'rust-hash-264',
    category: 'HashMap/HashSet',
    difficulty: 'easy',
    title: 'HashSet Insert',
    text: 'Insert elements into a HashSet.',
    setup: 'use std::collections::HashSet; let mut set = HashSet::new();',
    setupCode: 'use std::collections::HashSet; let mut set = HashSet::new();',
    expected: 3,
    sample: 'set.insert(1); set.insert(2); set.insert(3); set.insert(2); set.len()',
    hints: [
      'HashSet stores unique values',
      '.insert() returns bool (true if new)',
      'Duplicates ignored',
    ],
    tags: ['hashset', 'insert', 'unique', 'basics'],
  },
  {
    id: 'rust-hash-265',
    category: 'HashMap/HashSet',
    difficulty: 'medium',
    title: 'HashSet Contains',
    text: 'Check if HashSet contains a value.',
    setup:
      'use std::collections::HashSet; let set: HashSet<i32> = [1, 2, 3, 4, 5].into_iter().collect();',
    setupCode:
      'use std::collections::HashSet; let set: HashSet<i32> = [1, 2, 3, 4, 5].into_iter().collect();',
    expected: [true, false],
    sample: 'vec![set.contains(&3), set.contains(&10)]',
    hints: [
      '.contains() checks membership',
      'O(1) average time complexity',
      'Takes reference to value',
    ],
    tags: ['hashset', 'contains', 'lookup', 'medium'],
  },
  {
    id: 'rust-hash-266',
    category: 'HashMap/HashSet',
    difficulty: 'medium',
    title: 'HashSet Intersection',
    text: 'Find common elements between two sets.',
    setup:
      'use std::collections::HashSet; let a: HashSet<i32> = [1, 2, 3, 4].into_iter().collect(); let b: HashSet<i32> = [3, 4, 5, 6].into_iter().collect();',
    setupCode:
      'use std::collections::HashSet; let a: HashSet<i32> = [1, 2, 3, 4].into_iter().collect(); let b: HashSet<i32> = [3, 4, 5, 6].into_iter().collect();',
    expected: [3, 4],
    sample: 'let mut v: Vec<_> = a.intersection(&b).cloned().collect(); v.sort(); v',
    hints: [
      '.intersection() finds common elements',
      'Returns iterator of references',
      'Clone to get owned values',
    ],
    tags: ['hashset', 'intersection', 'set-theory', 'medium'],
  },
  {
    id: 'rust-hash-267',
    category: 'HashMap/HashSet',
    difficulty: 'medium',
    title: 'HashSet Union',
    text: 'Combine all elements from both sets.',
    setup:
      'use std::collections::HashSet; let a: HashSet<i32> = [1, 2, 3].into_iter().collect(); let b: HashSet<i32> = [3, 4, 5].into_iter().collect();',
    setupCode:
      'use std::collections::HashSet; let a: HashSet<i32> = [1, 2, 3].into_iter().collect(); let b: HashSet<i32> = [3, 4, 5].into_iter().collect();',
    expected: [1, 2, 3, 4, 5],
    sample: 'let mut v: Vec<_> = a.union(&b).cloned().collect(); v.sort(); v',
    hints: ['.union() combines both sets', 'Duplicates appear once', 'Returns iterator'],
    tags: ['hashset', 'union', 'set-theory', 'medium'],
  },
  {
    id: 'rust-hash-268',
    category: 'HashMap/HashSet',
    difficulty: 'hard',
    title: 'HashSet Difference',
    text: 'Find elements in a but not in b.',
    setup:
      'use std::collections::HashSet; let a: HashSet<i32> = [1, 2, 3, 4].into_iter().collect(); let b: HashSet<i32> = [3, 4, 5, 6].into_iter().collect();',
    setupCode:
      'use std::collections::HashSet; let a: HashSet<i32> = [1, 2, 3, 4].into_iter().collect(); let b: HashSet<i32> = [3, 4, 5, 6].into_iter().collect();',
    expected: [1, 2],
    sample: 'let mut v: Vec<_> = a.difference(&b).cloned().collect(); v.sort(); v',
    hints: [
      '.difference() returns a - b',
      'Elements in self not in other',
      'Order matters for difference',
    ],
    tags: ['hashset', 'difference', 'set-theory', 'hard'],
  },
  {
    id: 'rust-hash-269',
    category: 'HashMap/HashSet',
    difficulty: 'hard',
    title: 'HashSet Symmetric Difference',
    text: 'Find elements in either set but not both.',
    setup:
      'use std::collections::HashSet; let a: HashSet<i32> = [1, 2, 3, 4].into_iter().collect(); let b: HashSet<i32> = [3, 4, 5, 6].into_iter().collect();',
    setupCode:
      'use std::collections::HashSet; let a: HashSet<i32> = [1, 2, 3, 4].into_iter().collect(); let b: HashSet<i32> = [3, 4, 5, 6].into_iter().collect();',
    expected: [1, 2, 5, 6],
    sample: 'let mut v: Vec<_> = a.symmetric_difference(&b).cloned().collect(); v.sort(); v',
    hints: [
      '.symmetric_difference() returns XOR',
      'Elements unique to each set',
      'Excludes common elements',
    ],
    tags: ['hashset', 'symmetric_difference', 'set-theory', 'hard'],
  },

  // ========================================
  // PATTERN MATCHING
  // ========================================
  {
    id: 'rust-pat-270',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'Match Option',
    text: 'Use match to extract value from Option.',
    setup: 'let x: Option<i32> = Some(5);',
    setupCode: 'let x: Option<i32> = Some(5);',
    expected: 5,
    sample: 'match x { Some(v) => v, None => 0 }',
    hints: [
      'match exhaustively handles all cases',
      'Some(v) binds inner value to v',
      'None case required',
    ],
    tags: ['match', 'option', 'pattern', 'basics'],
  },
  {
    id: 'rust-pat-271',
    category: 'Pattern Matching',
    difficulty: 'easy',
    title: 'If Let Pattern',
    text: 'Use if let to handle only Some case.',
    setup: 'let x: Option<i32> = Some(5);',
    setupCode: 'let x: Option<i32> = Some(5);',
    expected: 10,
    sample: 'if let Some(v) = x { v * 2 } else { 0 }',
    hints: [
      'if let handles one pattern',
      'Less verbose than full match',
      'else for non-matching case',
    ],
    tags: ['if_let', 'option', 'pattern', 'basics'],
  },
  {
    id: 'rust-pat-272',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Match with Guards',
    text: 'Use match guard to filter values.',
    setup: 'let x = 5;',
    setupCode: 'let x = 5;',
    expected: 'small positive',
    sample:
      'match x { n if n < 0 => "negative", n if n < 10 => "small positive", _ => "large positive" }',
    hints: [
      'if condition is a match guard',
      'Guards add extra conditions',
      'Checked after pattern matches',
    ],
    tags: ['match', 'guard', 'conditional', 'medium'],
  },
  {
    id: 'rust-pat-273',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Destructure Tuple',
    text: 'Destructure tuple in match.',
    setup: 'let point = (3, 5);',
    setupCode: 'let point = (3, 5);',
    expected: 8,
    sample: 'match point { (x, y) => x + y }',
    hints: [
      'Tuples can be destructured in patterns',
      'Each element bound to variable',
      'Works in let bindings too',
    ],
    tags: ['match', 'tuple', 'destructure', 'medium'],
  },
  {
    id: 'rust-pat-274',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Destructure Struct',
    text: 'Destructure struct fields in pattern.',
    setup: 'struct Point { x: i32, y: i32 } let p = Point { x: 3, y: 5 };',
    setupCode: 'struct Point { x: i32, y: i32 } let p = Point { x: 3, y: 5 };',
    expected: 8,
    sample: 'let Point { x, y } = p; x + y',
    hints: [
      'Struct fields can be destructured',
      'Field names become variables',
      'Use : for renaming',
    ],
    tags: ['destructure', 'struct', 'pattern', 'medium'],
  },
  {
    id: 'rust-pat-275',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'At Binding',
    text: 'Use @ to bind while matching.',
    setup: 'let x = 5;',
    setupCode: 'let x = 5;',
    expected: [5, true],
    sample: 'match x { n @ 1..=10 => (n, true), _ => (0, false) }',
    hints: [
      '@ binds value while testing pattern',
      'Useful with ranges',
      'Access both whole and pattern',
    ],
    tags: ['match', 'at_binding', 'range', 'hard'],
  },
  {
    id: 'rust-pat-276',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Or Pattern',
    text: 'Match multiple patterns with |.',
    setup: 'let x = 2;',
    setupCode: 'let x = 2;',
    expected: 'one or two',
    sample: 'match x { 1 | 2 => "one or two", 3 | 4 => "three or four", _ => "other" }',
    hints: [
      '| allows multiple patterns',
      'Any matching pattern succeeds',
      'Useful for grouping cases',
    ],
    tags: ['match', 'or_pattern', 'multiple', 'hard'],
  },
  {
    id: 'rust-pat-277',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Range Pattern',
    text: 'Match against a range of values.',
    setup: 'let x = 5;',
    setupCode: 'let x = 5;',
    expected: 'one to ten',
    sample: 'match x { 1..=10 => "one to ten", 11..=20 => "eleven to twenty", _ => "other" }',
    hints: ['..= is inclusive range pattern', 'Works with numbers and chars', 'End is included'],
    tags: ['match', 'range', 'pattern', 'medium'],
  },
  {
    id: 'rust-pat-278',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Nested Destructuring',
    text: 'Destructure nested structures.',
    setup: 'let nested = ((1, 2), (3, 4));',
    setupCode: 'let nested = ((1, 2), (3, 4));',
    expected: 10,
    sample: 'let ((a, b), (c, d)) = nested; a + b + c + d',
    hints: [
      'Patterns can be nested',
      'Each level destructures deeper',
      'Must match structure exactly',
    ],
    tags: ['destructure', 'nested', 'tuple', 'hard'],
  },
  {
    id: 'rust-pat-279',
    category: 'Pattern Matching',
    difficulty: 'medium',
    title: 'Ignore with Underscore',
    text: 'Use _ to ignore values in pattern.',
    setup: 'let tuple = (1, 2, 3);',
    setupCode: 'let tuple = (1, 2, 3);',
    expected: 2,
    sample: 'let (_, middle, _) = tuple; middle',
    hints: ['_ ignores a value', 'Does not bind anything', 'Can use multiple _'],
    tags: ['pattern', 'underscore', 'ignore', 'medium'],
  },
  {
    id: 'rust-pat-280',
    category: 'Pattern Matching',
    difficulty: 'hard',
    title: 'Rest Pattern',
    text: 'Use .. to ignore rest of struct fields.',
    setup: 'struct Point { x: i32, y: i32, z: i32 } let p = Point { x: 1, y: 2, z: 3 };',
    setupCode: 'struct Point { x: i32, y: i32, z: i32 } let p = Point { x: 1, y: 2, z: 3 };',
    expected: 1,
    sample: 'let Point { x, .. } = p; x',
    hints: [
      '.. ignores remaining fields',
      'Only one .. allowed per pattern',
      'Useful for partial destructuring',
    ],
    tags: ['pattern', 'rest', 'struct', 'hard'],
  },

  // ========================================
  // TRAITS
  // ========================================
  {
    id: 'rust-trait-281',
    category: 'Traits',
    difficulty: 'easy',
    title: 'Derive Debug',
    text: 'Use derive to implement Debug trait.',
    setup: '#[derive(Debug)] struct Point { x: i32, y: i32 } let p = Point { x: 1, y: 2 };',
    setupCode: '#[derive(Debug)] struct Point { x: i32, y: i32 } let p = Point { x: 1, y: 2 };',
    expected: 'Point { x: 1, y: 2 }',
    sample: 'format!("{:?}", p)',
    hints: [
      '#[derive(Debug)] auto-implements Debug',
      'Enables {:?} formatting',
      'All fields must implement Debug',
    ],
    tags: ['derive', 'debug', 'trait', 'basics'],
  },
  {
    id: 'rust-trait-282',
    category: 'Traits',
    difficulty: 'easy',
    title: 'Derive Clone',
    text: 'Use derive to implement Clone trait.',
    setup: '#[derive(Clone)] struct Point { x: i32, y: i32 } let p1 = Point { x: 1, y: 2 };',
    setupCode: '#[derive(Clone)] struct Point { x: i32, y: i32 } let p1 = Point { x: 1, y: 2 };',
    expected: [1, 2],
    sample: 'let p2 = p1.clone(); vec![p2.x, p2.y]',
    hints: [
      '#[derive(Clone)] enables .clone()',
      'Creates deep copy of value',
      'All fields must implement Clone',
    ],
    tags: ['derive', 'clone', 'trait', 'basics'],
  },
  {
    id: 'rust-trait-283',
    category: 'Traits',
    difficulty: 'medium',
    title: 'Implement Display',
    text: 'Implement Display trait for custom formatting.',
    setup: 'use std::fmt; struct Point { x: i32, y: i32 }',
    setupCode: 'use std::fmt; struct Point { x: i32, y: i32 }',
    expected: '(1, 2)',
    sample:
      'impl fmt::Display for Point { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { write!(f, "({}, {})", self.x, self.y) } } let p = Point { x: 1, y: 2 }; format!("{}", p)',
    hints: ['Display trait for {} formatting', 'Implement fmt method', 'Use write! macro'],
    tags: ['trait', 'display', 'impl', 'medium'],
  },
  {
    id: 'rust-trait-284',
    category: 'Traits',
    difficulty: 'medium',
    title: 'Implement Default',
    text: 'Implement Default trait for a struct.',
    setup: 'struct Config { timeout: u32, retries: u32 }',
    setupCode: 'struct Config { timeout: u32, retries: u32 }',
    expected: [30, 3],
    sample:
      'impl Default for Config { fn default() -> Self { Config { timeout: 30, retries: 3 } } } let c = Config::default(); vec![c.timeout, c.retries]',
    hints: [
      'Default provides default() method',
      'Returns new instance with defaults',
      'Used with ..Default::default()',
    ],
    tags: ['trait', 'default', 'impl', 'medium'],
  },
  {
    id: 'rust-trait-285',
    category: 'Traits',
    difficulty: 'hard',
    title: 'Implement From',
    text: 'Implement From trait for type conversion.',
    setup: 'struct Meters(f64); struct Feet(f64);',
    setupCode: 'struct Meters(f64); struct Feet(f64);',
    expected: 3.28084,
    sample:
      'impl From<Meters> for Feet { fn from(m: Meters) -> Self { Feet(m.0 * 3.28084) } } let m = Meters(1.0); let f: Feet = m.into(); f.0',
    hints: [
      'From<T> enables .into() conversion',
      'Consumes input value',
      'Into<U> implemented automatically',
    ],
    tags: ['trait', 'from', 'conversion', 'hard'],
  },
  {
    id: 'rust-trait-286',
    category: 'Traits',
    difficulty: 'hard',
    title: 'Trait with Associated Type',
    text: 'Create trait with associated type.',
    setup: 'trait Container { type Item; fn get(&self) -> &Self::Item; }',
    setupCode: 'trait Container { type Item; fn get(&self) -> &Self::Item; }',
    expected: 42,
    sample:
      'struct IntBox(i32); impl Container for IntBox { type Item = i32; fn get(&self) -> &i32 { &self.0 } } let b = IntBox(42); *b.get()',
    hints: [
      'Associated types define type placeholder',
      'Implementor chooses concrete type',
      'More ergonomic than generics for some cases',
    ],
    tags: ['trait', 'associated_type', 'impl', 'hard'],
  },
  {
    id: 'rust-trait-287',
    category: 'Traits',
    difficulty: 'medium',
    title: 'Derive PartialEq',
    text: 'Enable equality comparison with derive.',
    setup: '#[derive(PartialEq)] struct Point { x: i32, y: i32 }',
    setupCode: '#[derive(PartialEq)] struct Point { x: i32, y: i32 }',
    expected: [true, false],
    sample:
      'let p1 = Point { x: 1, y: 2 }; let p2 = Point { x: 1, y: 2 }; let p3 = Point { x: 3, y: 4 }; vec![p1 == p2, p1 == p3]',
    hints: [
      'PartialEq enables == and !=',
      'Compares all fields',
      'All fields must implement PartialEq',
    ],
    tags: ['derive', 'partialeq', 'comparison', 'medium'],
  },
  {
    id: 'rust-trait-288',
    category: 'Traits',
    difficulty: 'hard',
    title: 'Implement PartialOrd',
    text: 'Implement ordering for custom type.',
    setup: '#[derive(PartialEq)] struct Score(i32);',
    setupCode: '#[derive(PartialEq)] struct Score(i32);',
    expected: true,
    sample:
      'impl PartialOrd for Score { fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> { self.0.partial_cmp(&other.0) } } let s1 = Score(10); let s2 = Score(5); s1 > s2',
    hints: ['PartialOrd enables <, >, <=, >=', 'Requires PartialEq', 'Returns Option<Ordering>'],
    tags: ['trait', 'partialord', 'ordering', 'hard'],
  },

  // ========================================
  // GENERICS
  // ========================================
  {
    id: 'rust-gen-289',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Function',
    text: 'Create a generic function that returns its input.',
    setup: 'fn identity<T>(x: T) -> T { x }',
    setupCode: 'fn identity<T>(x: T) -> T { x }',
    expected: [5, 'hello'],
    sample: 'vec![identity(5).to_string(), identity("hello").to_string()]',
    hints: ['<T> declares type parameter', 'T can be any type', 'Compiler infers type from usage'],
    tags: ['generic', 'function', 'type_parameter', 'basics'],
  },
  {
    id: 'rust-gen-290',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Generic Struct',
    text: 'Create a generic wrapper struct.',
    setup: 'struct Wrapper<T> { value: T }',
    setupCode: 'struct Wrapper<T> { value: T }',
    expected: [5, 'hello'],
    sample:
      'let w1 = Wrapper { value: 5 }; let w2 = Wrapper { value: "hello" }; vec![w1.value.to_string(), w2.value.to_string()]',
    hints: [
      'Struct can have type parameters',
      'Each instance chooses concrete type',
      'Fields use the type parameter',
    ],
    tags: ['generic', 'struct', 'type_parameter', 'medium'],
  },
  {
    id: 'rust-gen-291',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Trait Bound',
    text: 'Add trait bound to generic function.',
    setup: 'use std::fmt::Display;',
    setupCode: 'use std::fmt::Display;',
    expected: 'Value: 42',
    sample: 'fn describe<T: Display>(x: T) -> String { format!("Value: {}", x) } describe(42)',
    hints: [
      'T: Trait adds constraint',
      'T must implement the trait',
      'Enables using trait methods',
    ],
    tags: ['generic', 'trait_bound', 'constraint', 'medium'],
  },
  {
    id: 'rust-gen-292',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Multiple Trait Bounds',
    text: 'Require multiple traits on generic type.',
    setup: 'use std::fmt::{Display, Debug};',
    setupCode: 'use std::fmt::{Display, Debug};',
    expected: 'Display: 42, Debug: 42',
    sample:
      'fn show<T: Display + Debug>(x: T) -> String { format!("Display: {}, Debug: {:?}", x, x) } show(42)',
    hints: [
      'Use + for multiple bounds',
      'T must implement all listed traits',
      'Order does not matter',
    ],
    tags: ['generic', 'trait_bound', 'multiple', 'medium'],
  },
  {
    id: 'rust-gen-293',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Where Clause',
    text: 'Use where clause for complex bounds.',
    setup: 'use std::fmt::Display;',
    setupCode: 'use std::fmt::Display;',
    expected: '1, 2',
    sample:
      'fn pair_string<T, U>(a: T, b: U) -> String where T: Display, U: Display { format!("{}, {}", a, b) } pair_string(1, 2)',
    hints: [
      'where clause for readability',
      'Separates bounds from signature',
      'Better for complex constraints',
    ],
    tags: ['generic', 'where', 'trait_bound', 'hard'],
  },
  {
    id: 'rust-gen-294',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Impl Block with Generics',
    text: 'Implement methods for generic struct.',
    setup: 'struct Pair<T> { first: T, second: T }',
    setupCode: 'struct Pair<T> { first: T, second: T }',
    expected: [1, 2],
    sample:
      'impl<T> Pair<T> { fn new(first: T, second: T) -> Self { Pair { first, second } } fn into_tuple(self) -> (T, T) { (self.first, self.second) } } let p = Pair::new(1, 2); p.into_tuple()',
    hints: [
      'impl<T> for generic impl block',
      'Methods can use the type parameter',
      'Self refers to Pair<T>',
    ],
    tags: ['generic', 'impl', 'method', 'hard'],
  },
  {
    id: 'rust-gen-295',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Conditional Impl with Bounds',
    text: 'Implement trait only when T meets condition.',
    setup: '#[derive(Clone)] struct Container<T> { value: T }',
    setupCode: '#[derive(Clone)] struct Container<T> { value: T }',
    expected: 'Container: 42',
    sample:
      'use std::fmt::Display; impl<T: Display> Container<T> { fn describe(&self) -> String { format!("Container: {}", self.value) } } let c = Container { value: 42 }; c.describe()',
    hints: [
      'impl<T: Bound> adds conditional impl',
      'Method only available when bound met',
      'Different bounds = different impls',
    ],
    tags: ['generic', 'conditional_impl', 'trait_bound', 'hard'],
  },

  // ========================================
  // CLOSURES
  // ========================================
  {
    id: 'rust-clos-296',
    category: 'Closures',
    difficulty: 'easy',
    title: 'Basic Closure',
    text: 'Create a closure that adds two numbers.',
    setup: 'let add = |a, b| a + b;',
    setupCode: 'let add = |a, b| a + b;',
    expected: 7,
    sample: 'add(3, 4)',
    hints: ['|params| expr defines closure', 'Types often inferred', 'Can omit return type'],
    tags: ['closure', 'basic', 'function', 'basics'],
  },
  {
    id: 'rust-clos-297',
    category: 'Closures',
    difficulty: 'easy',
    title: 'Closure Capturing',
    text: 'Closure that captures environment variable.',
    setup: 'let x = 10;',
    setupCode: 'let x = 10;',
    expected: 15,
    sample: 'let add_x = |y| x + y; add_x(5)',
    hints: [
      'Closures capture from environment',
      'Captured by reference by default',
      'Can access outer variables',
    ],
    tags: ['closure', 'capture', 'environment', 'basics'],
  },
  {
    id: 'rust-clos-298',
    category: 'Closures',
    difficulty: 'medium',
    title: 'Move Closure',
    text: 'Use move to take ownership in closure.',
    setup: 'let s = String::from("hello");',
    setupCode: 'let s = String::from("hello");',
    expected: 'hello world',
    sample: 'let f = move || format!("{} world", s); f()',
    hints: [
      'move keyword forces ownership capture',
      'Useful for threads and async',
      'Original variable no longer usable',
    ],
    tags: ['closure', 'move', 'ownership', 'medium'],
  },
  {
    id: 'rust-clos-299',
    category: 'Closures',
    difficulty: 'medium',
    title: 'Fn Trait',
    text: 'Accept closure implementing Fn trait.',
    setup: 'fn apply<F: Fn(i32) -> i32>(f: F, x: i32) -> i32 { f(x) }',
    setupCode: 'fn apply<F: Fn(i32) -> i32>(f: F, x: i32) -> i32 { f(x) }',
    expected: 10,
    sample: 'apply(|x| x * 2, 5)',
    hints: [
      'Fn for closures that only read captures',
      'Can be called multiple times',
      'Most restrictive closure type',
    ],
    tags: ['closure', 'fn_trait', 'generic', 'medium'],
  },
  {
    id: 'rust-clos-300',
    category: 'Closures',
    difficulty: 'hard',
    title: 'FnMut Trait',
    text: 'Closure that mutates captured variable.',
    setup: 'let mut count = 0;',
    setupCode: 'let mut count = 0;',
    expected: 3,
    sample: 'let mut counter = || { count += 1; count }; counter(); counter(); counter()',
    hints: [
      'FnMut for closures that mutate captures',
      'Closure itself must be mut',
      'Can modify captured variables',
    ],
    tags: ['closure', 'fnmut', 'mutable', 'hard'],
  },
  {
    id: 'rust-clos-301',
    category: 'Closures',
    difficulty: 'hard',
    title: 'FnOnce Trait',
    text: 'Closure that consumes captured value.',
    setup: 'let s = String::from("hello");',
    setupCode: 'let s = String::from("hello");',
    expected: 'hello',
    sample: 'let consume = || s; consume()',
    hints: [
      'FnOnce can only be called once',
      'Moves captured values out',
      'Least restrictive closure type',
    ],
    tags: ['closure', 'fnonce', 'consume', 'hard'],
  },
  {
    id: 'rust-clos-302',
    category: 'Closures',
    difficulty: 'medium',
    title: 'Closure with Type Annotations',
    text: 'Create closure with explicit types.',
    setup: '// Explicit type annotation on closure',
    setupCode: '// Explicit type annotation on closure',
    expected: 6,
    sample: 'let multiply: fn(i32, i32) -> i32 = |a, b| a * b; multiply(2, 3)',
    hints: [
      'fn() is function pointer type',
      'Closures coerce to fn if no captures',
      'Explicit types sometimes needed',
    ],
    tags: ['closure', 'type_annotation', 'function_pointer', 'medium'],
  },
  {
    id: 'rust-clos-303',
    category: 'Closures',
    difficulty: 'hard',
    title: 'Return Closure from Function',
    text: 'Function that returns a closure.',
    setup: '// Function returning closure',
    setupCode: '// Function returning closure',
    expected: 15,
    sample:
      'fn make_adder(x: i32) -> impl Fn(i32) -> i32 { move |y| x + y } let add5 = make_adder(5); add5(10)',
    hints: [
      'impl Fn() for closure return type',
      'Use move to capture by value',
      'Each call creates new closure',
    ],
    tags: ['closure', 'return', 'impl_trait', 'hard'],
  },

  // ========================================
  // SMART POINTERS
  // ========================================
  {
    id: 'rust-ptr-304',
    category: 'Smart Pointers',
    difficulty: 'easy',
    title: 'Box Basic Usage',
    text: 'Store an integer on the heap using Box.',
    setup: 'let x = 5;',
    setupCode: 'let x = 5;',
    expected: 5,
    sample: 'let boxed = Box::new(x); *boxed',
    hints: [
      'Box::new() allocates on heap',
      'Deref with * to get value',
      'Automatically deallocated when dropped',
    ],
    tags: ['box', 'heap', 'smart_pointer', 'basics'],
  },
  {
    id: 'rust-ptr-305',
    category: 'Smart Pointers',
    difficulty: 'medium',
    title: 'Box for Recursive Type',
    text: 'Create a recursive list using Box.',
    setup: 'enum List { Cons(i32, Box<List>), Nil }',
    setupCode: 'enum List { Cons(i32, Box<List>), Nil }',
    expected: 1,
    sample:
      'use List::{Cons, Nil}; let list = Cons(1, Box::new(Cons(2, Box::new(Nil)))); match list { Cons(v, _) => v, Nil => 0 }',
    hints: [
      'Box enables recursive types',
      'Known size at compile time',
      'Indirection breaks infinite size',
    ],
    tags: ['box', 'recursive', 'enum', 'medium'],
  },
  {
    id: 'rust-ptr-306',
    category: 'Smart Pointers',
    difficulty: 'medium',
    title: 'Rc Basic Usage',
    text: 'Share ownership with Rc.',
    setup: 'use std::rc::Rc;',
    setupCode: 'use std::rc::Rc;',
    expected: 2,
    sample: 'let a = Rc::new(5); let b = Rc::clone(&a); Rc::strong_count(&a)',
    hints: ['Rc enables multiple owners', 'Reference counted pointer', 'Single-threaded only'],
    tags: ['rc', 'reference_counting', 'smart_pointer', 'medium'],
  },
  {
    id: 'rust-ptr-307',
    category: 'Smart Pointers',
    difficulty: 'hard',
    title: 'Arc for Thread Safety',
    text: 'Share data between threads with Arc.',
    setup: 'use std::sync::Arc;',
    setupCode: 'use std::sync::Arc;',
    expected: 2,
    sample: 'let a = Arc::new(5); let b = Arc::clone(&a); Arc::strong_count(&a)',
    hints: ['Arc is thread-safe Rc', 'Atomic reference counting', 'Use with threads and async'],
    tags: ['arc', 'thread_safe', 'smart_pointer', 'hard'],
  },
  {
    id: 'rust-ptr-308',
    category: 'Smart Pointers',
    difficulty: 'hard',
    title: 'RefCell Interior Mutability',
    text: 'Mutate data through shared reference using RefCell.',
    setup: 'use std::cell::RefCell;',
    setupCode: 'use std::cell::RefCell;',
    expected: 10,
    sample: 'let cell = RefCell::new(5); *cell.borrow_mut() = 10; *cell.borrow()',
    hints: [
      'RefCell enables interior mutability',
      'Runtime borrow checking',
      'borrow() and borrow_mut()',
    ],
    tags: ['refcell', 'interior_mutability', 'smart_pointer', 'hard'],
  },
  {
    id: 'rust-ptr-309',
    category: 'Smart Pointers',
    difficulty: 'hard',
    title: 'Rc with RefCell',
    text: 'Combine Rc and RefCell for shared mutable data.',
    setup: 'use std::rc::Rc; use std::cell::RefCell;',
    setupCode: 'use std::rc::Rc; use std::cell::RefCell;',
    expected: 10,
    sample:
      'let data = Rc::new(RefCell::new(5)); let clone = Rc::clone(&data); *clone.borrow_mut() = 10; *data.borrow()',
    hints: [
      'Rc<RefCell<T>> for shared mutability',
      'Common pattern for graphs',
      'Runtime borrow rules still apply',
    ],
    tags: ['rc', 'refcell', 'combination', 'hard'],
  },
  {
    id: 'rust-ptr-310',
    category: 'Smart Pointers',
    difficulty: 'hard',
    title: 'Mutex Basic Usage',
    text: 'Use Mutex for thread-safe mutation.',
    setup: 'use std::sync::Mutex;',
    setupCode: 'use std::sync::Mutex;',
    expected: 10,
    sample:
      'let m = Mutex::new(5); { let mut num = m.lock().unwrap(); *num = 10; } *m.lock().unwrap()',
    hints: [
      'Mutex provides mutual exclusion',
      '.lock() returns MutexGuard',
      'Guard auto-releases on drop',
    ],
    tags: ['mutex', 'thread_safe', 'smart_pointer', 'hard'],
  },
  {
    id: 'rust-ptr-311',
    category: 'Smart Pointers',
    difficulty: 'easy',
    title: 'Cow Clone on Write',
    text: 'Use Cow for efficient cloning.',
    setup: 'use std::borrow::Cow;',
    setupCode: 'use std::borrow::Cow;',
    expected: 'hello',
    sample: 'let s: Cow<str> = Cow::Borrowed("hello"); s.into_owned()',
    hints: [
      'Cow delays cloning until mutation',
      'Borrowed or Owned variants',
      'Clone on write semantics',
    ],
    tags: ['cow', 'clone_on_write', 'smart_pointer', 'basics'],
  },
  {
    id: 'rust-ptr-312',
    category: 'Smart Pointers',
    difficulty: 'medium',
    title: 'Weak Reference',
    text: 'Create weak reference to prevent cycles.',
    setup: 'use std::rc::{Rc, Weak};',
    setupCode: 'use std::rc::{Rc, Weak};',
    expected: [2, 1],
    sample:
      'let strong = Rc::new(5); let weak: Weak<_> = Rc::downgrade(&strong); vec![Rc::strong_count(&strong) as i32, Rc::weak_count(&strong) as i32]',
    hints: [
      'Weak does not prevent deallocation',
      'Use to break reference cycles',
      'upgrade() to get Option<Rc>',
    ],
    tags: ['weak', 'rc', 'reference_cycle', 'medium'],
  },

  // ========================================
  // ERROR HANDLING
  // ========================================
  {
    id: 'rust-err-313',
    category: 'Error Handling',
    difficulty: 'easy',
    title: 'Question Mark Operator',
    text: 'Use ? to propagate errors.',
    setup: 'fn parse(s: &str) -> Result<i32, std::num::ParseIntError> { s.parse() }',
    setupCode: 'fn parse(s: &str) -> Result<i32, std::num::ParseIntError> { s.parse() }',
    expected: 42,
    sample:
      'fn double(s: &str) -> Result<i32, std::num::ParseIntError> { Ok(parse(s)? * 2) } double("21").unwrap()',
    hints: ['? returns early on Err', 'Extracts Ok value otherwise', 'Function must return Result'],
    tags: ['error', 'question_mark', 'propagation', 'basics'],
  },
  {
    id: 'rust-err-314',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Custom Error Type',
    text: 'Create a simple custom error type.',
    setup: '#[derive(Debug)] struct MyError { message: String }',
    setupCode: '#[derive(Debug)] struct MyError { message: String }',
    expected: 'Something went wrong',
    sample: 'let err = MyError { message: "Something went wrong".to_string() }; err.message',
    hints: [
      'Custom errors are regular structs',
      'Derive Debug for formatting',
      'Can add more fields as needed',
    ],
    tags: ['error', 'custom', 'struct', 'medium'],
  },
  {
    id: 'rust-err-315',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Implement Error Trait',
    text: 'Implement std::error::Error for custom type.',
    setup: 'use std::fmt; use std::error::Error; #[derive(Debug)] struct MyError(String);',
    setupCode: 'use std::fmt; use std::error::Error; #[derive(Debug)] struct MyError(String);',
    expected: 'Custom error: test',
    sample:
      'impl fmt::Display for MyError { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { write!(f, "Custom error: {}", self.0) } } impl Error for MyError {} let e = MyError("test".to_string()); format!("{}", e)',
    hints: [
      'Error trait requires Display',
      'Implement fmt::Display first',
      'Error impl can be empty',
    ],
    tags: ['error', 'trait', 'display', 'hard'],
  },
  {
    id: 'rust-err-316',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Convert Error Types',
    text: 'Convert between error types with map_err.',
    setup:
      'fn parse(s: &str) -> Result<i32, String> { s.parse().map_err(|e| format!("Parse error: {}", e)) }',
    setupCode:
      'fn parse(s: &str) -> Result<i32, String> { s.parse().map_err(|e| format!("Parse error: {}", e)) }',
    expected: 42,
    sample: 'parse("42").unwrap()',
    hints: [
      'map_err transforms error type',
      'Useful for unified error types',
      'Original error can be wrapped',
    ],
    tags: ['error', 'map_err', 'conversion', 'medium'],
  },
  {
    id: 'rust-err-317',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Error with Source',
    text: 'Chain errors with source.',
    setup:
      'use std::fmt; use std::error::Error; #[derive(Debug)] struct WrapError { source: Box<dyn Error>, context: String }',
    setupCode:
      'use std::fmt; use std::error::Error; #[derive(Debug)] struct WrapError { source: Box<dyn Error>, context: String }',
    expected: 'Wrapped: context info',
    sample:
      'impl fmt::Display for WrapError { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { write!(f, "Wrapped: {}", self.context) } } impl Error for WrapError { fn source(&self) -> Option<&(dyn Error + \'static)> { Some(self.source.as_ref()) } } let inner: Box<dyn Error> = "inner error".into(); let e = WrapError { source: inner, context: "context info".to_string() }; format!("{}", e)',
    hints: [
      'source() returns underlying error',
      'Enables error chaining',
      'Used by ? for conversions',
    ],
    tags: ['error', 'source', 'chain', 'hard'],
  },
  {
    id: 'rust-err-318',
    category: 'Error Handling',
    difficulty: 'easy',
    title: 'Unwrap or Panic',
    text: 'Use expect for better panic messages.',
    setup: 'let x: Result<i32, &str> = Ok(5);',
    setupCode: 'let x: Result<i32, &str> = Ok(5);',
    expected: 5,
    sample: 'x.expect("Should have value")',
    hints: [
      'expect() like unwrap() but with message',
      'Message shown on panic',
      'Better for debugging',
    ],
    tags: ['error', 'expect', 'panic', 'basics'],
  },
  {
    id: 'rust-err-319',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Ok Or Function',
    text: 'Convert Option to Result with error.',
    setup: 'let x: Option<i32> = None;',
    setupCode: 'let x: Option<i32> = None;',
    expected: 'no value',
    sample: 'x.ok_or("no value").unwrap_err()',
    hints: [
      'ok_or converts None to Err',
      'Some(v) becomes Ok(v)',
      'Useful for Option in Result context',
    ],
    tags: ['error', 'ok_or', 'option', 'medium'],
  },

  // ========================================
  // ASYNC/AWAIT
  // ========================================
  {
    id: 'rust-async-320',
    category: 'Async/Await',
    difficulty: 'easy',
    title: 'Basic Async Function',
    text: 'Create a simple async function.',
    setup: 'async fn get_number() -> i32 { 42 }',
    setupCode: 'async fn get_number() -> i32 { 42 }',
    expected: 42,
    sample: 'futures::executor::block_on(get_number())',
    hints: [
      'async fn returns impl Future',
      'Must be awaited to run',
      'block_on runs future to completion',
    ],
    tags: ['async', 'function', 'future', 'basics'],
  },
  {
    id: 'rust-async-321',
    category: 'Async/Await',
    difficulty: 'medium',
    title: 'Await Future',
    text: 'Use await to get future result.',
    setup: 'async fn double(x: i32) -> i32 { x * 2 }',
    setupCode: 'async fn double(x: i32) -> i32 { x * 2 }',
    expected: 42,
    sample: 'async fn run() -> i32 { double(21).await } futures::executor::block_on(run())',
    hints: [
      '.await waits for future completion',
      'Can only use in async context',
      'Suspends until ready',
    ],
    tags: ['async', 'await', 'future', 'medium'],
  },
  {
    id: 'rust-async-322',
    category: 'Async/Await',
    difficulty: 'medium',
    title: 'Async Block',
    text: 'Create an async block inline.',
    setup: '// Create async block',
    setupCode: '// Create async block',
    expected: 5,
    sample: 'let future = async { 2 + 3 }; futures::executor::block_on(future)',
    hints: [
      'async {} creates anonymous future',
      'Captures environment like closures',
      'Returns impl Future',
    ],
    tags: ['async', 'block', 'future', 'medium'],
  },
  {
    id: 'rust-async-323',
    category: 'Async/Await',
    difficulty: 'hard',
    title: 'Join Multiple Futures',
    text: 'Run multiple futures concurrently.',
    setup: 'async fn a() -> i32 { 1 } async fn b() -> i32 { 2 }',
    setupCode: 'async fn a() -> i32 { 1 } async fn b() -> i32 { 2 }',
    expected: [1, 2],
    sample:
      'async fn run() -> (i32, i32) { futures::join!(a(), b()) } futures::executor::block_on(run())',
    hints: [
      'join! runs futures concurrently',
      'Waits for all to complete',
      'Returns tuple of results',
    ],
    tags: ['async', 'join', 'concurrent', 'hard'],
  },
  {
    id: 'rust-async-324',
    category: 'Async/Await',
    difficulty: 'hard',
    title: 'Select First Future',
    text: 'Return result of first completed future.',
    setup: 'use futures::future; async fn fast() -> i32 { 1 } async fn slow() -> i32 { 2 }',
    setupCode: 'use futures::future; async fn fast() -> i32 { 1 } async fn slow() -> i32 { 2 }',
    expected: 1,
    sample:
      'async fn run() -> i32 { futures::select_biased! { r = fast().fuse() => r, r = slow().fuse() => r, } } futures::executor::block_on(run())',
    hints: [
      'select! returns first completed',
      'Use fuse() for one-shot futures',
      'Cancels other futures',
    ],
    tags: ['async', 'select', 'race', 'hard'],
  },
  {
    id: 'rust-async-325',
    category: 'Async/Await',
    difficulty: 'medium',
    title: 'Async Move Closure',
    text: 'Create async closure that moves captured values.',
    setup: 'let s = String::from("hello");',
    setupCode: 'let s = String::from("hello");',
    expected: 'hello',
    sample: 'let future = async move { s }; futures::executor::block_on(future)',
    hints: ['async move captures by value', 'Useful for spawning tasks', 'Original variable moved'],
    tags: ['async', 'move', 'closure', 'medium'],
  },

  // ========================================
  // MACROS
  // ========================================
  {
    id: 'rust-macro-326',
    category: 'Macros',
    difficulty: 'easy',
    title: 'Vec Macro',
    text: 'Use vec! macro to create a vector.',
    setup: '// Create vector with macro',
    setupCode: '// Create vector with macro',
    expected: [1, 2, 3],
    sample: 'vec![1, 2, 3]',
    hints: [
      'vec! creates Vec from literals',
      'Cleaner than Vec::new() + push',
      'Can repeat: vec![0; 5]',
    ],
    tags: ['macro', 'vec', 'collection', 'basics'],
  },
  {
    id: 'rust-macro-327',
    category: 'Macros',
    difficulty: 'easy',
    title: 'Println Macro',
    text: 'Format and print with println!.',
    setup: 'let name = "World";',
    setupCode: 'let name = "World";',
    expected: 'Hello, World!',
    sample: 'format!("Hello, {}!", name)',
    hints: ['println! prints to stdout', 'format! returns String', '{} is placeholder'],
    tags: ['macro', 'println', 'format', 'basics'],
  },
  {
    id: 'rust-macro-328',
    category: 'Macros',
    difficulty: 'medium',
    title: 'Debug Print Macro',
    text: 'Use dbg! for quick debug output.',
    setup: 'let x = 5;',
    setupCode: 'let x = 5;',
    expected: 5,
    sample: 'dbg!(x)',
    hints: ['dbg! prints and returns value', 'Shows file:line info', 'Useful for debugging'],
    tags: ['macro', 'dbg', 'debug', 'medium'],
  },
  {
    id: 'rust-macro-329',
    category: 'Macros',
    difficulty: 'medium',
    title: 'Assert Macro',
    text: 'Use assert! to check conditions.',
    setup: 'let x = 5;',
    setupCode: 'let x = 5;',
    expected: true,
    sample: 'assert!(x > 0); true',
    hints: ['assert! panics if false', 'Removed in release builds', 'Use for invariants'],
    tags: ['macro', 'assert', 'test', 'medium'],
  },
  {
    id: 'rust-macro-330',
    category: 'Macros',
    difficulty: 'hard',
    title: 'Simple Declarative Macro',
    text: 'Create a macro that creates a pair.',
    setup: 'macro_rules! pair { ($a:expr, $b:expr) => { ($a, $b) }; }',
    setupCode: 'macro_rules! pair { ($a:expr, $b:expr) => { ($a, $b) }; }',
    expected: [1, 2],
    sample: 'pair!(1, 2)',
    hints: [
      'macro_rules! defines declarative macro',
      '$name:type captures pattern',
      'expr matches expressions',
    ],
    tags: ['macro', 'declarative', 'macro_rules', 'hard'],
  },
  {
    id: 'rust-macro-331',
    category: 'Macros',
    difficulty: 'hard',
    title: 'Macro with Repetition',
    text: 'Create macro that handles multiple arguments.',
    setup: 'macro_rules! sum { ($($x:expr),*) => { 0 $(+ $x)* }; }',
    setupCode: 'macro_rules! sum { ($($x:expr),*) => { 0 $(+ $x)* }; }',
    expected: 15,
    sample: 'sum!(1, 2, 3, 4, 5)',
    hints: [
      '$()* repeats zero or more times',
      'Separator between pattern and repetition',
      'Common for variadic macros',
    ],
    tags: ['macro', 'repetition', 'variadic', 'hard'],
  },

  // ========================================
  // MODULES
  // ========================================
  {
    id: 'rust-mod-332',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Use Statement',
    text: 'Bring HashMap into scope with use.',
    setup: '// Import HashMap',
    setupCode: '// Import HashMap',
    expected: 0,
    sample:
      'use std::collections::HashMap; let map: HashMap<&str, i32> = HashMap::new(); map.len()',
    hints: ['use brings item into scope', 'Avoids full path each time', 'Can alias with as'],
    tags: ['module', 'use', 'import', 'basics'],
  },
  {
    id: 'rust-mod-333',
    category: 'Modules',
    difficulty: 'easy',
    title: 'Glob Import',
    text: 'Import all public items from module.',
    setup: '// Glob import',
    setupCode: '// Glob import',
    expected: [1, 2, 3],
    sample: 'use std::collections::*; let v: Vec<i32> = vec![1, 2, 3]; v',
    hints: ['* imports all public items', 'Use sparingly to avoid conflicts', 'Common in preludes'],
    tags: ['module', 'glob', 'import', 'basics'],
  },
  {
    id: 'rust-mod-334',
    category: 'Modules',
    difficulty: 'medium',
    title: 'Nested Use',
    text: 'Import multiple items with nested paths.',
    setup: '// Nested use',
    setupCode: '// Nested use',
    expected: true,
    sample:
      'use std::collections::{HashMap, HashSet}; let _m: HashMap<i32, i32> = HashMap::new(); let _s: HashSet<i32> = HashSet::new(); true',
    hints: ['{} groups multiple imports', 'Reduces repetition', 'Can mix items and modules'],
    tags: ['module', 'nested', 'import', 'medium'],
  },
  {
    id: 'rust-mod-335',
    category: 'Modules',
    difficulty: 'medium',
    title: 'Rename Import',
    text: 'Rename imported item to avoid conflict.',
    setup: '// Rename import',
    setupCode: '// Rename import',
    expected: 0,
    sample: 'use std::collections::HashMap as Map; let m: Map<&str, i32> = Map::new(); m.len()',
    hints: ['as renames the import', 'Useful for name conflicts', 'Original name not available'],
    tags: ['module', 'rename', 'as', 'medium'],
  },
  {
    id: 'rust-mod-336',
    category: 'Modules',
    difficulty: 'hard',
    title: 'Pub Use Re-export',
    text: 'Re-export item for external use.',
    setup: 'mod inner { pub fn hello() -> &\'static str { "hello" } }',
    setupCode: 'mod inner { pub fn hello() -> &\'static str { "hello" } }',
    expected: 'hello',
    sample: 'pub use inner::hello; hello()',
    hints: ['pub use re-exports publicly', 'Simplifies API surface', 'Hides internal structure'],
    tags: ['module', 'pub_use', 'reexport', 'hard'],
  },

  // ========================================
  // MORE ITERATOR METHODS
  // ========================================
  {
    id: 'rust-iter-337',
    category: 'Iterators',
    difficulty: 'medium',
    title: 'Last Element',
    text: 'Get the last element of iterator.',
    setup: 'let v = vec![1, 2, 3, 4, 5];',
    setupCode: 'let v = vec![1, 2, 3, 4, 5];',
    expected: 5,
    sample: 'v.iter().last().cloned().unwrap()',
    hints: ['.last() consumes entire iterator', 'Returns Option<T>', 'O(n) for most iterators'],
    tags: ['iterator', 'last', 'element', 'medium'],
  },
  {
    id: 'rust-iter-338',
    category: 'Iterators',
    difficulty: 'medium',
    title: 'Nth Element',
    text: 'Get the element at specific index.',
    setup: 'let v = vec![10, 20, 30, 40, 50];',
    setupCode: 'let v = vec![10, 20, 30, 40, 50];',
    expected: 30,
    sample: 'v.iter().nth(2).cloned().unwrap()',
    hints: [
      '.nth(n) gets n-th element (0-indexed)',
      'Consumes elements up to n',
      'Returns Option<T>',
    ],
    tags: ['iterator', 'nth', 'index', 'medium'],
  },
  {
    id: 'rust-iter-339',
    category: 'Iterators',
    difficulty: 'easy',
    title: 'Take First N',
    text: 'Take first 3 elements from iterator.',
    setup: 'let v = vec![1, 2, 3, 4, 5];',
    setupCode: 'let v = vec![1, 2, 3, 4, 5];',
    expected: [1, 2, 3],
    sample: 'v.iter().take(3).cloned().collect::<Vec<_>>()',
    hints: ['.take(n) limits to first n', 'Creates new iterator', 'Original not consumed'],
    tags: ['iterator', 'take', 'limit', 'basics'],
  },
  {
    id: 'rust-iter-340',
    category: 'Iterators',
    difficulty: 'easy',
    title: 'Skip First N',
    text: 'Skip first 2 elements from iterator.',
    setup: 'let v = vec![1, 2, 3, 4, 5];',
    setupCode: 'let v = vec![1, 2, 3, 4, 5];',
    expected: [3, 4, 5],
    sample: 'v.iter().skip(2).cloned().collect::<Vec<_>>()',
    hints: [
      '.skip(n) skips first n elements',
      'Creates new iterator',
      'Remaining elements available',
    ],
    tags: ['iterator', 'skip', 'offset', 'basics'],
  },
  {
    id: 'rust-iter-341',
    category: 'Iterators',
    difficulty: 'hard',
    title: 'Cloned Iterator',
    text: 'Clone referenced elements.',
    setup: 'let v = vec![1, 2, 3];',
    setupCode: 'let v = vec![1, 2, 3];',
    expected: [1, 2, 3],
    sample: 'v.iter().cloned().collect::<Vec<_>>()',
    hints: ['.cloned() clones each element', 'Converts &T to T', 'T must implement Clone'],
    tags: ['iterator', 'cloned', 'clone', 'hard'],
  },
  {
    id: 'rust-iter-342',
    category: 'Iterators',
    difficulty: 'hard',
    title: 'Copied Iterator',
    text: 'Copy referenced elements.',
    setup: 'let v = vec![1, 2, 3];',
    setupCode: 'let v = vec![1, 2, 3];',
    expected: [1, 2, 3],
    sample: 'v.iter().copied().collect::<Vec<_>>()',
    hints: ['.copied() copies each element', 'Converts &T to T', 'T must implement Copy'],
    tags: ['iterator', 'copied', 'copy', 'hard'],
  },
  {
    id: 'rust-iter-343',
    category: 'Iterators',
    difficulty: 'medium',
    title: 'Fuse Iterator',
    text: 'Create iterator that stops after first None.',
    setup:
      'struct OnceIter { done: bool } impl Iterator for OnceIter { type Item = i32; fn next(&mut self) -> Option<i32> { if self.done { None } else { self.done = true; Some(1) } } }',
    setupCode:
      'struct OnceIter { done: bool } impl Iterator for OnceIter { type Item = i32; fn next(&mut self) -> Option<i32> { if self.done { None } else { self.done = true; Some(1) } } }',
    expected: 1,
    sample: 'let iter = OnceIter { done: false }; iter.fuse().count()',
    hints: [
      '.fuse() ensures None is final',
      'After first None, always None',
      'Safe for repeated calls',
    ],
    tags: ['iterator', 'fuse', 'safety', 'medium'],
  },

  // ========================================
  // BEGINNER FUNDAMENTALS
  // ========================================
  {
    id: 'rs-beginner-loop-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Sum Numbers with For Loop',
    text: 'Use a for loop to sum all numbers from 1 to 10.',
    setup: '',
    setupCode: '',
    expected: 55,
    sample: 'let mut sum = 0; for i in 1..=10 { sum += i; } sum',
    hints: [
      'Use mut for mutable variable',
      'Use 1..=10 for inclusive range',
      'Add each number to sum',
    ],
    tags: ['beginner', 'for-loop', 'sum'],
  },
  {
    id: 'rs-beginner-loop-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Count Even Numbers',
    text: 'Use a for loop to count how many even numbers are between 1 and 20.',
    setup: '',
    setupCode: '',
    expected: 10,
    sample: 'let mut count = 0; for i in 1..=20 { if i % 2 == 0 { count += 1; } } count',
    hints: [
      'Initialize count to 0',
      'Use modulo % to check for even',
      'Even numbers have remainder 0 when divided by 2',
    ],
    tags: ['beginner', 'for-loop', 'conditionals'],
  },
  {
    id: 'rs-beginner-loop-003',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Build a String with Loop',
    text: 'Use a for loop to build a string "123456789" by concatenating numbers 1 through 9.',
    setup: '',
    setupCode: '',
    expected: '123456789',
    sample: 'let mut s = String::new(); for i in 1..=9 { s.push_str(&i.to_string()); } s',
    hints: [
      'Use String::new() for mutable string',
      'Use push_str to append',
      'Convert number to string with to_string()',
    ],
    tags: ['beginner', 'for-loop', 'strings'],
  },
  {
    id: 'rs-beginner-loop-004',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Factorial with While Loop',
    text: 'Use a while loop to calculate the factorial of 5 (5! = 120).',
    setup: '',
    setupCode: '',
    expected: 120,
    sample: 'let mut result = 1; let mut n = 5; while n > 0 { result *= n; n -= 1; } result',
    hints: [
      'Initialize result to 1',
      'Multiply result by n each iteration',
      'Decrement n until it reaches 0',
    ],
    tags: ['beginner', 'while-loop', 'factorial'],
  },
  {
    id: 'rs-beginner-cond-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Check Positive or Negative',
    text: 'Use if/else to return "positive" if number is greater than 0, "negative" if less than 0, or "zero".',
    setup: 'let number = 5;',
    setupCode: 'let number = 5;',
    expected: 'positive',
    sample: 'if number > 0 { "positive" } else if number < 0 { "negative" } else { "zero" }',
    hints: [
      'Use if/else if/else chain',
      'Check > 0 first, then < 0',
      'Return string slices directly',
    ],
    tags: ['beginner', 'if-else', 'conditionals'],
  },
  {
    id: 'rs-beginner-cond-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Find Maximum of Two',
    text: 'Use if/else to return the larger of two numbers.',
    setup: 'let a = 15; let b = 8;',
    setupCode: 'let a = 15; let b = 8;',
    expected: 15,
    sample: 'if a > b { a } else { b }',
    hints: [
      'Compare a and b directly',
      'Return the larger value',
      'if/else is an expression in Rust',
    ],
    tags: ['beginner', 'if-else', 'comparison'],
  },
  {
    id: 'rs-beginner-cond-003',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Grade Calculator',
    text: 'Return letter grade: A for score >= 90, B for >= 80, C for >= 70, D for >= 60, F otherwise.',
    setup: 'let score = 85;',
    setupCode: 'let score = 85;',
    expected: 'B',
    sample:
      'if score >= 90 { "A" } else if score >= 80 { "B" } else if score >= 70 { "C" } else if score >= 60 { "D" } else { "F" }',
    hints: [
      'Check from highest to lowest',
      'Use if/else if chain',
      'Return string slice for grade',
    ],
    tags: ['beginner', 'if-else', 'grades'],
  },
  {
    id: 'rs-beginner-vec-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Create and Sum Vector',
    text: 'Create a vector with values 1, 2, 3, 4, 5 and sum all elements.',
    setup: '',
    setupCode: '',
    expected: 15,
    sample: 'let v = vec![1, 2, 3, 4, 5]; v.iter().sum::<i32>()',
    hints: [
      'Use vec! macro to create vector',
      'Use iter() to iterate',
      'Use sum() to add all elements',
    ],
    tags: ['beginner', 'vec', 'sum'],
  },
  {
    id: 'rs-beginner-vec-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Push and Get Length',
    text: 'Create an empty vector, push 3 elements (10, 20, 30), and return its length.',
    setup: '',
    setupCode: '',
    expected: 3,
    sample: 'let mut v: Vec<i32> = Vec::new(); v.push(10); v.push(20); v.push(30); v.len()',
    hints: [
      'Use Vec::new() for empty vector',
      'Use push() to add elements',
      'Use len() to get size',
    ],
    tags: ['beginner', 'vec', 'push', 'len'],
  },
  {
    id: 'rs-beginner-vec-003',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Access Vector Element',
    text: 'Given a vector, safely get the element at index 2 or return 0 if not found.',
    setup: 'let v = vec![10, 20, 30, 40];',
    setupCode: 'let v = vec![10, 20, 30, 40];',
    expected: 30,
    sample: '*v.get(2).unwrap_or(&0)',
    hints: [
      'Use get() for safe access',
      'get() returns Option<&T>',
      'Use unwrap_or for default value',
    ],
    tags: ['beginner', 'vec', 'get', 'option'],
  },
  {
    id: 'rs-beginner-hashmap-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Create and Access HashMap',
    text: 'Create a HashMap with key "apple" = 3 and return the value for "apple".',
    setup: 'use std::collections::HashMap;',
    setupCode: 'use std::collections::HashMap;',
    expected: 3,
    sample: 'let mut map = HashMap::new(); map.insert("apple", 3); *map.get("apple").unwrap()',
    hints: [
      'Use HashMap::new() to create',
      'Use insert() to add entries',
      'Use get() to retrieve values',
    ],
    tags: ['beginner', 'hashmap', 'insert', 'get'],
  },
  {
    id: 'rs-beginner-hashmap-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Count HashMap Entries',
    text: 'Create a HashMap with 3 fruit entries and return its length.',
    setup: 'use std::collections::HashMap;',
    setupCode: 'use std::collections::HashMap;',
    expected: 3,
    sample:
      'let mut map = HashMap::new(); map.insert("apple", 1); map.insert("banana", 2); map.insert("cherry", 3); map.len()',
    hints: [
      'Insert three key-value pairs',
      'Use len() to count entries',
      'Each insert adds one entry',
    ],
    tags: ['beginner', 'hashmap', 'len'],
  },
  {
    id: 'rs-beginner-string-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'String Concatenation',
    text: 'Concatenate the strings "Hello, " and "World!" to form "Hello, World!".',
    setup: '',
    setupCode: '',
    expected: 'Hello, World!',
    sample: 'let s = String::from("Hello, ") + "World!"; s',
    hints: [
      'Use + operator with String and &str',
      'String::from() creates owned String',
      'Or use format!() macro',
    ],
    tags: ['beginner', 'string', 'concatenation'],
  },
  {
    id: 'rs-beginner-string-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'String Length',
    text: 'Return the length of the string "Rust".',
    setup: '',
    setupCode: '',
    expected: 4,
    sample: '"Rust".len()',
    hints: [
      'Use .len() method on strings',
      'Returns number of bytes',
      'For char count use .chars().count()',
    ],
    tags: ['beginner', 'string', 'len'],
  },
  {
    id: 'rs-beginner-while-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Basic While Loop',
    text: 'Use a while loop to sum numbers from 1 to 5 and return the total.',
    setup: '',
    setupCode: '',
    expected: 15,
    sample: 'let mut sum = 0; let mut i = 1; while i <= 5 { sum += i; i += 1; } sum',
    hints: [
      'Initialize counter and sum as mutable',
      'while condition { body }',
      'Increment counter inside loop',
    ],
    tags: ['beginner', 'while', 'loop', 'sum'],
  },
  {
    id: 'rs-beginner-while-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Loop with Break',
    text: 'Use a loop to find the first number greater than 10 that is divisible by 3, starting from 1.',
    setup: '',
    setupCode: '',
    expected: 12,
    sample: 'let mut n = 1; loop { if n > 10 && n % 3 == 0 { break n; } n += 1; }',
    hints: [
      'Use loop { } for infinite loop',
      'break value returns from loop',
      'Check both conditions',
    ],
    tags: ['beginner', 'loop', 'break'],
  },
  {
    id: 'rs-beginner-vec-adv-001',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Vec Iterator Max',
    text: 'Find the maximum value in vec![3, 7, 2, 9, 4] using iterators.',
    setup: '',
    setupCode: '',
    expected: 9,
    sample: '*vec![3, 7, 2, 9, 4].iter().max().unwrap()',
    hints: [
      'Use .iter() to get iterator',
      'Use .max() to find maximum',
      'Returns Option<&T>, unwrap it',
    ],
    tags: ['beginner', 'vec', 'iterator', 'max'],
  },
  {
    id: 'rs-beginner-vec-adv-002',
    category: 'Beginner Fundamentals',
    difficulty: 'easy',
    title: 'Vec Contains',
    text: 'Check if vec![10, 20, 30, 40] contains the value 30.',
    setup: '',
    setupCode: '',
    expected: true,
    sample: 'vec![10, 20, 30, 40].contains(&30)',
    hints: ['Use .contains() method', 'Pass a reference to the value', 'Returns bool'],
    tags: ['beginner', 'vec', 'contains'],
  },
];

export default rustProblems;
