import type { Problem } from '../types';

/**
 * C programming language coding drill problems
 * Focus on standard library functions and common patterns
 * Note: C problems use pattern matching since we cannot execute C in browser
 */

export const cProblems: Problem[] = [
  // ============================================================
  // String Functions (string.h)
  // ============================================================
  {
    id: 'c-strlen',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Get String Length with strlen',
    text: 'Get the length of the string "Hello" using strlen()',
    setup: '#include <string.h>\nchar str[] = "Hello";',
    setupCode: '#include <string.h>\nchar str[] = "Hello";',
    expected: 'strlen(str)',
    sample: 'strlen(str)',
    hints: [
      'strlen returns the number of characters before null terminator',
      'Return type is size_t',
    ],
    validPatterns: [/strlen\s*\(\s*str\s*\)/],
    tags: ['strlen', 'string.h'],
  },
  {
    id: 'c-strcpy',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Copy String with strcpy',
    text: 'Copy the source string to the destination buffer using strcpy()',
    setup: '#include <string.h>\nchar src[] = "Hello";\nchar dest[20];',
    setupCode: '#include <string.h>\nchar src[] = "Hello";\nchar dest[20];',
    expected: 'strcpy(dest, src)',
    sample: 'strcpy(dest, src)',
    hints: ['strcpy(destination, source)', 'Destination must have enough space'],
    validPatterns: [/strcpy\s*\(\s*dest\s*,\s*src\s*\)/],
    tags: ['strcpy', 'string.h'],
  },
  {
    id: 'c-strncpy',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Safe String Copy with strncpy',
    text: 'Copy at most 5 characters from source to destination using strncpy()',
    setup: '#include <string.h>\nchar src[] = "Hello World";\nchar dest[6];',
    setupCode: '#include <string.h>\nchar src[] = "Hello World";\nchar dest[6];',
    expected: 'strncpy(dest, src, 5)',
    sample: 'strncpy(dest, src, 5)',
    hints: [
      'strncpy(dest, src, n) copies at most n characters',
      'May not null-terminate if src is longer than n',
    ],
    validPatterns: [/strncpy\s*\(\s*dest\s*,\s*src\s*,\s*5\s*\)/],
    tags: ['strncpy', 'string.h', 'safe'],
  },
  {
    id: 'c-strcat',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Concatenate Strings with strcat',
    text: 'Append the source string to the destination using strcat()',
    setup: '#include <string.h>\nchar dest[20] = "Hello ";\nchar src[] = "World";',
    setupCode: '#include <string.h>\nchar dest[20] = "Hello ";\nchar src[] = "World";',
    expected: 'strcat(dest, src)',
    sample: 'strcat(dest, src)',
    hints: [
      'strcat appends src to the end of dest',
      'dest must have enough space for both strings',
    ],
    validPatterns: [/strcat\s*\(\s*dest\s*,\s*src\s*\)/],
    tags: ['strcat', 'string.h'],
  },
  {
    id: 'c-strncat',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Safe String Concatenation with strncat',
    text: 'Append at most 3 characters from source to destination using strncat()',
    setup: '#include <string.h>\nchar dest[20] = "Hello ";\nchar src[] = "World";',
    setupCode: '#include <string.h>\nchar dest[20] = "Hello ";\nchar src[] = "World";',
    expected: 'strncat(dest, src, 3)',
    sample: 'strncat(dest, src, 3)',
    hints: ['strncat appends at most n characters', 'Always null-terminates the result'],
    validPatterns: [/strncat\s*\(\s*dest\s*,\s*src\s*,\s*3\s*\)/],
    tags: ['strncat', 'string.h', 'safe'],
  },
  {
    id: 'c-strcmp',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Compare Strings with strcmp',
    text: 'Compare two strings using strcmp()',
    setup: '#include <string.h>\nchar str1[] = "apple";\nchar str2[] = "banana";',
    setupCode: '#include <string.h>\nchar str1[] = "apple";\nchar str2[] = "banana";',
    expected: 'strcmp(str1, str2)',
    sample: 'strcmp(str1, str2)',
    hints: [
      'Returns 0 if equal, negative if str1 < str2, positive if str1 > str2',
      'Comparison is lexicographic',
    ],
    validPatterns: [/strcmp\s*\(\s*str1\s*,\s*str2\s*\)/],
    tags: ['strcmp', 'string.h'],
  },
  {
    id: 'c-strncmp',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Compare N Characters with strncmp',
    text: 'Compare only the first 3 characters of the strings using strncmp()',
    setup: '#include <string.h>\nchar str1[] = "Hello World";\nchar str2[] = "Hello There";',
    setupCode: '#include <string.h>\nchar str1[] = "Hello World";\nchar str2[] = "Hello There";',
    expected: 'strncmp(str1, str2, 3)',
    sample: 'strncmp(str1, str2, 3)',
    hints: ['strncmp compares at most n characters', 'Useful for prefix comparisons'],
    validPatterns: [/strncmp\s*\(\s*str1\s*,\s*str2\s*,\s*3\s*\)/],
    tags: ['strncmp', 'string.h'],
  },
  {
    id: 'c-strchr',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Find Character with strchr',
    text: 'Find the first occurrence of character "o" in the string',
    setup: '#include <string.h>\nchar str[] = "Hello World";',
    setupCode: '#include <string.h>\nchar str[] = "Hello World";',
    expected: "strchr(str, 'o')",
    sample: "strchr(str, 'o')",
    hints: ['strchr returns pointer to first occurrence', 'Returns NULL if not found'],
    validPatterns: [/strchr\s*\(\s*str\s*,\s*['"]?o['"]?\s*\)/],
    tags: ['strchr', 'string.h'],
  },
  {
    id: 'c-strrchr',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Find Last Character with strrchr',
    text: 'Find the last occurrence of character "o" in the string',
    setup: '#include <string.h>\nchar str[] = "Hello World";',
    setupCode: '#include <string.h>\nchar str[] = "Hello World";',
    expected: "strrchr(str, 'o')",
    sample: "strrchr(str, 'o')",
    hints: ['strrchr searches from the end', 'Returns pointer to last occurrence'],
    validPatterns: [/strrchr\s*\(\s*str\s*,\s*['"]?o['"]?\s*\)/],
    tags: ['strrchr', 'string.h'],
  },
  {
    id: 'c-strstr',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Find Substring with strstr',
    text: 'Find the substring "World" in the string',
    setup: '#include <string.h>\nchar str[] = "Hello World";',
    setupCode: '#include <string.h>\nchar str[] = "Hello World";',
    expected: 'strstr(str, "World")',
    sample: 'strstr(str, "World")',
    hints: ['strstr returns pointer to first occurrence of substring', 'Returns NULL if not found'],
    validPatterns: [/strstr\s*\(\s*str\s*,\s*["']World["']\s*\)/],
    tags: ['strstr', 'string.h'],
  },
  {
    id: 'c-memcpy',
    category: 'Memory Functions',
    difficulty: 'medium',
    title: 'Copy Memory with memcpy',
    text: 'Copy 5 bytes from source to destination using memcpy()',
    setup: '#include <string.h>\nchar src[] = "Hello";\nchar dest[10];',
    setupCode: '#include <string.h>\nchar src[] = "Hello";\nchar dest[10];',
    expected: 'memcpy(dest, src, 5)',
    sample: 'memcpy(dest, src, 5)',
    hints: ['memcpy(dest, src, n) copies n bytes', 'Does not handle overlapping memory'],
    validPatterns: [/memcpy\s*\(\s*dest\s*,\s*src\s*,\s*5\s*\)/],
    tags: ['memcpy', 'string.h', 'memory'],
  },
  {
    id: 'c-memmove',
    category: 'Memory Functions',
    difficulty: 'medium',
    title: 'Move Memory with memmove',
    text: 'Safely copy overlapping memory regions using memmove()',
    setup: '#include <string.h>\nchar str[] = "Hello World";\n// Move "World" to start',
    setupCode: '#include <string.h>\nchar str[] = "Hello World";',
    expected: 'memmove(str, str + 6, 5)',
    sample: 'memmove(str, str + 6, 5)',
    hints: [
      'memmove handles overlapping memory safely',
      'Use when source and destination may overlap',
    ],
    validPatterns: [/memmove\s*\(\s*str\s*,\s*str\s*\+\s*6\s*,\s*5\s*\)/],
    tags: ['memmove', 'string.h', 'memory'],
  },
  {
    id: 'c-memset',
    category: 'Memory Functions',
    difficulty: 'easy',
    title: 'Initialize Memory with memset',
    text: 'Set the first 10 bytes of the buffer to zero using memset()',
    setup: '#include <string.h>\nchar buffer[20];',
    setupCode: '#include <string.h>\nchar buffer[20];',
    expected: 'memset(buffer, 0, 10)',
    sample: 'memset(buffer, 0, 10)',
    hints: ['memset(ptr, value, n) sets n bytes to value', 'Commonly used for zeroing memory'],
    validPatterns: [/memset\s*\(\s*buffer\s*,\s*0\s*,\s*10\s*\)/],
    tags: ['memset', 'string.h', 'memory'],
  },
  {
    id: 'c-memcmp',
    category: 'Memory Functions',
    difficulty: 'easy',
    title: 'Compare Memory with memcmp',
    text: 'Compare the first 5 bytes of two memory regions',
    setup: '#include <string.h>\nchar a[] = "Hello";\nchar b[] = "Hello World";',
    setupCode: '#include <string.h>\nchar a[] = "Hello";\nchar b[] = "Hello World";',
    expected: 'memcmp(a, b, 5)',
    sample: 'memcmp(a, b, 5)',
    hints: ['memcmp compares n bytes', 'Returns 0 if equal, like strcmp'],
    validPatterns: [/memcmp\s*\(\s*a\s*,\s*b\s*,\s*5\s*\)/],
    tags: ['memcmp', 'string.h', 'memory'],
  },

  // ============================================================
  // Standard Library (stdlib.h)
  // ============================================================
  {
    id: 'c-malloc',
    category: 'Memory Allocation',
    difficulty: 'medium',
    title: 'Allocate Memory with malloc',
    text: 'Allocate memory for 10 integers using malloc()',
    setup: '#include <stdlib.h>',
    setupCode: '#include <stdlib.h>',
    expected: 'malloc(10 * sizeof(int))',
    sample: 'int *arr = (int *)malloc(10 * sizeof(int))',
    hints: ['malloc returns void*, cast to appropriate type', 'Always use sizeof for portability'],
    validPatterns: [/malloc\s*\(\s*10\s*\*\s*sizeof\s*\(\s*int\s*\)\s*\)/],
    tags: ['malloc', 'stdlib.h', 'memory'],
  },
  {
    id: 'c-calloc',
    category: 'Memory Allocation',
    difficulty: 'medium',
    title: 'Allocate Zeroed Memory with calloc',
    text: 'Allocate and zero-initialize memory for 10 integers using calloc()',
    setup: '#include <stdlib.h>',
    setupCode: '#include <stdlib.h>',
    expected: 'calloc(10, sizeof(int))',
    sample: 'int *arr = (int *)calloc(10, sizeof(int))',
    hints: ['calloc(n, size) allocates n elements of size bytes', 'Memory is zero-initialized'],
    validPatterns: [/calloc\s*\(\s*10\s*,\s*sizeof\s*\(\s*int\s*\)\s*\)/],
    tags: ['calloc', 'stdlib.h', 'memory'],
  },
  {
    id: 'c-realloc',
    category: 'Memory Allocation',
    difficulty: 'medium',
    title: 'Resize Memory with realloc',
    text: 'Resize the allocated array to hold 20 integers using realloc()',
    setup: '#include <stdlib.h>\nint *arr = (int *)malloc(10 * sizeof(int));',
    setupCode: '#include <stdlib.h>\nint *arr = (int *)malloc(10 * sizeof(int));',
    expected: 'realloc(arr, 20 * sizeof(int))',
    sample: 'arr = (int *)realloc(arr, 20 * sizeof(int))',
    hints: ['realloc may move the memory block', 'Original contents are preserved'],
    validPatterns: [/realloc\s*\(\s*arr\s*,\s*20\s*\*\s*sizeof\s*\(\s*int\s*\)\s*\)/],
    tags: ['realloc', 'stdlib.h', 'memory'],
  },
  {
    id: 'c-free',
    category: 'Memory Allocation',
    difficulty: 'easy',
    title: 'Free Allocated Memory',
    text: 'Free the dynamically allocated memory',
    setup: '#include <stdlib.h>\nint *arr = (int *)malloc(10 * sizeof(int));',
    setupCode: '#include <stdlib.h>\nint *arr = (int *)malloc(10 * sizeof(int));',
    expected: 'free(arr)',
    sample: 'free(arr)',
    hints: [
      'Always free allocated memory when done',
      'Set pointer to NULL after freeing to avoid dangling pointer',
    ],
    validPatterns: [/free\s*\(\s*arr\s*\)/],
    tags: ['free', 'stdlib.h', 'memory'],
  },
  {
    id: 'c-atoi',
    category: 'Conversion Functions',
    difficulty: 'easy',
    title: 'Convert String to Integer with atoi',
    text: 'Convert the string "42" to an integer using atoi()',
    setup: '#include <stdlib.h>\nchar str[] = "42";',
    setupCode: '#include <stdlib.h>\nchar str[] = "42";',
    expected: 'atoi(str)',
    sample: 'int num = atoi(str)',
    hints: ['atoi returns 0 on failure', 'Consider strtol for better error handling'],
    validPatterns: [/atoi\s*\(\s*str\s*\)/],
    tags: ['atoi', 'stdlib.h', 'conversion'],
  },
  {
    id: 'c-atof',
    category: 'Conversion Functions',
    difficulty: 'easy',
    title: 'Convert String to Float with atof',
    text: 'Convert the string "3.14" to a double using atof()',
    setup: '#include <stdlib.h>\nchar str[] = "3.14";',
    setupCode: '#include <stdlib.h>\nchar str[] = "3.14";',
    expected: 'atof(str)',
    sample: 'double num = atof(str)',
    hints: ['atof returns double, not float', 'Returns 0.0 on failure'],
    validPatterns: [/atof\s*\(\s*str\s*\)/],
    tags: ['atof', 'stdlib.h', 'conversion'],
  },
  {
    id: 'c-strtol',
    category: 'Conversion Functions',
    difficulty: 'medium',
    title: 'Convert String to Long with strtol',
    text: 'Convert the string "255" to a long integer with base 10 using strtol()',
    setup: '#include <stdlib.h>\nchar str[] = "255";\nchar *endptr;',
    setupCode: '#include <stdlib.h>\nchar str[] = "255";\nchar *endptr;',
    expected: 'strtol(str, &endptr, 10)',
    sample: 'long num = strtol(str, &endptr, 10)',
    hints: [
      'strtol provides better error handling than atoi',
      'Third argument is the base (2-36, or 0 for auto)',
    ],
    validPatterns: [
      /strtol\s*\(\s*str\s*,\s*&?endptr\s*,\s*10\s*\)/,
      /strtol\s*\(\s*str\s*,\s*NULL\s*,\s*10\s*\)/,
    ],
    tags: ['strtol', 'stdlib.h', 'conversion'],
  },
  {
    id: 'c-abs',
    category: 'Math Functions',
    difficulty: 'easy',
    title: 'Absolute Value with abs',
    text: 'Get the absolute value of -42 using abs()',
    setup: '#include <stdlib.h>\nint num = -42;',
    setupCode: '#include <stdlib.h>\nint num = -42;',
    expected: 'abs(num)',
    sample: 'int result = abs(num)',
    hints: ['abs works with integers', 'Use fabs from math.h for floating point'],
    validPatterns: [/abs\s*\(\s*num\s*\)/],
    tags: ['abs', 'stdlib.h', 'math'],
  },
  {
    id: 'c-qsort',
    category: 'Algorithm Functions',
    difficulty: 'hard',
    title: 'Sort Array with qsort',
    text: 'Sort the integer array in ascending order using qsort()',
    setup:
      '#include <stdlib.h>\nint arr[] = {5, 2, 8, 1, 9};\nint n = 5;\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}',
    setupCode:
      '#include <stdlib.h>\nint arr[] = {5, 2, 8, 1, 9};\nint n = 5;\nint compare(const void *a, const void *b) { return (*(int*)a - *(int*)b); }',
    expected: 'qsort(arr, n, sizeof(int), compare)',
    sample: 'qsort(arr, n, sizeof(int), compare)',
    hints: [
      'qsort(array, count, size, comparator)',
      'Comparator returns negative, zero, or positive',
    ],
    validPatterns: [/qsort\s*\(\s*arr\s*,\s*n\s*,\s*sizeof\s*\(\s*int\s*\)\s*,\s*compare\s*\)/],
    tags: ['qsort', 'stdlib.h', 'sorting'],
  },
  {
    id: 'c-bsearch',
    category: 'Algorithm Functions',
    difficulty: 'hard',
    title: 'Binary Search with bsearch',
    text: 'Search for the value 5 in the sorted array using bsearch()',
    setup:
      '#include <stdlib.h>\nint arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\nint n = 9;\nint key = 5;\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}',
    setupCode:
      '#include <stdlib.h>\nint arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\nint n = 9;\nint key = 5;\nint compare(const void *a, const void *b) { return (*(int*)a - *(int*)b); }',
    expected: 'bsearch(&key, arr, n, sizeof(int), compare)',
    sample: 'int *result = (int *)bsearch(&key, arr, n, sizeof(int), compare)',
    hints: ['bsearch requires a sorted array', 'Returns NULL if not found'],
    validPatterns: [
      /bsearch\s*\(\s*&key\s*,\s*arr\s*,\s*n\s*,\s*sizeof\s*\(\s*int\s*\)\s*,\s*compare\s*\)/,
    ],
    tags: ['bsearch', 'stdlib.h', 'searching'],
  },
  {
    id: 'c-rand',
    category: 'Random Functions',
    difficulty: 'easy',
    title: 'Generate Random Number',
    text: 'Generate a random number between 0 and RAND_MAX',
    setup: '#include <stdlib.h>',
    setupCode: '#include <stdlib.h>',
    expected: 'rand()',
    sample: 'int random = rand()',
    hints: ['rand() returns int from 0 to RAND_MAX', 'Use srand() to seed the generator'],
    validPatterns: [/rand\s*\(\s*\)/],
    tags: ['rand', 'stdlib.h', 'random'],
  },
  {
    id: 'c-srand',
    category: 'Random Functions',
    difficulty: 'easy',
    title: 'Seed Random Generator',
    text: 'Seed the random number generator with current time',
    setup: '#include <stdlib.h>\n#include <time.h>',
    setupCode: '#include <stdlib.h>\n#include <time.h>',
    expected: 'srand(time(NULL))',
    sample: 'srand(time(NULL))',
    hints: ['srand sets the seed for rand()', 'time(NULL) provides varying seed'],
    validPatterns: [/srand\s*\(\s*time\s*\(\s*NULL\s*\)\s*\)/],
    tags: ['srand', 'stdlib.h', 'random'],
  },

  // ============================================================
  // stdio.h Patterns
  // ============================================================
  {
    id: 'c-sprintf',
    category: 'Format Functions',
    difficulty: 'medium',
    title: 'Format String with sprintf',
    text: 'Format an integer into a string buffer using sprintf()',
    setup: '#include <stdio.h>\nchar buffer[50];\nint num = 42;',
    setupCode: '#include <stdio.h>\nchar buffer[50];\nint num = 42;',
    expected: 'sprintf(buffer, "%d", num)',
    sample: 'sprintf(buffer, "%d", num)',
    hints: ['sprintf writes formatted output to string', 'Buffer must be large enough'],
    validPatterns: [/sprintf\s*\(\s*buffer\s*,\s*['"]%d['"]\s*,\s*num\s*\)/],
    tags: ['sprintf', 'stdio.h', 'format'],
  },
  {
    id: 'c-snprintf',
    category: 'Format Functions',
    difficulty: 'medium',
    title: 'Safe Format with snprintf',
    text: 'Safely format a string with maximum buffer size using snprintf()',
    setup: '#include <stdio.h>\nchar buffer[20];\nint num = 42;',
    setupCode: '#include <stdio.h>\nchar buffer[20];\nint num = 42;',
    expected: 'snprintf(buffer, sizeof(buffer), "%d", num)',
    sample: 'snprintf(buffer, sizeof(buffer), "%d", num)',
    hints: ['snprintf prevents buffer overflow', 'Second argument is maximum bytes to write'],
    validPatterns: [
      /snprintf\s*\(\s*buffer\s*,\s*(sizeof\s*\(\s*buffer\s*\)|20)\s*,\s*['"]%d['"]\s*,\s*num\s*\)/,
    ],
    tags: ['snprintf', 'stdio.h', 'format', 'safe'],
  },
  {
    id: 'c-sscanf',
    category: 'Format Functions',
    difficulty: 'medium',
    title: 'Parse String with sscanf',
    text: 'Parse an integer from a string using sscanf()',
    setup: '#include <stdio.h>\nchar str[] = "42";\nint num;',
    setupCode: '#include <stdio.h>\nchar str[] = "42";\nint num;',
    expected: 'sscanf(str, "%d", &num)',
    sample: 'sscanf(str, "%d", &num)',
    hints: [
      'sscanf reads formatted input from string',
      'Returns number of items successfully read',
    ],
    validPatterns: [/sscanf\s*\(\s*str\s*,\s*['"]%d['"]\s*,\s*&num\s*\)/],
    tags: ['sscanf', 'stdio.h', 'parse'],
  },
  {
    id: 'c-printf-format',
    category: 'Format Functions',
    difficulty: 'easy',
    title: 'Printf with Multiple Format Specifiers',
    text: 'Print name and age using printf with format specifiers',
    setup: '#include <stdio.h>\nchar name[] = "Alice";\nint age = 30;',
    setupCode: '#include <stdio.h>\nchar name[] = "Alice";\nint age = 30;',
    expected: 'printf("%s is %d years old", name, age)',
    sample: 'printf("%s is %d years old\\n", name, age)',
    hints: ['%s for strings, %d for integers', 'Arguments must match format specifiers'],
    validPatterns: [/printf\s*\(\s*["'].*%s.*%d.*["']\s*,\s*name\s*,\s*age\s*\)/],
    tags: ['printf', 'stdio.h', 'format'],
  },

  // ============================================================
  // Array Operations (Manual Implementations)
  // ============================================================
  {
    id: 'c-array-max',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Find Maximum in Array',
    text: 'Write code to find the maximum value in an integer array',
    setup: 'int arr[] = {3, 1, 4, 1, 5, 9, 2, 6};\nint n = 8;',
    setupCode: 'int arr[] = {3, 1, 4, 1, 5, 9, 2, 6};\nint n = 8;',
    expected: '9',
    sample:
      'int max = arr[0];\nfor (int i = 1; i < n; i++) {\n    if (arr[i] > max) max = arr[i];\n}',
    hints: ['Initialize max with first element', 'Compare each element with current max'],
    validPatterns: [/for\s*\([^)]+\)/, /if\s*\([^)]*>\s*max/, /max\s*=\s*arr\s*\[/],
    tags: ['array', 'max', 'loop'],
  },
  {
    id: 'c-array-min',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Find Minimum in Array',
    text: 'Write code to find the minimum value in an integer array',
    setup: 'int arr[] = {3, 1, 4, 1, 5, 9, 2, 6};\nint n = 8;',
    setupCode: 'int arr[] = {3, 1, 4, 1, 5, 9, 2, 6};\nint n = 8;',
    expected: '1',
    sample:
      'int min = arr[0];\nfor (int i = 1; i < n; i++) {\n    if (arr[i] < min) min = arr[i];\n}',
    hints: ['Initialize min with first element', 'Compare each element with current min'],
    validPatterns: [/for\s*\([^)]+\)/, /if\s*\([^)]*<\s*min/, /min\s*=\s*arr\s*\[/],
    tags: ['array', 'min', 'loop'],
  },
  {
    id: 'c-array-sum',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Sum Array Elements',
    text: 'Write code to calculate the sum of all elements in an integer array',
    setup: 'int arr[] = {1, 2, 3, 4, 5};\nint n = 5;',
    setupCode: 'int arr[] = {1, 2, 3, 4, 5};\nint n = 5;',
    expected: '15',
    sample: 'int sum = 0;\nfor (int i = 0; i < n; i++) {\n    sum += arr[i];\n}',
    hints: ['Initialize sum to 0', 'Add each element to sum'],
    validPatterns: [/for\s*\([^)]+\)/, /sum\s*\+=|sum\s*=\s*sum\s*\+/],
    tags: ['array', 'sum', 'loop'],
  },
  {
    id: 'c-array-reverse',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Reverse Array In-Place',
    text: 'Write code to reverse an array in place',
    setup: 'int arr[] = {1, 2, 3, 4, 5};\nint n = 5;',
    setupCode: 'int arr[] = {1, 2, 3, 4, 5};\nint n = 5;',
    expected: '{5, 4, 3, 2, 1}',
    sample:
      'for (int i = 0; i < n / 2; i++) {\n    int temp = arr[i];\n    arr[i] = arr[n - 1 - i];\n    arr[n - 1 - i] = temp;\n}',
    hints: ['Swap elements from both ends', 'Only iterate to middle of array'],
    validPatterns: [/for\s*\([^)]+n\s*\/\s*2/, /temp|swap/i, /arr\s*\[\s*n\s*-\s*1\s*-\s*i\s*\]/],
    tags: ['array', 'reverse', 'loop'],
  },
  {
    id: 'c-array-search-linear',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Linear Search in Array',
    text: 'Write code to find the index of a target value in an array (-1 if not found)',
    setup: 'int arr[] = {10, 20, 30, 40, 50};\nint n = 5;\nint target = 30;',
    setupCode: 'int arr[] = {10, 20, 30, 40, 50};\nint n = 5;\nint target = 30;',
    expected: '2',
    sample:
      'int index = -1;\nfor (int i = 0; i < n; i++) {\n    if (arr[i] == target) {\n        index = i;\n        break;\n    }\n}',
    hints: ['Initialize index to -1 for not found', 'Break when element is found'],
    validPatterns: [/for\s*\([^)]+\)/, /if\s*\([^)]*==\s*target/, /break/],
    tags: ['array', 'search', 'linear'],
  },
  {
    id: 'c-array-binary-search',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Binary Search Implementation',
    text: 'Write a binary search to find target in sorted array (-1 if not found)',
    setup: 'int arr[] = {1, 3, 5, 7, 9, 11, 13};\nint n = 7;\nint target = 7;',
    setupCode: 'int arr[] = {1, 3, 5, 7, 9, 11, 13};\nint n = 7;\nint target = 7;',
    expected: '3',
    sample:
      'int left = 0, right = n - 1, result = -1;\nwhile (left <= right) {\n    int mid = left + (right - left) / 2;\n    if (arr[mid] == target) { result = mid; break; }\n    else if (arr[mid] < target) left = mid + 1;\n    else right = mid - 1;\n}',
    hints: ['Use left, right, and mid pointers', 'Avoid overflow: mid = left + (right - left) / 2'],
    validPatterns: [/while\s*\([^)]*<=|for\s*\([^)]+\)/, /mid\s*=/, /left.*right|low.*high/i],
    tags: ['array', 'binary-search', 'algorithm'],
  },
  {
    id: 'c-array-copy',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Copy Array Elements',
    text: 'Write code to copy elements from source array to destination array',
    setup: 'int src[] = {1, 2, 3, 4, 5};\nint dest[5];\nint n = 5;',
    setupCode: 'int src[] = {1, 2, 3, 4, 5};\nint dest[5];\nint n = 5;',
    expected: 'dest = {1, 2, 3, 4, 5}',
    sample: 'for (int i = 0; i < n; i++) {\n    dest[i] = src[i];\n}',
    hints: ['Iterate through all elements', 'Can also use memcpy for this'],
    validPatterns: [/for\s*\([^)]+\)/, /dest\s*\[\s*i\s*\]\s*=\s*src\s*\[\s*i\s*\]/],
    tags: ['array', 'copy', 'loop'],
  },
  {
    id: 'c-array-count-occurrences',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Count Occurrences',
    text: 'Write code to count how many times a target value appears in the array',
    setup: 'int arr[] = {1, 2, 2, 3, 2, 4, 2};\nint n = 7;\nint target = 2;',
    setupCode: 'int arr[] = {1, 2, 2, 3, 2, 4, 2};\nint n = 7;\nint target = 2;',
    expected: '4',
    sample: 'int count = 0;\nfor (int i = 0; i < n; i++) {\n    if (arr[i] == target) count++;\n}',
    hints: ['Initialize counter to 0', 'Increment when element matches target'],
    validPatterns: [/for\s*\([^)]+\)/, /if\s*\([^)]*==\s*target/, /count\s*\+\+|count\s*\+=\s*1/],
    tags: ['array', 'count', 'loop'],
  },

  // ============================================================
  // Pointer Operations
  // ============================================================
  {
    id: 'c-pointer-swap',
    category: 'Pointer Operations',
    difficulty: 'medium',
    title: 'Swap Using Pointers',
    text: 'Write a swap function using pointers',
    setup: 'int a = 5, b = 10;',
    setupCode: 'int a = 5, b = 10;',
    expected: 'a = 10, b = 5',
    sample:
      'void swap(int *x, int *y) {\n    int temp = *x;\n    *x = *y;\n    *y = temp;\n}\nswap(&a, &b);',
    hints: ['Use pointers to modify values in caller', 'Dereference with * to access values'],
    validPatterns: [/\*\s*\w+\s*=\s*\*\s*\w+/, /temp|tmp/i, /&\w+/],
    tags: ['pointer', 'swap', 'function'],
  },
  {
    id: 'c-pointer-array-traverse',
    category: 'Pointer Operations',
    difficulty: 'medium',
    title: 'Traverse Array with Pointer',
    text: 'Sum array elements using pointer arithmetic',
    setup: 'int arr[] = {1, 2, 3, 4, 5};\nint n = 5;',
    setupCode: 'int arr[] = {1, 2, 3, 4, 5};\nint n = 5;',
    expected: '15',
    sample:
      'int sum = 0;\nint *ptr = arr;\nfor (int i = 0; i < n; i++) {\n    sum += *(ptr + i);\n}',
    hints: ['Array name is pointer to first element', 'ptr + i points to arr[i]'],
    validPatterns: [/\*\s*\(\s*ptr\s*\+|\*\s*ptr\s*\+\+|\*ptr\s*\+\+/, /ptr\s*=\s*arr/],
    tags: ['pointer', 'array', 'arithmetic'],
  },

  // ============================================================
  // Additional String Functions
  // ============================================================
  {
    id: 'c-strlen-manual',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Manual String Length Calculation',
    text: 'Write code to calculate string length without using strlen()',
    setup: 'char str[] = "Hello World";',
    setupCode: 'char str[] = "Hello World";',
    expected: '11',
    sample:
      'int len = 0;\nwhile (str[len] != \'\\0\') {\n    len++;\n}',
    hints: [
      'Strings in C are null-terminated',
      'Count characters until you hit the null terminator \\0',
    ],
    validPatterns: [/while\s*\([^)]*!=\s*['"]?\\0['"]?\s*\)|while\s*\(\s*str\s*\[/, /len\s*\+\+|len\s*\+=\s*1/],
    tags: ['strlen', 'string', 'manual', 'loop'],
  },
  {
    id: 'c-strcpy-manual',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Manual String Copy',
    text: 'Write code to copy src to dest without using strcpy()',
    setup: 'char src[] = "Hello";\nchar dest[20];',
    setupCode: 'char src[] = "Hello";\nchar dest[20];',
    expected: 'dest = "Hello"',
    sample:
      'int i = 0;\nwhile (src[i] != \'\\0\') {\n    dest[i] = src[i];\n    i++;\n}\ndest[i] = \'\\0\';',
    hints: [
      'Copy character by character until null terminator',
      'Remember to add null terminator to destination',
    ],
    validPatterns: [/while\s*\([^)]+\)|for\s*\([^)]+\)/, /dest\s*\[\s*\w+\s*\]\s*=\s*src\s*\[/, /dest\s*\[\s*\w+\s*\]\s*=\s*['"]?\\0['"]?/],
    tags: ['strcpy', 'string', 'manual', 'loop'],
  },
  {
    id: 'c-strcat-manual',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Manual String Concatenation',
    text: 'Write code to concatenate src to dest without using strcat()',
    setup: 'char dest[30] = "Hello ";\nchar src[] = "World";',
    setupCode: 'char dest[30] = "Hello ";\nchar src[] = "World";',
    expected: 'dest = "Hello World"',
    sample:
      'int i = 0, j = 0;\nwhile (dest[i] != \'\\0\') i++;\nwhile (src[j] != \'\\0\') {\n    dest[i++] = src[j++];\n}\ndest[i] = \'\\0\';',
    hints: [
      'First find the end of dest string',
      'Then copy src starting at that position',
    ],
    validPatterns: [/while\s*\([^)]*!=\s*['"]?\\0['"]?\s*\)/, /dest\s*\[\s*\w+\s*\]\s*=\s*src\s*\[/],
    tags: ['strcat', 'string', 'manual', 'loop'],
  },
  {
    id: 'c-strcmp-manual',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Manual String Comparison',
    text: 'Write code to compare str1 and str2 without using strcmp()',
    setup: 'char str1[] = "apple";\nchar str2[] = "banana";',
    setupCode: 'char str1[] = "apple";\nchar str2[] = "banana";',
    expected: 'negative value (str1 < str2)',
    sample:
      'int i = 0;\nwhile (str1[i] && str2[i] && str1[i] == str2[i]) i++;\nint result = str1[i] - str2[i];',
    hints: [
      'Compare character by character',
      'Stop when characters differ or string ends',
      'Return difference of characters at mismatch point',
    ],
    validPatterns: [/while\s*\([^)]+&&[^)]+==/, /str1\s*\[\s*\w+\s*\]\s*-\s*str2\s*\[/],
    tags: ['strcmp', 'string', 'manual', 'comparison'],
  },
  {
    id: 'c-strstr-manual',
    category: 'String Functions',
    difficulty: 'hard',
    title: 'Manual Substring Search',
    text: 'Write code to find needle in haystack without using strstr()',
    setup: 'char haystack[] = "Hello World";\nchar needle[] = "World";',
    setupCode: 'char haystack[] = "Hello World";\nchar needle[] = "World";',
    expected: 'pointer to "World" in haystack',
    sample:
      'char *result = NULL;\nfor (int i = 0; haystack[i]; i++) {\n    int j = 0;\n    while (needle[j] && haystack[i+j] == needle[j]) j++;\n    if (!needle[j]) { result = &haystack[i]; break; }\n}',
    hints: [
      'For each position in haystack, try to match needle',
      'If all characters of needle match, found it',
      'Return NULL if not found',
    ],
    validPatterns: [/for\s*\([^)]+\).*while|while\s*\([^)]+\).*for/, /haystack\s*\[\s*\w+\s*\+\s*\w+\s*\]\s*==\s*needle/],
    tags: ['strstr', 'string', 'manual', 'search'],
  },
  {
    id: 'c-strtok-basic',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Tokenize String with strtok',
    text: 'Split the string by comma delimiter using strtok()',
    setup: '#include <string.h>\nchar str[] = "apple,banana,cherry";',
    setupCode: '#include <string.h>\nchar str[] = "apple,banana,cherry";',
    expected: 'tokens: "apple", "banana", "cherry"',
    sample:
      'char *token = strtok(str, ",");\nwhile (token != NULL) {\n    // process token\n    token = strtok(NULL, ",");\n}',
    hints: [
      'First call uses the string, subsequent calls use NULL',
      'strtok modifies the original string',
      'Returns NULL when no more tokens',
    ],
    validPatterns: [/strtok\s*\(\s*str\s*,\s*["'],["']\s*\)/, /strtok\s*\(\s*NULL\s*,/],
    tags: ['strtok', 'string.h', 'tokenize'],
  },

  // ============================================================
  // Additional Memory Functions
  // ============================================================
  {
    id: 'c-memcpy-struct',
    category: 'Memory Functions',
    difficulty: 'medium',
    title: 'Copy Struct with memcpy',
    text: 'Copy the source struct to destination using memcpy()',
    setup: '#include <string.h>\nstruct Point { int x; int y; };\nstruct Point src = {10, 20};\nstruct Point dest;',
    setupCode: '#include <string.h>\nstruct Point { int x; int y; };\nstruct Point src = {10, 20};\nstruct Point dest;',
    expected: 'memcpy(&dest, &src, sizeof(struct Point))',
    sample: 'memcpy(&dest, &src, sizeof(struct Point))',
    hints: [
      'Use sizeof to get the struct size',
      'Pass addresses of structs with &',
    ],
    validPatterns: [/memcpy\s*\(\s*&dest\s*,\s*&src\s*,\s*sizeof\s*\(\s*(struct\s+)?Point\s*\)\s*\)/],
    tags: ['memcpy', 'string.h', 'struct', 'memory'],
  },
  {
    id: 'c-memset-pattern',
    category: 'Memory Functions',
    difficulty: 'easy',
    title: 'Fill Array with Pattern using memset',
    text: 'Fill the character buffer with the character "A" for 10 bytes',
    setup: '#include <string.h>\nchar buffer[20];',
    setupCode: '#include <string.h>\nchar buffer[20];',
    expected: "memset(buffer, 'A', 10)",
    sample: "memset(buffer, 'A', 10)",
    hints: [
      'memset sets each byte to the specified value',
      'Works well for char arrays and zeroing memory',
    ],
    validPatterns: [/memset\s*\(\s*buffer\s*,\s*['"]?A['"]?\s*,\s*10\s*\)/],
    tags: ['memset', 'string.h', 'memory'],
  },
  {
    id: 'c-memmove-overlap',
    category: 'Memory Functions',
    difficulty: 'hard',
    title: 'Handle Overlapping Memory with memmove',
    text: 'Shift array elements left by 2 positions using memmove() (overlapping regions)',
    setup: '#include <string.h>\nint arr[] = {1, 2, 3, 4, 5, 6, 7, 8};\nint n = 8;',
    setupCode: '#include <string.h>\nint arr[] = {1, 2, 3, 4, 5, 6, 7, 8};\nint n = 8;',
    expected: 'memmove(arr, arr + 2, (n - 2) * sizeof(int))',
    sample: 'memmove(arr, arr + 2, (n - 2) * sizeof(int))',
    hints: [
      'memmove safely handles overlapping source and destination',
      'Calculate byte count with sizeof',
      'Source is arr + 2, destination is arr',
    ],
    validPatterns: [/memmove\s*\(\s*arr\s*,\s*arr\s*\+\s*2\s*,\s*\(\s*n\s*-\s*2\s*\)\s*\*\s*sizeof\s*\(\s*int\s*\)\s*\)/],
    tags: ['memmove', 'string.h', 'memory', 'overlap'],
  },
  {
    id: 'c-memcmp-arrays',
    category: 'Memory Functions',
    difficulty: 'easy',
    title: 'Compare Integer Arrays with memcmp',
    text: 'Compare two integer arrays using memcmp()',
    setup: '#include <string.h>\nint arr1[] = {1, 2, 3, 4, 5};\nint arr2[] = {1, 2, 3, 4, 5};\nint n = 5;',
    setupCode: '#include <string.h>\nint arr1[] = {1, 2, 3, 4, 5};\nint arr2[] = {1, 2, 3, 4, 5};\nint n = 5;',
    expected: 'memcmp(arr1, arr2, n * sizeof(int))',
    sample: 'int result = memcmp(arr1, arr2, n * sizeof(int))',
    hints: [
      'memcmp compares raw bytes',
      'Calculate byte count as n * sizeof(element_type)',
      'Returns 0 if arrays are equal',
    ],
    validPatterns: [/memcmp\s*\(\s*arr1\s*,\s*arr2\s*,\s*n\s*\*\s*sizeof\s*\(\s*int\s*\)\s*\)/],
    tags: ['memcmp', 'string.h', 'memory', 'comparison'],
  },

  // ============================================================
  // Character Functions (ctype.h)
  // ============================================================
  {
    id: 'c-isalpha-check',
    category: 'Character Functions',
    difficulty: 'easy',
    title: 'Check if Character is Alphabetic',
    text: 'Check if the character is a letter using isalpha()',
    setup: '#include <ctype.h>\nchar ch = \'A\';',
    setupCode: '#include <ctype.h>\nchar ch = \'A\';',
    expected: 'isalpha(ch)',
    sample: 'if (isalpha(ch)) { /* is a letter */ }',
    hints: [
      'isalpha returns non-zero for a-z and A-Z',
      'Returns 0 for non-alphabetic characters',
    ],
    validPatterns: [/isalpha\s*\(\s*ch\s*\)/],
    tags: ['isalpha', 'ctype.h', 'character'],
  },
  {
    id: 'c-isdigit-check',
    category: 'Character Functions',
    difficulty: 'easy',
    title: 'Check if Character is Digit',
    text: 'Check if the character is a digit using isdigit()',
    setup: '#include <ctype.h>\nchar ch = \'5\';',
    setupCode: '#include <ctype.h>\nchar ch = \'5\';',
    expected: 'isdigit(ch)',
    sample: 'if (isdigit(ch)) { /* is a digit */ }',
    hints: [
      'isdigit returns non-zero for 0-9',
      'Returns 0 for non-digit characters',
    ],
    validPatterns: [/isdigit\s*\(\s*ch\s*\)/],
    tags: ['isdigit', 'ctype.h', 'character'],
  },
  {
    id: 'c-toupper-convert',
    category: 'Character Functions',
    difficulty: 'easy',
    title: 'Convert to Uppercase',
    text: 'Convert the lowercase character to uppercase using toupper()',
    setup: '#include <ctype.h>\nchar ch = \'a\';',
    setupCode: '#include <ctype.h>\nchar ch = \'a\';',
    expected: 'toupper(ch)',
    sample: 'char upper = toupper(ch)',
    hints: [
      'toupper converts lowercase to uppercase',
      'Non-lowercase characters are returned unchanged',
    ],
    validPatterns: [/toupper\s*\(\s*ch\s*\)/],
    tags: ['toupper', 'ctype.h', 'character'],
  },
  {
    id: 'c-tolower-convert',
    category: 'Character Functions',
    difficulty: 'easy',
    title: 'Convert to Lowercase',
    text: 'Convert the uppercase character to lowercase using tolower()',
    setup: '#include <ctype.h>\nchar ch = \'Z\';',
    setupCode: '#include <ctype.h>\nchar ch = \'Z\';',
    expected: 'tolower(ch)',
    sample: 'char lower = tolower(ch)',
    hints: [
      'tolower converts uppercase to lowercase',
      'Non-uppercase characters are returned unchanged',
    ],
    validPatterns: [/tolower\s*\(\s*ch\s*\)/],
    tags: ['tolower', 'ctype.h', 'character'],
  },
  {
    id: 'c-isspace-check',
    category: 'Character Functions',
    difficulty: 'easy',
    title: 'Check if Character is Whitespace',
    text: 'Check if the character is whitespace using isspace()',
    setup: '#include <ctype.h>\nchar ch = \' \';',
    setupCode: '#include <ctype.h>\nchar ch = \' \';',
    expected: 'isspace(ch)',
    sample: 'if (isspace(ch)) { /* is whitespace */ }',
    hints: [
      'isspace matches space, tab, newline, etc.',
      'Includes: space, \\t, \\n, \\v, \\f, \\r',
    ],
    validPatterns: [/isspace\s*\(\s*ch\s*\)/],
    tags: ['isspace', 'ctype.h', 'character'],
  },
  {
    id: 'c-string-uppercase',
    category: 'Character Functions',
    difficulty: 'medium',
    title: 'Convert String to Uppercase',
    text: 'Convert entire string to uppercase using toupper()',
    setup: '#include <ctype.h>\nchar str[] = "Hello World";',
    setupCode: '#include <ctype.h>\nchar str[] = "Hello World";',
    expected: 'str = "HELLO WORLD"',
    sample:
      'for (int i = 0; str[i]; i++) {\n    str[i] = toupper(str[i]);\n}',
    hints: [
      'Loop through each character',
      'Apply toupper to each character',
    ],
    validPatterns: [/for\s*\([^)]+\)|while\s*\([^)]+\)/, /str\s*\[\s*\w+\s*\]\s*=\s*toupper/],
    tags: ['toupper', 'ctype.h', 'string', 'loop'],
  },

  // ============================================================
  // Math Functions (math.h)
  // ============================================================
  {
    id: 'c-fabs-absolute',
    category: 'Math Functions',
    difficulty: 'easy',
    title: 'Floating Point Absolute Value',
    text: 'Get the absolute value of -3.14 using fabs()',
    setup: '#include <math.h>\ndouble num = -3.14;',
    setupCode: '#include <math.h>\ndouble num = -3.14;',
    expected: 'fabs(num)',
    sample: 'double result = fabs(num)',
    hints: [
      'fabs is for floating point (double)',
      'abs from stdlib.h is for integers',
    ],
    validPatterns: [/fabs\s*\(\s*num\s*\)/],
    tags: ['fabs', 'math.h', 'absolute'],
  },
  {
    id: 'c-pow-power',
    category: 'Math Functions',
    difficulty: 'easy',
    title: 'Calculate Power with pow',
    text: 'Calculate 2 raised to the power of 10 using pow()',
    setup: '#include <math.h>\ndouble base = 2.0;\ndouble exponent = 10.0;',
    setupCode: '#include <math.h>\ndouble base = 2.0;\ndouble exponent = 10.0;',
    expected: 'pow(base, exponent)',
    sample: 'double result = pow(base, exponent)',
    hints: [
      'pow(base, exponent) returns base^exponent',
      'Both arguments and return type are double',
    ],
    validPatterns: [/pow\s*\(\s*base\s*,\s*exponent\s*\)|pow\s*\(\s*2(\.0)?\s*,\s*10(\.0)?\s*\)/],
    tags: ['pow', 'math.h', 'power'],
  },
  {
    id: 'c-sqrt-root',
    category: 'Math Functions',
    difficulty: 'easy',
    title: 'Calculate Square Root',
    text: 'Calculate the square root of 16.0 using sqrt()',
    setup: '#include <math.h>\ndouble num = 16.0;',
    setupCode: '#include <math.h>\ndouble num = 16.0;',
    expected: 'sqrt(num)',
    sample: 'double result = sqrt(num)',
    hints: [
      'sqrt returns the square root as double',
      'Negative input results in NaN',
    ],
    validPatterns: [/sqrt\s*\(\s*num\s*\)|sqrt\s*\(\s*16(\.0)?\s*\)/],
    tags: ['sqrt', 'math.h', 'root'],
  },
  {
    id: 'c-ceil-floor',
    category: 'Math Functions',
    difficulty: 'medium',
    title: 'Ceiling and Floor Functions',
    text: 'Get the ceiling of 3.2 and floor of 3.8 using ceil() and floor()',
    setup: '#include <math.h>\ndouble a = 3.2;\ndouble b = 3.8;',
    setupCode: '#include <math.h>\ndouble a = 3.2;\ndouble b = 3.8;',
    expected: 'ceil(a) = 4.0, floor(b) = 3.0',
    sample: 'double ceiling = ceil(a);\ndouble floored = floor(b);',
    hints: [
      'ceil rounds up to nearest integer',
      'floor rounds down to nearest integer',
      'Both return double, not int',
    ],
    validPatterns: [/ceil\s*\(\s*a\s*\)/, /floor\s*\(\s*b\s*\)/],
    tags: ['ceil', 'floor', 'math.h', 'rounding'],
  },
  {
    id: 'c-fmod-remainder',
    category: 'Math Functions',
    difficulty: 'medium',
    title: 'Floating Point Modulo',
    text: 'Calculate the remainder of 5.5 divided by 2.0 using fmod()',
    setup: '#include <math.h>\ndouble a = 5.5;\ndouble b = 2.0;',
    setupCode: '#include <math.h>\ndouble a = 5.5;\ndouble b = 2.0;',
    expected: 'fmod(a, b)',
    sample: 'double remainder = fmod(a, b)',
    hints: [
      'fmod(x, y) returns remainder of x/y',
      '% operator only works for integers',
    ],
    validPatterns: [/fmod\s*\(\s*a\s*,\s*b\s*\)|fmod\s*\(\s*5\.5\s*,\s*2(\.0)?\s*\)/],
    tags: ['fmod', 'math.h', 'modulo'],
  },
  {
    id: 'c-distance-formula',
    category: 'Math Functions',
    difficulty: 'hard',
    title: 'Calculate Distance Between Points',
    text: 'Calculate Euclidean distance between two points using sqrt() and pow()',
    setup: '#include <math.h>\ndouble x1 = 0.0, y1 = 0.0;\ndouble x2 = 3.0, y2 = 4.0;',
    setupCode: '#include <math.h>\ndouble x1 = 0.0, y1 = 0.0;\ndouble x2 = 3.0, y2 = 4.0;',
    expected: '5.0',
    sample: 'double distance = sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));',
    hints: [
      'Distance formula: sqrt((x2-x1)^2 + (y2-y1)^2)',
      'Use pow(value, 2) to square',
    ],
    validPatterns: [/sqrt\s*\(\s*pow\s*\([^)]+,\s*2\s*\)\s*\+\s*pow\s*\([^)]+,\s*2\s*\)\s*\)/],
    tags: ['sqrt', 'pow', 'math.h', 'geometry'],
  },

  // ============================================================
  // Standard I/O Functions
  // ============================================================
  {
    id: 'c-sprintf-formatted',
    category: 'Standard I/O',
    difficulty: 'medium',
    title: 'Format Multiple Values with sprintf',
    text: 'Format name and score into a string buffer using sprintf()',
    setup: '#include <stdio.h>\nchar buffer[100];\nchar name[] = "Alice";\nint score = 95;',
    setupCode: '#include <stdio.h>\nchar buffer[100];\nchar name[] = "Alice";\nint score = 95;',
    expected: 'sprintf(buffer, "%s scored %d points", name, score)',
    sample: 'sprintf(buffer, "%s scored %d points", name, score)',
    hints: [
      'sprintf writes formatted string to buffer',
      'Use %s for strings, %d for integers',
    ],
    validPatterns: [/sprintf\s*\(\s*buffer\s*,\s*["'][^"']*%s[^"']*%d[^"']*["']\s*,\s*name\s*,\s*score\s*\)/],
    tags: ['sprintf', 'stdio.h', 'format'],
  },
  {
    id: 'c-sscanf-multiple',
    category: 'Standard I/O',
    difficulty: 'hard',
    title: 'Parse Multiple Values with sscanf',
    text: 'Parse date components (day, month, year) from string using sscanf()',
    setup: '#include <stdio.h>\nchar date[] = "25-12-2024";\nint day, month, year;',
    setupCode: '#include <stdio.h>\nchar date[] = "25-12-2024";\nint day, month, year;',
    expected: 'sscanf(date, "%d-%d-%d", &day, &month, &year)',
    sample: 'sscanf(date, "%d-%d-%d", &day, &month, &year)',
    hints: [
      'sscanf parses formatted input from string',
      'Use & to pass address of variables',
      'Format string matches input pattern',
    ],
    validPatterns: [/sscanf\s*\(\s*date\s*,\s*["']%d-%d-%d["']\s*,\s*&day\s*,\s*&month\s*,\s*&year\s*\)/],
    tags: ['sscanf', 'stdio.h', 'parse'],
  },
  {
    id: 'c-snprintf-safe',
    category: 'Standard I/O',
    difficulty: 'hard',
    title: 'Safe String Formatting with snprintf',
    text: 'Safely format a long message into a small buffer using snprintf()',
    setup: '#include <stdio.h>\nchar buffer[20];\nchar *message = "This is a very long message that exceeds buffer";',
    setupCode: '#include <stdio.h>\nchar buffer[20];\nchar *message = "This is a very long message that exceeds buffer";',
    expected: 'snprintf(buffer, sizeof(buffer), "%s", message)',
    sample: 'int written = snprintf(buffer, sizeof(buffer), "%s", message);',
    hints: [
      'snprintf prevents buffer overflow',
      'Returns number of characters that would be written',
      'If return >= size, output was truncated',
    ],
    validPatterns: [/snprintf\s*\(\s*buffer\s*,\s*(sizeof\s*\(\s*buffer\s*\)|20)\s*,\s*["']%s["']\s*,\s*message\s*\)/],
    tags: ['snprintf', 'stdio.h', 'safe', 'format'],
  },

  // ============================================================
  // String and Array Operations - Advanced
  // ============================================================
  {
    id: 'c-str-strncpy-null-term',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Safe strncpy with Null Termination',
    text: 'Copy at most 10 characters from src to dest using strncpy, ensuring null termination',
    setup: '#include <string.h>\nchar src[] = "Hello World!";\nchar dest[11];',
    setupCode: '#include <string.h>\nchar src[] = "Hello World!";\nchar dest[11];',
    expected: 'strncpy(dest, src, 10); dest[10] = \'\\0\';',
    sample: 'strncpy(dest, src, 10);\ndest[10] = \'\\0\';',
    hints: [
      'strncpy may not null-terminate if src is longer than n',
      'Always manually set the last byte to null for safety',
    ],
    validPatterns: [/strncpy\s*\(\s*dest\s*,\s*src\s*,\s*10\s*\)/, /dest\s*\[\s*10\s*\]\s*=\s*['"]?\\0['"]?/],
    tags: ['strncpy', 'string.h', 'safe', 'null-termination'],
  },
  {
    id: 'c-str-strncat-bounded',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Bounded String Concatenation',
    text: 'Append suffix to prefix, but limit to only 4 characters from suffix using strncat',
    setup: '#include <string.h>\nchar prefix[20] = "Hello";\nchar suffix[] = " World!";',
    setupCode: '#include <string.h>\nchar prefix[20] = "Hello";\nchar suffix[] = " World!";',
    expected: 'strncat(prefix, suffix, 4)',
    sample: 'strncat(prefix, suffix, 4); // Result: "Hello Wor"',
    hints: [
      'strncat appends at most n characters from src',
      'Unlike strncpy, strncat always null-terminates',
    ],
    validPatterns: [/strncat\s*\(\s*prefix\s*,\s*suffix\s*,\s*4\s*\)/],
    tags: ['strncat', 'string.h', 'safe', 'concatenation'],
  },
  {
    id: 'c-str-strncmp-prefix',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Compare String Prefix with strncmp',
    text: 'Check if the string starts with "Hello" by comparing the first 5 characters',
    setup: '#include <string.h>\nchar str[] = "Hello World";\nchar prefix[] = "Hello";',
    setupCode: '#include <string.h>\nchar str[] = "Hello World";\nchar prefix[] = "Hello";',
    expected: 'strncmp(str, prefix, 5) == 0',
    sample: 'int isPrefix = (strncmp(str, prefix, 5) == 0);',
    hints: [
      'strncmp compares at most n characters',
      'Returns 0 if the compared portions are equal',
    ],
    validPatterns: [/strncmp\s*\(\s*str\s*,\s*prefix\s*,\s*5\s*\)\s*==\s*0/],
    tags: ['strncmp', 'string.h', 'prefix', 'comparison'],
  },
  {
    id: 'c-str-strchr-count',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Count Character Occurrences with strchr',
    text: 'Count how many times the letter "l" appears in the string using strchr',
    setup: '#include <string.h>\nchar str[] = "Hello World";',
    setupCode: '#include <string.h>\nchar str[] = "Hello World";',
    expected: 'count = 3',
    sample: 'int count = 0;\nchar *ptr = str;\nwhile ((ptr = strchr(ptr, \'l\')) != NULL) {\n    count++;\n    ptr++;\n}',
    hints: [
      'strchr finds the first occurrence of a character',
      'Call repeatedly starting from position after last match',
    ],
    validPatterns: [/strchr\s*\(\s*ptr\s*,\s*['"]?l['"]?\s*\)/, /while\s*\([^)]*strchr/, /count\s*\+\+/],
    tags: ['strchr', 'string.h', 'count', 'loop'],
  },
  {
    id: 'c-str-strrchr-extension',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Extract File Extension with strrchr',
    text: 'Find the file extension (part after last dot) using strrchr',
    setup: '#include <string.h>\nchar filename[] = "archive.tar.gz";',
    setupCode: '#include <string.h>\nchar filename[] = "archive.tar.gz";',
    expected: 'strrchr(filename, \'.\')',
    sample: 'char *ext = strrchr(filename, \'.\');\n// ext points to ".gz"',
    hints: [
      'strrchr finds the last occurrence of a character',
      'Perfect for extracting file extensions',
    ],
    validPatterns: [/strrchr\s*\(\s*filename\s*,\s*['"]?\.['"]?\s*\)/],
    tags: ['strrchr', 'string.h', 'file', 'extension'],
  },
  {
    id: 'c-str-strpbrk-delimiters',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Find First Delimiter with strpbrk',
    text: 'Find the first occurrence of any delimiter (comma, semicolon, or colon) in the string',
    setup: '#include <string.h>\nchar str[] = "key:value;data,more";',
    setupCode: '#include <string.h>\nchar str[] = "key:value;data,more";',
    expected: 'strpbrk(str, ",;:")',
    sample: 'char *delim = strpbrk(str, ",;:");\n// delim points to ":"',
    hints: [
      'strpbrk finds the first occurrence of any character from a set',
      'Returns NULL if no matching character is found',
    ],
    validPatterns: [/strpbrk\s*\(\s*str\s*,\s*["'][,;:]+["']\s*\)/],
    tags: ['strpbrk', 'string.h', 'delimiter', 'search'],
  },
  {
    id: 'c-str-strspn-numeric',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Count Leading Digits with strspn',
    text: 'Find the length of the leading numeric portion of the string using strspn',
    setup: '#include <string.h>\nchar str[] = "12345abc678";',
    setupCode: '#include <string.h>\nchar str[] = "12345abc678";',
    expected: 'strspn(str, "0123456789")',
    sample: 'size_t len = strspn(str, "0123456789");\n// len = 5',
    hints: [
      'strspn returns length of initial segment containing only accepted chars',
      'Useful for validating input prefixes',
    ],
    validPatterns: [/strspn\s*\(\s*str\s*,\s*["']0123456789["']\s*\)/],
    tags: ['strspn', 'string.h', 'validation', 'numeric'],
  },
  {
    id: 'c-str-strcspn-reject',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Find First Invalid Character with strcspn',
    text: 'Find the position of the first non-alphanumeric character using strcspn',
    setup: '#include <string.h>\nchar str[] = "Hello123!@#World";',
    setupCode: '#include <string.h>\nchar str[] = "Hello123!@#World";',
    expected: 'strcspn(str, "!@#$%^&*()")',
    sample: 'size_t pos = strcspn(str, "!@#$%^&*()");\n// pos = 8 (position of !)',
    hints: [
      'strcspn returns length until first rejected character',
      'Complement of strspn functionality',
    ],
    validPatterns: [/strcspn\s*\(\s*str\s*,\s*["'][!@#$%^&*()]+["']\s*\)/],
    tags: ['strcspn', 'string.h', 'validation', 'search'],
  },
  {
    id: 'c-str-memchr-find',
    category: 'Memory Functions',
    difficulty: 'easy',
    title: 'Find Byte in Memory with memchr',
    text: 'Find the first occurrence of newline character in the buffer using memchr',
    setup: '#include <string.h>\nchar buffer[] = "Line1\\nLine2\\nLine3";\nsize_t len = 18;',
    setupCode: '#include <string.h>\nchar buffer[] = "Line1\\nLine2\\nLine3";\nsize_t len = 18;',
    expected: 'memchr(buffer, \'\\n\', len)',
    sample: 'char *newline = memchr(buffer, \'\\n\', len);',
    hints: [
      'memchr searches n bytes for the specified byte value',
      'Works with binary data that may contain null bytes',
    ],
    validPatterns: [/memchr\s*\(\s*buffer\s*,\s*['"]?\\n['"]?\s*,\s*len\s*\)/],
    tags: ['memchr', 'string.h', 'memory', 'search'],
  },
  {
    id: 'c-str-memmove-insert',
    category: 'Memory Functions',
    difficulty: 'medium',
    title: 'Insert Character with memmove',
    text: 'Insert a space at position 5 by shifting the rest of the string using memmove',
    setup: '#include <string.h>\nchar str[20] = "HelloWorld";\nint pos = 5;',
    setupCode: '#include <string.h>\nchar str[20] = "HelloWorld";\nint pos = 5;',
    expected: 'memmove(str + pos + 1, str + pos, strlen(str) - pos + 1); str[pos] = \' \';',
    sample: 'memmove(str + pos + 1, str + pos, strlen(str) - pos + 1);\nstr[pos] = \' \';\n// Result: "Hello World"',
    hints: [
      'memmove handles overlapping regions safely',
      'Shift includes the null terminator (+1)',
    ],
    validPatterns: [/memmove\s*\(\s*str\s*\+\s*pos\s*\+\s*1/, /str\s*\[\s*pos\s*\]\s*=\s*['"]?\s['"]?/],
    tags: ['memmove', 'string.h', 'memory', 'insert'],
  },
  {
    id: 'c-str-atoi-validation',
    category: 'Conversion Functions',
    difficulty: 'easy',
    title: 'Convert String to Integer with Validation',
    text: 'Convert the numeric string to integer using atoi, handling the leading whitespace',
    setup: '#include <stdlib.h>\nchar str[] = "   -42";',
    setupCode: '#include <stdlib.h>\nchar str[] = "   -42";',
    expected: 'atoi(str)',
    sample: 'int num = atoi(str);\n// num = -42 (atoi skips leading whitespace)',
    hints: [
      'atoi automatically skips leading whitespace',
      'Handles optional sign (+ or -)',
    ],
    validPatterns: [/atoi\s*\(\s*str\s*\)/],
    tags: ['atoi', 'stdlib.h', 'conversion', 'whitespace'],
  },
  {
    id: 'c-str-atof-scientific',
    category: 'Conversion Functions',
    difficulty: 'medium',
    title: 'Parse Scientific Notation with atof',
    text: 'Convert the scientific notation string to double using atof',
    setup: '#include <stdlib.h>\nchar str[] = "1.5e-3";',
    setupCode: '#include <stdlib.h>\nchar str[] = "1.5e-3";',
    expected: 'atof(str)',
    sample: 'double num = atof(str);\n// num = 0.0015',
    hints: [
      'atof handles scientific notation (e or E)',
      'Returns double, not float',
    ],
    validPatterns: [/atof\s*\(\s*str\s*\)/],
    tags: ['atof', 'stdlib.h', 'conversion', 'scientific'],
  },
  {
    id: 'c-str-strtol-hex',
    category: 'Conversion Functions',
    difficulty: 'medium',
    title: 'Parse Hexadecimal with strtol',
    text: 'Convert the hexadecimal string "0xFF" to integer using strtol with base 16',
    setup: '#include <stdlib.h>\nchar str[] = "0xFF";\nchar *endptr;',
    setupCode: '#include <stdlib.h>\nchar str[] = "0xFF";\nchar *endptr;',
    expected: 'strtol(str, &endptr, 16)',
    sample: 'long num = strtol(str, &endptr, 16);\n// num = 255',
    hints: [
      'Use base 16 for hexadecimal conversion',
      'strtol can handle 0x prefix with base 0 or 16',
    ],
    validPatterns: [/strtol\s*\(\s*str\s*,\s*(&endptr|NULL)\s*,\s*16\s*\)/],
    tags: ['strtol', 'stdlib.h', 'conversion', 'hexadecimal'],
  },
  {
    id: 'c-str-strtod-endptr',
    category: 'Conversion Functions',
    difficulty: 'medium',
    title: 'Parse Double with Error Detection using strtod',
    text: 'Convert the string to double using strtod and check for trailing characters',
    setup: '#include <stdlib.h>\nchar str[] = "3.14159abc";\nchar *endptr;',
    setupCode: '#include <stdlib.h>\nchar str[] = "3.14159abc";\nchar *endptr;',
    expected: 'strtod(str, &endptr)',
    sample: 'double num = strtod(str, &endptr);\n// num = 3.14159, endptr points to "abc"',
    hints: [
      'endptr points to first character not part of the number',
      'Check *endptr to detect trailing garbage',
    ],
    validPatterns: [/strtod\s*\(\s*str\s*,\s*&endptr\s*\)/],
    tags: ['strtod', 'stdlib.h', 'conversion', 'validation'],
  },
  {
    id: 'c-str-strtol-binary',
    category: 'Conversion Functions',
    difficulty: 'medium',
    title: 'Parse Binary String with strtol',
    text: 'Convert the binary string "11010110" to integer using strtol with base 2',
    setup: '#include <stdlib.h>\nchar str[] = "11010110";\nchar *endptr;',
    setupCode: '#include <stdlib.h>\nchar str[] = "11010110";\nchar *endptr;',
    expected: 'strtol(str, &endptr, 2)',
    sample: 'long num = strtol(str, &endptr, 2);\n// num = 214',
    hints: [
      'Use base 2 for binary conversion',
      'Only 0 and 1 are valid binary digits',
    ],
    validPatterns: [/strtol\s*\(\s*str\s*,\s*(&endptr|NULL)\s*,\s*2\s*\)/],
    tags: ['strtol', 'stdlib.h', 'conversion', 'binary'],
  },
  {
    id: 'c-str-array-reverse',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Reverse String In-Place',
    text: 'Reverse the string in-place using character array manipulation',
    setup: '#include <string.h>\nchar str[] = "Hello";',
    setupCode: '#include <string.h>\nchar str[] = "Hello";',
    expected: 'str = "olleH"',
    sample: 'int len = strlen(str);\nfor (int i = 0; i < len / 2; i++) {\n    char temp = str[i];\n    str[i] = str[len - 1 - i];\n    str[len - 1 - i] = temp;\n}',
    hints: [
      'Swap characters from both ends moving toward center',
      'Only iterate to len/2 to avoid double-swapping',
    ],
    validPatterns: [/for\s*\([^)]*len\s*\/\s*2/, /temp|swap/i, /str\s*\[\s*len\s*-\s*1\s*-\s*\w+\s*\]/],
    tags: ['string', 'reverse', 'array', 'in-place'],
  },
  {
    id: 'c-str-buffer-shift-left',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Left Shift Buffer Contents',
    text: 'Remove the first 3 characters by shifting buffer contents left using memmove',
    setup: '#include <string.h>\nchar buffer[] = "ABCDEFGHIJ";\nint shift = 3;',
    setupCode: '#include <string.h>\nchar buffer[] = "ABCDEFGHIJ";\nint shift = 3;',
    expected: 'memmove(buffer, buffer + shift, strlen(buffer) - shift + 1)',
    sample: 'memmove(buffer, buffer + shift, strlen(buffer) - shift + 1);\n// Result: "DEFGHIJ"',
    hints: [
      'Use memmove for overlapping memory regions',
      'Include null terminator in the move (+1)',
    ],
    validPatterns: [/memmove\s*\(\s*buffer\s*,\s*buffer\s*\+\s*shift/],
    tags: ['memmove', 'buffer', 'shift', 'string.h'],
  },
  {
    id: 'c-str-tokenize-csv',
    category: 'String Functions',
    difficulty: 'hard',
    title: 'Tokenize CSV Line with strtok',
    text: 'Parse a CSV line into individual fields using strtok with comma delimiter',
    setup: '#include <string.h>\n#include <stdio.h>\nchar csv[] = "John,25,Engineer,NYC";\nchar *fields[10];\nint count = 0;',
    setupCode: '#include <string.h>\n#include <stdio.h>\nchar csv[] = "John,25,Engineer,NYC";\nchar *fields[10];\nint count = 0;',
    expected: 'fields contains: "John", "25", "Engineer", "NYC"',
    sample: 'char *token = strtok(csv, ",");\nwhile (token && count < 10) {\n    fields[count++] = token;\n    token = strtok(NULL, ",");\n}',
    hints: [
      'First call uses the string, subsequent calls use NULL',
      'strtok modifies the original string (inserts nulls)',
      'Store pointers to tokens, not copies',
    ],
    validPatterns: [/strtok\s*\(\s*csv\s*,\s*["'],["']\s*\)/, /strtok\s*\(\s*NULL\s*,/, /fields\s*\[\s*count/],
    tags: ['strtok', 'string.h', 'csv', 'tokenize'],
  },
  {
    id: 'c-str-strspn-validate-identifier',
    category: 'String Functions',
    difficulty: 'hard',
    title: 'Validate C Identifier with strspn',
    text: 'Check if a string is a valid C identifier (starts with letter/underscore, contains only alphanumeric and underscore)',
    setup: '#include <string.h>\n#include <ctype.h>\nchar ident[] = "my_var123";',
    setupCode: '#include <string.h>\n#include <ctype.h>\nchar ident[] = "my_var123";',
    expected: 'Valid identifier check',
    sample: 'int isValid = (isalpha(ident[0]) || ident[0] == \'_\') &&\n    strspn(ident, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_") == strlen(ident);',
    hints: [
      'First character must be letter or underscore',
      'strspn returns length of valid prefix',
      'Valid if strspn length equals string length',
    ],
    validPatterns: [/isalpha\s*\(\s*ident\s*\[\s*0\s*\]\s*\)|ident\s*\[\s*0\s*\]\s*==\s*['"]_['"]/, /strspn\s*\(\s*ident/, /strlen\s*\(\s*ident\s*\)/],
    tags: ['strspn', 'string.h', 'validation', 'identifier'],
  },
  {
    id: 'c-str-pointer-word-count',
    category: 'Pointer Operations',
    difficulty: 'hard',
    title: 'Count Words Using Pointer Traversal',
    text: 'Count the number of words in a string using pointer arithmetic and character checks',
    setup: '#include <ctype.h>\nchar text[] = "  Hello   World  How Are   You  ";',
    setupCode: '#include <ctype.h>\nchar text[] = "  Hello   World  How Are   You  ";',
    expected: 'count = 5',
    sample: 'int count = 0;\nchar *ptr = text;\nwhile (*ptr) {\n    while (*ptr && isspace(*ptr)) ptr++;\n    if (*ptr) {\n        count++;\n        while (*ptr && !isspace(*ptr)) ptr++;\n    }\n}',
    hints: [
      'Skip leading spaces, then count word start',
      'Use isspace() to detect whitespace',
      'Handle multiple consecutive spaces',
    ],
    validPatterns: [/while\s*\(\s*\*\s*ptr\s*\)/, /isspace\s*\(\s*\*\s*ptr\s*\)/, /count\s*\+\+/],
    tags: ['pointer', 'word-count', 'string', 'ctype.h'],
  },
  {
    id: 'c-str-circular-buffer',
    category: 'Array Operations',
    difficulty: 'hard',
    title: 'Implement Circular Buffer Write',
    text: 'Write data to a circular buffer, wrapping around to the beginning when full',
    setup: '#include <string.h>\nchar buffer[10];\nint head = 7;\nint size = 10;\nchar data[] = "HELLO";',
    setupCode: '#include <string.h>\nchar buffer[10];\nint head = 7;\nint size = 10;\nchar data[] = "HELLO";',
    expected: 'Data wraps around in circular buffer',
    sample: 'for (int i = 0; data[i]; i++) {\n    buffer[(head + i) % size] = data[i];\n}\nhead = (head + strlen(data)) % size;',
    hints: [
      'Use modulo operator for wrapping',
      'head + offset % size gives circular index',
      'Update head position after write',
    ],
    validPatterns: [/\(\s*head\s*\+\s*\w+\s*\)\s*%\s*size/, /buffer\s*\[\s*\([^]]*%\s*size\s*\)\s*\]/],
    tags: ['circular-buffer', 'array', 'modulo', 'ring-buffer'],
  },
  {
    id: 'c-str-memchr-line-parser',
    category: 'Memory Functions',
    difficulty: 'medium',
    title: 'Parse Lines from Buffer with memchr',
    text: 'Find and extract the first line from a buffer containing multiple lines',
    setup: '#include <string.h>\nchar buffer[] = "First line\\nSecond line\\nThird";\nsize_t buflen = 29;',
    setupCode: '#include <string.h>\nchar buffer[] = "First line\\nSecond line\\nThird";\nsize_t buflen = 29;',
    expected: 'Pointer to newline and line length',
    sample: 'char *newline = memchr(buffer, \'\\n\', buflen);\nsize_t linelen = newline ? (newline - buffer) : buflen;',
    hints: [
      'memchr returns pointer to found byte or NULL',
      'Calculate line length by pointer subtraction',
      'Handle case when no newline is found',
    ],
    validPatterns: [/memchr\s*\(\s*buffer\s*,\s*['"]?\\n['"]?\s*,\s*buflen\s*\)/, /newline\s*-\s*buffer/],
    tags: ['memchr', 'string.h', 'parsing', 'lines'],
  },
  {
    id: 'c-str-memmove-delete',
    category: 'Memory Functions',
    difficulty: 'medium',
    title: 'Delete Substring with memmove',
    text: 'Delete 3 characters starting at position 5 from the string',
    setup: '#include <string.h>\nchar str[] = "Hello World";\nint pos = 5;\nint len = 3;',
    setupCode: '#include <string.h>\nchar str[] = "Hello World";\nint pos = 5;\nint len = 3;',
    expected: 'memmove(str + pos, str + pos + len, strlen(str) - pos - len + 1)',
    sample: 'memmove(str + pos, str + pos + len, strlen(str) - pos - len + 1);\n// Result: "Helloorld"',
    hints: [
      'Move characters after deleted portion to fill the gap',
      'Include null terminator in the move',
    ],
    validPatterns: [/memmove\s*\(\s*str\s*\+\s*pos\s*,\s*str\s*\+\s*pos\s*\+\s*len/],
    tags: ['memmove', 'string.h', 'delete', 'substring'],
  },
  {
    id: 'c-str-strtok-r-reentrant',
    category: 'String Functions',
    difficulty: 'hard',
    title: 'Thread-Safe Tokenization with strtok_r',
    text: 'Tokenize a string in a thread-safe manner using strtok_r',
    setup: '#include <string.h>\nchar str[] = "apple:banana:cherry";\nchar *saveptr;',
    setupCode: '#include <string.h>\nchar str[] = "apple:banana:cherry";\nchar *saveptr;',
    expected: 'Use strtok_r with saveptr for thread safety',
    sample: 'char *token = strtok_r(str, ":", &saveptr);\nwhile (token) {\n    // process token\n    token = strtok_r(NULL, ":", &saveptr);\n}',
    hints: [
      'strtok_r uses saveptr instead of static state',
      'Safe to use in multi-threaded code',
      'POSIX function, may need _GNU_SOURCE',
    ],
    validPatterns: [/strtok_r\s*\(\s*str\s*,\s*["']:["']\s*,\s*&saveptr\s*\)/, /strtok_r\s*\(\s*NULL\s*,/],
    tags: ['strtok_r', 'string.h', 'thread-safe', 'tokenize'],
  },
  {
    id: 'c-str-buffer-pack',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Pack Multiple Values into Buffer',
    text: 'Pack an integer and a string into a binary buffer using memcpy',
    setup: '#include <string.h>\nchar buffer[100];\nint id = 42;\nchar name[] = "Test";',
    setupCode: '#include <string.h>\nchar buffer[100];\nint id = 42;\nchar name[] = "Test";',
    expected: 'memcpy(buffer, &id, sizeof(int)); memcpy(buffer + sizeof(int), name, strlen(name) + 1);',
    sample: 'int offset = 0;\nmemcpy(buffer + offset, &id, sizeof(int));\noffset += sizeof(int);\nmemcpy(buffer + offset, name, strlen(name) + 1);',
    hints: [
      'Track current offset in buffer',
      'Use sizeof for type-safe offsets',
      'Include null terminator for strings (+1)',
    ],
    validPatterns: [/memcpy\s*\(\s*buffer[^,]*,\s*&id\s*,\s*sizeof\s*\(\s*int\s*\)\s*\)/, /memcpy\s*\(\s*buffer\s*\+/],
    tags: ['memcpy', 'buffer', 'packing', 'binary'],
  },
];

// Helper functions
export function getCProblemById(id: string): Problem | undefined {
  return cProblems.find((p) => p.id === id);
}

export function getCProblemsByCategory(category: string): Problem[] {
  return cProblems.filter((p) => p.category === category);
}

export function getCProblemsByDifficulty(difficulty: Problem['difficulty']): Problem[] {
  return cProblems.filter((p) => p.difficulty === difficulty);
}

export function getCProblemsByTag(tag: string): Problem[] {
  return cProblems.filter((p) => p.tags?.includes(tag));
}

export function getCCategories(): string[] {
  return [...new Set(cProblems.map((p) => p.category))];
}

export default cProblems;
