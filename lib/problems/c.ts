import type { Problem } from '../types';

/**
 * C programming language coding drill problems
 * Focus on standard library functions and common patterns
 * Note: C problems use pattern matching since we cannot execute C in browser
 */

export const cProblems: Problem[] = [
  // ============================================================
  // String Functions (string.h)
  // ============================================================
  {
    id: 'c-strlen',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Get String Length with strlen',
    text: 'Get the length of the string "Hello" using strlen()',
    setup: '#include <string.h>\nchar str[] = "Hello";',
    setupCode: '#include <string.h>\nchar str[] = "Hello";',
    expected: 'strlen(str)',
    sample: 'strlen(str)',
    hints: [
      'strlen returns the number of characters before null terminator',
      'Return type is size_t',
    ],
    validPatterns: [/strlen\s*\(\s*str\s*\)/],
    tags: ['strlen', 'string.h'],
  },
  {
    id: 'c-strcpy',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Copy String with strcpy',
    text: 'Copy the source string to the destination buffer using strcpy()',
    setup: '#include <string.h>\nchar src[] = "Hello";\nchar dest[20];',
    setupCode: '#include <string.h>\nchar src[] = "Hello";\nchar dest[20];',
    expected: 'strcpy(dest, src)',
    sample: 'strcpy(dest, src)',
    hints: ['strcpy(destination, source)', 'Destination must have enough space'],
    validPatterns: [/strcpy\s*\(\s*dest\s*,\s*src\s*\)/],
    tags: ['strcpy', 'string.h'],
  },
  {
    id: 'c-strncpy',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Safe String Copy with strncpy',
    text: 'Copy at most 5 characters from source to destination using strncpy()',
    setup: '#include <string.h>\nchar src[] = "Hello World";\nchar dest[6];',
    setupCode: '#include <string.h>\nchar src[] = "Hello World";\nchar dest[6];',
    expected: 'strncpy(dest, src, 5)',
    sample: 'strncpy(dest, src, 5)',
    hints: [
      'strncpy(dest, src, n) copies at most n characters',
      'May not null-terminate if src is longer than n',
    ],
    validPatterns: [/strncpy\s*\(\s*dest\s*,\s*src\s*,\s*5\s*\)/],
    tags: ['strncpy', 'string.h', 'safe'],
  },
  {
    id: 'c-strcat',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Concatenate Strings with strcat',
    text: 'Append the source string to the destination using strcat()',
    setup: '#include <string.h>\nchar dest[20] = "Hello ";\nchar src[] = "World";',
    setupCode: '#include <string.h>\nchar dest[20] = "Hello ";\nchar src[] = "World";',
    expected: 'strcat(dest, src)',
    sample: 'strcat(dest, src)',
    hints: [
      'strcat appends src to the end of dest',
      'dest must have enough space for both strings',
    ],
    validPatterns: [/strcat\s*\(\s*dest\s*,\s*src\s*\)/],
    tags: ['strcat', 'string.h'],
  },
  {
    id: 'c-strncat',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Safe String Concatenation with strncat',
    text: 'Append at most 3 characters from source to destination using strncat()',
    setup: '#include <string.h>\nchar dest[20] = "Hello ";\nchar src[] = "World";',
    setupCode: '#include <string.h>\nchar dest[20] = "Hello ";\nchar src[] = "World";',
    expected: 'strncat(dest, src, 3)',
    sample: 'strncat(dest, src, 3)',
    hints: ['strncat appends at most n characters', 'Always null-terminates the result'],
    validPatterns: [/strncat\s*\(\s*dest\s*,\s*src\s*,\s*3\s*\)/],
    tags: ['strncat', 'string.h', 'safe'],
  },
  {
    id: 'c-strcmp',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Compare Strings with strcmp',
    text: 'Compare two strings using strcmp()',
    setup: '#include <string.h>\nchar str1[] = "apple";\nchar str2[] = "banana";',
    setupCode: '#include <string.h>\nchar str1[] = "apple";\nchar str2[] = "banana";',
    expected: 'strcmp(str1, str2)',
    sample: 'strcmp(str1, str2)',
    hints: [
      'Returns 0 if equal, negative if str1 < str2, positive if str1 > str2',
      'Comparison is lexicographic',
    ],
    validPatterns: [/strcmp\s*\(\s*str1\s*,\s*str2\s*\)/],
    tags: ['strcmp', 'string.h'],
  },
  {
    id: 'c-strncmp',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Compare N Characters with strncmp',
    text: 'Compare only the first 3 characters of the strings using strncmp()',
    setup: '#include <string.h>\nchar str1[] = "Hello World";\nchar str2[] = "Hello There";',
    setupCode: '#include <string.h>\nchar str1[] = "Hello World";\nchar str2[] = "Hello There";',
    expected: 'strncmp(str1, str2, 3)',
    sample: 'strncmp(str1, str2, 3)',
    hints: ['strncmp compares at most n characters', 'Useful for prefix comparisons'],
    validPatterns: [/strncmp\s*\(\s*str1\s*,\s*str2\s*,\s*3\s*\)/],
    tags: ['strncmp', 'string.h'],
  },
  {
    id: 'c-strchr',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Find Character with strchr',
    text: 'Find the first occurrence of character "o" in the string',
    setup: '#include <string.h>\nchar str[] = "Hello World";',
    setupCode: '#include <string.h>\nchar str[] = "Hello World";',
    expected: "strchr(str, 'o')",
    sample: "strchr(str, 'o')",
    hints: ['strchr returns pointer to first occurrence', 'Returns NULL if not found'],
    validPatterns: [/strchr\s*\(\s*str\s*,\s*['"]?o['"]?\s*\)/],
    tags: ['strchr', 'string.h'],
  },
  {
    id: 'c-strrchr',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Find Last Character with strrchr',
    text: 'Find the last occurrence of character "o" in the string',
    setup: '#include <string.h>\nchar str[] = "Hello World";',
    setupCode: '#include <string.h>\nchar str[] = "Hello World";',
    expected: "strrchr(str, 'o')",
    sample: "strrchr(str, 'o')",
    hints: ['strrchr searches from the end', 'Returns pointer to last occurrence'],
    validPatterns: [/strrchr\s*\(\s*str\s*,\s*['"]?o['"]?\s*\)/],
    tags: ['strrchr', 'string.h'],
  },
  {
    id: 'c-strstr',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Find Substring with strstr',
    text: 'Find the substring "World" in the string',
    setup: '#include <string.h>\nchar str[] = "Hello World";',
    setupCode: '#include <string.h>\nchar str[] = "Hello World";',
    expected: 'strstr(str, "World")',
    sample: 'strstr(str, "World")',
    hints: ['strstr returns pointer to first occurrence of substring', 'Returns NULL if not found'],
    validPatterns: [/strstr\s*\(\s*str\s*,\s*["']World["']\s*\)/],
    tags: ['strstr', 'string.h'],
  },
  {
    id: 'c-memcpy',
    category: 'Memory Functions',
    difficulty: 'medium',
    title: 'Copy Memory with memcpy',
    text: 'Copy 5 bytes from source to destination using memcpy()',
    setup: '#include <string.h>\nchar src[] = "Hello";\nchar dest[10];',
    setupCode: '#include <string.h>\nchar src[] = "Hello";\nchar dest[10];',
    expected: 'memcpy(dest, src, 5)',
    sample: 'memcpy(dest, src, 5)',
    hints: ['memcpy(dest, src, n) copies n bytes', 'Does not handle overlapping memory'],
    validPatterns: [/memcpy\s*\(\s*dest\s*,\s*src\s*,\s*5\s*\)/],
    tags: ['memcpy', 'string.h', 'memory'],
  },
  {
    id: 'c-memmove',
    category: 'Memory Functions',
    difficulty: 'medium',
    title: 'Move Memory with memmove',
    text: 'Safely copy overlapping memory regions using memmove()',
    setup: '#include <string.h>\nchar str[] = "Hello World";\n// Move "World" to start',
    setupCode: '#include <string.h>\nchar str[] = "Hello World";',
    expected: 'memmove(str, str + 6, 5)',
    sample: 'memmove(str, str + 6, 5)',
    hints: [
      'memmove handles overlapping memory safely',
      'Use when source and destination may overlap',
    ],
    validPatterns: [/memmove\s*\(\s*str\s*,\s*str\s*\+\s*6\s*,\s*5\s*\)/],
    tags: ['memmove', 'string.h', 'memory'],
  },
  {
    id: 'c-memset',
    category: 'Memory Functions',
    difficulty: 'easy',
    title: 'Initialize Memory with memset',
    text: 'Set the first 10 bytes of the buffer to zero using memset()',
    setup: '#include <string.h>\nchar buffer[20];',
    setupCode: '#include <string.h>\nchar buffer[20];',
    expected: 'memset(buffer, 0, 10)',
    sample: 'memset(buffer, 0, 10)',
    hints: ['memset(ptr, value, n) sets n bytes to value', 'Commonly used for zeroing memory'],
    validPatterns: [/memset\s*\(\s*buffer\s*,\s*0\s*,\s*10\s*\)/],
    tags: ['memset', 'string.h', 'memory'],
  },
  {
    id: 'c-memcmp',
    category: 'Memory Functions',
    difficulty: 'easy',
    title: 'Compare Memory with memcmp',
    text: 'Compare the first 5 bytes of two memory regions',
    setup: '#include <string.h>\nchar a[] = "Hello";\nchar b[] = "Hello World";',
    setupCode: '#include <string.h>\nchar a[] = "Hello";\nchar b[] = "Hello World";',
    expected: 'memcmp(a, b, 5)',
    sample: 'memcmp(a, b, 5)',
    hints: ['memcmp compares n bytes', 'Returns 0 if equal, like strcmp'],
    validPatterns: [/memcmp\s*\(\s*a\s*,\s*b\s*,\s*5\s*\)/],
    tags: ['memcmp', 'string.h', 'memory'],
  },

  // ============================================================
  // Standard Library (stdlib.h)
  // ============================================================
  {
    id: 'c-malloc',
    category: 'Memory Allocation',
    difficulty: 'medium',
    title: 'Allocate Memory with malloc',
    text: 'Allocate memory for 10 integers using malloc()',
    setup: '#include <stdlib.h>',
    setupCode: '#include <stdlib.h>',
    expected: 'malloc(10 * sizeof(int))',
    sample: 'int *arr = (int *)malloc(10 * sizeof(int))',
    hints: ['malloc returns void*, cast to appropriate type', 'Always use sizeof for portability'],
    validPatterns: [/malloc\s*\(\s*10\s*\*\s*sizeof\s*\(\s*int\s*\)\s*\)/],
    tags: ['malloc', 'stdlib.h', 'memory'],
  },
  {
    id: 'c-calloc',
    category: 'Memory Allocation',
    difficulty: 'medium',
    title: 'Allocate Zeroed Memory with calloc',
    text: 'Allocate and zero-initialize memory for 10 integers using calloc()',
    setup: '#include <stdlib.h>',
    setupCode: '#include <stdlib.h>',
    expected: 'calloc(10, sizeof(int))',
    sample: 'int *arr = (int *)calloc(10, sizeof(int))',
    hints: ['calloc(n, size) allocates n elements of size bytes', 'Memory is zero-initialized'],
    validPatterns: [/calloc\s*\(\s*10\s*,\s*sizeof\s*\(\s*int\s*\)\s*\)/],
    tags: ['calloc', 'stdlib.h', 'memory'],
  },
  {
    id: 'c-realloc',
    category: 'Memory Allocation',
    difficulty: 'medium',
    title: 'Resize Memory with realloc',
    text: 'Resize the allocated array to hold 20 integers using realloc()',
    setup: '#include <stdlib.h>\nint *arr = (int *)malloc(10 * sizeof(int));',
    setupCode: '#include <stdlib.h>\nint *arr = (int *)malloc(10 * sizeof(int));',
    expected: 'realloc(arr, 20 * sizeof(int))',
    sample: 'arr = (int *)realloc(arr, 20 * sizeof(int))',
    hints: ['realloc may move the memory block', 'Original contents are preserved'],
    validPatterns: [/realloc\s*\(\s*arr\s*,\s*20\s*\*\s*sizeof\s*\(\s*int\s*\)\s*\)/],
    tags: ['realloc', 'stdlib.h', 'memory'],
  },
  {
    id: 'c-free',
    category: 'Memory Allocation',
    difficulty: 'easy',
    title: 'Free Allocated Memory',
    text: 'Free the dynamically allocated memory',
    setup: '#include <stdlib.h>\nint *arr = (int *)malloc(10 * sizeof(int));',
    setupCode: '#include <stdlib.h>\nint *arr = (int *)malloc(10 * sizeof(int));',
    expected: 'free(arr)',
    sample: 'free(arr)',
    hints: [
      'Always free allocated memory when done',
      'Set pointer to NULL after freeing to avoid dangling pointer',
    ],
    validPatterns: [/free\s*\(\s*arr\s*\)/],
    tags: ['free', 'stdlib.h', 'memory'],
  },
  {
    id: 'c-atoi',
    category: 'Conversion Functions',
    difficulty: 'easy',
    title: 'Convert String to Integer with atoi',
    text: 'Convert the string "42" to an integer using atoi()',
    setup: '#include <stdlib.h>\nchar str[] = "42";',
    setupCode: '#include <stdlib.h>\nchar str[] = "42";',
    expected: 'atoi(str)',
    sample: 'int num = atoi(str)',
    hints: ['atoi returns 0 on failure', 'Consider strtol for better error handling'],
    validPatterns: [/atoi\s*\(\s*str\s*\)/],
    tags: ['atoi', 'stdlib.h', 'conversion'],
  },
  {
    id: 'c-atof',
    category: 'Conversion Functions',
    difficulty: 'easy',
    title: 'Convert String to Float with atof',
    text: 'Convert the string "3.14" to a double using atof()',
    setup: '#include <stdlib.h>\nchar str[] = "3.14";',
    setupCode: '#include <stdlib.h>\nchar str[] = "3.14";',
    expected: 'atof(str)',
    sample: 'double num = atof(str)',
    hints: ['atof returns double, not float', 'Returns 0.0 on failure'],
    validPatterns: [/atof\s*\(\s*str\s*\)/],
    tags: ['atof', 'stdlib.h', 'conversion'],
  },
  {
    id: 'c-strtol',
    category: 'Conversion Functions',
    difficulty: 'medium',
    title: 'Convert String to Long with strtol',
    text: 'Convert the string "255" to a long integer with base 10 using strtol()',
    setup: '#include <stdlib.h>\nchar str[] = "255";\nchar *endptr;',
    setupCode: '#include <stdlib.h>\nchar str[] = "255";\nchar *endptr;',
    expected: 'strtol(str, &endptr, 10)',
    sample: 'long num = strtol(str, &endptr, 10)',
    hints: [
      'strtol provides better error handling than atoi',
      'Third argument is the base (2-36, or 0 for auto)',
    ],
    validPatterns: [
      /strtol\s*\(\s*str\s*,\s*&?endptr\s*,\s*10\s*\)/,
      /strtol\s*\(\s*str\s*,\s*NULL\s*,\s*10\s*\)/,
    ],
    tags: ['strtol', 'stdlib.h', 'conversion'],
  },
  {
    id: 'c-abs',
    category: 'Math Functions',
    difficulty: 'easy',
    title: 'Absolute Value with abs',
    text: 'Get the absolute value of -42 using abs()',
    setup: '#include <stdlib.h>\nint num = -42;',
    setupCode: '#include <stdlib.h>\nint num = -42;',
    expected: 'abs(num)',
    sample: 'int result = abs(num)',
    hints: ['abs works with integers', 'Use fabs from math.h for floating point'],
    validPatterns: [/abs\s*\(\s*num\s*\)/],
    tags: ['abs', 'stdlib.h', 'math'],
  },
  {
    id: 'c-qsort',
    category: 'Algorithm Functions',
    difficulty: 'hard',
    title: 'Sort Array with qsort',
    text: 'Sort the integer array in ascending order using qsort()',
    setup:
      '#include <stdlib.h>\nint arr[] = {5, 2, 8, 1, 9};\nint n = 5;\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}',
    setupCode:
      '#include <stdlib.h>\nint arr[] = {5, 2, 8, 1, 9};\nint n = 5;\nint compare(const void *a, const void *b) { return (*(int*)a - *(int*)b); }',
    expected: 'qsort(arr, n, sizeof(int), compare)',
    sample: 'qsort(arr, n, sizeof(int), compare)',
    hints: [
      'qsort(array, count, size, comparator)',
      'Comparator returns negative, zero, or positive',
    ],
    validPatterns: [/qsort\s*\(\s*arr\s*,\s*n\s*,\s*sizeof\s*\(\s*int\s*\)\s*,\s*compare\s*\)/],
    tags: ['qsort', 'stdlib.h', 'sorting'],
  },
  {
    id: 'c-bsearch',
    category: 'Algorithm Functions',
    difficulty: 'hard',
    title: 'Binary Search with bsearch',
    text: 'Search for the value 5 in the sorted array using bsearch()',
    setup:
      '#include <stdlib.h>\nint arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\nint n = 9;\nint key = 5;\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}',
    setupCode:
      '#include <stdlib.h>\nint arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\nint n = 9;\nint key = 5;\nint compare(const void *a, const void *b) { return (*(int*)a - *(int*)b); }',
    expected: 'bsearch(&key, arr, n, sizeof(int), compare)',
    sample: 'int *result = (int *)bsearch(&key, arr, n, sizeof(int), compare)',
    hints: ['bsearch requires a sorted array', 'Returns NULL if not found'],
    validPatterns: [
      /bsearch\s*\(\s*&key\s*,\s*arr\s*,\s*n\s*,\s*sizeof\s*\(\s*int\s*\)\s*,\s*compare\s*\)/,
    ],
    tags: ['bsearch', 'stdlib.h', 'searching'],
  },
  {
    id: 'c-rand',
    category: 'Random Functions',
    difficulty: 'easy',
    title: 'Generate Random Number',
    text: 'Generate a random number between 0 and RAND_MAX',
    setup: '#include <stdlib.h>',
    setupCode: '#include <stdlib.h>',
    expected: 'rand()',
    sample: 'int random = rand()',
    hints: ['rand() returns int from 0 to RAND_MAX', 'Use srand() to seed the generator'],
    validPatterns: [/rand\s*\(\s*\)/],
    tags: ['rand', 'stdlib.h', 'random'],
  },
  {
    id: 'c-srand',
    category: 'Random Functions',
    difficulty: 'easy',
    title: 'Seed Random Generator',
    text: 'Seed the random number generator with current time',
    setup: '#include <stdlib.h>\n#include <time.h>',
    setupCode: '#include <stdlib.h>\n#include <time.h>',
    expected: 'srand(time(NULL))',
    sample: 'srand(time(NULL))',
    hints: ['srand sets the seed for rand()', 'time(NULL) provides varying seed'],
    validPatterns: [/srand\s*\(\s*time\s*\(\s*NULL\s*\)\s*\)/],
    tags: ['srand', 'stdlib.h', 'random'],
  },

  // ============================================================
  // stdio.h Patterns
  // ============================================================
  {
    id: 'c-sprintf',
    category: 'Format Functions',
    difficulty: 'medium',
    title: 'Format String with sprintf',
    text: 'Format an integer into a string buffer using sprintf()',
    setup: '#include <stdio.h>\nchar buffer[50];\nint num = 42;',
    setupCode: '#include <stdio.h>\nchar buffer[50];\nint num = 42;',
    expected: 'sprintf(buffer, "%d", num)',
    sample: 'sprintf(buffer, "%d", num)',
    hints: ['sprintf writes formatted output to string', 'Buffer must be large enough'],
    validPatterns: [/sprintf\s*\(\s*buffer\s*,\s*['"]%d['"]\s*,\s*num\s*\)/],
    tags: ['sprintf', 'stdio.h', 'format'],
  },
  {
    id: 'c-snprintf',
    category: 'Format Functions',
    difficulty: 'medium',
    title: 'Safe Format with snprintf',
    text: 'Safely format a string with maximum buffer size using snprintf()',
    setup: '#include <stdio.h>\nchar buffer[20];\nint num = 42;',
    setupCode: '#include <stdio.h>\nchar buffer[20];\nint num = 42;',
    expected: 'snprintf(buffer, sizeof(buffer), "%d", num)',
    sample: 'snprintf(buffer, sizeof(buffer), "%d", num)',
    hints: ['snprintf prevents buffer overflow', 'Second argument is maximum bytes to write'],
    validPatterns: [
      /snprintf\s*\(\s*buffer\s*,\s*(sizeof\s*\(\s*buffer\s*\)|20)\s*,\s*['"]%d['"]\s*,\s*num\s*\)/,
    ],
    tags: ['snprintf', 'stdio.h', 'format', 'safe'],
  },
  {
    id: 'c-sscanf',
    category: 'Format Functions',
    difficulty: 'medium',
    title: 'Parse String with sscanf',
    text: 'Parse an integer from a string using sscanf()',
    setup: '#include <stdio.h>\nchar str[] = "42";\nint num;',
    setupCode: '#include <stdio.h>\nchar str[] = "42";\nint num;',
    expected: 'sscanf(str, "%d", &num)',
    sample: 'sscanf(str, "%d", &num)',
    hints: [
      'sscanf reads formatted input from string',
      'Returns number of items successfully read',
    ],
    validPatterns: [/sscanf\s*\(\s*str\s*,\s*['"]%d['"]\s*,\s*&num\s*\)/],
    tags: ['sscanf', 'stdio.h', 'parse'],
  },
  {
    id: 'c-printf-format',
    category: 'Format Functions',
    difficulty: 'easy',
    title: 'Printf with Multiple Format Specifiers',
    text: 'Print name and age using printf with format specifiers',
    setup: '#include <stdio.h>\nchar name[] = "Alice";\nint age = 30;',
    setupCode: '#include <stdio.h>\nchar name[] = "Alice";\nint age = 30;',
    expected: 'printf("%s is %d years old", name, age)',
    sample: 'printf("%s is %d years old\\n", name, age)',
    hints: ['%s for strings, %d for integers', 'Arguments must match format specifiers'],
    validPatterns: [/printf\s*\(\s*["'].*%s.*%d.*["']\s*,\s*name\s*,\s*age\s*\)/],
    tags: ['printf', 'stdio.h', 'format'],
  },

  // ============================================================
  // Array Operations (Manual Implementations)
  // ============================================================
  {
    id: 'c-array-max',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Find Maximum in Array',
    text: 'Write code to find the maximum value in an integer array',
    setup: 'int arr[] = {3, 1, 4, 1, 5, 9, 2, 6};\nint n = 8;',
    setupCode: 'int arr[] = {3, 1, 4, 1, 5, 9, 2, 6};\nint n = 8;',
    expected: '9',
    sample:
      'int max = arr[0];\nfor (int i = 1; i < n; i++) {\n    if (arr[i] > max) max = arr[i];\n}',
    hints: ['Initialize max with first element', 'Compare each element with current max'],
    validPatterns: [/for\s*\([^)]+\)/, /if\s*\([^)]*>\s*max/, /max\s*=\s*arr\s*\[/],
    tags: ['array', 'max', 'loop'],
  },
  {
    id: 'c-array-min',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Find Minimum in Array',
    text: 'Write code to find the minimum value in an integer array',
    setup: 'int arr[] = {3, 1, 4, 1, 5, 9, 2, 6};\nint n = 8;',
    setupCode: 'int arr[] = {3, 1, 4, 1, 5, 9, 2, 6};\nint n = 8;',
    expected: '1',
    sample:
      'int min = arr[0];\nfor (int i = 1; i < n; i++) {\n    if (arr[i] < min) min = arr[i];\n}',
    hints: ['Initialize min with first element', 'Compare each element with current min'],
    validPatterns: [/for\s*\([^)]+\)/, /if\s*\([^)]*<\s*min/, /min\s*=\s*arr\s*\[/],
    tags: ['array', 'min', 'loop'],
  },
  {
    id: 'c-array-sum',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Sum Array Elements',
    text: 'Write code to calculate the sum of all elements in an integer array',
    setup: 'int arr[] = {1, 2, 3, 4, 5};\nint n = 5;',
    setupCode: 'int arr[] = {1, 2, 3, 4, 5};\nint n = 5;',
    expected: '15',
    sample: 'int sum = 0;\nfor (int i = 0; i < n; i++) {\n    sum += arr[i];\n}',
    hints: ['Initialize sum to 0', 'Add each element to sum'],
    validPatterns: [/for\s*\([^)]+\)/, /sum\s*\+=|sum\s*=\s*sum\s*\+/],
    tags: ['array', 'sum', 'loop'],
  },
  {
    id: 'c-array-reverse',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Reverse Array In-Place',
    text: 'Write code to reverse an array in place',
    setup: 'int arr[] = {1, 2, 3, 4, 5};\nint n = 5;',
    setupCode: 'int arr[] = {1, 2, 3, 4, 5};\nint n = 5;',
    expected: '{5, 4, 3, 2, 1}',
    sample:
      'for (int i = 0; i < n / 2; i++) {\n    int temp = arr[i];\n    arr[i] = arr[n - 1 - i];\n    arr[n - 1 - i] = temp;\n}',
    hints: ['Swap elements from both ends', 'Only iterate to middle of array'],
    validPatterns: [/for\s*\([^)]+n\s*\/\s*2/, /temp|swap/i, /arr\s*\[\s*n\s*-\s*1\s*-\s*i\s*\]/],
    tags: ['array', 'reverse', 'loop'],
  },
  {
    id: 'c-array-search-linear',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Linear Search in Array',
    text: 'Write code to find the index of a target value in an array (-1 if not found)',
    setup: 'int arr[] = {10, 20, 30, 40, 50};\nint n = 5;\nint target = 30;',
    setupCode: 'int arr[] = {10, 20, 30, 40, 50};\nint n = 5;\nint target = 30;',
    expected: '2',
    sample:
      'int index = -1;\nfor (int i = 0; i < n; i++) {\n    if (arr[i] == target) {\n        index = i;\n        break;\n    }\n}',
    hints: ['Initialize index to -1 for not found', 'Break when element is found'],
    validPatterns: [/for\s*\([^)]+\)/, /if\s*\([^)]*==\s*target/, /break/],
    tags: ['array', 'search', 'linear'],
  },
  {
    id: 'c-array-binary-search',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Binary Search Implementation',
    text: 'Write a binary search to find target in sorted array (-1 if not found)',
    setup: 'int arr[] = {1, 3, 5, 7, 9, 11, 13};\nint n = 7;\nint target = 7;',
    setupCode: 'int arr[] = {1, 3, 5, 7, 9, 11, 13};\nint n = 7;\nint target = 7;',
    expected: '3',
    sample:
      'int left = 0, right = n - 1, result = -1;\nwhile (left <= right) {\n    int mid = left + (right - left) / 2;\n    if (arr[mid] == target) { result = mid; break; }\n    else if (arr[mid] < target) left = mid + 1;\n    else right = mid - 1;\n}',
    hints: ['Use left, right, and mid pointers', 'Avoid overflow: mid = left + (right - left) / 2'],
    validPatterns: [/while\s*\([^)]*<=|for\s*\([^)]+\)/, /mid\s*=/, /left.*right|low.*high/i],
    tags: ['array', 'binary-search', 'algorithm'],
  },
  {
    id: 'c-array-copy',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Copy Array Elements',
    text: 'Write code to copy elements from source array to destination array',
    setup: 'int src[] = {1, 2, 3, 4, 5};\nint dest[5];\nint n = 5;',
    setupCode: 'int src[] = {1, 2, 3, 4, 5};\nint dest[5];\nint n = 5;',
    expected: 'dest = {1, 2, 3, 4, 5}',
    sample: 'for (int i = 0; i < n; i++) {\n    dest[i] = src[i];\n}',
    hints: ['Iterate through all elements', 'Can also use memcpy for this'],
    validPatterns: [/for\s*\([^)]+\)/, /dest\s*\[\s*i\s*\]\s*=\s*src\s*\[\s*i\s*\]/],
    tags: ['array', 'copy', 'loop'],
  },
  {
    id: 'c-array-count-occurrences',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Count Occurrences',
    text: 'Write code to count how many times a target value appears in the array',
    setup: 'int arr[] = {1, 2, 2, 3, 2, 4, 2};\nint n = 7;\nint target = 2;',
    setupCode: 'int arr[] = {1, 2, 2, 3, 2, 4, 2};\nint n = 7;\nint target = 2;',
    expected: '4',
    sample: 'int count = 0;\nfor (int i = 0; i < n; i++) {\n    if (arr[i] == target) count++;\n}',
    hints: ['Initialize counter to 0', 'Increment when element matches target'],
    validPatterns: [/for\s*\([^)]+\)/, /if\s*\([^)]*==\s*target/, /count\s*\+\+|count\s*\+=\s*1/],
    tags: ['array', 'count', 'loop'],
  },

  // ============================================================
  // Pointer Operations
  // ============================================================
  {
    id: 'c-pointer-swap',
    category: 'Pointer Operations',
    difficulty: 'medium',
    title: 'Swap Using Pointers',
    text: 'Write a swap function using pointers',
    setup: 'int a = 5, b = 10;',
    setupCode: 'int a = 5, b = 10;',
    expected: 'a = 10, b = 5',
    sample:
      'void swap(int *x, int *y) {\n    int temp = *x;\n    *x = *y;\n    *y = temp;\n}\nswap(&a, &b);',
    hints: ['Use pointers to modify values in caller', 'Dereference with * to access values'],
    validPatterns: [/\*\s*\w+\s*=\s*\*\s*\w+/, /temp|tmp/i, /&\w+/],
    tags: ['pointer', 'swap', 'function'],
  },
  {
    id: 'c-pointer-array-traverse',
    category: 'Pointer Operations',
    difficulty: 'medium',
    title: 'Traverse Array with Pointer',
    text: 'Sum array elements using pointer arithmetic',
    setup: 'int arr[] = {1, 2, 3, 4, 5};\nint n = 5;',
    setupCode: 'int arr[] = {1, 2, 3, 4, 5};\nint n = 5;',
    expected: '15',
    sample:
      'int sum = 0;\nint *ptr = arr;\nfor (int i = 0; i < n; i++) {\n    sum += *(ptr + i);\n}',
    hints: ['Array name is pointer to first element', 'ptr + i points to arr[i]'],
    validPatterns: [/\*\s*\(\s*ptr\s*\+|\*\s*ptr\s*\+\+|\*ptr\s*\+\+/, /ptr\s*=\s*arr/],
    tags: ['pointer', 'array', 'arithmetic'],
  },

  // ============================================================
  // Additional String Functions
  // ============================================================
  {
    id: 'c-strlen-manual',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Manual String Length Calculation',
    text: 'Write code to calculate string length without using strlen()',
    setup: 'char str[] = "Hello World";',
    setupCode: 'char str[] = "Hello World";',
    expected: '11',
    sample: "int len = 0;\nwhile (str[len] != '\\0') {\n    len++;\n}",
    hints: [
      'Strings in C are null-terminated',
      'Count characters until you hit the null terminator \\0',
    ],
    validPatterns: [
      /while\s*\([^)]*!=\s*['"]?\\0['"]?\s*\)|while\s*\(\s*str\s*\[/,
      /len\s*\+\+|len\s*\+=\s*1/,
    ],
    tags: ['strlen', 'string', 'manual', 'loop'],
  },
  {
    id: 'c-strcpy-manual',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Manual String Copy',
    text: 'Write code to copy src to dest without using strcpy()',
    setup: 'char src[] = "Hello";\nchar dest[20];',
    setupCode: 'char src[] = "Hello";\nchar dest[20];',
    expected: 'dest = "Hello"',
    sample:
      "int i = 0;\nwhile (src[i] != '\\0') {\n    dest[i] = src[i];\n    i++;\n}\ndest[i] = '\\0';",
    hints: [
      'Copy character by character until null terminator',
      'Remember to add null terminator to destination',
    ],
    validPatterns: [
      /while\s*\([^)]+\)|for\s*\([^)]+\)/,
      /dest\s*\[\s*\w+\s*\]\s*=\s*src\s*\[/,
      /dest\s*\[\s*\w+\s*\]\s*=\s*['"]?\\0['"]?/,
    ],
    tags: ['strcpy', 'string', 'manual', 'loop'],
  },
  {
    id: 'c-strcat-manual',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Manual String Concatenation',
    text: 'Write code to concatenate src to dest without using strcat()',
    setup: 'char dest[30] = "Hello ";\nchar src[] = "World";',
    setupCode: 'char dest[30] = "Hello ";\nchar src[] = "World";',
    expected: 'dest = "Hello World"',
    sample:
      "int i = 0, j = 0;\nwhile (dest[i] != '\\0') i++;\nwhile (src[j] != '\\0') {\n    dest[i++] = src[j++];\n}\ndest[i] = '\\0';",
    hints: ['First find the end of dest string', 'Then copy src starting at that position'],
    validPatterns: [
      /while\s*\([^)]*!=\s*['"]?\\0['"]?\s*\)/,
      /dest\s*\[\s*\w+\s*\]\s*=\s*src\s*\[/,
    ],
    tags: ['strcat', 'string', 'manual', 'loop'],
  },
  {
    id: 'c-strcmp-manual',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Manual String Comparison',
    text: 'Write code to compare str1 and str2 without using strcmp()',
    setup: 'char str1[] = "apple";\nchar str2[] = "banana";',
    setupCode: 'char str1[] = "apple";\nchar str2[] = "banana";',
    expected: 'negative value (str1 < str2)',
    sample:
      'int i = 0;\nwhile (str1[i] && str2[i] && str1[i] == str2[i]) i++;\nint result = str1[i] - str2[i];',
    hints: [
      'Compare character by character',
      'Stop when characters differ or string ends',
      'Return difference of characters at mismatch point',
    ],
    validPatterns: [/while\s*\([^)]+&&[^)]+==/, /str1\s*\[\s*\w+\s*\]\s*-\s*str2\s*\[/],
    tags: ['strcmp', 'string', 'manual', 'comparison'],
  },
  {
    id: 'c-strstr-manual',
    category: 'String Functions',
    difficulty: 'hard',
    title: 'Manual Substring Search',
    text: 'Write code to find needle in haystack without using strstr()',
    setup: 'char haystack[] = "Hello World";\nchar needle[] = "World";',
    setupCode: 'char haystack[] = "Hello World";\nchar needle[] = "World";',
    expected: 'pointer to "World" in haystack',
    sample:
      'char *result = NULL;\nfor (int i = 0; haystack[i]; i++) {\n    int j = 0;\n    while (needle[j] && haystack[i+j] == needle[j]) j++;\n    if (!needle[j]) { result = &haystack[i]; break; }\n}',
    hints: [
      'For each position in haystack, try to match needle',
      'If all characters of needle match, found it',
      'Return NULL if not found',
    ],
    validPatterns: [
      /for\s*\([^)]+\).*while|while\s*\([^)]+\).*for/,
      /haystack\s*\[\s*\w+\s*\+\s*\w+\s*\]\s*==\s*needle/,
    ],
    tags: ['strstr', 'string', 'manual', 'search'],
  },
  {
    id: 'c-strtok-basic',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Tokenize String with strtok',
    text: 'Split the string by comma delimiter using strtok()',
    setup: '#include <string.h>\nchar str[] = "apple,banana,cherry";',
    setupCode: '#include <string.h>\nchar str[] = "apple,banana,cherry";',
    expected: 'tokens: "apple", "banana", "cherry"',
    sample:
      'char *token = strtok(str, ",");\nwhile (token != NULL) {\n    // process token\n    token = strtok(NULL, ",");\n}',
    hints: [
      'First call uses the string, subsequent calls use NULL',
      'strtok modifies the original string',
      'Returns NULL when no more tokens',
    ],
    validPatterns: [/strtok\s*\(\s*str\s*,\s*["'],["']\s*\)/, /strtok\s*\(\s*NULL\s*,/],
    tags: ['strtok', 'string.h', 'tokenize'],
  },

  // ============================================================
  // Additional Memory Functions
  // ============================================================
  {
    id: 'c-memcpy-struct',
    category: 'Memory Functions',
    difficulty: 'medium',
    title: 'Copy Struct with memcpy',
    text: 'Copy the source struct to destination using memcpy()',
    setup:
      '#include <string.h>\nstruct Point { int x; int y; };\nstruct Point src = {10, 20};\nstruct Point dest;',
    setupCode:
      '#include <string.h>\nstruct Point { int x; int y; };\nstruct Point src = {10, 20};\nstruct Point dest;',
    expected: 'memcpy(&dest, &src, sizeof(struct Point))',
    sample: 'memcpy(&dest, &src, sizeof(struct Point))',
    hints: ['Use sizeof to get the struct size', 'Pass addresses of structs with &'],
    validPatterns: [
      /memcpy\s*\(\s*&dest\s*,\s*&src\s*,\s*sizeof\s*\(\s*(struct\s+)?Point\s*\)\s*\)/,
    ],
    tags: ['memcpy', 'string.h', 'struct', 'memory'],
  },
  {
    id: 'c-memset-pattern',
    category: 'Memory Functions',
    difficulty: 'easy',
    title: 'Fill Array with Pattern using memset',
    text: 'Fill the character buffer with the character "A" for 10 bytes',
    setup: '#include <string.h>\nchar buffer[20];',
    setupCode: '#include <string.h>\nchar buffer[20];',
    expected: "memset(buffer, 'A', 10)",
    sample: "memset(buffer, 'A', 10)",
    hints: [
      'memset sets each byte to the specified value',
      'Works well for char arrays and zeroing memory',
    ],
    validPatterns: [/memset\s*\(\s*buffer\s*,\s*['"]?A['"]?\s*,\s*10\s*\)/],
    tags: ['memset', 'string.h', 'memory'],
  },
  {
    id: 'c-memmove-overlap',
    category: 'Memory Functions',
    difficulty: 'hard',
    title: 'Handle Overlapping Memory with memmove',
    text: 'Shift array elements left by 2 positions using memmove() (overlapping regions)',
    setup: '#include <string.h>\nint arr[] = {1, 2, 3, 4, 5, 6, 7, 8};\nint n = 8;',
    setupCode: '#include <string.h>\nint arr[] = {1, 2, 3, 4, 5, 6, 7, 8};\nint n = 8;',
    expected: 'memmove(arr, arr + 2, (n - 2) * sizeof(int))',
    sample: 'memmove(arr, arr + 2, (n - 2) * sizeof(int))',
    hints: [
      'memmove safely handles overlapping source and destination',
      'Calculate byte count with sizeof',
      'Source is arr + 2, destination is arr',
    ],
    validPatterns: [
      /memmove\s*\(\s*arr\s*,\s*arr\s*\+\s*2\s*,\s*\(\s*n\s*-\s*2\s*\)\s*\*\s*sizeof\s*\(\s*int\s*\)\s*\)/,
    ],
    tags: ['memmove', 'string.h', 'memory', 'overlap'],
  },
  {
    id: 'c-memcmp-arrays',
    category: 'Memory Functions',
    difficulty: 'easy',
    title: 'Compare Integer Arrays with memcmp',
    text: 'Compare two integer arrays using memcmp()',
    setup:
      '#include <string.h>\nint arr1[] = {1, 2, 3, 4, 5};\nint arr2[] = {1, 2, 3, 4, 5};\nint n = 5;',
    setupCode:
      '#include <string.h>\nint arr1[] = {1, 2, 3, 4, 5};\nint arr2[] = {1, 2, 3, 4, 5};\nint n = 5;',
    expected: 'memcmp(arr1, arr2, n * sizeof(int))',
    sample: 'int result = memcmp(arr1, arr2, n * sizeof(int))',
    hints: [
      'memcmp compares raw bytes',
      'Calculate byte count as n * sizeof(element_type)',
      'Returns 0 if arrays are equal',
    ],
    validPatterns: [/memcmp\s*\(\s*arr1\s*,\s*arr2\s*,\s*n\s*\*\s*sizeof\s*\(\s*int\s*\)\s*\)/],
    tags: ['memcmp', 'string.h', 'memory', 'comparison'],
  },

  // ============================================================
  // Character Functions (ctype.h)
  // ============================================================
  {
    id: 'c-isalpha-check',
    category: 'Character Functions',
    difficulty: 'easy',
    title: 'Check if Character is Alphabetic',
    text: 'Check if the character is a letter using isalpha()',
    setup: "#include <ctype.h>\nchar ch = 'A';",
    setupCode: "#include <ctype.h>\nchar ch = 'A';",
    expected: 'isalpha(ch)',
    sample: 'if (isalpha(ch)) { /* is a letter */ }',
    hints: ['isalpha returns non-zero for a-z and A-Z', 'Returns 0 for non-alphabetic characters'],
    validPatterns: [/isalpha\s*\(\s*ch\s*\)/],
    tags: ['isalpha', 'ctype.h', 'character'],
  },
  {
    id: 'c-isdigit-check',
    category: 'Character Functions',
    difficulty: 'easy',
    title: 'Check if Character is Digit',
    text: 'Check if the character is a digit using isdigit()',
    setup: "#include <ctype.h>\nchar ch = '5';",
    setupCode: "#include <ctype.h>\nchar ch = '5';",
    expected: 'isdigit(ch)',
    sample: 'if (isdigit(ch)) { /* is a digit */ }',
    hints: ['isdigit returns non-zero for 0-9', 'Returns 0 for non-digit characters'],
    validPatterns: [/isdigit\s*\(\s*ch\s*\)/],
    tags: ['isdigit', 'ctype.h', 'character'],
  },
  {
    id: 'c-toupper-convert',
    category: 'Character Functions',
    difficulty: 'easy',
    title: 'Convert to Uppercase',
    text: 'Convert the lowercase character to uppercase using toupper()',
    setup: "#include <ctype.h>\nchar ch = 'a';",
    setupCode: "#include <ctype.h>\nchar ch = 'a';",
    expected: 'toupper(ch)',
    sample: 'char upper = toupper(ch)',
    hints: [
      'toupper converts lowercase to uppercase',
      'Non-lowercase characters are returned unchanged',
    ],
    validPatterns: [/toupper\s*\(\s*ch\s*\)/],
    tags: ['toupper', 'ctype.h', 'character'],
  },
  {
    id: 'c-tolower-convert',
    category: 'Character Functions',
    difficulty: 'easy',
    title: 'Convert to Lowercase',
    text: 'Convert the uppercase character to lowercase using tolower()',
    setup: "#include <ctype.h>\nchar ch = 'Z';",
    setupCode: "#include <ctype.h>\nchar ch = 'Z';",
    expected: 'tolower(ch)',
    sample: 'char lower = tolower(ch)',
    hints: [
      'tolower converts uppercase to lowercase',
      'Non-uppercase characters are returned unchanged',
    ],
    validPatterns: [/tolower\s*\(\s*ch\s*\)/],
    tags: ['tolower', 'ctype.h', 'character'],
  },
  {
    id: 'c-isspace-check',
    category: 'Character Functions',
    difficulty: 'easy',
    title: 'Check if Character is Whitespace',
    text: 'Check if the character is whitespace using isspace()',
    setup: "#include <ctype.h>\nchar ch = ' ';",
    setupCode: "#include <ctype.h>\nchar ch = ' ';",
    expected: 'isspace(ch)',
    sample: 'if (isspace(ch)) { /* is whitespace */ }',
    hints: [
      'isspace matches space, tab, newline, etc.',
      'Includes: space, \\t, \\n, \\v, \\f, \\r',
    ],
    validPatterns: [/isspace\s*\(\s*ch\s*\)/],
    tags: ['isspace', 'ctype.h', 'character'],
  },
  {
    id: 'c-string-uppercase',
    category: 'Character Functions',
    difficulty: 'medium',
    title: 'Convert String to Uppercase',
    text: 'Convert entire string to uppercase using toupper()',
    setup: '#include <ctype.h>\nchar str[] = "Hello World";',
    setupCode: '#include <ctype.h>\nchar str[] = "Hello World";',
    expected: 'str = "HELLO WORLD"',
    sample: 'for (int i = 0; str[i]; i++) {\n    str[i] = toupper(str[i]);\n}',
    hints: ['Loop through each character', 'Apply toupper to each character'],
    validPatterns: [/for\s*\([^)]+\)|while\s*\([^)]+\)/, /str\s*\[\s*\w+\s*\]\s*=\s*toupper/],
    tags: ['toupper', 'ctype.h', 'string', 'loop'],
  },

  // ============================================================
  // Math Functions (math.h)
  // ============================================================
  {
    id: 'c-fabs-absolute',
    category: 'Math Functions',
    difficulty: 'easy',
    title: 'Floating Point Absolute Value',
    text: 'Get the absolute value of -3.14 using fabs()',
    setup: '#include <math.h>\ndouble num = -3.14;',
    setupCode: '#include <math.h>\ndouble num = -3.14;',
    expected: 'fabs(num)',
    sample: 'double result = fabs(num)',
    hints: ['fabs is for floating point (double)', 'abs from stdlib.h is for integers'],
    validPatterns: [/fabs\s*\(\s*num\s*\)/],
    tags: ['fabs', 'math.h', 'absolute'],
  },
  {
    id: 'c-pow-power',
    category: 'Math Functions',
    difficulty: 'easy',
    title: 'Calculate Power with pow',
    text: 'Calculate 2 raised to the power of 10 using pow()',
    setup: '#include <math.h>\ndouble base = 2.0;\ndouble exponent = 10.0;',
    setupCode: '#include <math.h>\ndouble base = 2.0;\ndouble exponent = 10.0;',
    expected: 'pow(base, exponent)',
    sample: 'double result = pow(base, exponent)',
    hints: [
      'pow(base, exponent) returns base^exponent',
      'Both arguments and return type are double',
    ],
    validPatterns: [/pow\s*\(\s*base\s*,\s*exponent\s*\)|pow\s*\(\s*2(\.0)?\s*,\s*10(\.0)?\s*\)/],
    tags: ['pow', 'math.h', 'power'],
  },
  {
    id: 'c-sqrt-root',
    category: 'Math Functions',
    difficulty: 'easy',
    title: 'Calculate Square Root',
    text: 'Calculate the square root of 16.0 using sqrt()',
    setup: '#include <math.h>\ndouble num = 16.0;',
    setupCode: '#include <math.h>\ndouble num = 16.0;',
    expected: 'sqrt(num)',
    sample: 'double result = sqrt(num)',
    hints: ['sqrt returns the square root as double', 'Negative input results in NaN'],
    validPatterns: [/sqrt\s*\(\s*num\s*\)|sqrt\s*\(\s*16(\.0)?\s*\)/],
    tags: ['sqrt', 'math.h', 'root'],
  },
  {
    id: 'c-ceil-floor',
    category: 'Math Functions',
    difficulty: 'medium',
    title: 'Ceiling and Floor Functions',
    text: 'Get the ceiling of 3.2 and floor of 3.8 using ceil() and floor()',
    setup: '#include <math.h>\ndouble a = 3.2;\ndouble b = 3.8;',
    setupCode: '#include <math.h>\ndouble a = 3.2;\ndouble b = 3.8;',
    expected: 'ceil(a) = 4.0, floor(b) = 3.0',
    sample: 'double ceiling = ceil(a);\ndouble floored = floor(b);',
    hints: [
      'ceil rounds up to nearest integer',
      'floor rounds down to nearest integer',
      'Both return double, not int',
    ],
    validPatterns: [/ceil\s*\(\s*a\s*\)/, /floor\s*\(\s*b\s*\)/],
    tags: ['ceil', 'floor', 'math.h', 'rounding'],
  },
  {
    id: 'c-fmod-remainder',
    category: 'Math Functions',
    difficulty: 'medium',
    title: 'Floating Point Modulo',
    text: 'Calculate the remainder of 5.5 divided by 2.0 using fmod()',
    setup: '#include <math.h>\ndouble a = 5.5;\ndouble b = 2.0;',
    setupCode: '#include <math.h>\ndouble a = 5.5;\ndouble b = 2.0;',
    expected: 'fmod(a, b)',
    sample: 'double remainder = fmod(a, b)',
    hints: ['fmod(x, y) returns remainder of x/y', '% operator only works for integers'],
    validPatterns: [/fmod\s*\(\s*a\s*,\s*b\s*\)|fmod\s*\(\s*5\.5\s*,\s*2(\.0)?\s*\)/],
    tags: ['fmod', 'math.h', 'modulo'],
  },
  {
    id: 'c-distance-formula',
    category: 'Math Functions',
    difficulty: 'hard',
    title: 'Calculate Distance Between Points',
    text: 'Calculate Euclidean distance between two points using sqrt() and pow()',
    setup: '#include <math.h>\ndouble x1 = 0.0, y1 = 0.0;\ndouble x2 = 3.0, y2 = 4.0;',
    setupCode: '#include <math.h>\ndouble x1 = 0.0, y1 = 0.0;\ndouble x2 = 3.0, y2 = 4.0;',
    expected: '5.0',
    sample: 'double distance = sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));',
    hints: ['Distance formula: sqrt((x2-x1)^2 + (y2-y1)^2)', 'Use pow(value, 2) to square'],
    validPatterns: [/sqrt\s*\(\s*pow\s*\([^)]+,\s*2\s*\)\s*\+\s*pow\s*\([^)]+,\s*2\s*\)\s*\)/],
    tags: ['sqrt', 'pow', 'math.h', 'geometry'],
  },

  // ============================================================
  // Standard I/O Functions
  // ============================================================
  {
    id: 'c-sprintf-formatted',
    category: 'Standard I/O',
    difficulty: 'medium',
    title: 'Format Multiple Values with sprintf',
    text: 'Format name and score into a string buffer using sprintf()',
    setup: '#include <stdio.h>\nchar buffer[100];\nchar name[] = "Alice";\nint score = 95;',
    setupCode: '#include <stdio.h>\nchar buffer[100];\nchar name[] = "Alice";\nint score = 95;',
    expected: 'sprintf(buffer, "%s scored %d points", name, score)',
    sample: 'sprintf(buffer, "%s scored %d points", name, score)',
    hints: ['sprintf writes formatted string to buffer', 'Use %s for strings, %d for integers'],
    validPatterns: [
      /sprintf\s*\(\s*buffer\s*,\s*["'][^"']*%s[^"']*%d[^"']*["']\s*,\s*name\s*,\s*score\s*\)/,
    ],
    tags: ['sprintf', 'stdio.h', 'format'],
  },
  {
    id: 'c-sscanf-multiple',
    category: 'Standard I/O',
    difficulty: 'hard',
    title: 'Parse Multiple Values with sscanf',
    text: 'Parse date components (day, month, year) from string using sscanf()',
    setup: '#include <stdio.h>\nchar date[] = "25-12-2024";\nint day, month, year;',
    setupCode: '#include <stdio.h>\nchar date[] = "25-12-2024";\nint day, month, year;',
    expected: 'sscanf(date, "%d-%d-%d", &day, &month, &year)',
    sample: 'sscanf(date, "%d-%d-%d", &day, &month, &year)',
    hints: [
      'sscanf parses formatted input from string',
      'Use & to pass address of variables',
      'Format string matches input pattern',
    ],
    validPatterns: [
      /sscanf\s*\(\s*date\s*,\s*["']%d-%d-%d["']\s*,\s*&day\s*,\s*&month\s*,\s*&year\s*\)/,
    ],
    tags: ['sscanf', 'stdio.h', 'parse'],
  },
  {
    id: 'c-snprintf-safe',
    category: 'Standard I/O',
    difficulty: 'hard',
    title: 'Safe String Formatting with snprintf',
    text: 'Safely format a long message into a small buffer using snprintf()',
    setup:
      '#include <stdio.h>\nchar buffer[20];\nchar *message = "This is a very long message that exceeds buffer";',
    setupCode:
      '#include <stdio.h>\nchar buffer[20];\nchar *message = "This is a very long message that exceeds buffer";',
    expected: 'snprintf(buffer, sizeof(buffer), "%s", message)',
    sample: 'int written = snprintf(buffer, sizeof(buffer), "%s", message);',
    hints: [
      'snprintf prevents buffer overflow',
      'Returns number of characters that would be written',
      'If return >= size, output was truncated',
    ],
    validPatterns: [
      /snprintf\s*\(\s*buffer\s*,\s*(sizeof\s*\(\s*buffer\s*\)|20)\s*,\s*["']%s["']\s*,\s*message\s*\)/,
    ],
    tags: ['snprintf', 'stdio.h', 'safe', 'format'],
  },

  // ============================================================
  // String and Array Operations - Advanced
  // ============================================================
  {
    id: 'c-str-strncpy-null-term',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Safe strncpy with Null Termination',
    text: 'Copy at most 10 characters from src to dest using strncpy, ensuring null termination',
    setup: '#include <string.h>\nchar src[] = "Hello World!";\nchar dest[11];',
    setupCode: '#include <string.h>\nchar src[] = "Hello World!";\nchar dest[11];',
    expected: "strncpy(dest, src, 10); dest[10] = '\\0';",
    sample: "strncpy(dest, src, 10);\ndest[10] = '\\0';",
    hints: [
      'strncpy may not null-terminate if src is longer than n',
      'Always manually set the last byte to null for safety',
    ],
    validPatterns: [
      /strncpy\s*\(\s*dest\s*,\s*src\s*,\s*10\s*\)/,
      /dest\s*\[\s*10\s*\]\s*=\s*['"]?\\0['"]?/,
    ],
    tags: ['strncpy', 'string.h', 'safe', 'null-termination'],
  },
  {
    id: 'c-str-strncat-bounded',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Bounded String Concatenation',
    text: 'Append suffix to prefix, but limit to only 4 characters from suffix using strncat',
    setup: '#include <string.h>\nchar prefix[20] = "Hello";\nchar suffix[] = " World!";',
    setupCode: '#include <string.h>\nchar prefix[20] = "Hello";\nchar suffix[] = " World!";',
    expected: 'strncat(prefix, suffix, 4)',
    sample: 'strncat(prefix, suffix, 4); // Result: "Hello Wor"',
    hints: [
      'strncat appends at most n characters from src',
      'Unlike strncpy, strncat always null-terminates',
    ],
    validPatterns: [/strncat\s*\(\s*prefix\s*,\s*suffix\s*,\s*4\s*\)/],
    tags: ['strncat', 'string.h', 'safe', 'concatenation'],
  },
  {
    id: 'c-str-strncmp-prefix',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Compare String Prefix with strncmp',
    text: 'Check if the string starts with "Hello" by comparing the first 5 characters',
    setup: '#include <string.h>\nchar str[] = "Hello World";\nchar prefix[] = "Hello";',
    setupCode: '#include <string.h>\nchar str[] = "Hello World";\nchar prefix[] = "Hello";',
    expected: 'strncmp(str, prefix, 5) == 0',
    sample: 'int isPrefix = (strncmp(str, prefix, 5) == 0);',
    hints: [
      'strncmp compares at most n characters',
      'Returns 0 if the compared portions are equal',
    ],
    validPatterns: [/strncmp\s*\(\s*str\s*,\s*prefix\s*,\s*5\s*\)\s*==\s*0/],
    tags: ['strncmp', 'string.h', 'prefix', 'comparison'],
  },
  {
    id: 'c-str-strchr-count',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Count Character Occurrences with strchr',
    text: 'Count how many times the letter "l" appears in the string using strchr',
    setup: '#include <string.h>\nchar str[] = "Hello World";',
    setupCode: '#include <string.h>\nchar str[] = "Hello World";',
    expected: 'count = 3',
    sample:
      "int count = 0;\nchar *ptr = str;\nwhile ((ptr = strchr(ptr, 'l')) != NULL) {\n    count++;\n    ptr++;\n}",
    hints: [
      'strchr finds the first occurrence of a character',
      'Call repeatedly starting from position after last match',
    ],
    validPatterns: [
      /strchr\s*\(\s*ptr\s*,\s*['"]?l['"]?\s*\)/,
      /while\s*\([^)]*strchr/,
      /count\s*\+\+/,
    ],
    tags: ['strchr', 'string.h', 'count', 'loop'],
  },
  {
    id: 'c-str-strrchr-extension',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Extract File Extension with strrchr',
    text: 'Find the file extension (part after last dot) using strrchr',
    setup: '#include <string.h>\nchar filename[] = "archive.tar.gz";',
    setupCode: '#include <string.h>\nchar filename[] = "archive.tar.gz";',
    expected: "strrchr(filename, '.')",
    sample: 'char *ext = strrchr(filename, \'.\');\n// ext points to ".gz"',
    hints: [
      'strrchr finds the last occurrence of a character',
      'Perfect for extracting file extensions',
    ],
    validPatterns: [/strrchr\s*\(\s*filename\s*,\s*['"]?\.['"]?\s*\)/],
    tags: ['strrchr', 'string.h', 'file', 'extension'],
  },
  {
    id: 'c-str-strpbrk-delimiters',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Find First Delimiter with strpbrk',
    text: 'Find the first occurrence of any delimiter (comma, semicolon, or colon) in the string',
    setup: '#include <string.h>\nchar str[] = "key:value;data,more";',
    setupCode: '#include <string.h>\nchar str[] = "key:value;data,more";',
    expected: 'strpbrk(str, ",;:")',
    sample: 'char *delim = strpbrk(str, ",;:");\n// delim points to ":"',
    hints: [
      'strpbrk finds the first occurrence of any character from a set',
      'Returns NULL if no matching character is found',
    ],
    validPatterns: [/strpbrk\s*\(\s*str\s*,\s*["'][,;:]+["']\s*\)/],
    tags: ['strpbrk', 'string.h', 'delimiter', 'search'],
  },
  {
    id: 'c-str-strspn-numeric',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Count Leading Digits with strspn',
    text: 'Find the length of the leading numeric portion of the string using strspn',
    setup: '#include <string.h>\nchar str[] = "12345abc678";',
    setupCode: '#include <string.h>\nchar str[] = "12345abc678";',
    expected: 'strspn(str, "0123456789")',
    sample: 'size_t len = strspn(str, "0123456789");\n// len = 5',
    hints: [
      'strspn returns length of initial segment containing only accepted chars',
      'Useful for validating input prefixes',
    ],
    validPatterns: [/strspn\s*\(\s*str\s*,\s*["']0123456789["']\s*\)/],
    tags: ['strspn', 'string.h', 'validation', 'numeric'],
  },
  {
    id: 'c-str-strcspn-reject',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Find First Invalid Character with strcspn',
    text: 'Find the position of the first non-alphanumeric character using strcspn',
    setup: '#include <string.h>\nchar str[] = "Hello123!@#World";',
    setupCode: '#include <string.h>\nchar str[] = "Hello123!@#World";',
    expected: 'strcspn(str, "!@#$%^&*()")',
    sample: 'size_t pos = strcspn(str, "!@#$%^&*()");\n// pos = 8 (position of !)',
    hints: [
      'strcspn returns length until first rejected character',
      'Complement of strspn functionality',
    ],
    validPatterns: [/strcspn\s*\(\s*str\s*,\s*["'][!@#$%^&*()]+["']\s*\)/],
    tags: ['strcspn', 'string.h', 'validation', 'search'],
  },
  {
    id: 'c-str-memchr-find',
    category: 'Memory Functions',
    difficulty: 'easy',
    title: 'Find Byte in Memory with memchr',
    text: 'Find the first occurrence of newline character in the buffer using memchr',
    setup: '#include <string.h>\nchar buffer[] = "Line1\\nLine2\\nLine3";\nsize_t len = 18;',
    setupCode: '#include <string.h>\nchar buffer[] = "Line1\\nLine2\\nLine3";\nsize_t len = 18;',
    expected: "memchr(buffer, '\\n', len)",
    sample: "char *newline = memchr(buffer, '\\n', len);",
    hints: [
      'memchr searches n bytes for the specified byte value',
      'Works with binary data that may contain null bytes',
    ],
    validPatterns: [/memchr\s*\(\s*buffer\s*,\s*['"]?\\n['"]?\s*,\s*len\s*\)/],
    tags: ['memchr', 'string.h', 'memory', 'search'],
  },
  {
    id: 'c-str-memmove-insert',
    category: 'Memory Functions',
    difficulty: 'medium',
    title: 'Insert Character with memmove',
    text: 'Insert a space at position 5 by shifting the rest of the string using memmove',
    setup: '#include <string.h>\nchar str[20] = "HelloWorld";\nint pos = 5;',
    setupCode: '#include <string.h>\nchar str[20] = "HelloWorld";\nint pos = 5;',
    expected: "memmove(str + pos + 1, str + pos, strlen(str) - pos + 1); str[pos] = ' ';",
    sample:
      'memmove(str + pos + 1, str + pos, strlen(str) - pos + 1);\nstr[pos] = \' \';\n// Result: "Hello World"',
    hints: [
      'memmove handles overlapping regions safely',
      'Shift includes the null terminator (+1)',
    ],
    validPatterns: [
      /memmove\s*\(\s*str\s*\+\s*pos\s*\+\s*1/,
      /str\s*\[\s*pos\s*\]\s*=\s*['"]?\s['"]?/,
    ],
    tags: ['memmove', 'string.h', 'memory', 'insert'],
  },
  {
    id: 'c-str-atoi-validation',
    category: 'Conversion Functions',
    difficulty: 'easy',
    title: 'Convert String to Integer with Validation',
    text: 'Convert the numeric string to integer using atoi, handling the leading whitespace',
    setup: '#include <stdlib.h>\nchar str[] = "   -42";',
    setupCode: '#include <stdlib.h>\nchar str[] = "   -42";',
    expected: 'atoi(str)',
    sample: 'int num = atoi(str);\n// num = -42 (atoi skips leading whitespace)',
    hints: ['atoi automatically skips leading whitespace', 'Handles optional sign (+ or -)'],
    validPatterns: [/atoi\s*\(\s*str\s*\)/],
    tags: ['atoi', 'stdlib.h', 'conversion', 'whitespace'],
  },
  {
    id: 'c-str-atof-scientific',
    category: 'Conversion Functions',
    difficulty: 'medium',
    title: 'Parse Scientific Notation with atof',
    text: 'Convert the scientific notation string to double using atof',
    setup: '#include <stdlib.h>\nchar str[] = "1.5e-3";',
    setupCode: '#include <stdlib.h>\nchar str[] = "1.5e-3";',
    expected: 'atof(str)',
    sample: 'double num = atof(str);\n// num = 0.0015',
    hints: ['atof handles scientific notation (e or E)', 'Returns double, not float'],
    validPatterns: [/atof\s*\(\s*str\s*\)/],
    tags: ['atof', 'stdlib.h', 'conversion', 'scientific'],
  },
  {
    id: 'c-str-strtol-hex',
    category: 'Conversion Functions',
    difficulty: 'medium',
    title: 'Parse Hexadecimal with strtol',
    text: 'Convert the hexadecimal string "0xFF" to integer using strtol with base 16',
    setup: '#include <stdlib.h>\nchar str[] = "0xFF";\nchar *endptr;',
    setupCode: '#include <stdlib.h>\nchar str[] = "0xFF";\nchar *endptr;',
    expected: 'strtol(str, &endptr, 16)',
    sample: 'long num = strtol(str, &endptr, 16);\n// num = 255',
    hints: [
      'Use base 16 for hexadecimal conversion',
      'strtol can handle 0x prefix with base 0 or 16',
    ],
    validPatterns: [/strtol\s*\(\s*str\s*,\s*(&endptr|NULL)\s*,\s*16\s*\)/],
    tags: ['strtol', 'stdlib.h', 'conversion', 'hexadecimal'],
  },
  {
    id: 'c-str-strtod-endptr',
    category: 'Conversion Functions',
    difficulty: 'medium',
    title: 'Parse Double with Error Detection using strtod',
    text: 'Convert the string to double using strtod and check for trailing characters',
    setup: '#include <stdlib.h>\nchar str[] = "3.14159abc";\nchar *endptr;',
    setupCode: '#include <stdlib.h>\nchar str[] = "3.14159abc";\nchar *endptr;',
    expected: 'strtod(str, &endptr)',
    sample: 'double num = strtod(str, &endptr);\n// num = 3.14159, endptr points to "abc"',
    hints: [
      'endptr points to first character not part of the number',
      'Check *endptr to detect trailing garbage',
    ],
    validPatterns: [/strtod\s*\(\s*str\s*,\s*&endptr\s*\)/],
    tags: ['strtod', 'stdlib.h', 'conversion', 'validation'],
  },
  {
    id: 'c-str-strtol-binary',
    category: 'Conversion Functions',
    difficulty: 'medium',
    title: 'Parse Binary String with strtol',
    text: 'Convert the binary string "11010110" to integer using strtol with base 2',
    setup: '#include <stdlib.h>\nchar str[] = "11010110";\nchar *endptr;',
    setupCode: '#include <stdlib.h>\nchar str[] = "11010110";\nchar *endptr;',
    expected: 'strtol(str, &endptr, 2)',
    sample: 'long num = strtol(str, &endptr, 2);\n// num = 214',
    hints: ['Use base 2 for binary conversion', 'Only 0 and 1 are valid binary digits'],
    validPatterns: [/strtol\s*\(\s*str\s*,\s*(&endptr|NULL)\s*,\s*2\s*\)/],
    tags: ['strtol', 'stdlib.h', 'conversion', 'binary'],
  },
  {
    id: 'c-str-array-reverse',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Reverse String In-Place',
    text: 'Reverse the string in-place using character array manipulation',
    setup: '#include <string.h>\nchar str[] = "Hello";',
    setupCode: '#include <string.h>\nchar str[] = "Hello";',
    expected: 'str = "olleH"',
    sample:
      'int len = strlen(str);\nfor (int i = 0; i < len / 2; i++) {\n    char temp = str[i];\n    str[i] = str[len - 1 - i];\n    str[len - 1 - i] = temp;\n}',
    hints: [
      'Swap characters from both ends moving toward center',
      'Only iterate to len/2 to avoid double-swapping',
    ],
    validPatterns: [
      /for\s*\([^)]*len\s*\/\s*2/,
      /temp|swap/i,
      /str\s*\[\s*len\s*-\s*1\s*-\s*\w+\s*\]/,
    ],
    tags: ['string', 'reverse', 'array', 'in-place'],
  },
  {
    id: 'c-str-buffer-shift-left',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Left Shift Buffer Contents',
    text: 'Remove the first 3 characters by shifting buffer contents left using memmove',
    setup: '#include <string.h>\nchar buffer[] = "ABCDEFGHIJ";\nint shift = 3;',
    setupCode: '#include <string.h>\nchar buffer[] = "ABCDEFGHIJ";\nint shift = 3;',
    expected: 'memmove(buffer, buffer + shift, strlen(buffer) - shift + 1)',
    sample: 'memmove(buffer, buffer + shift, strlen(buffer) - shift + 1);\n// Result: "DEFGHIJ"',
    hints: [
      'Use memmove for overlapping memory regions',
      'Include null terminator in the move (+1)',
    ],
    validPatterns: [/memmove\s*\(\s*buffer\s*,\s*buffer\s*\+\s*shift/],
    tags: ['memmove', 'buffer', 'shift', 'string.h'],
  },
  {
    id: 'c-str-tokenize-csv',
    category: 'String Functions',
    difficulty: 'hard',
    title: 'Tokenize CSV Line with strtok',
    text: 'Parse a CSV line into individual fields using strtok with comma delimiter',
    setup:
      '#include <string.h>\n#include <stdio.h>\nchar csv[] = "John,25,Engineer,NYC";\nchar *fields[10];\nint count = 0;',
    setupCode:
      '#include <string.h>\n#include <stdio.h>\nchar csv[] = "John,25,Engineer,NYC";\nchar *fields[10];\nint count = 0;',
    expected: 'fields contains: "John", "25", "Engineer", "NYC"',
    sample:
      'char *token = strtok(csv, ",");\nwhile (token && count < 10) {\n    fields[count++] = token;\n    token = strtok(NULL, ",");\n}',
    hints: [
      'First call uses the string, subsequent calls use NULL',
      'strtok modifies the original string (inserts nulls)',
      'Store pointers to tokens, not copies',
    ],
    validPatterns: [
      /strtok\s*\(\s*csv\s*,\s*["'],["']\s*\)/,
      /strtok\s*\(\s*NULL\s*,/,
      /fields\s*\[\s*count/,
    ],
    tags: ['strtok', 'string.h', 'csv', 'tokenize'],
  },
  {
    id: 'c-str-strspn-validate-identifier',
    category: 'String Functions',
    difficulty: 'hard',
    title: 'Validate C Identifier with strspn',
    text: 'Check if a string is a valid C identifier (starts with letter/underscore, contains only alphanumeric and underscore)',
    setup: '#include <string.h>\n#include <ctype.h>\nchar ident[] = "my_var123";',
    setupCode: '#include <string.h>\n#include <ctype.h>\nchar ident[] = "my_var123";',
    expected: 'Valid identifier check',
    sample:
      'int isValid = (isalpha(ident[0]) || ident[0] == \'_\') &&\n    strspn(ident, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_") == strlen(ident);',
    hints: [
      'First character must be letter or underscore',
      'strspn returns length of valid prefix',
      'Valid if strspn length equals string length',
    ],
    validPatterns: [
      /isalpha\s*\(\s*ident\s*\[\s*0\s*\]\s*\)|ident\s*\[\s*0\s*\]\s*==\s*['"]_['"]/,
      /strspn\s*\(\s*ident/,
      /strlen\s*\(\s*ident\s*\)/,
    ],
    tags: ['strspn', 'string.h', 'validation', 'identifier'],
  },
  {
    id: 'c-str-pointer-word-count',
    category: 'Pointer Operations',
    difficulty: 'hard',
    title: 'Count Words Using Pointer Traversal',
    text: 'Count the number of words in a string using pointer arithmetic and character checks',
    setup: '#include <ctype.h>\nchar text[] = "  Hello   World  How Are   You  ";',
    setupCode: '#include <ctype.h>\nchar text[] = "  Hello   World  How Are   You  ";',
    expected: 'count = 5',
    sample:
      'int count = 0;\nchar *ptr = text;\nwhile (*ptr) {\n    while (*ptr && isspace(*ptr)) ptr++;\n    if (*ptr) {\n        count++;\n        while (*ptr && !isspace(*ptr)) ptr++;\n    }\n}',
    hints: [
      'Skip leading spaces, then count word start',
      'Use isspace() to detect whitespace',
      'Handle multiple consecutive spaces',
    ],
    validPatterns: [/while\s*\(\s*\*\s*ptr\s*\)/, /isspace\s*\(\s*\*\s*ptr\s*\)/, /count\s*\+\+/],
    tags: ['pointer', 'word-count', 'string', 'ctype.h'],
  },
  {
    id: 'c-str-circular-buffer',
    category: 'Array Operations',
    difficulty: 'hard',
    title: 'Implement Circular Buffer Write',
    text: 'Write data to a circular buffer, wrapping around to the beginning when full',
    setup:
      '#include <string.h>\nchar buffer[10];\nint head = 7;\nint size = 10;\nchar data[] = "HELLO";',
    setupCode:
      '#include <string.h>\nchar buffer[10];\nint head = 7;\nint size = 10;\nchar data[] = "HELLO";',
    expected: 'Data wraps around in circular buffer',
    sample:
      'for (int i = 0; data[i]; i++) {\n    buffer[(head + i) % size] = data[i];\n}\nhead = (head + strlen(data)) % size;',
    hints: [
      'Use modulo operator for wrapping',
      'head + offset % size gives circular index',
      'Update head position after write',
    ],
    validPatterns: [/\(\s*head\s*\+\s*\w+\s*\)\s*%\s*size/, /buffer\s*\[\s*\(.*%\s*size\s*\)\s*\]/],
    tags: ['circular-buffer', 'array', 'modulo', 'ring-buffer'],
  },
  {
    id: 'c-str-memchr-line-parser',
    category: 'Memory Functions',
    difficulty: 'medium',
    title: 'Parse Lines from Buffer with memchr',
    text: 'Find and extract the first line from a buffer containing multiple lines',
    setup:
      '#include <string.h>\nchar buffer[] = "First line\\nSecond line\\nThird";\nsize_t buflen = 29;',
    setupCode:
      '#include <string.h>\nchar buffer[] = "First line\\nSecond line\\nThird";\nsize_t buflen = 29;',
    expected: 'Pointer to newline and line length',
    sample:
      "char *newline = memchr(buffer, '\\n', buflen);\nsize_t linelen = newline ? (newline - buffer) : buflen;",
    hints: [
      'memchr returns pointer to found byte or NULL',
      'Calculate line length by pointer subtraction',
      'Handle case when no newline is found',
    ],
    validPatterns: [
      /memchr\s*\(\s*buffer\s*,\s*['"]?\\n['"]?\s*,\s*buflen\s*\)/,
      /newline\s*-\s*buffer/,
    ],
    tags: ['memchr', 'string.h', 'parsing', 'lines'],
  },
  {
    id: 'c-str-memmove-delete',
    category: 'Memory Functions',
    difficulty: 'medium',
    title: 'Delete Substring with memmove',
    text: 'Delete 3 characters starting at position 5 from the string',
    setup: '#include <string.h>\nchar str[] = "Hello World";\nint pos = 5;\nint len = 3;',
    setupCode: '#include <string.h>\nchar str[] = "Hello World";\nint pos = 5;\nint len = 3;',
    expected: 'memmove(str + pos, str + pos + len, strlen(str) - pos - len + 1)',
    sample:
      'memmove(str + pos, str + pos + len, strlen(str) - pos - len + 1);\n// Result: "Helloorld"',
    hints: [
      'Move characters after deleted portion to fill the gap',
      'Include null terminator in the move',
    ],
    validPatterns: [/memmove\s*\(\s*str\s*\+\s*pos\s*,\s*str\s*\+\s*pos\s*\+\s*len/],
    tags: ['memmove', 'string.h', 'delete', 'substring'],
  },
  {
    id: 'c-str-strtok-r-reentrant',
    category: 'String Functions',
    difficulty: 'hard',
    title: 'Thread-Safe Tokenization with strtok_r',
    text: 'Tokenize a string in a thread-safe manner using strtok_r',
    setup: '#include <string.h>\nchar str[] = "apple:banana:cherry";\nchar *saveptr;',
    setupCode: '#include <string.h>\nchar str[] = "apple:banana:cherry";\nchar *saveptr;',
    expected: 'Use strtok_r with saveptr for thread safety',
    sample:
      'char *token = strtok_r(str, ":", &saveptr);\nwhile (token) {\n    // process token\n    token = strtok_r(NULL, ":", &saveptr);\n}',
    hints: [
      'strtok_r uses saveptr instead of static state',
      'Safe to use in multi-threaded code',
      'POSIX function, may need _GNU_SOURCE',
    ],
    validPatterns: [
      /strtok_r\s*\(\s*str\s*,\s*["']:["']\s*,\s*&saveptr\s*\)/,
      /strtok_r\s*\(\s*NULL\s*,/,
    ],
    tags: ['strtok_r', 'string.h', 'thread-safe', 'tokenize'],
  },
  {
    id: 'c-str-buffer-pack',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Pack Multiple Values into Buffer',
    text: 'Pack an integer and a string into a binary buffer using memcpy',
    setup: '#include <string.h>\nchar buffer[100];\nint id = 42;\nchar name[] = "Test";',
    setupCode: '#include <string.h>\nchar buffer[100];\nint id = 42;\nchar name[] = "Test";',
    expected:
      'memcpy(buffer, &id, sizeof(int)); memcpy(buffer + sizeof(int), name, strlen(name) + 1);',
    sample:
      'int offset = 0;\nmemcpy(buffer + offset, &id, sizeof(int));\noffset += sizeof(int);\nmemcpy(buffer + offset, name, strlen(name) + 1);',
    hints: [
      'Track current offset in buffer',
      'Use sizeof for type-safe offsets',
      'Include null terminator for strings (+1)',
    ],
    validPatterns: [
      /memcpy\s*\(\s*buffer[^,]*,\s*&id\s*,\s*sizeof\s*\(\s*int\s*\)\s*\)/,
      /memcpy\s*\(\s*buffer\s*\+/,
    ],
    tags: ['memcpy', 'buffer', 'packing', 'binary'],
  },

  // ============================================================
  // NEW PROBLEMS - String Functions (100-124)
  // ============================================================
  {
    id: 'c-str-100',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Get String Length of Empty String',
    text: 'Get the length of an empty string using strlen()',
    setup: '#include <string.h>\nchar str[] = "";',
    setupCode: '#include <string.h>\nchar str[] = "";',
    expected: 'strlen(str)',
    sample: 'size_t len = strlen(str); // len = 0',
    hints: ['Empty string has length 0', 'Only null terminator present'],
    validPatterns: [/strlen\s*\(\s*str\s*\)/],
    tags: ['strlen', 'string.h', 'empty'],
  },
  {
    id: 'c-str-101',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Copy String to Larger Buffer',
    text: 'Copy a short string to a larger destination buffer using strcpy()',
    setup: '#include <string.h>\nchar src[] = "Hi";\nchar dest[100];',
    setupCode: '#include <string.h>\nchar src[] = "Hi";\nchar dest[100];',
    expected: 'strcpy(dest, src)',
    sample: 'strcpy(dest, src);',
    hints: [
      'strcpy copies entire string including null terminator',
      'Destination must be large enough',
    ],
    validPatterns: [/strcpy\s*\(\s*dest\s*,\s*src\s*\)/],
    tags: ['strcpy', 'string.h'],
  },
  {
    id: 'c-str-102',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Compare Equal Strings',
    text: 'Compare two identical strings using strcmp()',
    setup: '#include <string.h>\nchar str1[] = "test";\nchar str2[] = "test";',
    setupCode: '#include <string.h>\nchar str1[] = "test";\nchar str2[] = "test";',
    expected: 'strcmp(str1, str2) == 0',
    sample: 'int result = strcmp(str1, str2); // result = 0',
    hints: ['strcmp returns 0 for equal strings', 'Compares character by character'],
    validPatterns: [/strcmp\s*\(\s*str1\s*,\s*str2\s*\)/],
    tags: ['strcmp', 'string.h', 'comparison'],
  },
  {
    id: 'c-str-103',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Find First Space in String',
    text: 'Find the first space character in the string using strchr()',
    setup: '#include <string.h>\nchar str[] = "Hello World";',
    setupCode: '#include <string.h>\nchar str[] = "Hello World";',
    expected: "strchr(str, ' ')",
    sample: "char *space = strchr(str, ' ');",
    hints: ['strchr returns pointer to first occurrence', 'Returns NULL if not found'],
    validPatterns: [/strchr\s*\(\s*str\s*,\s*['"]?\s['"]?\s*\)/],
    tags: ['strchr', 'string.h', 'search'],
  },
  {
    id: 'c-str-104',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Find Substring in Text',
    text: 'Find the substring "cat" in the text using strstr()',
    setup: '#include <string.h>\nchar text[] = "The cat sat on the mat";',
    setupCode: '#include <string.h>\nchar text[] = "The cat sat on the mat";',
    expected: 'strstr(text, "cat")',
    sample: 'char *found = strstr(text, "cat");',
    hints: ['strstr finds first occurrence of substring', 'Returns NULL if not found'],
    validPatterns: [/strstr\s*\(\s*text\s*,\s*["']cat["']\s*\)/],
    tags: ['strstr', 'string.h', 'substring'],
  },
  {
    id: 'c-str-105',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Tokenize Path by Slash',
    text: 'Split a file path by slash delimiter using strtok()',
    setup: '#include <string.h>\nchar path[] = "/home/user/documents";',
    setupCode: '#include <string.h>\nchar path[] = "/home/user/documents";',
    expected: 'strtok(path, "/")',
    sample: 'char *token = strtok(path, "/");\nwhile (token) {\n    token = strtok(NULL, "/");\n}',
    hints: ['strtok modifies original string', 'Use NULL for subsequent calls'],
    validPatterns: [/strtok\s*\(\s*path\s*,\s*["']\/["']\s*\)/],
    tags: ['strtok', 'string.h', 'path'],
  },
  {
    id: 'c-str-106',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Concatenate Three Strings',
    text: 'Concatenate " " and "World" to "Hello" using strcat()',
    setup:
      '#include <string.h>\nchar dest[50] = "Hello";\nchar space[] = " ";\nchar world[] = "World";',
    setupCode:
      '#include <string.h>\nchar dest[50] = "Hello";\nchar space[] = " ";\nchar world[] = "World";',
    expected: 'strcat(strcat(dest, space), world)',
    sample: 'strcat(dest, space);\nstrcat(dest, world);',
    hints: ['strcat returns dest pointer', 'Can chain calls'],
    validPatterns: [/strcat\s*\(\s*dest\s*,\s*space\s*\)/, /strcat\s*\(\s*dest\s*,\s*world\s*\)/],
    tags: ['strcat', 'string.h', 'concatenation'],
  },
  {
    id: 'c-str-107',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Case-Insensitive Compare First 4 Chars',
    text: 'Compare first 4 characters of strings case-insensitively',
    setup: '#include <string.h>\n#include <ctype.h>\nchar str1[] = "Hello";\nchar str2[] = "HELP";',
    setupCode:
      '#include <string.h>\n#include <ctype.h>\nchar str1[] = "Hello";\nchar str2[] = "HELP";',
    expected: 'Manual case-insensitive comparison',
    sample:
      'int i = 0, result = 0;\nwhile (i < 4 && str1[i] && str2[i]) {\n    result = tolower(str1[i]) - tolower(str2[i]);\n    if (result != 0) break;\n    i++;\n}',
    hints: ['Use tolower() on each character', 'Compare character by character'],
    validPatterns: [/tolower\s*\(\s*str1\s*\[/, /tolower\s*\(\s*str2\s*\[/],
    tags: ['strcmp', 'tolower', 'case-insensitive'],
  },
  {
    id: 'c-str-108',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Find Last Slash in Path',
    text: 'Find the last slash in a file path using strrchr()',
    setup: '#include <string.h>\nchar path[] = "/home/user/file.txt";',
    setupCode: '#include <string.h>\nchar path[] = "/home/user/file.txt";',
    expected: "strrchr(path, '/')",
    sample: "char *lastSlash = strrchr(path, '/');",
    hints: ['strrchr finds last occurrence', 'Useful for extracting filename from path'],
    validPatterns: [/strrchr\s*\(\s*path\s*,\s*['"]?\/['"]?\s*\)/],
    tags: ['strrchr', 'string.h', 'path'],
  },
  {
    id: 'c-str-109',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Extract Filename from Path',
    text: 'Extract filename from path using strrchr()',
    setup: '#include <string.h>\nchar path[] = "/home/user/document.pdf";',
    setupCode: '#include <string.h>\nchar path[] = "/home/user/document.pdf";',
    expected: 'filename = "document.pdf"',
    sample: "char *filename = strrchr(path, '/');\nif (filename) filename++; else filename = path;",
    hints: ['strrchr returns pointer to slash', 'Increment to skip the slash'],
    validPatterns: [/strrchr\s*\(\s*path\s*,\s*['"]?\/['"]?\s*\)/, /filename\s*\+\+/],
    tags: ['strrchr', 'string.h', 'filename'],
  },
  {
    id: 'c-str-110',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Check String Starts With Prefix',
    text: 'Check if string starts with "http" using strncmp()',
    setup: '#include <string.h>\nchar url[] = "https://example.com";',
    setupCode: '#include <string.h>\nchar url[] = "https://example.com";',
    expected: 'strncmp(url, "http", 4) == 0',
    sample: 'int startsWithHttp = (strncmp(url, "http", 4) == 0);',
    hints: ['strncmp compares first n characters', 'Returns 0 if equal'],
    validPatterns: [/strncmp\s*\(\s*url\s*,\s*["']http["']\s*,\s*4\s*\)\s*==\s*0/],
    tags: ['strncmp', 'string.h', 'prefix'],
  },
  {
    id: 'c-str-111',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Count Vowels in String',
    text: 'Count the number of vowels in the string',
    setup: '#include <string.h>\n#include <ctype.h>\nchar str[] = "Hello World";',
    setupCode: '#include <string.h>\n#include <ctype.h>\nchar str[] = "Hello World";',
    expected: 'count = 3',
    sample:
      "int count = 0;\nfor (int i = 0; str[i]; i++) {\n    char c = tolower(str[i]);\n    if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') count++;\n}",
    hints: ['Convert to lowercase for easy comparison', 'Check each character against vowels'],
    validPatterns: [/for\s*\([^)]+\)/, /tolower/, /count\s*\+\+/],
    tags: ['string', 'loop', 'vowels'],
  },
  {
    id: 'c-str-112',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Replace Character in String',
    text: 'Replace all spaces with underscores in the string',
    setup: 'char str[] = "hello world test";',
    setupCode: 'char str[] = "hello world test";',
    expected: 'str = "hello_world_test"',
    sample: "for (int i = 0; str[i]; i++) {\n    if (str[i] == ' ') str[i] = '_';\n}",
    hints: ['Iterate through each character', 'Replace in-place'],
    validPatterns: [/for\s*\([^)]+\)/, /str\s*\[\s*\w+\s*\]\s*=\s*['"]_['"]/],
    tags: ['string', 'replace', 'loop'],
  },
  {
    id: 'c-str-113',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Check Empty String',
    text: 'Check if a string is empty',
    setup: 'char str[] = "";',
    setupCode: 'char str[] = "";',
    expected: "str[0] == '\\0' or strlen(str) == 0",
    sample: "int isEmpty = (str[0] == '\\0');",
    hints: ['Empty string has null terminator at index 0', 'Can also use strlen'],
    validPatterns: [/str\s*\[\s*0\s*\]\s*==\s*['"]?\\0['"]?|strlen\s*\(\s*str\s*\)\s*==\s*0/],
    tags: ['string', 'empty', 'check'],
  },
  {
    id: 'c-str-114',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Trim Leading Spaces',
    text: 'Find pointer to first non-space character',
    setup: '#include <ctype.h>\nchar str[] = "   Hello";',
    setupCode: '#include <ctype.h>\nchar str[] = "   Hello";',
    expected: 'Pointer to "Hello"',
    sample: 'char *trimmed = str;\nwhile (*trimmed && isspace(*trimmed)) trimmed++;',
    hints: ['Use isspace() to check for whitespace', 'Increment pointer until non-space'],
    validPatterns: [/while\s*\([^)]*isspace/, /trimmed\s*\+\+/],
    tags: ['string', 'trim', 'whitespace'],
  },
  {
    id: 'c-str-115',
    category: 'String Functions',
    difficulty: 'hard',
    title: 'Remove Duplicate Characters',
    text: 'Remove duplicate characters from string keeping first occurrence',
    setup: 'char str[] = "programming";',
    setupCode: 'char str[] = "programming";',
    expected: 'str = "progamin"',
    sample:
      "int seen[256] = {0};\nint j = 0;\nfor (int i = 0; str[i]; i++) {\n    if (!seen[(unsigned char)str[i]]) {\n        seen[(unsigned char)str[i]] = 1;\n        str[j++] = str[i];\n    }\n}\nstr[j] = '\\0';",
    hints: ['Use array to track seen characters', 'Compact string in-place'],
    validPatterns: [/seen\s*\[/, /for\s*\([^)]+\)/, /str\s*\[\s*j\s*\+\+\s*\]/],
    tags: ['string', 'duplicate', 'array'],
  },
  {
    id: 'c-str-116',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Count Words in String',
    text: 'Count the number of words separated by spaces',
    setup: 'char str[] = "one two three four";',
    setupCode: 'char str[] = "one two three four";',
    expected: 'count = 4',
    sample:
      "int count = 0, inWord = 0;\nfor (int i = 0; str[i]; i++) {\n    if (str[i] != ' ' && !inWord) { count++; inWord = 1; }\n    else if (str[i] == ' ') inWord = 0;\n}",
    hints: ['Track if currently in a word', 'Count transitions from space to non-space'],
    validPatterns: [/for\s*\([^)]+\)/, /inWord|in_word/, /count\s*\+\+/],
    tags: ['string', 'words', 'count'],
  },
  {
    id: 'c-str-117',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Convert Digit Char to Int',
    text: 'Convert a single digit character to its integer value',
    setup: "char c = '7';",
    setupCode: "char c = '7';",
    expected: "c - '0'",
    sample: "int digit = c - '0'; // digit = 7",
    hints: ['ASCII digits are consecutive', "Subtract '0' to get numeric value"],
    validPatterns: [/c\s*-\s*['"]0['"]/],
    tags: ['char', 'conversion', 'digit'],
  },
  {
    id: 'c-str-118',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Convert Int to Digit Char',
    text: 'Convert integer 5 to character "5"',
    setup: 'int n = 5;',
    setupCode: 'int n = 5;',
    expected: "n + '0'",
    sample: "char c = n + '0'; // c = '5'",
    hints: ['Add ASCII value of 0', 'Only works for 0-9'],
    validPatterns: [/n\s*\+\s*['"]0['"]/],
    tags: ['char', 'conversion', 'digit'],
  },
  {
    id: 'c-str-119',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Check Palindrome String',
    text: 'Check if the string is a palindrome',
    setup: 'char str[] = "radar";',
    setupCode: 'char str[] = "radar";',
    expected: 'isPalindrome = 1',
    sample:
      'int len = strlen(str);\nint isPalindrome = 1;\nfor (int i = 0; i < len / 2; i++) {\n    if (str[i] != str[len - 1 - i]) { isPalindrome = 0; break; }\n}',
    hints: ['Compare characters from both ends', 'Only check half the string'],
    validPatterns: [/for\s*\([^)]*len\s*\/\s*2/, /str\s*\[\s*\w+\s*\]\s*!=\s*str\s*\[\s*len/],
    tags: ['string', 'palindrome', 'algorithm'],
  },
  {
    id: 'c-str-120',
    category: 'String Functions',
    difficulty: 'hard',
    title: 'Implement strstr Manually',
    text: 'Find substring without using strstr()',
    setup: 'char haystack[] = "Hello World";\nchar needle[] = "Wor";',
    setupCode: 'char haystack[] = "Hello World";\nchar needle[] = "Wor";',
    expected: 'Pointer to "World"',
    sample:
      'char *result = NULL;\nfor (int i = 0; haystack[i]; i++) {\n    int j = 0;\n    while (needle[j] && haystack[i+j] == needle[j]) j++;\n    if (!needle[j]) { result = &haystack[i]; break; }\n}',
    hints: ['Nested loop to match substring', 'Break when full match found'],
    validPatterns: [/for\s*\([^)]+\)/, /while\s*\([^)]+\)/, /haystack\s*\[\s*\w+\s*\+\s*\w+\s*\]/],
    tags: ['strstr', 'manual', 'substring'],
  },
  {
    id: 'c-str-121',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Find All Occurrences of Char',
    text: 'Find all positions where character appears',
    setup: '#include <string.h>\nchar str[] = "banana";\nint positions[10];\nint count = 0;',
    setupCode: '#include <string.h>\nchar str[] = "banana";\nint positions[10];\nint count = 0;',
    expected: 'positions = {1, 3, 5} for "a"',
    sample: "for (int i = 0; str[i]; i++) {\n    if (str[i] == 'a') positions[count++] = i;\n}",
    hints: ['Iterate through string', 'Store matching indices'],
    validPatterns: [/for\s*\([^)]+\)/, /positions\s*\[\s*count\s*\+\+\s*\]/],
    tags: ['string', 'search', 'positions'],
  },
  {
    id: 'c-str-122',
    category: 'String Functions',
    difficulty: 'easy',
    title: 'Append Character to String',
    text: 'Append a single character to the end of a string',
    setup: 'char str[20] = "Hello";\nchar c = "!";',
    setupCode: 'char str[20] = "Hello";\nchar c = \'!\';',
    expected: 'str = "Hello!"',
    sample: "int len = strlen(str);\nstr[len] = c;\nstr[len + 1] = '\\0';",
    hints: ['Find current length', 'Add char and new null terminator'],
    validPatterns: [
      /str\s*\[\s*len\s*\]\s*=\s*c/,
      /str\s*\[\s*len\s*\+\s*1\s*\]\s*=\s*['"]?\\0['"]?/,
    ],
    tags: ['string', 'append', 'char'],
  },
  {
    id: 'c-str-123',
    category: 'String Functions',
    difficulty: 'medium',
    title: 'Remove Character from String',
    text: 'Remove all occurrences of a character from string',
    setup: 'char str[] = "hello world";',
    setupCode: 'char str[] = "hello world";',
    expected: 'str without "l" = "heo word"',
    sample:
      "int j = 0;\nfor (int i = 0; str[i]; i++) {\n    if (str[i] != 'l') str[j++] = str[i];\n}\nstr[j] = '\\0';",
    hints: ['Use two pointers', 'Copy only non-matching chars'],
    validPatterns: [/for\s*\([^)]+\)/, /str\s*\[\s*j\s*\+\+\s*\]\s*=\s*str\s*\[\s*i\s*\]/],
    tags: ['string', 'remove', 'filter'],
  },
  {
    id: 'c-str-124',
    category: 'String Functions',
    difficulty: 'hard',
    title: 'Reverse Words in String',
    text: 'Reverse the order of words in a string',
    setup: '#include <string.h>\nchar str[] = "Hello World Test";',
    setupCode: '#include <string.h>\nchar str[] = "Hello World Test";',
    expected: 'str = "Test World Hello"',
    sample:
      '// Reverse entire string, then reverse each word\nint len = strlen(str);\n// First reverse whole string\nfor (int i = 0; i < len/2; i++) {\n    char t = str[i]; str[i] = str[len-1-i]; str[len-1-i] = t;\n}',
    hints: ['Reverse entire string first', 'Then reverse each word individually'],
    validPatterns: [/for\s*\([^)]+\)/, /strlen/, /temp|swap/i],
    tags: ['string', 'reverse', 'words'],
  },

  // ============================================================
  // Memory Operations (125-149)
  // ============================================================
  {
    id: 'c-mem-125',
    category: 'Memory Operations',
    difficulty: 'easy',
    title: 'Allocate Memory for String',
    text: 'Allocate memory for a 50-character string using malloc()',
    setup: '#include <stdlib.h>',
    setupCode: '#include <stdlib.h>',
    expected: 'malloc(51)',
    sample: 'char *str = (char *)malloc(51); // +1 for null terminator',
    hints: ['Include space for null terminator', 'Cast void* to char*'],
    validPatterns: [/malloc\s*\(\s*51\s*\)/],
    tags: ['malloc', 'stdlib.h', 'string'],
  },
  {
    id: 'c-mem-126',
    category: 'Memory Operations',
    difficulty: 'easy',
    title: 'Allocate Zeroed String Buffer',
    text: 'Allocate and zero-initialize a 100-byte buffer using calloc()',
    setup: '#include <stdlib.h>',
    setupCode: '#include <stdlib.h>',
    expected: 'calloc(100, 1)',
    sample: 'char *buffer = (char *)calloc(100, 1);',
    hints: ['calloc zeros memory automatically', 'Good for strings'],
    validPatterns: [/calloc\s*\(\s*100\s*,\s*1\s*\)|calloc\s*\(\s*1\s*,\s*100\s*\)/],
    tags: ['calloc', 'stdlib.h', 'zero'],
  },
  {
    id: 'c-mem-127',
    category: 'Memory Operations',
    difficulty: 'medium',
    title: 'Resize Array with realloc',
    text: 'Double the size of an existing array using realloc()',
    setup: '#include <stdlib.h>\nint *arr = (int *)malloc(10 * sizeof(int));\nint size = 10;',
    setupCode: '#include <stdlib.h>\nint *arr = (int *)malloc(10 * sizeof(int));\nint size = 10;',
    expected: 'realloc(arr, 2 * size * sizeof(int))',
    sample: 'arr = (int *)realloc(arr, 2 * size * sizeof(int));',
    hints: ['realloc preserves existing data', 'May return different pointer'],
    validPatterns: [/realloc\s*\(\s*arr\s*,\s*2\s*\*\s*size\s*\*\s*sizeof\s*\(\s*int\s*\)\s*\)/],
    tags: ['realloc', 'stdlib.h', 'resize'],
  },
  {
    id: 'c-mem-128',
    category: 'Memory Operations',
    difficulty: 'easy',
    title: 'Free and Nullify Pointer',
    text: 'Free memory and set pointer to NULL to avoid dangling pointer',
    setup: '#include <stdlib.h>\nint *ptr = (int *)malloc(sizeof(int));',
    setupCode: '#include <stdlib.h>\nint *ptr = (int *)malloc(sizeof(int));',
    expected: 'free(ptr); ptr = NULL;',
    sample: 'free(ptr);\nptr = NULL;',
    hints: ['Setting to NULL prevents use-after-free bugs', 'Good practice for safety'],
    validPatterns: [/free\s*\(\s*ptr\s*\)/, /ptr\s*=\s*NULL/],
    tags: ['free', 'stdlib.h', 'safety'],
  },
  {
    id: 'c-mem-129',
    category: 'Memory Operations',
    difficulty: 'medium',
    title: 'Copy Array with memcpy',
    text: 'Copy an integer array using memcpy()',
    setup: '#include <string.h>\nint src[] = {1, 2, 3, 4, 5};\nint dest[5];',
    setupCode: '#include <string.h>\nint src[] = {1, 2, 3, 4, 5};\nint dest[5];',
    expected: 'memcpy(dest, src, 5 * sizeof(int))',
    sample: 'memcpy(dest, src, 5 * sizeof(int));',
    hints: ['Use sizeof for correct byte count', 'memcpy is faster than loop'],
    validPatterns: [/memcpy\s*\(\s*dest\s*,\s*src\s*,\s*5\s*\*\s*sizeof\s*\(\s*int\s*\)\s*\)/],
    tags: ['memcpy', 'string.h', 'array'],
  },
  {
    id: 'c-mem-130',
    category: 'Memory Operations',
    difficulty: 'easy',
    title: 'Zero Initialize Array with memset',
    text: 'Initialize an integer array to all zeros using memset()',
    setup: '#include <string.h>\nint arr[10];',
    setupCode: '#include <string.h>\nint arr[10];',
    expected: 'memset(arr, 0, sizeof(arr))',
    sample: 'memset(arr, 0, sizeof(arr));',
    hints: ['memset sets bytes to value', '0 works for zeroing any type'],
    validPatterns: [/memset\s*\(\s*arr\s*,\s*0\s*,\s*sizeof\s*\(\s*arr\s*\)\s*\)/],
    tags: ['memset', 'string.h', 'zero'],
  },
  {
    id: 'c-mem-131',
    category: 'Memory Operations',
    difficulty: 'medium',
    title: 'Allocate 2D Array Dynamically',
    text: 'Allocate a 3x4 2D integer array dynamically',
    setup: '#include <stdlib.h>\nint rows = 3, cols = 4;',
    setupCode: '#include <stdlib.h>\nint rows = 3, cols = 4;',
    expected: 'Array of pointers to rows',
    sample:
      'int **arr = (int **)malloc(rows * sizeof(int *));\nfor (int i = 0; i < rows; i++)\n    arr[i] = (int *)malloc(cols * sizeof(int));',
    hints: ['First allocate array of pointers', 'Then allocate each row'],
    validPatterns: [
      /malloc\s*\(\s*rows\s*\*\s*sizeof\s*\(\s*int\s*\*\s*\)\s*\)/,
      /malloc\s*\(\s*cols\s*\*\s*sizeof\s*\(\s*int\s*\)\s*\)/,
    ],
    tags: ['malloc', '2d-array', 'dynamic'],
  },
  {
    id: 'c-mem-132',
    category: 'Memory Operations',
    difficulty: 'medium',
    title: 'Free 2D Array',
    text: 'Free a dynamically allocated 2D array',
    setup: '#include <stdlib.h>\nint **arr; // previously allocated 3x4 array\nint rows = 3;',
    setupCode: '#include <stdlib.h>\nint **arr;\nint rows = 3;',
    expected: 'Free each row then the array of pointers',
    sample: 'for (int i = 0; i < rows; i++)\n    free(arr[i]);\nfree(arr);',
    hints: ['Free in reverse order of allocation', 'Free rows first, then pointer array'],
    validPatterns: [/free\s*\(\s*arr\s*\[\s*i\s*\]\s*\)/, /free\s*\(\s*arr\s*\)/],
    tags: ['free', '2d-array', 'dynamic'],
  },
  {
    id: 'c-mem-133',
    category: 'Memory Operations',
    difficulty: 'easy',
    title: 'Compare Memory Blocks',
    text: 'Compare two memory blocks of 10 bytes using memcmp()',
    setup: '#include <string.h>\nchar a[] = "HelloWorld";\nchar b[] = "HelloWorld";',
    setupCode: '#include <string.h>\nchar a[] = "HelloWorld";\nchar b[] = "HelloWorld";',
    expected: 'memcmp(a, b, 10)',
    sample: 'int result = memcmp(a, b, 10); // result = 0 if equal',
    hints: ['memcmp returns 0 if equal', 'Compares raw bytes'],
    validPatterns: [/memcmp\s*\(\s*a\s*,\s*b\s*,\s*10\s*\)/],
    tags: ['memcmp', 'string.h', 'compare'],
  },
  {
    id: 'c-mem-134',
    category: 'Memory Operations',
    difficulty: 'medium',
    title: 'Shift Array Elements Right',
    text: 'Shift array elements right by 2 positions using memmove()',
    setup: '#include <string.h>\nint arr[10] = {1, 2, 3, 4, 5, 0, 0, 0, 0, 0};',
    setupCode: '#include <string.h>\nint arr[10] = {1, 2, 3, 4, 5, 0, 0, 0, 0, 0};',
    expected: 'memmove(arr + 2, arr, 5 * sizeof(int))',
    sample: 'memmove(arr + 2, arr, 5 * sizeof(int));',
    hints: ['memmove handles overlapping regions', 'Destination is arr + 2'],
    validPatterns: [
      /memmove\s*\(\s*arr\s*\+\s*2\s*,\s*arr\s*,\s*5\s*\*\s*sizeof\s*\(\s*int\s*\)\s*\)/,
    ],
    tags: ['memmove', 'string.h', 'shift'],
  },
  {
    id: 'c-mem-135',
    category: 'Memory Operations',
    difficulty: 'hard',
    title: 'Implement memset Manually',
    text: 'Fill memory with a byte value without using memset()',
    setup: 'char buffer[20];\nint value = 65;\nint n = 10;',
    setupCode: 'char buffer[20];\nint value = 65;\nint n = 10;',
    expected: 'First 10 bytes set to 65',
    sample: 'for (int i = 0; i < n; i++) {\n    buffer[i] = (char)value;\n}',
    hints: ['Cast value to char', 'Loop through n bytes'],
    validPatterns: [/for\s*\([^)]+\)/, /buffer\s*\[\s*i\s*\]\s*=/],
    tags: ['memset', 'manual', 'loop'],
  },
  {
    id: 'c-mem-136',
    category: 'Memory Operations',
    difficulty: 'hard',
    title: 'Implement memcpy Manually',
    text: 'Copy n bytes from source to destination without using memcpy()',
    setup: 'char src[] = "Hello";\nchar dest[10];\nint n = 5;',
    setupCode: 'char src[] = "Hello";\nchar dest[10];\nint n = 5;',
    expected: 'dest contains first 5 bytes of src',
    sample: 'for (int i = 0; i < n; i++) {\n    dest[i] = src[i];\n}',
    hints: ['Copy byte by byte', 'No overlap handling needed'],
    validPatterns: [/for\s*\([^)]+\)/, /dest\s*\[\s*i\s*\]\s*=\s*src\s*\[\s*i\s*\]/],
    tags: ['memcpy', 'manual', 'loop'],
  },
  {
    id: 'c-mem-137',
    category: 'Memory Operations',
    difficulty: 'medium',
    title: 'Allocate Struct Array',
    text: 'Allocate an array of 5 Point structs',
    setup: '#include <stdlib.h>\nstruct Point { int x; int y; };',
    setupCode: '#include <stdlib.h>\nstruct Point { int x; int y; };',
    expected: 'malloc(5 * sizeof(struct Point))',
    sample: 'struct Point *points = (struct Point *)malloc(5 * sizeof(struct Point));',
    hints: ['Use sizeof(struct Point) for size', 'Cast result to struct pointer'],
    validPatterns: [/malloc\s*\(\s*5\s*\*\s*sizeof\s*\(\s*struct\s+Point\s*\)\s*\)/],
    tags: ['malloc', 'struct', 'array'],
  },
  {
    id: 'c-mem-138',
    category: 'Memory Operations',
    difficulty: 'easy',
    title: 'Check malloc Success',
    text: 'Allocate memory and check if allocation succeeded',
    setup: '#include <stdlib.h>\n#include <stdio.h>',
    setupCode: '#include <stdlib.h>\n#include <stdio.h>',
    expected: 'Check for NULL after malloc',
    sample:
      'int *ptr = (int *)malloc(sizeof(int));\nif (ptr == NULL) {\n    printf("Allocation failed\\n");\n    return 1;\n}',
    hints: ['malloc returns NULL on failure', 'Always check before using'],
    validPatterns: [/if\s*\(\s*ptr\s*==\s*NULL\s*\)|if\s*\(\s*!ptr\s*\)/],
    tags: ['malloc', 'error-handling', 'null'],
  },
  {
    id: 'c-mem-139',
    category: 'Memory Operations',
    difficulty: 'medium',
    title: 'Duplicate String with malloc',
    text: 'Duplicate a string by allocating new memory and copying',
    setup: '#include <stdlib.h>\n#include <string.h>\nchar original[] = "Hello";',
    setupCode: '#include <stdlib.h>\n#include <string.h>\nchar original[] = "Hello";',
    expected: 'Allocate and copy string',
    sample: 'char *copy = (char *)malloc(strlen(original) + 1);\nif (copy) strcpy(copy, original);',
    hints: ['Allocate strlen + 1 for null terminator', 'Then use strcpy to copy'],
    validPatterns: [
      /malloc\s*\(\s*strlen\s*\(\s*original\s*\)\s*\+\s*1\s*\)/,
      /strcpy\s*\(\s*copy\s*,\s*original\s*\)/,
    ],
    tags: ['malloc', 'strdup', 'copy'],
  },
  {
    id: 'c-mem-140',
    category: 'Memory Operations',
    difficulty: 'hard',
    title: 'Reallocate with Error Handling',
    text: 'Safely reallocate memory handling potential failure',
    setup: '#include <stdlib.h>\nint *arr = (int *)malloc(10 * sizeof(int));',
    setupCode: '#include <stdlib.h>\nint *arr = (int *)malloc(10 * sizeof(int));',
    expected: 'Use temporary pointer for realloc',
    sample:
      'int *temp = (int *)realloc(arr, 20 * sizeof(int));\nif (temp) arr = temp;\nelse { /* handle error, arr still valid */ }',
    hints: ['realloc may return NULL', 'Use temp pointer to preserve original'],
    validPatterns: [/temp\s*=.*realloc/, /if\s*\(\s*temp\s*\)/],
    tags: ['realloc', 'error-handling', 'safety'],
  },
  {
    id: 'c-mem-141',
    category: 'Memory Operations',
    difficulty: 'easy',
    title: 'Fill Array with Pattern',
    text: 'Fill an integer array with the value -1 using memset (note: only works for 0 and -1)',
    setup: '#include <string.h>\nint arr[10];',
    setupCode: '#include <string.h>\nint arr[10];',
    expected: 'memset(arr, -1, sizeof(arr))',
    sample: 'memset(arr, -1, sizeof(arr)); // Sets all bytes to 0xFF',
    hints: ['memset with -1 sets all bytes to 0xFF', 'Works for int -1 representation'],
    validPatterns: [/memset\s*\(\s*arr\s*,\s*-1\s*,\s*sizeof\s*\(\s*arr\s*\)\s*\)/],
    tags: ['memset', 'pattern', 'initialization'],
  },
  {
    id: 'c-mem-142',
    category: 'Memory Operations',
    difficulty: 'medium',
    title: 'Allocate Contiguous 2D Array',
    text: 'Allocate a 2D array as single contiguous block',
    setup: '#include <stdlib.h>\nint rows = 3, cols = 4;',
    setupCode: '#include <stdlib.h>\nint rows = 3, cols = 4;',
    expected: 'Single malloc for all elements',
    sample: 'int *arr = (int *)malloc(rows * cols * sizeof(int));\n// Access: arr[i * cols + j]',
    hints: ['Single allocation is cache-friendly', 'Use i * cols + j for indexing'],
    validPatterns: [/malloc\s*\(\s*rows\s*\*\s*cols\s*\*\s*sizeof\s*\(\s*int\s*\)\s*\)/],
    tags: ['malloc', '2d-array', 'contiguous'],
  },
  {
    id: 'c-mem-143',
    category: 'Memory Operations',
    difficulty: 'easy',
    title: 'Find Byte in Memory',
    text: 'Find the first occurrence of byte value 0 in buffer using memchr()',
    setup: '#include <string.h>\nchar buffer[] = {1, 2, 0, 4, 5};\nsize_t len = 5;',
    setupCode: '#include <string.h>\nchar buffer[] = {1, 2, 0, 4, 5};\nsize_t len = 5;',
    expected: 'memchr(buffer, 0, len)',
    sample: 'char *found = memchr(buffer, 0, len);',
    hints: ['memchr searches for byte value', 'Returns pointer or NULL'],
    validPatterns: [/memchr\s*\(\s*buffer\s*,\s*0\s*,\s*len\s*\)/],
    tags: ['memchr', 'string.h', 'search'],
  },
  {
    id: 'c-mem-144',
    category: 'Memory Operations',
    difficulty: 'medium',
    title: 'Copy Overlapping Memory Forward',
    text: 'Copy bytes forward in same buffer using memmove()',
    setup: '#include <string.h>\nchar str[] = "ABCDEFGH";',
    setupCode: '#include <string.h>\nchar str[] = "ABCDEFGH";',
    expected: 'memmove(str + 4, str, 4)',
    sample: 'memmove(str + 4, str, 4); // "ABCDABCD"',
    hints: ['memmove handles forward overlap', 'Copies first 4 chars to position 4'],
    validPatterns: [/memmove\s*\(\s*str\s*\+\s*4\s*,\s*str\s*,\s*4\s*\)/],
    tags: ['memmove', 'overlap', 'copy'],
  },
  {
    id: 'c-mem-145',
    category: 'Memory Operations',
    difficulty: 'hard',
    title: 'Implement Memory Pool',
    text: 'Create a simple fixed-size memory pool',
    setup: '#include <stdlib.h>\n#define POOL_SIZE 1024\n#define BLOCK_SIZE 32',
    setupCode: '#include <stdlib.h>\n#define POOL_SIZE 1024\n#define BLOCK_SIZE 32',
    expected: 'Pre-allocated pool with block management',
    sample:
      'char pool[POOL_SIZE];\nint used[POOL_SIZE / BLOCK_SIZE] = {0};\n// Allocate: find free block, mark used\n// Free: mark block as unused',
    hints: ['Fixed-size blocks avoid fragmentation', 'Track used blocks with array'],
    validPatterns: [/pool\s*\[/, /used\s*\[/, /BLOCK_SIZE/],
    tags: ['memory-pool', 'allocation', 'advanced'],
  },
  {
    id: 'c-mem-146',
    category: 'Memory Operations',
    difficulty: 'easy',
    title: 'Allocate and Initialize Integer',
    text: 'Allocate memory for one integer and initialize to 42',
    setup: '#include <stdlib.h>',
    setupCode: '#include <stdlib.h>',
    expected: 'malloc and assign',
    sample: 'int *p = (int *)malloc(sizeof(int));\nif (p) *p = 42;',
    hints: ['Allocate sizeof(int) bytes', 'Dereference to assign value'],
    validPatterns: [/malloc\s*\(\s*sizeof\s*\(\s*int\s*\)\s*\)/, /\*\s*p\s*=\s*42/],
    tags: ['malloc', 'initialize', 'pointer'],
  },
  {
    id: 'c-mem-147',
    category: 'Memory Operations',
    difficulty: 'medium',
    title: 'Swap Arrays with memcpy',
    text: 'Swap contents of two arrays using a temporary buffer',
    setup: '#include <string.h>\nint a[] = {1, 2, 3};\nint b[] = {4, 5, 6};\nint temp[3];',
    setupCode: '#include <string.h>\nint a[] = {1, 2, 3};\nint b[] = {4, 5, 6};\nint temp[3];',
    expected: 'Three memcpy calls to swap',
    sample: 'memcpy(temp, a, sizeof(a));\nmemcpy(a, b, sizeof(a));\nmemcpy(b, temp, sizeof(a));',
    hints: ['Use temp buffer for swap', 'Classic three-step swap pattern'],
    validPatterns: [
      /memcpy\s*\(\s*temp\s*,\s*a/,
      /memcpy\s*\(\s*a\s*,\s*b/,
      /memcpy\s*\(\s*b\s*,\s*temp/,
    ],
    tags: ['memcpy', 'swap', 'array'],
  },
  {
    id: 'c-mem-148',
    category: 'Memory Operations',
    difficulty: 'hard',
    title: 'Implement realloc Behavior',
    text: 'Simulate realloc by allocating new block and copying',
    setup:
      '#include <stdlib.h>\n#include <string.h>\nint *old = (int *)malloc(5 * sizeof(int));\nint oldSize = 5, newSize = 10;',
    setupCode:
      '#include <stdlib.h>\n#include <string.h>\nint *old = (int *)malloc(5 * sizeof(int));\nint oldSize = 5, newSize = 10;',
    expected: 'Allocate, copy, free old',
    sample:
      'int *new = (int *)malloc(newSize * sizeof(int));\nif (new) {\n    memcpy(new, old, oldSize * sizeof(int));\n    free(old);\n    old = new;\n}',
    hints: ['Allocate new block', 'Copy old data', 'Free old block'],
    validPatterns: [/malloc\s*\(\s*newSize/, /memcpy\s*\(\s*new\s*,\s*old/, /free\s*\(\s*old\s*\)/],
    tags: ['realloc', 'manual', 'copy'],
  },
  {
    id: 'c-mem-149',
    category: 'Memory Operations',
    difficulty: 'easy',
    title: 'Clear Sensitive Data',
    text: 'Securely clear a password buffer using memset',
    setup: '#include <string.h>\nchar password[64] = "secret123";',
    setupCode: '#include <string.h>\nchar password[64] = "secret123";',
    expected: 'memset(password, 0, sizeof(password))',
    sample: 'memset(password, 0, sizeof(password));',
    hints: ['Zero out sensitive data when done', 'Prevents data leakage'],
    validPatterns: [/memset\s*\(\s*password\s*,\s*0\s*,\s*sizeof\s*\(\s*password\s*\)\s*\)/],
    tags: ['memset', 'security', 'clear'],
  },

  // ============================================================
  // Array Operations (150-174)
  // ============================================================
  {
    id: 'c-arr-150',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Initialize Array with Values',
    text: 'Initialize an array with specific values',
    setup: 'int arr[5];',
    setupCode: 'int arr[5];',
    expected: 'arr = {10, 20, 30, 40, 50}',
    sample: 'int arr[5] = {10, 20, 30, 40, 50};',
    hints: ['Use initializer list', 'Size can be omitted with initializer'],
    validPatterns: [/int\s+arr\s*\[\s*\d*\s*\]\s*=\s*\{/],
    tags: ['array', 'initialization'],
  },
  {
    id: 'c-arr-151',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Find Array Length',
    text: 'Calculate the number of elements in an array',
    setup: 'int arr[] = {1, 2, 3, 4, 5, 6, 7};',
    setupCode: 'int arr[] = {1, 2, 3, 4, 5, 6, 7};',
    expected: 'sizeof(arr) / sizeof(arr[0])',
    sample: 'int len = sizeof(arr) / sizeof(arr[0]); // len = 7',
    hints: ['Total size / element size = count', 'Works only for static arrays'],
    validPatterns: [/sizeof\s*\(\s*arr\s*\)\s*\/\s*sizeof\s*\(\s*arr\s*\[\s*0\s*\]\s*\)/],
    tags: ['array', 'sizeof', 'length'],
  },
  {
    id: 'c-arr-152',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Access Last Element',
    text: 'Access the last element of an array',
    setup: 'int arr[] = {10, 20, 30, 40, 50};\nint n = 5;',
    setupCode: 'int arr[] = {10, 20, 30, 40, 50};\nint n = 5;',
    expected: 'arr[n - 1]',
    sample: 'int last = arr[n - 1]; // last = 50',
    hints: ['Last index is n - 1', 'Arrays are 0-indexed'],
    validPatterns: [/arr\s*\[\s*n\s*-\s*1\s*\]/],
    tags: ['array', 'access', 'index'],
  },
  {
    id: 'c-arr-153',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Bubble Sort Implementation',
    text: 'Sort array in ascending order using bubble sort',
    setup: 'int arr[] = {64, 34, 25, 12, 22, 11, 90};\nint n = 7;',
    setupCode: 'int arr[] = {64, 34, 25, 12, 22, 11, 90};\nint n = 7;',
    expected: 'arr sorted ascending',
    sample:
      'for (int i = 0; i < n-1; i++)\n    for (int j = 0; j < n-i-1; j++)\n        if (arr[j] > arr[j+1]) {\n            int t = arr[j]; arr[j] = arr[j+1]; arr[j+1] = t;\n        }',
    hints: ['Compare adjacent elements', 'Swap if out of order'],
    validPatterns: [
      /for\s*\([^)]+\)/,
      /if\s*\(\s*arr\s*\[\s*j\s*\]\s*>\s*arr\s*\[\s*j\s*\+\s*1\s*\]\s*\)/,
    ],
    tags: ['array', 'sorting', 'bubble-sort'],
  },
  {
    id: 'c-arr-154',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Selection Sort Implementation',
    text: 'Sort array using selection sort',
    setup: 'int arr[] = {64, 25, 12, 22, 11};\nint n = 5;',
    setupCode: 'int arr[] = {64, 25, 12, 22, 11};\nint n = 5;',
    expected: 'arr sorted ascending',
    sample:
      'for (int i = 0; i < n-1; i++) {\n    int min = i;\n    for (int j = i+1; j < n; j++)\n        if (arr[j] < arr[min]) min = j;\n    int t = arr[i]; arr[i] = arr[min]; arr[min] = t;\n}',
    hints: ['Find minimum in unsorted portion', 'Swap with first unsorted'],
    validPatterns: [
      /for\s*\([^)]+\)/,
      /min\s*=\s*i|minIdx/,
      /arr\s*\[\s*j\s*\]\s*<\s*arr\s*\[\s*min/,
    ],
    tags: ['array', 'sorting', 'selection-sort'],
  },
  {
    id: 'c-arr-155',
    category: 'Array Operations',
    difficulty: 'hard',
    title: 'Insertion Sort Implementation',
    text: 'Sort array using insertion sort',
    setup: 'int arr[] = {12, 11, 13, 5, 6};\nint n = 5;',
    setupCode: 'int arr[] = {12, 11, 13, 5, 6};\nint n = 5;',
    expected: 'arr sorted ascending',
    sample:
      'for (int i = 1; i < n; i++) {\n    int key = arr[i];\n    int j = i - 1;\n    while (j >= 0 && arr[j] > key) {\n        arr[j + 1] = arr[j];\n        j--;\n    }\n    arr[j + 1] = key;\n}',
    hints: ['Insert each element into sorted portion', 'Shift larger elements right'],
    validPatterns: [
      /for\s*\([^)]+\)/,
      /key\s*=\s*arr\s*\[\s*i\s*\]/,
      /while\s*\([^)]*arr\s*\[\s*j\s*\]\s*>\s*key/,
    ],
    tags: ['array', 'sorting', 'insertion-sort'],
  },
  {
    id: 'c-arr-156',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Calculate Array Average',
    text: 'Calculate the average of all elements in an array',
    setup: 'int arr[] = {10, 20, 30, 40, 50};\nint n = 5;',
    setupCode: 'int arr[] = {10, 20, 30, 40, 50};\nint n = 5;',
    expected: 'average = 30.0',
    sample:
      'int sum = 0;\nfor (int i = 0; i < n; i++) sum += arr[i];\ndouble avg = (double)sum / n;',
    hints: ['Sum all elements', 'Cast to double before division'],
    validPatterns: [/for\s*\([^)]+\)/, /sum\s*\+=/, /\(\s*double\s*\)\s*sum\s*\/\s*n/],
    tags: ['array', 'average', 'loop'],
  },
  {
    id: 'c-arr-157',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Find Second Largest Element',
    text: 'Find the second largest element in an array',
    setup: 'int arr[] = {12, 35, 1, 10, 34, 1};\nint n = 6;',
    setupCode: 'int arr[] = {12, 35, 1, 10, 34, 1};\nint n = 6;',
    expected: 'second = 34',
    sample:
      'int first = INT_MIN, second = INT_MIN;\nfor (int i = 0; i < n; i++) {\n    if (arr[i] > first) { second = first; first = arr[i]; }\n    else if (arr[i] > second && arr[i] != first) second = arr[i];\n}',
    hints: ['Track both first and second largest', 'Update both when new max found'],
    validPatterns: [/first.*second|largest/, /for\s*\([^)]+\)/],
    tags: ['array', 'search', 'second-largest'],
  },
  {
    id: 'c-arr-158',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Remove Duplicates from Sorted Array',
    text: 'Remove duplicate elements from a sorted array in-place',
    setup: 'int arr[] = {1, 1, 2, 2, 2, 3, 4, 4, 5};\nint n = 9;',
    setupCode: 'int arr[] = {1, 1, 2, 2, 2, 3, 4, 4, 5};\nint n = 9;',
    expected: 'arr = {1, 2, 3, 4, 5}, newLen = 5',
    sample:
      'int j = 0;\nfor (int i = 1; i < n; i++) {\n    if (arr[i] != arr[j]) arr[++j] = arr[i];\n}\nint newLen = j + 1;',
    hints: ['Use two pointers', 'Copy unique elements forward'],
    validPatterns: [/for\s*\([^)]+\)/, /arr\s*\[\s*i\s*\]\s*!=\s*arr\s*\[\s*j\s*\]/],
    tags: ['array', 'duplicates', 'in-place'],
  },
  {
    id: 'c-arr-159',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Check if Array is Sorted',
    text: 'Check if an array is sorted in ascending order',
    setup: 'int arr[] = {1, 2, 3, 4, 5};\nint n = 5;',
    setupCode: 'int arr[] = {1, 2, 3, 4, 5};\nint n = 5;',
    expected: 'isSorted = 1',
    sample:
      'int isSorted = 1;\nfor (int i = 1; i < n; i++) {\n    if (arr[i] < arr[i-1]) { isSorted = 0; break; }\n}',
    hints: ['Compare each element with previous', 'Break on first violation'],
    validPatterns: [/for\s*\([^)]+\)/, /arr\s*\[\s*i\s*\]\s*<\s*arr\s*\[\s*i\s*-\s*1\s*\]/],
    tags: ['array', 'sorted', 'check'],
  },
  {
    id: 'c-arr-160',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Rotate Array Left by K',
    text: 'Rotate array elements left by k positions',
    setup: 'int arr[] = {1, 2, 3, 4, 5};\nint n = 5;\nint k = 2;',
    setupCode: 'int arr[] = {1, 2, 3, 4, 5};\nint n = 5;\nint k = 2;',
    expected: 'arr = {3, 4, 5, 1, 2}',
    sample:
      'int temp[2];\nfor (int i = 0; i < k; i++) temp[i] = arr[i];\nfor (int i = 0; i < n - k; i++) arr[i] = arr[i + k];\nfor (int i = 0; i < k; i++) arr[n - k + i] = temp[i];',
    hints: ['Save first k elements', 'Shift remaining left', 'Place saved at end'],
    validPatterns: [
      /for\s*\([^)]+\)/,
      /temp\s*\[/,
      /arr\s*\[\s*i\s*\]\s*=\s*arr\s*\[\s*i\s*\+\s*k\s*\]/,
    ],
    tags: ['array', 'rotate', 'left'],
  },
  {
    id: 'c-arr-161',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Merge Two Sorted Arrays',
    text: 'Merge two sorted arrays into one sorted array',
    setup: 'int a[] = {1, 3, 5};\nint b[] = {2, 4, 6};\nint m = 3, n = 3;\nint result[6];',
    setupCode: 'int a[] = {1, 3, 5};\nint b[] = {2, 4, 6};\nint m = 3, n = 3;\nint result[6];',
    expected: 'result = {1, 2, 3, 4, 5, 6}',
    sample:
      'int i = 0, j = 0, k = 0;\nwhile (i < m && j < n) {\n    if (a[i] <= b[j]) result[k++] = a[i++];\n    else result[k++] = b[j++];\n}\nwhile (i < m) result[k++] = a[i++];\nwhile (j < n) result[k++] = b[j++];',
    hints: ['Use two pointers', 'Copy smaller element', 'Handle remaining elements'],
    validPatterns: [/while\s*\([^)]*&&/, /result\s*\[\s*k\s*\+\+\s*\]/],
    tags: ['array', 'merge', 'sorted'],
  },
  {
    id: 'c-arr-162',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Find Index of Element',
    text: 'Find the index of a target element in array',
    setup: 'int arr[] = {10, 20, 30, 40, 50};\nint n = 5;\nint target = 30;',
    setupCode: 'int arr[] = {10, 20, 30, 40, 50};\nint n = 5;\nint target = 30;',
    expected: 'index = 2',
    sample:
      'int index = -1;\nfor (int i = 0; i < n; i++) {\n    if (arr[i] == target) { index = i; break; }\n}',
    hints: ['Linear search through array', 'Return -1 if not found'],
    validPatterns: [/for\s*\([^)]+\)/, /arr\s*\[\s*i\s*\]\s*==\s*target/],
    tags: ['array', 'search', 'index'],
  },
  {
    id: 'c-arr-163',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Move Zeros to End',
    text: 'Move all zeros to the end of array maintaining order of non-zeros',
    setup: 'int arr[] = {0, 1, 0, 3, 12};\nint n = 5;',
    setupCode: 'int arr[] = {0, 1, 0, 3, 12};\nint n = 5;',
    expected: 'arr = {1, 3, 12, 0, 0}',
    sample:
      'int j = 0;\nfor (int i = 0; i < n; i++) {\n    if (arr[i] != 0) arr[j++] = arr[i];\n}\nwhile (j < n) arr[j++] = 0;',
    hints: ['Copy non-zeros to front', 'Fill rest with zeros'],
    validPatterns: [
      /for\s*\([^)]+\)/,
      /arr\s*\[\s*i\s*\]\s*!=\s*0/,
      /arr\s*\[\s*j\s*\+\+\s*\]\s*=\s*0/,
    ],
    tags: ['array', 'zeros', 'in-place'],
  },
  {
    id: 'c-arr-164',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Find Missing Number',
    text: 'Find the missing number in array containing 1 to n',
    setup: 'int arr[] = {1, 2, 4, 5, 6};\nint n = 5; // should have 1-6',
    setupCode: 'int arr[] = {1, 2, 4, 5, 6};\nint n = 5;',
    expected: 'missing = 3',
    sample:
      'int expected = (n + 1) * (n + 2) / 2;\nint actual = 0;\nfor (int i = 0; i < n; i++) actual += arr[i];\nint missing = expected - actual;',
    hints: ['Use sum formula n*(n+1)/2', 'Difference is missing number'],
    validPatterns: [
      /\(\s*n\s*\+\s*1\s*\)\s*\*\s*\(\s*n\s*\+\s*2\s*\)\s*\/\s*2|sum/,
      /expected\s*-\s*actual|missing/,
    ],
    tags: ['array', 'missing', 'math'],
  },
  {
    id: 'c-arr-165',
    category: 'Array Operations',
    difficulty: 'hard',
    title: 'Partition Array Around Pivot',
    text: 'Partition array around a pivot (elements < pivot on left, >= on right)',
    setup: 'int arr[] = {3, 8, 2, 5, 1, 4, 7, 6};\nint n = 8;\nint pivot = 5;',
    setupCode: 'int arr[] = {3, 8, 2, 5, 1, 4, 7, 6};\nint n = 8;\nint pivot = 5;',
    expected: 'Elements < 5 on left, >= 5 on right',
    sample:
      'int i = 0;\nfor (int j = 0; j < n; j++) {\n    if (arr[j] < pivot) {\n        int t = arr[i]; arr[i] = arr[j]; arr[j] = t;\n        i++;\n    }\n}',
    hints: ['Use two pointers', 'Swap smaller elements to front'],
    validPatterns: [/for\s*\([^)]+\)/, /arr\s*\[\s*j\s*\]\s*<\s*pivot/, /swap|temp/i],
    tags: ['array', 'partition', 'quicksort'],
  },
  {
    id: 'c-arr-166',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Initialize 2D Array',
    text: 'Initialize a 3x3 2D array with values',
    setup: 'int matrix[3][3];',
    setupCode: 'int matrix[3][3];',
    expected: 'Identity matrix',
    sample: 'int matrix[3][3] = {\n    {1, 0, 0},\n    {0, 1, 0},\n    {0, 0, 1}\n};',
    hints: ['Nested braces for rows', 'Can use nested initializer lists'],
    validPatterns: [/int\s+matrix\s*\[\s*3\s*\]\s*\[\s*3\s*\]\s*=\s*\{/],
    tags: ['array', '2d', 'initialization'],
  },
  {
    id: 'c-arr-167',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Transpose 2D Matrix',
    text: 'Transpose a 3x3 matrix in-place',
    setup: 'int matrix[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};',
    setupCode: 'int matrix[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};',
    expected: 'matrix transposed',
    sample:
      'for (int i = 0; i < 3; i++) {\n    for (int j = i + 1; j < 3; j++) {\n        int t = matrix[i][j];\n        matrix[i][j] = matrix[j][i];\n        matrix[j][i] = t;\n    }\n}',
    hints: ['Swap matrix[i][j] with matrix[j][i]', 'Only process upper triangle'],
    validPatterns: [
      /for\s*\([^)]+\)/,
      /matrix\s*\[\s*i\s*\]\s*\[\s*j\s*\]\s*=\s*matrix\s*\[\s*j\s*\]\s*\[\s*i\s*\]/,
    ],
    tags: ['array', '2d', 'transpose'],
  },
  {
    id: 'c-arr-168',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Sum of 2D Array Diagonal',
    text: 'Calculate sum of main diagonal elements',
    setup: 'int matrix[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};',
    setupCode: 'int matrix[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};',
    expected: 'sum = 15 (1 + 5 + 9)',
    sample: 'int sum = 0;\nfor (int i = 0; i < 3; i++) {\n    sum += matrix[i][i];\n}',
    hints: ['Diagonal elements have equal row and column index', 'matrix[i][i]'],
    validPatterns: [/for\s*\([^)]+\)/, /sum\s*\+=\s*matrix\s*\[\s*i\s*\]\s*\[\s*i\s*\]/],
    tags: ['array', '2d', 'diagonal'],
  },
  {
    id: 'c-arr-169',
    category: 'Array Operations',
    difficulty: 'hard',
    title: 'Rotate Matrix 90 Degrees',
    text: 'Rotate a 3x3 matrix 90 degrees clockwise',
    setup: 'int matrix[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};',
    setupCode: 'int matrix[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};',
    expected: 'matrix rotated 90 degrees clockwise',
    sample:
      '// Transpose then reverse each row\nfor (int i = 0; i < 3; i++)\n    for (int j = i; j < 3; j++) {\n        int t = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = t;\n    }\nfor (int i = 0; i < 3; i++)\n    for (int j = 0; j < 3/2; j++) {\n        int t = matrix[i][j]; matrix[i][j] = matrix[i][2-j]; matrix[i][2-j] = t;\n    }',
    hints: ['Transpose then reverse rows', 'Or use formula: new[j][n-1-i] = old[i][j]'],
    validPatterns: [/for\s*\([^)]+\)/, /transpose|reverse|rotate/i],
    tags: ['array', '2d', 'rotate'],
  },
  {
    id: 'c-arr-170',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Find Row with Max Sum',
    text: 'Find the row index with maximum sum in a 2D array',
    setup: 'int matrix[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {1, 1, 1, 1}};',
    setupCode: 'int matrix[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {1, 1, 1, 1}};',
    expected: 'maxRow = 1 (sum = 26)',
    sample:
      'int maxSum = 0, maxRow = 0;\nfor (int i = 0; i < 3; i++) {\n    int sum = 0;\n    for (int j = 0; j < 4; j++) sum += matrix[i][j];\n    if (sum > maxSum) { maxSum = sum; maxRow = i; }\n}',
    hints: ['Calculate sum for each row', 'Track maximum and its index'],
    validPatterns: [/for\s*\([^)]+\)/, /maxSum|maxRow/],
    tags: ['array', '2d', 'max'],
  },
  {
    id: 'c-arr-171',
    category: 'Array Operations',
    difficulty: 'easy',
    title: 'Print 2D Array Row by Row',
    text: 'Print all elements of 2D array row by row',
    setup: '#include <stdio.h>\nint matrix[2][3] = {{1, 2, 3}, {4, 5, 6}};',
    setupCode: '#include <stdio.h>\nint matrix[2][3] = {{1, 2, 3}, {4, 5, 6}};',
    expected: 'Print: 1 2 3 4 5 6',
    sample:
      'for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < 3; j++) {\n        printf("%d ", matrix[i][j]);\n    }\n}',
    hints: ['Nested loops: outer for rows, inner for columns', 'Access with matrix[i][j]'],
    validPatterns: [/for\s*\([^)]+\).*for\s*\([^)]+\)/, /matrix\s*\[\s*i\s*\]\s*\[\s*j\s*\]/],
    tags: ['array', '2d', 'print'],
  },
  {
    id: 'c-arr-172',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Matrix Multiplication',
    text: 'Multiply two 2x2 matrices',
    setup: 'int A[2][2] = {{1, 2}, {3, 4}};\nint B[2][2] = {{5, 6}, {7, 8}};\nint C[2][2];',
    setupCode: 'int A[2][2] = {{1, 2}, {3, 4}};\nint B[2][2] = {{5, 6}, {7, 8}};\nint C[2][2];',
    expected: 'C = {{19, 22}, {43, 50}}',
    sample:
      'for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++) {\n        C[i][j] = 0;\n        for (int k = 0; k < 2; k++)\n            C[i][j] += A[i][k] * B[k][j];\n    }',
    hints: ['C[i][j] = sum of A[i][k] * B[k][j]', 'Three nested loops'],
    validPatterns: [
      /for\s*\([^)]+\)/,
      /C\s*\[\s*i\s*\]\s*\[\s*j\s*\]\s*\+=\s*A\s*\[\s*i\s*\]\s*\[\s*k\s*\]\s*\*\s*B\s*\[\s*k\s*\]\s*\[\s*j\s*\]/,
    ],
    tags: ['array', '2d', 'matrix', 'multiplication'],
  },
  {
    id: 'c-arr-173',
    category: 'Array Operations',
    difficulty: 'medium',
    title: 'Find Saddle Point',
    text: 'Find saddle point (min in row, max in column) in matrix',
    setup: 'int matrix[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};',
    setupCode: 'int matrix[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};',
    expected: 'Saddle point at (0, 2) or (2, 0) if exists',
    sample:
      'for (int i = 0; i < 3; i++) {\n    int minJ = 0;\n    for (int j = 1; j < 3; j++)\n        if (matrix[i][j] < matrix[i][minJ]) minJ = j;\n    int isMax = 1;\n    for (int k = 0; k < 3; k++)\n        if (matrix[k][minJ] > matrix[i][minJ]) isMax = 0;\n    if (isMax) printf("Saddle at (%d, %d)\\n", i, minJ);\n}',
    hints: ['Find minimum in each row', 'Check if its maximum in that column'],
    validPatterns: [/for\s*\([^)]+\)/, /min.*max|saddle/i],
    tags: ['array', '2d', 'saddle-point'],
  },
  {
    id: 'c-arr-174',
    category: 'Array Operations',
    difficulty: 'hard',
    title: 'Spiral Matrix Traversal',
    text: 'Print matrix elements in spiral order',
    setup: 'int matrix[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};',
    setupCode: 'int matrix[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};',
    expected: 'Print: 1 2 3 6 9 8 7 4 5',
    sample:
      'int top = 0, bottom = 2, left = 0, right = 2;\nwhile (top <= bottom && left <= right) {\n    for (int i = left; i <= right; i++) printf("%d ", matrix[top][i]);\n    top++;\n    for (int i = top; i <= bottom; i++) printf("%d ", matrix[i][right]);\n    right--;\n    if (top <= bottom) { for (int i = right; i >= left; i--) printf("%d ", matrix[bottom][i]); bottom--; }\n    if (left <= right) { for (int i = bottom; i >= top; i--) printf("%d ", matrix[i][left]); left++; }\n}',
    hints: ['Track four boundaries', 'Shrink boundaries after each direction'],
    validPatterns: [/top.*bottom.*left.*right/, /while\s*\([^)]+\)/],
    tags: ['array', '2d', 'spiral'],
  },
];

// Helper functions
export function getCProblemById(id: string): Problem | undefined {
  return cProblems.find((p) => p.id === id);
}

export function getCProblemsByCategory(category: string): Problem[] {
  return cProblems.filter((p) => p.category === category);
}

export function getCProblemsByDifficulty(difficulty: Problem['difficulty']): Problem[] {
  return cProblems.filter((p) => p.difficulty === difficulty);
}

export function getCProblemsByTag(tag: string): Problem[] {
  return cProblems.filter((p) => p.tags?.includes(tag));
}

export function getCCategories(): string[] {
  return [...new Set(cProblems.map((p) => p.category))];
}

export default cProblems;
