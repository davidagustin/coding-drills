/**
 * Go coding drill problems
 * Covers Slice, String, Map, and Sort operations
 */

import type { Problem } from '../types';

export const goProblems: Problem[] = [
  // ============================================================
  // Slice Operations
  // ============================================================

  // append()
  {
    id: 'go-slice-append-1',
    category: 'Slice Operations',
    difficulty: 'easy',
    title: 'Append Element to Slice',
    text: 'Use `append()` to add the number 4 to the slice.',
    setup: 'numbers := []int{1, 2, 3}',
    setupCode: 'numbers := []int{1, 2, 3}',
    expected: [1, 2, 3, 4],
    sample: 'append(numbers, 4)',
    hints: ['append returns a new slice', 'First arg is slice, rest are elements to add'],
    validPatterns: [/append\s*\(\s*numbers\s*,\s*4\s*\)/],
    tags: ['append', 'add', 'slice'],
  },
  {
    id: 'go-slice-append-2',
    category: 'Slice Operations',
    difficulty: 'easy',
    title: 'Append Multiple Elements',
    text: 'Use `append()` to add 4, 5, and 6 to the slice.',
    setup: 'numbers := []int{1, 2, 3}',
    setupCode: 'numbers := []int{1, 2, 3}',
    expected: [1, 2, 3, 4, 5, 6],
    sample: 'append(numbers, 4, 5, 6)',
    hints: ['append can take multiple values', 'All values are added at the end'],
    validPatterns: [/append\s*\(\s*numbers\s*,\s*4\s*,\s*5\s*,\s*6\s*\)/],
    tags: ['append', 'variadic', 'slice'],
  },
  {
    id: 'go-slice-append-3',
    category: 'Slice Operations',
    difficulty: 'medium',
    title: 'Append Slice to Slice',
    text: 'Use `append()` with variadic expansion (`...`) to combine two slices.',
    setup: 'a := []int{1, 2}\nb := []int{3, 4}',
    setupCode: 'a := []int{1, 2}\nb := []int{3, 4}',
    expected: [1, 2, 3, 4],
    sample: 'append(a, b...)',
    hints: ['Use ... to unpack a slice', 'This expands b into individual elements'],
    validPatterns: [/append\s*\(\s*a\s*,\s*b\s*\.\.\.\s*\)/],
    tags: ['append', 'spread', 'concat'],
  },

  // len() / cap()
  {
    id: 'go-slice-len-1',
    category: 'Slice Operations',
    difficulty: 'easy',
    title: 'Get Slice Length',
    text: 'Use `len()` to get the number of elements in the slice.',
    setup: 'numbers := []int{10, 20, 30, 40, 50}',
    setupCode: 'numbers := []int{10, 20, 30, 40, 50}',
    expected: 5,
    sample: 'len(numbers)',
    hints: ['len() returns the number of elements'],
    validPatterns: [/len\s*\(\s*numbers\s*\)/],
    tags: ['len', 'length', 'size'],
  },
  {
    id: 'go-slice-cap-1',
    category: 'Slice Operations',
    difficulty: 'medium',
    title: 'Get Slice Capacity',
    text: 'Use `cap()` to get the capacity of the slice.',
    setup: 'numbers := make([]int, 3, 10)',
    setupCode: 'numbers := make([]int, 3, 10)',
    expected: 10,
    sample: 'cap(numbers)',
    hints: ['cap() returns the capacity', 'Capacity is max elements before reallocation'],
    validPatterns: [/cap\s*\(\s*numbers\s*\)/],
    tags: ['cap', 'capacity'],
  },

  // copy()
  {
    id: 'go-slice-copy-1',
    category: 'Slice Operations',
    difficulty: 'medium',
    title: 'Copy Slice Elements',
    text: 'Use `copy()` to copy elements from src to dst. Return number copied.',
    setup: 'src := []int{1, 2, 3}\ndst := make([]int, 3)',
    setupCode: 'src := []int{1, 2, 3}\ndst := make([]int, 3)',
    expected: 3,
    sample: 'copy(dst, src)',
    hints: ['copy(dst, src) copies from src to dst', 'Returns number of elements copied'],
    validPatterns: [/copy\s*\(\s*dst\s*,\s*src\s*\)/],
    tags: ['copy', 'duplicate'],
  },
  {
    id: 'go-slice-copy-2',
    category: 'Slice Operations',
    difficulty: 'medium',
    title: 'Partial Copy',
    text: 'Copy only 2 elements from src to dst using copy().',
    setup: 'src := []int{1, 2, 3, 4, 5}\ndst := make([]int, 2)',
    setupCode: 'src := []int{1, 2, 3, 4, 5}\ndst := make([]int, 2)',
    expected: 2,
    sample: 'copy(dst, src)',
    hints: ['copy copies min(len(dst), len(src)) elements', 'dst length limits the copy'],
    validPatterns: [/copy\s*\(\s*dst\s*,\s*src\s*\)/, /copy\s*\(\s*dst\s*,\s*src\[:2\]\s*\)/],
    tags: ['copy', 'partial'],
  },

  // slicing [start:end]
  {
    id: 'go-slice-slicing-1',
    category: 'Slice Operations',
    difficulty: 'easy',
    title: 'Slice from Index',
    text: 'Get elements from index 2 to the end of the slice.',
    setup: 'numbers := []int{10, 20, 30, 40, 50}',
    setupCode: 'numbers := []int{10, 20, 30, 40, 50}',
    expected: [30, 40, 50],
    sample: 'numbers[2:]',
    hints: ['[start:] gives elements from start to end', 'Index is 0-based'],
    validPatterns: [/numbers\s*\[\s*2\s*:\s*\]/],
    tags: ['slice', 'range'],
  },
  {
    id: 'go-slice-slicing-2',
    category: 'Slice Operations',
    difficulty: 'easy',
    title: 'Slice to Index',
    text: 'Get the first 3 elements of the slice.',
    setup: 'numbers := []int{10, 20, 30, 40, 50}',
    setupCode: 'numbers := []int{10, 20, 30, 40, 50}',
    expected: [10, 20, 30],
    sample: 'numbers[:3]',
    hints: ['[:end] gives elements from 0 to end-1', 'End index is exclusive'],
    validPatterns: [/numbers\s*\[\s*:\s*3\s*\]/],
    tags: ['slice', 'range'],
  },
  {
    id: 'go-slice-slicing-3',
    category: 'Slice Operations',
    difficulty: 'easy',
    title: 'Slice Range',
    text: 'Get elements from index 1 to 3 (exclusive).',
    setup: 'numbers := []int{10, 20, 30, 40, 50}',
    setupCode: 'numbers := []int{10, 20, 30, 40, 50}',
    expected: [20, 30],
    sample: 'numbers[1:3]',
    hints: ['[start:end] gives elements from start to end-1', 'Both indices are provided'],
    validPatterns: [/numbers\s*\[\s*1\s*:\s*3\s*\]/],
    tags: ['slice', 'range', 'subslice'],
  },
  {
    id: 'go-slice-slicing-4',
    category: 'Slice Operations',
    difficulty: 'medium',
    title: 'Get Last Element',
    text: 'Get the last element of the slice using len().',
    setup: 'numbers := []int{10, 20, 30, 40, 50}',
    setupCode: 'numbers := []int{10, 20, 30, 40, 50}',
    expected: 50,
    sample: 'numbers[len(numbers)-1]',
    hints: ['Use len() to get the length', 'Last index is len - 1'],
    validPatterns: [/numbers\s*\[\s*len\s*\(\s*numbers\s*\)\s*-\s*1\s*\]/],
    tags: ['slice', 'last', 'len'],
  },

  // make()
  {
    id: 'go-slice-make-1',
    category: 'Slice Operations',
    difficulty: 'easy',
    title: 'Create Slice with make',
    text: 'Use `make()` to create an int slice with length 5.',
    setup: '// Create a slice of 5 integers',
    setupCode: '// Create a slice of 5 integers',
    expected: [0, 0, 0, 0, 0],
    sample: 'make([]int, 5)',
    hints: ['make(type, length) creates a slice', 'Elements are initialized to zero value'],
    validPatterns: [/make\s*\(\s*\[\s*\]\s*int\s*,\s*5\s*\)/],
    tags: ['make', 'create', 'initialize'],
  },
  {
    id: 'go-slice-make-2',
    category: 'Slice Operations',
    difficulty: 'medium',
    title: 'Create Slice with Capacity',
    text: 'Use `make()` to create a string slice with length 3 and capacity 10.',
    setup: '// Create a slice with specific length and capacity',
    setupCode: '// Create a slice with specific length and capacity',
    expected: 'make([]string, 3, 10)',
    sample: 'make([]string, 3, 10)',
    hints: ['make(type, length, capacity)', 'Capacity pre-allocates memory'],
    validPatterns: [/make\s*\(\s*\[\s*\]\s*string\s*,\s*3\s*,\s*10\s*\)/],
    tags: ['make', 'capacity', 'preallocate'],
  },

  // ============================================================
  // String Operations
  // ============================================================

  // strings.Split() / strings.Join()
  {
    id: 'go-string-split-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Split String by Separator',
    text: 'Use `strings.Split()` to split the string by spaces.',
    setup: 'import "strings"\ns := "hello world go"',
    setupCode: 'import "strings"\ns := "hello world go"',
    expected: ['hello', 'world', 'go'],
    sample: 'strings.Split(s, " ")',
    hints: ['strings.Split(str, separator)', 'Returns a slice of strings'],
    validPatterns: [/strings\.Split\s*\(\s*s\s*,\s*["'] ["']\s*\)/],
    tags: ['Split', 'tokenize', 'strings'],
  },
  {
    id: 'go-string-split-2',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Split by Comma',
    text: 'Use `strings.Split()` to split the CSV string.',
    setup: 'import "strings"\ncsv := "a,b,c,d"',
    setupCode: 'import "strings"\ncsv := "a,b,c,d"',
    expected: ['a', 'b', 'c', 'd'],
    sample: 'strings.Split(csv, ",")',
    hints: ['Use comma as separator'],
    validPatterns: [/strings\.Split\s*\(\s*csv\s*,\s*["'],["']\s*\)/],
    tags: ['Split', 'CSV'],
  },
  {
    id: 'go-string-join-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Join Strings with Separator',
    text: 'Use `strings.Join()` to combine the words with a dash.',
    setup: 'import "strings"\nwords := []string{"go", "is", "fun"}',
    setupCode: 'import "strings"\nwords := []string{"go", "is", "fun"}',
    expected: 'go-is-fun',
    sample: 'strings.Join(words, "-")',
    hints: ['strings.Join(slice, separator)', 'Returns a single string'],
    validPatterns: [/strings\.Join\s*\(\s*words\s*,\s*["']-["']\s*\)/],
    tags: ['Join', 'concatenate'],
  },

  // strings.Contains()
  {
    id: 'go-string-contains-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Check Substring',
    text: 'Use `strings.Contains()` to check if the string contains "world".',
    setup: 'import "strings"\ns := "hello world"',
    setupCode: 'import "strings"\ns := "hello world"',
    expected: true,
    sample: 'strings.Contains(s, "world")',
    hints: ['strings.Contains(str, substr)', 'Returns bool'],
    validPatterns: [/strings\.Contains\s*\(\s*s\s*,\s*["']world["']\s*\)/],
    tags: ['Contains', 'substring'],
  },

  // strings.HasPrefix() / strings.HasSuffix()
  {
    id: 'go-string-hasprefix-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Check String Prefix',
    text: 'Use `strings.HasPrefix()` to check if the string starts with "hello".',
    setup: 'import "strings"\ns := "hello world"',
    setupCode: 'import "strings"\ns := "hello world"',
    expected: true,
    sample: 'strings.HasPrefix(s, "hello")',
    hints: ['strings.HasPrefix(str, prefix)', 'Returns bool'],
    validPatterns: [/strings\.HasPrefix\s*\(\s*s\s*,\s*["']hello["']\s*\)/],
    tags: ['HasPrefix', 'prefix'],
  },
  {
    id: 'go-string-hassuffix-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Check String Suffix',
    text: 'Use `strings.HasSuffix()` to check if the string ends with ".go".',
    setup: 'import "strings"\nfilename := "main.go"',
    setupCode: 'import "strings"\nfilename := "main.go"',
    expected: true,
    sample: 'strings.HasSuffix(filename, ".go")',
    hints: ['strings.HasSuffix(str, suffix)', 'Returns bool'],
    validPatterns: [/strings\.HasSuffix\s*\(\s*filename\s*,\s*["']\.go["']\s*\)/],
    tags: ['HasSuffix', 'suffix'],
  },

  // strings.ToUpper() / strings.ToLower()
  {
    id: 'go-string-toupper-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Convert to Uppercase',
    text: 'Use `strings.ToUpper()` to convert the string to uppercase.',
    setup: 'import "strings"\ns := "hello"',
    setupCode: 'import "strings"\ns := "hello"',
    expected: 'HELLO',
    sample: 'strings.ToUpper(s)',
    hints: ['strings.ToUpper(str)', 'Returns uppercase string'],
    validPatterns: [/strings\.ToUpper\s*\(\s*s\s*\)/],
    tags: ['ToUpper', 'uppercase'],
  },
  {
    id: 'go-string-tolower-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Convert to Lowercase',
    text: 'Use `strings.ToLower()` to convert the string to lowercase.',
    setup: 'import "strings"\ns := "HELLO"',
    setupCode: 'import "strings"\ns := "HELLO"',
    expected: 'hello',
    sample: 'strings.ToLower(s)',
    hints: ['strings.ToLower(str)', 'Returns lowercase string'],
    validPatterns: [/strings\.ToLower\s*\(\s*s\s*\)/],
    tags: ['ToLower', 'lowercase'],
  },

  // strings.TrimSpace()
  {
    id: 'go-string-trimspace-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Trim Whitespace',
    text: 'Use `strings.TrimSpace()` to remove leading and trailing whitespace.',
    setup: 'import "strings"\ns := "  hello world  "',
    setupCode: 'import "strings"\ns := "  hello world  "',
    expected: 'hello world',
    sample: 'strings.TrimSpace(s)',
    hints: ['strings.TrimSpace(str)', 'Removes spaces, tabs, newlines'],
    validPatterns: [/strings\.TrimSpace\s*\(\s*s\s*\)/],
    tags: ['TrimSpace', 'trim'],
  },
  {
    id: 'go-string-trim-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Trim Specific Characters',
    text: 'Use `strings.Trim()` to remove leading/trailing dashes.',
    setup: 'import "strings"\ns := "--hello--"',
    setupCode: 'import "strings"\ns := "--hello--"',
    expected: 'hello',
    sample: 'strings.Trim(s, "-")',
    hints: ['strings.Trim(str, cutset)', 'cutset is characters to remove'],
    validPatterns: [/strings\.Trim\s*\(\s*s\s*,\s*["']-["']\s*\)/],
    tags: ['Trim', 'characters'],
  },

  // strings.Replace()
  {
    id: 'go-string-replace-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Replace All Occurrences',
    text: 'Use `strings.ReplaceAll()` to replace all spaces with underscores.',
    setup: 'import "strings"\ns := "hello world go"',
    setupCode: 'import "strings"\ns := "hello world go"',
    expected: 'hello_world_go',
    sample: 'strings.ReplaceAll(s, " ", "_")',
    hints: ['strings.ReplaceAll(str, old, new)', 'Replaces all occurrences'],
    validPatterns: [
      /strings\.ReplaceAll\s*\(\s*s\s*,\s*["'] ["']\s*,\s*["']_["']\s*\)/,
      /strings\.Replace\s*\(\s*s\s*,\s*["'] ["']\s*,\s*["']_["']\s*,\s*-1\s*\)/,
    ],
    tags: ['ReplaceAll', 'replace'],
  },
  {
    id: 'go-string-replace-2',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Replace First N Occurrences',
    text: 'Use `strings.Replace()` to replace only the first space.',
    setup: 'import "strings"\ns := "hello world go"',
    setupCode: 'import "strings"\ns := "hello world go"',
    expected: 'hello_world go',
    sample: 'strings.Replace(s, " ", "_", 1)',
    hints: ['strings.Replace(str, old, new, n)', 'n=1 replaces first occurrence'],
    validPatterns: [/strings\.Replace\s*\(\s*s\s*,\s*["'] ["']\s*,\s*["']_["']\s*,\s*1\s*\)/],
    tags: ['Replace', 'first'],
  },

  // len() for strings
  {
    id: 'go-string-len-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Get String Length',
    text: 'Use `len()` to get the byte length of the string.',
    setup: 's := "hello"',
    setupCode: 's := "hello"',
    expected: 5,
    sample: 'len(s)',
    hints: ['len() returns byte count for strings', 'ASCII chars are 1 byte each'],
    validPatterns: [/len\s*\(\s*s\s*\)/],
    tags: ['len', 'length', 'bytes'],
  },
  {
    id: 'go-string-rune-count-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Count Unicode Characters',
    text: 'Use `utf8.RuneCountInString()` to count Unicode characters.',
    setup: 'import "unicode/utf8"\ns := "Hello"',
    setupCode: 'import "unicode/utf8"\ns := "Hello"',
    expected: 5,
    sample: 'utf8.RuneCountInString(s)',
    hints: ['RuneCountInString counts runes not bytes', 'Important for Unicode strings'],
    validPatterns: [
      /utf8\.RuneCountInString\s*\(\s*s\s*\)/,
      /len\s*\(\s*\[\s*\]\s*rune\s*\(\s*s\s*\)\s*\)/,
    ],
    tags: ['rune', 'unicode', 'count'],
  },

  // string conversion
  {
    id: 'go-string-convert-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Convert Int to String',
    text: 'Use `strconv.Itoa()` to convert an integer to a string.',
    setup: 'import "strconv"\nn := 42',
    setupCode: 'import "strconv"\nn := 42',
    expected: '42',
    sample: 'strconv.Itoa(n)',
    hints: ['strconv.Itoa = Integer to ASCII', 'Returns string representation'],
    validPatterns: [/strconv\.Itoa\s*\(\s*n\s*\)/, /fmt\.Sprintf\s*\(\s*["']%d["']\s*,\s*n\s*\)/],
    tags: ['Itoa', 'convert', 'strconv'],
  },
  {
    id: 'go-string-convert-2',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Convert String to Int',
    text: 'Use `strconv.Atoi()` to convert a string to an integer. Handle the error.',
    setup: 'import "strconv"\ns := "42"',
    setupCode: 'import "strconv"\ns := "42"',
    expected: 42,
    sample: 'n, err := strconv.Atoi(s); if err != nil { panic(err) }; n',
    hints: ['strconv.Atoi = ASCII to Integer', 'Returns (int, error) - always check err'],
    validPatterns: [
      /strconv\.Atoi\s*\(\s*s\s*\)/,
      /\w+\s*,\s*(?:err|_)\s*:?=\s*strconv\.Atoi\s*\(\s*s\s*\)/,
    ],
    tags: ['Atoi', 'parse', 'strconv', 'error-handling'],
  },

  // ============================================================
  // Map Operations
  // ============================================================

  // make(map[K]V)
  {
    id: 'go-map-make-1',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Create Map with make',
    text: 'Use `make()` to create a map with string keys and int values.',
    setup: '// Create an empty map',
    setupCode: '// Create an empty map',
    expected: 'make(map[string]int)',
    sample: 'make(map[string]int)',
    hints: ['make(map[KeyType]ValueType)', 'Creates an empty initialized map'],
    validPatterns: [/make\s*\(\s*map\s*\[\s*string\s*\]\s*int\s*\)/],
    tags: ['make', 'map', 'create'],
  },
  {
    id: 'go-map-literal-1',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Map Literal',
    text: 'Create a map literal with "a": 1, "b": 2.',
    setup: '// Create a map with initial values',
    setupCode: '// Create a map with initial values',
    expected: { a: 1, b: 2 },
    sample: 'map[string]int{"a": 1, "b": 2}',
    hints: ['Use map[K]V{...} syntax', 'Key-value pairs separated by commas'],
    validPatterns: [
      /map\s*\[\s*string\s*\]\s*int\s*\{\s*["']a["']\s*:\s*1\s*,\s*["']b["']\s*:\s*2\s*\}/,
    ],
    tags: ['map', 'literal', 'initialize'],
  },

  // access / assignment
  {
    id: 'go-map-access-1',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Access Map Value',
    text: 'Access the value for key "name" from the map.',
    setup: 'm := map[string]string{"name": "Alice", "city": "NYC"}',
    setupCode: 'm := map[string]string{"name": "Alice", "city": "NYC"}',
    expected: 'Alice',
    sample: 'm["name"]',
    hints: ['Use m[key] to access values', 'Returns zero value if key missing'],
    validPatterns: [/m\s*\[\s*["']name["']\s*\]/],
    tags: ['map', 'access', 'read'],
  },
  {
    id: 'go-map-access-2',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Check Key Existence',
    text: 'Check if key "age" exists in the map using comma ok idiom.',
    setup: 'm := map[string]int{"score": 100, "level": 5}',
    setupCode: 'm := map[string]int{"score": 100, "level": 5}',
    expected: false,
    sample: '_, ok := m["age"]; ok',
    hints: ['Use v, ok := m[key]', 'ok is true if key exists, false otherwise'],
    validPatterns: [
      /_\s*,\s*ok\s*:=\s*m\s*\[\s*["']age["']\s*\]/,
      /if\s*_\s*,\s*ok\s*:=\s*m\s*\[\s*["']age["']\s*\]/,
    ],
    tags: ['map', 'exists', 'comma-ok'],
  },
  {
    id: 'go-map-assign-1',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Assign Map Value',
    text: 'Set the value for key "score" to 100.',
    setup: 'm := make(map[string]int)',
    setupCode: 'm := make(map[string]int)',
    expected: { score: 100 },
    sample: 'm["score"] = 100',
    hints: ['Use m[key] = value', 'Creates or updates the key'],
    validPatterns: [/m\s*\[\s*["']score["']\s*\]\s*=\s*100/],
    tags: ['map', 'assign', 'set'],
  },

  // delete()
  {
    id: 'go-map-delete-1',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Delete Map Entry',
    text: 'Use `delete()` to remove the "temp" key from the map.',
    setup: 'm := map[string]int{"score": 100, "temp": 50}',
    setupCode: 'm := map[string]int{"score": 100, "temp": 50}',
    expected: { score: 100 },
    sample: 'delete(m, "temp")',
    hints: ['delete(map, key)', 'No-op if key does not exist'],
    validPatterns: [/delete\s*\(\s*m\s*,\s*["']temp["']\s*\)/],
    tags: ['delete', 'remove', 'map'],
  },

  // range iteration
  {
    id: 'go-map-range-1',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Iterate Map with range',
    text: 'Use `range` to iterate over map keys and values.',
    setup: 'm := map[string]int{"a": 1, "b": 2}',
    setupCode: 'm := map[string]int{"a": 1, "b": 2}',
    expected: 'for k, v := range m',
    sample: 'for k, v := range m { fmt.Println(k, v) }',
    hints: ['for key, value := range map', 'Order is not guaranteed'],
    validPatterns: [/for\s+\w+\s*,\s*\w+\s*:=\s*range\s+m/],
    tags: ['range', 'iterate', 'loop'],
  },
  {
    id: 'go-map-range-2',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Iterate Map Keys Only',
    text: 'Use `range` to iterate over only the map keys.',
    setup: 'm := map[string]int{"a": 1, "b": 2}',
    setupCode: 'm := map[string]int{"a": 1, "b": 2}',
    expected: 'for k := range m',
    sample: 'for k := range m { fmt.Println(k) }',
    hints: ['for key := range map', 'Omit value variable'],
    validPatterns: [/for\s+\w+\s*:=\s*range\s+m/],
    tags: ['range', 'keys', 'loop'],
  },
  {
    id: 'go-map-len-1',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Get Map Length',
    text: 'Use `len()` to get the number of entries in the map.',
    setup: 'm := map[string]int{"a": 1, "b": 2, "c": 3}',
    setupCode: 'm := map[string]int{"a": 1, "b": 2, "c": 3}',
    expected: 3,
    sample: 'len(m)',
    hints: ['len() works on maps', 'Returns number of key-value pairs'],
    validPatterns: [/len\s*\(\s*m\s*\)/],
    tags: ['len', 'size', 'map'],
  },

  // ============================================================
  // Sort Package
  // ============================================================

  // sort.Ints()
  {
    id: 'go-sort-ints-1',
    category: 'Sort Package',
    difficulty: 'easy',
    title: 'Sort Integer Slice',
    text: 'Use `sort.Ints()` to sort the slice in ascending order.',
    setup: 'import "sort"\nnumbers := []int{5, 2, 8, 1, 9}',
    setupCode: 'import "sort"\nnumbers := []int{5, 2, 8, 1, 9}',
    expected: [1, 2, 5, 8, 9],
    sample: 'sort.Ints(numbers)',
    hints: ['sort.Ints(slice)', 'Sorts in place, ascending order'],
    validPatterns: [/sort\.Ints\s*\(\s*numbers\s*\)/],
    tags: ['sort', 'Ints', 'ascending'],
  },
  {
    id: 'go-sort-ints-2',
    category: 'Sort Package',
    difficulty: 'medium',
    title: 'Sort Integers Descending',
    text: 'Sort the slice in descending order using sort.Sort with Reverse.',
    setup: 'import "sort"\nnumbers := []int{5, 2, 8, 1, 9}',
    setupCode: 'import "sort"\nnumbers := []int{5, 2, 8, 1, 9}',
    expected: [9, 8, 5, 2, 1],
    sample: 'sort.Sort(sort.Reverse(sort.IntSlice(numbers)))',
    hints: ['Use sort.Reverse() wrapper', 'IntSlice converts []int to sortable'],
    validPatterns: [
      /sort\.Sort\s*\(\s*sort\.Reverse\s*\(\s*sort\.IntSlice\s*\(\s*numbers\s*\)\s*\)\s*\)/,
    ],
    tags: ['sort', 'descending', 'Reverse'],
  },

  // sort.Strings()
  {
    id: 'go-sort-strings-1',
    category: 'Sort Package',
    difficulty: 'easy',
    title: 'Sort String Slice',
    text: 'Use `sort.Strings()` to sort the slice alphabetically.',
    setup: 'import "sort"\nwords := []string{"go", "python", "java", "rust"}',
    setupCode: 'import "sort"\nwords := []string{"go", "python", "java", "rust"}',
    expected: ['go', 'java', 'python', 'rust'],
    sample: 'sort.Strings(words)',
    hints: ['sort.Strings(slice)', 'Sorts alphabetically in place'],
    validPatterns: [/sort\.Strings\s*\(\s*words\s*\)/],
    tags: ['sort', 'Strings', 'alphabetical'],
  },

  // sort.Slice()
  {
    id: 'go-sort-slice-1',
    category: 'Sort Package',
    difficulty: 'medium',
    title: 'Custom Sort with sort.Slice',
    text: 'Use `sort.Slice()` to sort by string length (shortest first).',
    setup: 'import "sort"\nwords := []string{"golang", "is", "awesome"}',
    setupCode: 'import "sort"\nwords := []string{"golang", "is", "awesome"}',
    expected: ['is', 'golang', 'awesome'],
    sample: 'sort.Slice(words, func(i, j int) bool { return len(words[i]) < len(words[j]) })',
    hints: ['sort.Slice(slice, lessFn)', 'lessFn returns true if i should come before j'],
    validPatterns: [
      /sort\.Slice\s*\(\s*words\s*,\s*func\s*\(\s*i\s*,\s*j\s+int\s*\)\s*bool\s*\{\s*return\s+len\s*\(\s*words\s*\[\s*i\s*\]\s*\)\s*<\s*len\s*\(\s*words\s*\[\s*j\s*\]\s*\)/,
    ],
    tags: ['sort', 'Slice', 'custom'],
  },
  {
    id: 'go-sort-slice-2',
    category: 'Sort Package',
    difficulty: 'medium',
    title: 'Sort Structs by Field',
    text: 'Use `sort.Slice()` to sort people by age.',
    setup:
      'import "sort"\ntype Person struct { Name string; Age int }\npeople := []Person{{"Alice", 30}, {"Bob", 25}, {"Carol", 35}}',
    setupCode:
      'import "sort"\ntype Person struct { Name string; Age int }\npeople := []Person{{"Alice", 30}, {"Bob", 25}, {"Carol", 35}}',
    expected: [
      { Name: 'Bob', Age: 25 },
      { Name: 'Alice', Age: 30 },
      { Name: 'Carol', Age: 35 },
    ],
    sample: 'sort.Slice(people, func(i, j int) bool { return people[i].Age < people[j].Age })',
    hints: ['Access struct fields in comparison', 'Compare .Age for sorting'],
    validPatterns: [
      /sort\.Slice\s*\(\s*people\s*,\s*func\s*\(\s*i\s*,\s*j\s+int\s*\)\s*bool\s*\{\s*return\s+people\s*\[\s*i\s*\]\.Age\s*<\s*people\s*\[\s*j\s*\]\.Age/,
    ],
    tags: ['sort', 'struct', 'custom'],
  },

  // sort.SearchInts() - binary search
  {
    id: 'go-sort-search-1',
    category: 'Sort Package',
    difficulty: 'medium',
    title: 'Binary Search in Sorted Slice',
    text: 'Use `sort.SearchInts()` to find the index where 5 should be inserted.',
    setup: 'import "sort"\nnumbers := []int{1, 3, 5, 7, 9}',
    setupCode: 'import "sort"\nnumbers := []int{1, 3, 5, 7, 9}',
    expected: 2,
    sample: 'sort.SearchInts(numbers, 5)',
    hints: ['sort.SearchInts(slice, value)', 'Slice must be sorted', 'Returns insertion index'],
    validPatterns: [/sort\.SearchInts\s*\(\s*numbers\s*,\s*5\s*\)/],
    tags: ['search', 'binary', 'SearchInts'],
  },

  // sort.IsSorted()
  {
    id: 'go-sort-issorted-1',
    category: 'Sort Package',
    difficulty: 'easy',
    title: 'Check if Slice is Sorted',
    text: 'Use `sort.IntsAreSorted()` to check if the slice is sorted.',
    setup: 'import "sort"\nnumbers := []int{1, 2, 3, 4, 5}',
    setupCode: 'import "sort"\nnumbers := []int{1, 2, 3, 4, 5}',
    expected: true,
    sample: 'sort.IntsAreSorted(numbers)',
    hints: ['sort.IntsAreSorted(slice)', 'Returns true if ascending order'],
    validPatterns: [/sort\.IntsAreSorted\s*\(\s*numbers\s*\)/],
    tags: ['sort', 'check', 'IsSorted'],
  },

  // Additional utility problems
  {
    id: 'go-slice-remove-1',
    category: 'Slice Operations',
    difficulty: 'hard',
    title: 'Remove Element from Slice',
    text: 'Remove the element at index 2 from the slice using append.',
    setup: 'numbers := []int{1, 2, 3, 4, 5}',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5}',
    expected: [1, 2, 4, 5],
    sample: 'append(numbers[:2], numbers[3:]...)',
    hints: [
      'Combine slice before and after index',
      'Use append with ... to unpack',
      'In Go 1.21+ consider slices.Delete()',
    ],
    validPatterns: [
      /append\s*\(\s*numbers\s*\[\s*:\s*2\s*\]\s*,\s*numbers\s*\[\s*3\s*:\s*\]\s*\.\.\.\s*\)/,
      /slices\.Delete\s*\(\s*numbers\s*,\s*2\s*,\s*3\s*\)/,
    ],
    tags: ['slice', 'remove', 'append'],
  },
  {
    id: 'go-slice-insert-1',
    category: 'Slice Operations',
    difficulty: 'hard',
    title: 'Insert Element into Slice',
    text: 'Insert 99 at index 2 in the slice.',
    setup: 'numbers := []int{1, 2, 3, 4}',
    setupCode: 'numbers := []int{1, 2, 3, 4}',
    expected: [1, 2, 99, 3, 4],
    sample: 'append(numbers[:2], append([]int{99}, numbers[2:]...)...)',
    hints: [
      'Create slice with new element',
      'Append rest of original slice',
      'In Go 1.21+ consider slices.Insert()',
    ],
    validPatterns: [
      /append\s*\(\s*numbers\s*\[\s*:\s*2\s*\]\s*,\s*append\s*\(\s*\[\s*\]\s*int\s*\{\s*99\s*\}\s*,\s*numbers\s*\[\s*2\s*:\s*\]\s*\.\.\.\s*\)\s*\.\.\.\s*\)/,
      /slices\.Insert\s*\(\s*numbers\s*,\s*2\s*,\s*99\s*\)/,
    ],
    tags: ['slice', 'insert', 'append'],
  },

  // ============================================================
  // Go 1.21+ slices Package
  // ============================================================

  {
    id: 'go-slices-contains-1',
    category: 'Slices Package (Go 1.21+)',
    difficulty: 'easy',
    title: 'Check if Slice Contains Value',
    text: 'Use `slices.Contains()` to check if the slice contains 3.',
    setup: 'import "slices"\nnumbers := []int{1, 2, 3, 4, 5}',
    setupCode: 'import "slices"\nnumbers := []int{1, 2, 3, 4, 5}',
    expected: true,
    sample: 'slices.Contains(numbers, 3)',
    hints: ['slices.Contains(slice, value)', 'Returns bool'],
    validPatterns: [/slices\.Contains\s*\(\s*numbers\s*,\s*3\s*\)/],
    tags: ['slices', 'contains', 'Go1.21'],
  },
  {
    id: 'go-slices-index-1',
    category: 'Slices Package (Go 1.21+)',
    difficulty: 'easy',
    title: 'Find Index of Value',
    text: 'Use `slices.Index()` to find the index of value 30.',
    setup: 'import "slices"\nnumbers := []int{10, 20, 30, 40}',
    setupCode: 'import "slices"\nnumbers := []int{10, 20, 30, 40}',
    expected: 2,
    sample: 'slices.Index(numbers, 30)',
    hints: ['slices.Index(slice, value)', 'Returns -1 if not found'],
    validPatterns: [/slices\.Index\s*\(\s*numbers\s*,\s*30\s*\)/],
    tags: ['slices', 'index', 'find', 'Go1.21'],
  },
  {
    id: 'go-slices-reverse-1',
    category: 'Slices Package (Go 1.21+)',
    difficulty: 'easy',
    title: 'Reverse Slice In-Place',
    text: 'Use `slices.Reverse()` to reverse the slice in place.',
    setup: 'import "slices"\nnumbers := []int{1, 2, 3, 4, 5}',
    setupCode: 'import "slices"\nnumbers := []int{1, 2, 3, 4, 5}',
    expected: [5, 4, 3, 2, 1],
    sample: 'slices.Reverse(numbers)',
    hints: ['slices.Reverse modifies in place', 'No return value'],
    validPatterns: [/slices\.Reverse\s*\(\s*numbers\s*\)/],
    tags: ['slices', 'reverse', 'Go1.21'],
  },
  {
    id: 'go-slices-sort-1',
    category: 'Slices Package (Go 1.21+)',
    difficulty: 'easy',
    title: 'Sort Slice with slices.Sort',
    text: 'Use `slices.Sort()` to sort the slice.',
    setup: 'import "slices"\nnumbers := []int{5, 2, 8, 1, 9}',
    setupCode: 'import "slices"\nnumbers := []int{5, 2, 8, 1, 9}',
    expected: [1, 2, 5, 8, 9],
    sample: 'slices.Sort(numbers)',
    hints: ['slices.Sort is simpler than sort.Ints', 'Works with any ordered type'],
    validPatterns: [/slices\.Sort\s*\(\s*numbers\s*\)/],
    tags: ['slices', 'sort', 'Go1.21'],
  },
  {
    id: 'go-slices-max-1',
    category: 'Slices Package (Go 1.21+)',
    difficulty: 'easy',
    title: 'Find Maximum Value',
    text: 'Use `slices.Max()` to find the maximum value in the slice.',
    setup: 'import "slices"\nnumbers := []int{5, 2, 8, 1, 9}',
    setupCode: 'import "slices"\nnumbers := []int{5, 2, 8, 1, 9}',
    expected: 9,
    sample: 'slices.Max(numbers)',
    hints: ['slices.Max returns the largest element', 'Panics on empty slice'],
    validPatterns: [/slices\.Max\s*\(\s*numbers\s*\)/],
    tags: ['slices', 'max', 'Go1.21'],
  },
  {
    id: 'go-slices-min-1',
    category: 'Slices Package (Go 1.21+)',
    difficulty: 'easy',
    title: 'Find Minimum Value',
    text: 'Use `slices.Min()` to find the minimum value in the slice.',
    setup: 'import "slices"\nnumbers := []int{5, 2, 8, 1, 9}',
    setupCode: 'import "slices"\nnumbers := []int{5, 2, 8, 1, 9}',
    expected: 1,
    sample: 'slices.Min(numbers)',
    hints: ['slices.Min returns the smallest element', 'Panics on empty slice'],
    validPatterns: [/slices\.Min\s*\(\s*numbers\s*\)/],
    tags: ['slices', 'min', 'Go1.21'],
  },
  {
    id: 'go-slices-clone-1',
    category: 'Slices Package (Go 1.21+)',
    difficulty: 'easy',
    title: 'Clone a Slice',
    text: 'Use `slices.Clone()` to create a copy of the slice.',
    setup: 'import "slices"\noriginal := []int{1, 2, 3}',
    setupCode: 'import "slices"\noriginal := []int{1, 2, 3}',
    expected: [1, 2, 3],
    sample: 'slices.Clone(original)',
    hints: ['slices.Clone creates a shallow copy', 'Changes to clone do not affect original'],
    validPatterns: [/slices\.Clone\s*\(\s*original\s*\)/],
    tags: ['slices', 'clone', 'copy', 'Go1.21'],
  },

  // ============================================================
  // Go 1.21+ maps Package
  // ============================================================

  {
    id: 'go-maps-clone-1',
    category: 'Maps Package (Go 1.21+)',
    difficulty: 'easy',
    title: 'Clone a Map',
    text: 'Use `maps.Clone()` to create a shallow copy of the map.',
    setup: 'import "maps"\noriginal := map[string]int{"a": 1, "b": 2}',
    setupCode: 'import "maps"\noriginal := map[string]int{"a": 1, "b": 2}',
    expected: { a: 1, b: 2 },
    sample: 'maps.Clone(original)',
    hints: ['maps.Clone creates a shallow copy', 'Modifying clone does not affect original'],
    validPatterns: [/maps\.Clone\s*\(\s*original\s*\)/],
    tags: ['maps', 'clone', 'copy', 'Go1.21'],
  },
  {
    id: 'go-maps-keys-1',
    category: 'Maps Package (Go 1.23+)',
    difficulty: 'easy',
    title: 'Get Map Keys',
    text: 'Use `maps.Keys()` to get all keys from the map as an iterator.',
    setup: 'import "maps"\nimport "slices"\nm := map[string]int{"a": 1, "b": 2, "c": 3}',
    setupCode: 'import "maps"\nimport "slices"\nm := map[string]int{"a": 1, "b": 2, "c": 3}',
    expected: 'slices.Collect(maps.Keys(m))',
    sample: 'slices.Collect(maps.Keys(m))',
    hints: ['maps.Keys returns an iterator', 'Use slices.Collect to get a slice'],
    validPatterns: [
      /slices\.Collect\s*\(\s*maps\.Keys\s*\(\s*m\s*\)\s*\)/,
      /maps\.Keys\s*\(\s*m\s*\)/,
    ],
    tags: ['maps', 'keys', 'iterator', 'Go1.23'],
  },

  // ============================================================
  // Error Handling Patterns
  // ============================================================

  {
    id: 'go-error-wrap-1',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Wrap Error with Context',
    text: 'Use `fmt.Errorf()` with %w to wrap an error with context.',
    setup: 'import "fmt"\nimport "errors"\noriginalErr := errors.New("file not found")',
    setupCode: 'import "fmt"\nimport "errors"\noriginalErr := errors.New("file not found")',
    expected: 'wrapped error',
    sample: 'fmt.Errorf("failed to open config: %w", originalErr)',
    hints: ['Use %w verb to wrap errors', 'Preserves original error for errors.Is/As'],
    validPatterns: [/fmt\.Errorf\s*\([^)]*%w[^)]*,\s*originalErr\s*\)/],
    tags: ['error', 'wrap', 'fmt.Errorf'],
  },
  {
    id: 'go-error-is-1',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Check Error Type with errors.Is',
    text: 'Use `errors.Is()` to check if err matches os.ErrNotExist.',
    setup: 'import "errors"\nimport "os"\nerr := os.ErrNotExist',
    setupCode: 'import "errors"\nimport "os"\nerr := os.ErrNotExist',
    expected: true,
    sample: 'errors.Is(err, os.ErrNotExist)',
    hints: ['errors.Is checks error chain', 'Works with wrapped errors'],
    validPatterns: [/errors\.Is\s*\(\s*err\s*,\s*os\.ErrNotExist\s*\)/],
    tags: ['error', 'errors.Is', 'sentinel'],
  },
  {
    id: 'go-error-new-1',
    category: 'Error Handling',
    difficulty: 'easy',
    title: 'Create Simple Error',
    text: 'Use `errors.New()` to create a simple error with a message.',
    setup: 'import "errors"',
    setupCode: 'import "errors"',
    expected: 'invalid input',
    sample: 'errors.New("invalid input")',
    hints: ['errors.New creates a simple error', 'For formatted errors use fmt.Errorf'],
    validPatterns: [/errors\.New\s*\(\s*["']invalid input["']\s*\)/],
    tags: ['error', 'errors.New', 'create'],
  },

  // ============================================================
  // Built-in Functions
  // ============================================================

  {
    id: 'go-builtin-clear-1',
    category: 'Built-in Functions (Go 1.21+)',
    difficulty: 'easy',
    title: 'Clear Map',
    text: 'Use `clear()` to remove all entries from the map.',
    setup: 'm := map[string]int{"a": 1, "b": 2, "c": 3}',
    setupCode: 'm := map[string]int{"a": 1, "b": 2, "c": 3}',
    expected: {},
    sample: 'clear(m)',
    hints: ['clear() removes all map entries', 'Map is still usable after clear'],
    validPatterns: [/clear\s*\(\s*m\s*\)/],
    tags: ['clear', 'map', 'builtin', 'Go1.21'],
  },
  {
    id: 'go-builtin-clear-2',
    category: 'Built-in Functions (Go 1.21+)',
    difficulty: 'easy',
    title: 'Clear Slice',
    text: 'Use `clear()` to zero all elements in the slice.',
    setup: 'numbers := []int{1, 2, 3, 4, 5}',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5}',
    expected: [0, 0, 0, 0, 0],
    sample: 'clear(numbers)',
    hints: ['clear() sets slice elements to zero value', 'Length remains the same'],
    validPatterns: [/clear\s*\(\s*numbers\s*\)/],
    tags: ['clear', 'slice', 'builtin', 'Go1.21'],
  },
  {
    id: 'go-builtin-max-1',
    category: 'Built-in Functions (Go 1.21+)',
    difficulty: 'easy',
    title: 'Get Maximum of Values',
    text: 'Use `max()` to get the maximum of three integers.',
    setup: 'a, b, c := 10, 25, 15',
    setupCode: 'a, b, c := 10, 25, 15',
    expected: 25,
    sample: 'max(a, b, c)',
    hints: ['max() is a built-in since Go 1.21', 'Works with any ordered type'],
    validPatterns: [/max\s*\(\s*a\s*,\s*b\s*,\s*c\s*\)/],
    tags: ['max', 'builtin', 'Go1.21'],
  },
  {
    id: 'go-builtin-min-1',
    category: 'Built-in Functions (Go 1.21+)',
    difficulty: 'easy',
    title: 'Get Minimum of Values',
    text: 'Use `min()` to get the minimum of three integers.',
    setup: 'a, b, c := 10, 25, 15',
    setupCode: 'a, b, c := 10, 25, 15',
    expected: 10,
    sample: 'min(a, b, c)',
    hints: ['min() is a built-in since Go 1.21', 'Works with any ordered type'],
    validPatterns: [/min\s*\(\s*a\s*,\s*b\s*,\s*c\s*\)/],
    tags: ['min', 'builtin', 'Go1.21'],
  },

  // ============================================================
  // fmt Package
  // ============================================================

  {
    id: 'go-fmt-sprintf-1',
    category: 'fmt Package',
    difficulty: 'easy',
    title: 'Format String with Sprintf',
    text: 'Use `fmt.Sprintf()` to format name and age into a string.',
    setup: 'import "fmt"\nname := "Alice"\nage := 30',
    setupCode: 'import "fmt"\nname := "Alice"\nage := 30',
    expected: 'Alice is 30 years old',
    sample: 'fmt.Sprintf("%s is %d years old", name, age)',
    hints: ['%s for strings, %d for integers', 'Returns formatted string'],
    validPatterns: [/fmt\.Sprintf\s*\(\s*["']%s is %d years old["']\s*,\s*name\s*,\s*age\s*\)/],
    tags: ['fmt', 'Sprintf', 'format'],
  },
  {
    id: 'go-fmt-sprintf-2',
    category: 'fmt Package',
    difficulty: 'medium',
    title: 'Format with Type Representation',
    text: 'Use `fmt.Sprintf()` with %T to get the type of a variable.',
    setup: 'import "fmt"\nvalue := 3.14',
    setupCode: 'import "fmt"\nvalue := 3.14',
    expected: 'float64',
    sample: 'fmt.Sprintf("%T", value)',
    hints: ['%T prints the type of a value', 'Useful for debugging'],
    validPatterns: [/fmt\.Sprintf\s*\(\s*["']%T["']\s*,\s*value\s*\)/],
    tags: ['fmt', 'Sprintf', 'type'],
  },
  {
    id: 'go-fmt-sprintf-3',
    category: 'fmt Package',
    difficulty: 'medium',
    title: 'Format with Go Syntax',
    text: 'Use `fmt.Sprintf()` with %#v for Go-syntax representation.',
    setup: 'import "fmt"\ndata := []int{1, 2, 3}',
    setupCode: 'import "fmt"\ndata := []int{1, 2, 3}',
    expected: '[]int{1, 2, 3}',
    sample: 'fmt.Sprintf("%#v", data)',
    hints: ['%#v shows Go syntax representation', 'Useful for debugging complex types'],
    validPatterns: [/fmt\.Sprintf\s*\(\s*["']%#v["']\s*,\s*data\s*\)/],
    tags: ['fmt', 'Sprintf', 'debug'],
  },

  // ============================================================
  // Additional Slice Operations
  // ============================================================

  {
    id: 'go-slice-append-prepend-1',
    category: 'Slice Operations',
    difficulty: 'medium',
    title: 'Prepend Element to Slice',
    text: 'Use `append()` to add 0 at the beginning of the slice.',
    setup: 'numbers := []int{1, 2, 3}',
    setupCode: 'numbers := []int{1, 2, 3}',
    expected: [0, 1, 2, 3],
    sample: 'append([]int{0}, numbers...)',
    hints: ['Create a new slice with the element', 'Append the original slice using ...'],
    validPatterns: [/append\s*\(\s*\[\s*\]\s*int\s*\{\s*0\s*\}\s*,\s*numbers\s*\.\.\.\s*\)/],
    tags: ['append', 'prepend', 'slice'],
  },
  {
    id: 'go-slice-filter-1',
    category: 'Slice Operations',
    difficulty: 'hard',
    title: 'Filter Slice In-Place',
    text: 'Filter the slice to keep only even numbers using a for loop and slicing.',
    setup: 'numbers := []int{1, 2, 3, 4, 5, 6}',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5, 6}',
    expected: [2, 4, 6],
    sample:
      'result := numbers[:0]; for _, n := range numbers { if n%2 == 0 { result = append(result, n) } }',
    hints: [
      'Use numbers[:0] to reuse underlying array',
      'Append only elements that pass the filter',
      'This avoids extra allocation',
    ],
    validPatterns: [/numbers\s*\[\s*:\s*0\s*\]/, /for\s+.*range\s+numbers/, /n\s*%\s*2\s*==\s*0/],
    tags: ['slice', 'filter', 'in-place'],
  },
  {
    id: 'go-slice-make-zero-1',
    category: 'Slice Operations',
    difficulty: 'easy',
    title: 'Create Empty Slice with Capacity',
    text: 'Use `make()` to create an empty int slice with capacity 10.',
    setup: '// Create slice with length 0 but capacity 10',
    setupCode: '// Create slice with length 0 but capacity 10',
    expected: 'make([]int, 0, 10)',
    sample: 'make([]int, 0, 10)',
    hints: ['make(type, length, capacity)', 'Length 0 means empty slice'],
    validPatterns: [/make\s*\(\s*\[\s*\]\s*int\s*,\s*0\s*,\s*10\s*\)/],
    tags: ['make', 'capacity', 'empty'],
  },
  {
    id: 'go-slice-grow-1',
    category: 'Slice Operations',
    difficulty: 'medium',
    title: 'Grow Slice Capacity',
    text: 'Use `slices.Grow()` to ensure the slice has room for 100 more elements.',
    setup: 'import "slices"\nnumbers := []int{1, 2, 3}',
    setupCode: 'import "slices"\nnumbers := []int{1, 2, 3}',
    expected: 'slices.Grow(numbers, 100)',
    sample: 'slices.Grow(numbers, 100)',
    hints: ['slices.Grow increases capacity', 'Does not change length'],
    validPatterns: [/slices\.Grow\s*\(\s*numbers\s*,\s*100\s*\)/],
    tags: ['slices', 'grow', 'capacity', 'Go1.21'],
  },
  {
    id: 'go-slice-compact-1',
    category: 'Slice Operations',
    difficulty: 'medium',
    title: 'Remove Consecutive Duplicates',
    text: 'Use `slices.Compact()` to remove consecutive duplicate elements.',
    setup: 'import "slices"\nnumbers := []int{1, 1, 2, 2, 2, 3, 3}',
    setupCode: 'import "slices"\nnumbers := []int{1, 1, 2, 2, 2, 3, 3}',
    expected: [1, 2, 3],
    sample: 'slices.Compact(numbers)',
    hints: ['Compact removes consecutive duplicates', 'Slice must be sorted for full dedup'],
    validPatterns: [/slices\.Compact\s*\(\s*numbers\s*\)/],
    tags: ['slices', 'compact', 'dedupe', 'Go1.21'],
  },

  // ============================================================
  // Additional String Functions (strings package)
  // ============================================================

  {
    id: 'go-string-repeat-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Repeat String',
    text: 'Use `strings.Repeat()` to repeat the string 3 times.',
    setup: 'import "strings"\ns := "go"',
    setupCode: 'import "strings"\ns := "go"',
    expected: 'gogogo',
    sample: 'strings.Repeat(s, 3)',
    hints: ['strings.Repeat(str, count)', 'Returns concatenated string'],
    validPatterns: [/strings\.Repeat\s*\(\s*s\s*,\s*3\s*\)/],
    tags: ['Repeat', 'strings', 'multiply'],
  },
  {
    id: 'go-string-count-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Count Substring Occurrences',
    text: 'Use `strings.Count()` to count how many times "o" appears.',
    setup: 'import "strings"\ns := "hello world foo"',
    setupCode: 'import "strings"\ns := "hello world foo"',
    expected: 4,
    sample: 'strings.Count(s, "o")',
    hints: ['strings.Count(str, substr)', 'Returns number of non-overlapping occurrences'],
    validPatterns: [/strings\.Count\s*\(\s*s\s*,\s*["']o["']\s*\)/],
    tags: ['Count', 'strings', 'occurrences'],
  },
  {
    id: 'go-string-index-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Find Substring Index',
    text: 'Use `strings.Index()` to find the first occurrence of "world".',
    setup: 'import "strings"\ns := "hello world"',
    setupCode: 'import "strings"\ns := "hello world"',
    expected: 6,
    sample: 'strings.Index(s, "world")',
    hints: ['strings.Index(str, substr)', 'Returns -1 if not found'],
    validPatterns: [/strings\.Index\s*\(\s*s\s*,\s*["']world["']\s*\)/],
    tags: ['Index', 'strings', 'find'],
  },
  {
    id: 'go-string-fields-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Split on Whitespace',
    text: 'Use `strings.Fields()` to split the string by whitespace.',
    setup: 'import "strings"\ns := "  hello   world   go  "',
    setupCode: 'import "strings"\ns := "  hello   world   go  "',
    expected: ['hello', 'world', 'go'],
    sample: 'strings.Fields(s)',
    hints: ['Fields splits on any whitespace', 'Handles multiple spaces'],
    validPatterns: [/strings\.Fields\s*\(\s*s\s*\)/],
    tags: ['Fields', 'strings', 'split', 'whitespace'],
  },
  {
    id: 'go-string-trimprefix-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Trim Prefix from String',
    text: 'Use `strings.TrimPrefix()` to remove the "https://" prefix.',
    setup: 'import "strings"\nurl := "https://example.com"',
    setupCode: 'import "strings"\nurl := "https://example.com"',
    expected: 'example.com',
    sample: 'strings.TrimPrefix(url, "https://")',
    hints: ['TrimPrefix removes prefix if present', 'Returns original if no match'],
    validPatterns: [/strings\.TrimPrefix\s*\(\s*url\s*,\s*["']https:\/\/["']\s*\)/],
    tags: ['TrimPrefix', 'strings', 'trim'],
  },
  {
    id: 'go-string-cut-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Cut String at Separator',
    text: 'Use `strings.Cut()` to split the string at the first "=" sign.',
    setup: 'import "strings"\ns := "key=value=extra"',
    setupCode: 'import "strings"\ns := "key=value=extra"',
    expected: ['key', 'value=extra', true],
    sample: 'before, after, found := strings.Cut(s, "=")',
    hints: ['Cut splits at first occurrence', 'Returns before, after, and found bool'],
    validPatterns: [/strings\.Cut\s*\(\s*s\s*,\s*["']=["']\s*\)/],
    tags: ['Cut', 'strings', 'split', 'Go1.18'],
  },
  {
    id: 'go-string-builder-1',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Build String Efficiently',
    text: 'Use `strings.Builder` to efficiently concatenate strings.',
    setup: 'import "strings"\nwords := []string{"Go", "is", "fast"}',
    setupCode: 'import "strings"\nwords := []string{"Go", "is", "fast"}',
    expected: 'Go is fast',
    sample:
      'var b strings.Builder; for i, w := range words { if i > 0 { b.WriteString(" ") }; b.WriteString(w) }; b.String()',
    hints: [
      'Builder avoids allocations',
      'Use WriteString to append',
      'Call String() to get result',
    ],
    validPatterns: [/strings\.Builder/, /WriteString/, /\.String\s*\(\s*\)/],
    tags: ['Builder', 'strings', 'performance', 'concatenate'],
  },

  // ============================================================
  // Additional Map Operations
  // ============================================================

  {
    id: 'go-map-nested-1',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Create Nested Map',
    text: 'Create a nested map with string keys and map[string]int values.',
    setup: '// Create a map of maps',
    setupCode: '// Create a map of maps',
    expected: 'make(map[string]map[string]int)',
    sample: 'make(map[string]map[string]int)',
    hints: ['Maps can contain other maps', 'Inner maps need initialization too'],
    validPatterns: [/make\s*\(\s*map\s*\[\s*string\s*\]\s*map\s*\[\s*string\s*\]\s*int\s*\)/],
    tags: ['map', 'nested', 'make'],
  },
  {
    id: 'go-map-update-1',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Increment Map Value',
    text: 'Increment the "count" value by 1 (it exists and equals 5).',
    setup: 'm := map[string]int{"count": 5, "total": 100}',
    setupCode: 'm := map[string]int{"count": 5, "total": 100}',
    expected: 6,
    sample: 'm["count"]++',
    hints: ['Use ++ to increment', 'Zero value for int is 0'],
    validPatterns: [/m\s*\[\s*["']count["']\s*\]\s*\+\+/, /m\s*\[\s*["']count["']\s*\]\s*\+=\s*1/],
    tags: ['map', 'increment', 'update'],
  },
  {
    id: 'go-map-default-1',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Get Value with Default',
    text: 'Get the "missing" key value, defaulting to "N/A" if not found.',
    setup: 'm := map[string]string{"name": "Alice"}',
    setupCode: 'm := map[string]string{"name": "Alice"}',
    expected: 'N/A',
    sample: 'if v, ok := m["missing"]; ok { return v } else { return "N/A" }',
    hints: ['Use comma ok idiom', 'Return default if ok is false'],
    validPatterns: [
      /if\s+\w+\s*,\s*ok\s*:=\s*m\s*\[\s*["']missing["']\s*\]/,
      /m\s*\[\s*["']missing["']\s*\]/,
    ],
    tags: ['map', 'default', 'comma-ok'],
    // Note: Sample returns literal "N/A" but demonstrates map access with comma-ok idiom
  },
  {
    id: 'go-map-equal-1',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Compare Maps for Equality',
    text: 'Use `maps.Equal()` to check if two maps are equal.',
    setup:
      'import "maps"\nm1 := map[string]int{"a": 1, "b": 2}\nm2 := map[string]int{"a": 1, "b": 2}',
    setupCode:
      'import "maps"\nm1 := map[string]int{"a": 1, "b": 2}\nm2 := map[string]int{"a": 1, "b": 2}',
    expected: true,
    sample: 'maps.Equal(m1, m2)',
    hints: ['maps.Equal compares key-value pairs', 'Works with comparable value types'],
    validPatterns: [/maps\.Equal\s*\(\s*m1\s*,\s*m2\s*\)/],
    tags: ['maps', 'Equal', 'compare', 'Go1.21'],
  },
  {
    id: 'go-map-deleteFunc-1',
    category: 'Map Operations',
    difficulty: 'hard',
    title: 'Delete Map Entries by Condition',
    text: 'Use `maps.DeleteFunc()` to remove all entries where value < 10.',
    setup: 'import "maps"\nm := map[string]int{"a": 5, "b": 15, "c": 3, "d": 20}',
    setupCode: 'import "maps"\nm := map[string]int{"a": 5, "b": 15, "c": 3, "d": 20}',
    expected: { b: 15, d: 20 },
    sample: 'maps.DeleteFunc(m, func(k string, v int) bool { return v < 10 })',
    hints: ['DeleteFunc takes a predicate', 'Return true to delete the entry'],
    validPatterns: [/maps\.DeleteFunc\s*\(\s*m\s*,\s*func\s*\(/],
    tags: ['maps', 'DeleteFunc', 'filter', 'Go1.21'],
  },

  // ============================================================
  // Additional Sort Package
  // ============================================================

  {
    id: 'go-sort-float64s-1',
    category: 'Sort Package',
    difficulty: 'easy',
    title: 'Sort Float64 Slice',
    text: 'Use `sort.Float64s()` to sort the slice in ascending order.',
    setup: 'import "sort"\nnumbers := []float64{3.14, 1.41, 2.72, 0.58}',
    setupCode: 'import "sort"\nnumbers := []float64{3.14, 1.41, 2.72, 0.58}',
    expected: [0.58, 1.41, 2.72, 3.14],
    sample: 'sort.Float64s(numbers)',
    hints: ['sort.Float64s(slice)', 'Sorts in place, ascending order'],
    validPatterns: [/sort\.Float64s\s*\(\s*numbers\s*\)/],
    tags: ['sort', 'Float64s', 'ascending'],
  },
  {
    id: 'go-sort-stable-1',
    category: 'Sort Package',
    difficulty: 'medium',
    title: 'Stable Sort Slice',
    text: 'Use `sort.SliceStable()` to sort by name length, preserving original order for equal lengths.',
    setup: 'import "sort"\nnames := []string{"bob", "alice", "eve", "dan"}',
    setupCode: 'import "sort"\nnames := []string{"bob", "alice", "eve", "dan"}',
    expected: ['bob', 'eve', 'dan', 'alice'],
    sample: 'sort.SliceStable(names, func(i, j int) bool { return len(names[i]) < len(names[j]) })',
    hints: ['SliceStable preserves original order', 'Equal elements keep relative position'],
    validPatterns: [/sort\.SliceStable\s*\(\s*names\s*,\s*func\s*\(/],
    tags: ['sort', 'SliceStable', 'stable'],
  },
  {
    id: 'go-sort-search-string-1',
    category: 'Sort Package',
    difficulty: 'medium',
    title: 'Binary Search in String Slice',
    text: 'Use `sort.SearchStrings()` to find where "go" would be inserted.',
    setup: 'import "sort"\nwords := []string{"c", "go", "java", "python", "rust"}',
    setupCode: 'import "sort"\nwords := []string{"c", "go", "java", "python", "rust"}',
    expected: 1,
    sample: 'sort.SearchStrings(words, "go")',
    hints: ['Slice must be sorted', 'Returns insertion point index'],
    validPatterns: [/sort\.SearchStrings\s*\(\s*words\s*,\s*["']go["']\s*\)/],
    tags: ['sort', 'SearchStrings', 'binary'],
  },
  {
    id: 'go-sort-multikey-1',
    category: 'Sort Package',
    difficulty: 'hard',
    title: 'Sort by Multiple Keys',
    text: 'Sort people by age ascending, then by name alphabetically for same age.',
    setup:
      'import "sort"\ntype Person struct { Name string; Age int }\npeople := []Person{{"Bob", 25}, {"Alice", 25}, {"Carol", 20}}',
    setupCode:
      'import "sort"\ntype Person struct { Name string; Age int }\npeople := []Person{{"Bob", 25}, {"Alice", 25}, {"Carol", 20}}',
    expected: [
      { Name: 'Carol', Age: 20 },
      { Name: 'Alice', Age: 25 },
      { Name: 'Bob', Age: 25 },
    ],
    sample:
      'sort.Slice(people, func(i, j int) bool { if people[i].Age != people[j].Age { return people[i].Age < people[j].Age }; return people[i].Name < people[j].Name })',
    hints: [
      'Compare primary key first',
      'Only compare secondary key if primary is equal',
      'Use if statement for multi-key logic',
    ],
    validPatterns: [/sort\.Slice\s*\(\s*people\s*,\s*func\s*\(/, /Age\s*!=/, /\.Name\s*</],
    tags: ['sort', 'multikey', 'custom'],
  },

  // ============================================================
  // strconv Package
  // ============================================================

  {
    id: 'go-strconv-parseint-1',
    category: 'strconv Package',
    difficulty: 'medium',
    title: 'Parse Integer with Base',
    text: 'Use `strconv.ParseInt()` to parse the hex string "ff" as base 16.',
    setup: 'import "strconv"\ns := "ff"',
    setupCode: 'import "strconv"\ns := "ff"',
    expected: 255,
    sample: 'n, err := strconv.ParseInt(s, 16, 64); if err != nil { panic(err) }; n',
    hints: ['ParseInt(str, base, bitSize)', 'Base 16 for hexadecimal'],
    validPatterns: [/strconv\.ParseInt\s*\(\s*s\s*,\s*16\s*,\s*\d+\s*\)/],
    tags: ['strconv', 'ParseInt', 'hex'],
  },
  {
    id: 'go-strconv-formatint-1',
    category: 'strconv Package',
    difficulty: 'medium',
    title: 'Format Integer to Binary',
    text: 'Use `strconv.FormatInt()` to convert 42 to a binary string.',
    setup: 'import "strconv"\nn := int64(42)',
    setupCode: 'import "strconv"\nn := int64(42)',
    expected: '101010',
    sample: 'strconv.FormatInt(n, 2)',
    hints: ['FormatInt(value, base)', 'Base 2 for binary'],
    validPatterns: [/strconv\.FormatInt\s*\(\s*n\s*,\s*2\s*\)/],
    tags: ['strconv', 'FormatInt', 'binary'],
  },
  {
    id: 'go-strconv-parsefloat-1',
    category: 'strconv Package',
    difficulty: 'medium',
    title: 'Parse Float from String',
    text: 'Use `strconv.ParseFloat()` to parse "3.14159" as a float64.',
    setup: 'import "strconv"\ns := "3.14159"',
    setupCode: 'import "strconv"\ns := "3.14159"',
    // biome-ignore lint/suspicious/noApproximativeNumericConstant: literal parsed value, not Math.PI
    expected: 3.14159,
    sample: 'f, err := strconv.ParseFloat(s, 64); if err != nil { panic(err) }; f',
    hints: ['ParseFloat(str, bitSize)', '64 for float64'],
    validPatterns: [/strconv\.ParseFloat\s*\(\s*s\s*,\s*64\s*\)/],
    tags: ['strconv', 'ParseFloat', 'float'],
  },
  {
    id: 'go-strconv-formatfloat-1',
    category: 'strconv Package',
    difficulty: 'hard',
    title: 'Format Float with Precision',
    text: 'Use `strconv.FormatFloat()` to format pi with 2 decimal places.',
    setup: 'import "strconv"\npi := 3.14159265359',
    setupCode: 'import "strconv"\npi := 3.14159265359',
    expected: '3.14',
    sample: "strconv.FormatFloat(pi, 'f', 2, 64)",
    hints: ['FormatFloat(f, fmt, prec, bitSize)', "'f' for decimal notation"],
    validPatterns: [/strconv\.FormatFloat\s*\(\s*pi\s*,\s*'f'\s*,\s*2\s*,\s*64\s*\)/],
    tags: ['strconv', 'FormatFloat', 'precision'],
  },
  {
    id: 'go-strconv-parsebool-1',
    category: 'strconv Package',
    difficulty: 'easy',
    title: 'Parse Boolean from String',
    text: 'Use `strconv.ParseBool()` to parse "true" as a boolean.',
    setup: 'import "strconv"\ns := "true"',
    setupCode: 'import "strconv"\ns := "true"',
    expected: true,
    sample: 'b, err := strconv.ParseBool(s); if err != nil { panic(err) }; b',
    hints: ['Accepts "1", "t", "T", "TRUE", "true", "True"', 'Returns (bool, error)'],
    validPatterns: [/strconv\.ParseBool\s*\(\s*s\s*\)/],
    tags: ['strconv', 'ParseBool', 'boolean'],
  },
  {
    id: 'go-strconv-formatbool-1',
    category: 'strconv Package',
    difficulty: 'easy',
    title: 'Format Boolean to String',
    text: 'Use `strconv.FormatBool()` to convert false to a string.',
    setup: 'import "strconv"\nb := false',
    setupCode: 'import "strconv"\nb := false',
    expected: 'false',
    sample: 'strconv.FormatBool(b)',
    hints: ['FormatBool returns "true" or "false"', 'Simple and predictable'],
    validPatterns: [/strconv\.FormatBool\s*\(\s*b\s*\)/],
    tags: ['strconv', 'FormatBool', 'boolean'],
  },
  {
    id: 'go-strconv-quote-1',
    category: 'strconv Package',
    difficulty: 'medium',
    title: 'Quote String with Escapes',
    text: 'Use `strconv.Quote()` to create a double-quoted Go string literal.',
    setup: 'import "strconv"\ns := "hello\\nworld"',
    setupCode: 'import "strconv"\ns := "hello\\nworld"',
    expected: '"hello\\nworld"',
    sample: 'strconv.Quote(s)',
    hints: ['Quote adds quotes and escapes special chars', 'Useful for generating Go code'],
    validPatterns: [/strconv\.Quote\s*\(\s*s\s*\)/],
    tags: ['strconv', 'Quote', 'escape'],
  },

  // ============================================================
  // String Manipulation (Advanced)
  // ============================================================

  // --- EASY (8 problems) ---

  {
    id: 'go-str-builder-write-1',
    category: 'String Manipulation',
    difficulty: 'easy',
    title: 'Write Byte to Builder',
    text: 'Use `strings.Builder` to write a single byte character "X" to the builder.',
    setup: 'import "strings"\nvar b strings.Builder',
    setupCode: 'import "strings"\nvar b strings.Builder',
    expected: 'X',
    sample: "b.WriteByte('X'); b.String()",
    hints: ['WriteByte writes a single byte', 'Use single quotes for byte literals'],
    validPatterns: [/\.WriteByte\s*\(\s*'X'\s*\)/, /\.WriteByte\s*\(\s*88\s*\)/],
    tags: ['Builder', 'WriteByte', 'strings'],
  },
  {
    id: 'go-str-builder-write-rune-1',
    category: 'String Manipulation',
    difficulty: 'easy',
    title: 'Write Rune to Builder',
    text: 'Use `strings.Builder` to write the Unicode character "..." (U+4E16) to the builder.',
    setup: 'import "strings"\nvar b strings.Builder',
    setupCode: 'import "strings"\nvar b strings.Builder',
    expected: '\u4e16',
    sample: "b.WriteRune('\u4e16'); b.String()",
    hints: ['WriteRune handles multi-byte Unicode characters', 'Runes can be more than one byte'],
    validPatterns: [/\.WriteRune\s*\(/, /\.WriteRune\s*\(\s*0x4E16\s*\)/],
    tags: ['Builder', 'WriteRune', 'unicode', 'strings'],
  },
  {
    id: 'go-str-rune-iterate-1',
    category: 'String Manipulation',
    difficulty: 'easy',
    title: 'Iterate Over Runes',
    text: 'Use a for-range loop to iterate over each rune in the string.',
    setup: 's := "Go..."',
    setupCode: 's := "Go..."',
    expected: 'for i, r := range s',
    sample: 'for i, r := range s { fmt.Printf("%d: %c\\n", i, r) }',
    hints: ['for-range on string yields runes', 'Index is byte position, not rune position'],
    validPatterns: [/for\s+\w+\s*,\s*\w+\s*:=\s*range\s+s/],
    tags: ['rune', 'iterate', 'unicode', 'range'],
  },
  {
    id: 'go-str-bytes-to-string-1',
    category: 'String Manipulation',
    difficulty: 'easy',
    title: 'Convert Bytes to String',
    text: 'Convert a byte slice to a string.',
    setup: 'data := []byte{72, 101, 108, 108, 111}',
    setupCode: 'data := []byte{72, 101, 108, 108, 111}',
    expected: 'Hello',
    sample: 'string(data)',
    hints: ['Use string() type conversion', 'Each byte is an ASCII code'],
    validPatterns: [/string\s*\(\s*data\s*\)/],
    tags: ['bytes', 'string', 'convert'],
  },
  {
    id: 'go-str-string-to-bytes-1',
    category: 'String Manipulation',
    difficulty: 'easy',
    title: 'Convert String to Bytes',
    text: 'Convert the string to a byte slice.',
    setup: 's := "Hello"',
    setupCode: 's := "Hello"',
    expected: [72, 101, 108, 108, 111],
    sample: '[]byte(s)',
    hints: ['Use []byte() type conversion', 'Creates a copy of the string data'],
    validPatterns: [/\[\s*\]\s*byte\s*\(\s*s\s*\)/],
    tags: ['bytes', 'string', 'convert'],
  },
  {
    id: 'go-str-string-to-runes-1',
    category: 'String Manipulation',
    difficulty: 'easy',
    title: 'Convert String to Runes',
    text: 'Convert the string to a rune slice to properly handle Unicode.',
    setup: 's := "Hello..."',
    setupCode: 's := "Hello..."',
    expected: '[]rune(s)',
    sample: '[]rune(s)',
    hints: ['Use []rune() for Unicode-safe operations', 'Each rune is a Unicode code point'],
    validPatterns: [/\[\s*\]\s*rune\s*\(\s*s\s*\)/],
    tags: ['rune', 'string', 'convert', 'unicode'],
  },
  {
    id: 'go-str-fmt-padding-1',
    category: 'String Manipulation',
    difficulty: 'easy',
    title: 'Pad String with Spaces',
    text: 'Use `fmt.Sprintf()` to right-align the string in a 10-character field.',
    setup: 'import "fmt"\ns := "Go"',
    setupCode: 'import "fmt"\ns := "Go"',
    expected: '        Go',
    sample: 'fmt.Sprintf("%10s", s)',
    hints: ['%10s pads to 10 characters', 'Positive width right-aligns'],
    validPatterns: [/fmt\.Sprintf\s*\(\s*["']%10s["']\s*,\s*s\s*\)/],
    tags: ['fmt', 'Sprintf', 'padding', 'format'],
  },
  {
    id: 'go-str-fmt-left-pad-1',
    category: 'String Manipulation',
    difficulty: 'easy',
    title: 'Left-Align String',
    text: 'Use `fmt.Sprintf()` to left-align the string in a 10-character field.',
    setup: 'import "fmt"\ns := "Go"',
    setupCode: 'import "fmt"\ns := "Go"',
    expected: 'Go        ',
    sample: 'fmt.Sprintf("%-10s", s)',
    hints: ['%-10s left-aligns', 'Negative width left-aligns'],
    validPatterns: [/fmt\.Sprintf\s*\(\s*["']%-10s["']\s*,\s*s\s*\)/],
    tags: ['fmt', 'Sprintf', 'padding', 'format'],
  },

  // --- MEDIUM (12 problems) ---

  {
    id: 'go-str-builder-grow-1',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Pre-allocate Builder Capacity',
    text: 'Use `strings.Builder.Grow()` to pre-allocate space for 100 bytes.',
    setup: 'import "strings"\nvar b strings.Builder',
    setupCode: 'import "strings"\nvar b strings.Builder',
    expected: 'b.Grow(100)',
    sample: 'b.Grow(100)',
    hints: ['Grow pre-allocates capacity', 'Reduces allocations during writes'],
    validPatterns: [/b\.Grow\s*\(\s*100\s*\)/],
    tags: ['Builder', 'Grow', 'performance', 'strings'],
  },
  {
    id: 'go-str-reader-1',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Create String Reader',
    text: 'Use `strings.NewReader()` to create a Reader from the string.',
    setup: 'import "strings"\ns := "Hello, World!"',
    setupCode: 'import "strings"\ns := "Hello, World!"',
    expected: 'strings.NewReader(s)',
    sample: 'r := strings.NewReader(s)',
    hints: ['NewReader returns *strings.Reader', 'Implements io.Reader interface'],
    validPatterns: [/strings\.NewReader\s*\(\s*s\s*\)/],
    tags: ['Reader', 'strings', 'io'],
  },
  {
    id: 'go-str-replacer-1',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Create String Replacer',
    text: 'Use `strings.NewReplacer()` to replace multiple patterns: "<" with "&lt;" and ">" with "&gt;".',
    setup: 'import "strings"\ns := "<html>content</html>"',
    setupCode: 'import "strings"\ns := "<html>content</html>"',
    expected: '&lt;html&gt;content&lt;/html&gt;',
    sample: 'r := strings.NewReplacer("<", "&lt;", ">", "&gt;"); r.Replace(s)',
    hints: ['NewReplacer takes old/new pairs', 'Efficient for multiple replacements'],
    validPatterns: [/strings\.NewReplacer\s*\(/, /\.Replace\s*\(\s*s\s*\)/],
    tags: ['Replacer', 'strings', 'escape', 'html'],
  },
  {
    id: 'go-str-bytes-buffer-1',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Create Bytes Buffer',
    text: 'Use `bytes.NewBufferString()` to create a buffer from the string.',
    setup: 'import "bytes"\ns := "initial content"',
    setupCode: 'import "bytes"\ns := "initial content"',
    expected: 'bytes.NewBufferString(s)',
    sample: 'buf := bytes.NewBufferString(s)',
    hints: ['NewBufferString creates a Buffer', 'Buffer implements io.Reader and io.Writer'],
    validPatterns: [/bytes\.NewBufferString\s*\(\s*s\s*\)/],
    tags: ['bytes', 'Buffer', 'io'],
  },
  {
    id: 'go-str-bytes-contains-1',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Check Bytes Contains',
    text: 'Use `bytes.Contains()` to check if the byte slice contains "world".',
    setup: 'import "bytes"\ndata := []byte("hello world")',
    setupCode: 'import "bytes"\ndata := []byte("hello world")',
    expected: true,
    sample: 'bytes.Contains(data, []byte("world"))',
    hints: ['bytes.Contains works like strings.Contains', 'Second arg must be []byte'],
    validPatterns: [
      /bytes\.Contains\s*\(\s*data\s*,\s*\[\s*\]\s*byte\s*\(\s*["']world["']\s*\)\s*\)/,
    ],
    tags: ['bytes', 'Contains', 'search'],
  },
  {
    id: 'go-str-fmt-zero-pad-1',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Zero-Pad Integer',
    text: 'Use `fmt.Sprintf()` to format the number with leading zeros to 5 digits.',
    setup: 'import "fmt"\nn := 42',
    setupCode: 'import "fmt"\nn := 42',
    expected: '00042',
    sample: 'fmt.Sprintf("%05d", n)',
    hints: ['%05d pads with zeros', '0 flag enables zero-padding'],
    validPatterns: [/fmt\.Sprintf\s*\(\s*["']%05d["']\s*,\s*n\s*\)/],
    tags: ['fmt', 'Sprintf', 'padding', 'format'],
  },
  {
    id: 'go-str-fmt-hex-1',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Format as Hexadecimal',
    text: 'Use `fmt.Sprintf()` to format the number as uppercase hexadecimal with 0x prefix.',
    setup: 'import "fmt"\nn := 255',
    setupCode: 'import "fmt"\nn := 255',
    expected: '0xFF',
    sample: 'fmt.Sprintf("0x%X", n)',
    hints: ['%X for uppercase hex', '%x for lowercase hex'],
    validPatterns: [/fmt\.Sprintf\s*\(\s*["']0x%X["']\s*,\s*n\s*\)/],
    tags: ['fmt', 'Sprintf', 'hex', 'format'],
  },
  {
    id: 'go-str-strconv-appendint-1',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Append Integer to Byte Slice',
    text: 'Use `strconv.AppendInt()` to append 42 in base 10 to the byte slice.',
    setup: 'import "strconv"\nbuf := []byte("value: ")',
    setupCode: 'import "strconv"\nbuf := []byte("value: ")',
    expected: 'value: 42',
    sample: 'string(strconv.AppendInt(buf, 42, 10))',
    hints: ['AppendInt is more efficient than Itoa+append', 'Third arg is the base'],
    validPatterns: [/strconv\.AppendInt\s*\(\s*buf\s*,\s*42\s*,\s*10\s*\)/],
    tags: ['strconv', 'AppendInt', 'performance'],
  },
  {
    id: 'go-str-unicode-isletter-1',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Check if Rune is Letter',
    text: 'Use `unicode.IsLetter()` to check if the rune is a letter.',
    setup: 'import "unicode"\nr := \'A\'',
    setupCode: 'import "unicode"\nr := \'A\'',
    expected: true,
    sample: 'unicode.IsLetter(r)',
    hints: ['Works with any Unicode letter', 'Not just ASCII a-zA-Z'],
    validPatterns: [/unicode\.IsLetter\s*\(\s*r\s*\)/],
    tags: ['unicode', 'IsLetter', 'rune'],
  },
  {
    id: 'go-str-unicode-toupper-1',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Convert Rune to Uppercase',
    text: 'Use `unicode.ToUpper()` to convert the rune to uppercase.',
    setup: 'import "unicode"\nr := \'a\'',
    setupCode: 'import "unicode"\nr := \'a\'',
    expected: 'A',
    sample: 'unicode.ToUpper(r)',
    hints: ['ToUpper works on individual runes', 'Returns the uppercase rune'],
    validPatterns: [/unicode\.ToUpper\s*\(\s*r\s*\)/],
    tags: ['unicode', 'ToUpper', 'rune'],
  },
  {
    id: 'go-str-regexp-match-1',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Check Regex Match',
    text: 'Use `regexp.MatchString()` to check if the string matches the email pattern.',
    setup:
      'import "regexp"\nemail := "test@example.com"\npattern := `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$`',
    setupCode:
      'import "regexp"\nemail := "test@example.com"\npattern := `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$`',
    expected: true,
    sample:
      'matched, err := regexp.MatchString(pattern, email); if err != nil { panic(err) }; matched',
    hints: ['MatchString returns (bool, error)', 'Compile regex for repeated use'],
    validPatterns: [/regexp\.MatchString\s*\(\s*pattern\s*,\s*email\s*\)/],
    tags: ['regexp', 'MatchString', 'regex'],
  },
  {
    id: 'go-str-regexp-find-1',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Find First Match',
    text: 'Use compiled regex `FindString()` to find the first number in the string.',
    setup: 'import "regexp"\nre := regexp.MustCompile(`\\d+`)\ns := "abc123def456"',
    setupCode: 'import "regexp"\nre := regexp.MustCompile(`\\d+`)\ns := "abc123def456"',
    expected: '123',
    sample: 're.FindString(s)',
    hints: ['FindString returns first match', 'Returns empty string if no match'],
    validPatterns: [/re\.FindString\s*\(\s*s\s*\)/],
    tags: ['regexp', 'FindString', 'regex'],
  },

  // --- HARD (5 problems) ---

  {
    id: 'go-str-builder-reset-1',
    category: 'String Manipulation',
    difficulty: 'hard',
    title: 'Reuse Builder with Reset',
    text: 'Use `strings.Builder` to build "Hello", get the result, reset, then build "World".',
    setup: 'import "strings"\nvar b strings.Builder',
    setupCode: 'import "strings"\nvar b strings.Builder',
    expected: ['Hello', 'World'],
    sample:
      'b.WriteString("Hello"); s1 := b.String(); b.Reset(); b.WriteString("World"); s2 := b.String()',
    hints: ['Reset() clears the builder', 'Allows reusing without new allocation'],
    validPatterns: [/\.WriteString\s*\(/, /\.Reset\s*\(\s*\)/, /\.String\s*\(\s*\)/],
    tags: ['Builder', 'Reset', 'strings', 'performance'],
  },
  {
    id: 'go-str-regexp-replace-1',
    category: 'String Manipulation',
    difficulty: 'hard',
    title: 'Regex Replace All',
    text: 'Use compiled regex `ReplaceAllString()` to replace all digits with "X".',
    setup: 'import "regexp"\nre := regexp.MustCompile(`\\d`)\ns := "Phone: 123-456-7890"',
    setupCode: 'import "regexp"\nre := regexp.MustCompile(`\\d`)\ns := "Phone: 123-456-7890"',
    expected: 'Phone: XXX-XXX-XXXX',
    sample: 're.ReplaceAllString(s, "X")',
    hints: ['ReplaceAllString replaces all matches', 'Compiled regex is more efficient'],
    validPatterns: [/re\.ReplaceAllString\s*\(\s*s\s*,\s*["']X["']\s*\)/],
    tags: ['regexp', 'ReplaceAllString', 'regex'],
  },
  {
    id: 'go-str-regexp-groups-1',
    category: 'String Manipulation',
    difficulty: 'hard',
    title: 'Extract Regex Groups',
    text: 'Use `FindStringSubmatch()` to extract name and domain from the email.',
    setup: 'import "regexp"\nre := regexp.MustCompile(`(.+)@(.+)`)\nemail := "user@example.com"',
    setupCode:
      'import "regexp"\nre := regexp.MustCompile(`(.+)@(.+)`)\nemail := "user@example.com"',
    expected: ['user@example.com', 'user', 'example.com'],
    sample: 're.FindStringSubmatch(email)',
    hints: ['Returns slice: [fullMatch, group1, group2, ...]', 'Index 0 is full match'],
    validPatterns: [/re\.FindStringSubmatch\s*\(\s*email\s*\)/],
    tags: ['regexp', 'FindStringSubmatch', 'groups', 'regex'],
  },
  {
    id: 'go-str-normalize-whitespace-1',
    category: 'String Manipulation',
    difficulty: 'hard',
    title: 'Normalize Whitespace',
    text: 'Use `strings.Fields()` and `strings.Join()` to normalize whitespace to single spaces.',
    setup: 'import "strings"\ns := "  hello    world   go  "',
    setupCode: 'import "strings"\ns := "  hello    world   go  "',
    expected: 'hello world go',
    sample: 'strings.Join(strings.Fields(s), " ")',
    hints: ['Fields splits on any whitespace', 'Join with single space normalizes'],
    validPatterns: [/strings\.Join\s*\(\s*strings\.Fields\s*\(\s*s\s*\)\s*,\s*["'] ["']\s*\)/],
    tags: ['strings', 'Fields', 'Join', 'normalize'],
  },
  {
    id: 'go-str-title-case-1',
    category: 'String Manipulation',
    difficulty: 'hard',
    title: 'Convert to Title Case',
    text: 'Use `strings.Title()` or manual approach to convert the string to title case.',
    setup: 'import "strings"\nimport "unicode"\ns := "hello world"',
    setupCode: 'import "strings"\nimport "unicode"\ns := "hello world"',
    expected: 'Hello World',
    sample: 'strings.Title(s)',
    hints: ['strings.Title is deprecated but works', 'For new code, use golang.org/x/text/cases'],
    validPatterns: [/strings\.Title\s*\(\s*s\s*\)/, /cases\.Title/],
    tags: ['strings', 'Title', 'case', 'deprecated'],
  },

  // ============================================================
  // Go Slice Advanced Operations
  // ============================================================

  // --- EASY (8 problems) ---

  {
    id: 'go-slice-len-cap-diff-1',
    category: 'Slice Advanced Operations',
    difficulty: 'easy',
    title: 'Understand len vs cap',
    text: 'Create a slice with `make()` that has length 3 and capacity 10. What is `cap(s) - len(s)`?',
    setup: 's := make([]int, 3, 10)',
    setupCode: 's := make([]int, 3, 10)',
    expected: 7,
    sample: 'cap(s) - len(s)',
    hints: [
      'len() returns number of elements',
      'cap() returns total capacity',
      'Difference is room for growth',
    ],
    validPatterns: [/cap\s*\(\s*s\s*\)\s*-\s*len\s*\(\s*s\s*\)/],
    tags: ['slice', 'len', 'cap', 'internals'],
  },
  {
    id: 'go-slice-reslice-1',
    category: 'Slice Advanced Operations',
    difficulty: 'easy',
    title: 'Reslice to Extend Length',
    text: 'Given a slice with length 2 and capacity 5, extend it to length 4 using reslicing.',
    setup: 's := make([]int, 2, 5)\ns[0], s[1] = 1, 2',
    setupCode: 's := make([]int, 2, 5)\ns[0], s[1] = 1, 2',
    expected: [1, 2, 0, 0],
    sample: 's[:4]',
    hints: ['You can reslice up to capacity', 's[:n] extends length if n <= cap(s)'],
    validPatterns: [/s\s*\[\s*:\s*4\s*\]/],
    tags: ['slice', 'reslice', 'capacity'],
  },
  {
    id: 'go-slice-nil-check-1',
    category: 'Slice Advanced Operations',
    difficulty: 'easy',
    title: 'Check for Nil Slice',
    text: 'Check if the slice is nil.',
    setup: 'var s []int',
    setupCode: 'var s []int',
    expected: true,
    sample: 's == nil',
    hints: ['Uninitialized slice is nil', 'nil slice has len and cap of 0'],
    validPatterns: [/s\s*==\s*nil/],
    tags: ['slice', 'nil', 'check'],
  },
  {
    id: 'go-slice-empty-vs-nil-1',
    category: 'Slice Advanced Operations',
    difficulty: 'easy',
    title: 'Empty Slice vs Nil Slice',
    text: 'Create an empty (non-nil) slice using a literal. Check that it is not nil.',
    setup: '// Create empty non-nil slice',
    setupCode: '// Create empty non-nil slice',
    expected: false,
    sample: 's := []int{}; s == nil',
    hints: ['[]int{} creates empty non-nil slice', 'make([]int, 0) also creates non-nil'],
    validPatterns: [/\[\s*\]\s*int\s*\{\s*\}/, /make\s*\(\s*\[\s*\]\s*int\s*,\s*0\s*\)/],
    tags: ['slice', 'empty', 'nil', 'literal'],
  },
  {
    id: 'go-slice-copy-full-1',
    category: 'Slice Advanced Operations',
    difficulty: 'easy',
    title: 'Full Copy of Slice',
    text: 'Create a complete independent copy of the slice using append.',
    setup: 'original := []int{1, 2, 3, 4, 5}',
    setupCode: 'original := []int{1, 2, 3, 4, 5}',
    expected: [1, 2, 3, 4, 5],
    sample: 'append([]int(nil), original...)',
    hints: ['append to nil slice creates new backing array', 'This is a common copy idiom'],
    validPatterns: [
      /append\s*\(\s*\[\s*\]\s*int\s*\(\s*nil\s*\)\s*,\s*original\s*\.\.\.\s*\)/,
      /append\s*\(\s*\[\s*\]\s*int\s*\{\s*\}\s*,\s*original\s*\.\.\.\s*\)/,
      /slices\.Clone\s*\(\s*original\s*\)/,
    ],
    tags: ['slice', 'copy', 'append', 'idiom'],
  },
  {
    id: 'go-slice-zero-value-1',
    category: 'Slice Advanced Operations',
    difficulty: 'easy',
    title: 'Slice Zero Values',
    text: 'What are the elements of a slice created with `make([]int, 3)`?',
    setup: 's := make([]int, 3)',
    setupCode: 's := make([]int, 3)',
    expected: [0, 0, 0],
    sample: 's',
    hints: ['make initializes to zero values', 'int zero value is 0'],
    validPatterns: [/^s$/, /make\s*\(\s*\[\s*\]\s*int\s*,\s*3\s*\)/],
    tags: ['slice', 'make', 'zero-value'],
  },
  {
    id: 'go-slice-three-index-1',
    category: 'Slice Advanced Operations',
    difficulty: 'easy',
    title: 'Three-Index Slice (Limit Capacity)',
    text: 'Use three-index slicing to get elements 1-3 with capacity limited to 3.',
    setup: 's := []int{0, 1, 2, 3, 4, 5}',
    setupCode: 's := []int{0, 1, 2, 3, 4, 5}',
    expected: 'cap = 2',
    sample: 's[1:3:3]',
    hints: ['s[low:high:max] limits capacity', 'cap = max - low'],
    validPatterns: [/s\s*\[\s*1\s*:\s*3\s*:\s*3\s*\]/],
    tags: ['slice', 'three-index', 'capacity'],
  },
  {
    id: 'go-slice-clear-builtin-1',
    category: 'Slice Advanced Operations',
    difficulty: 'easy',
    title: 'Clear Slice with Built-in',
    text: 'Use the `clear()` built-in to zero all elements in the slice.',
    setup: 'numbers := []int{1, 2, 3, 4, 5}',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5}',
    expected: [0, 0, 0, 0, 0],
    sample: 'clear(numbers); numbers',
    hints: ['clear() zeros elements but keeps length', 'Go 1.21+ built-in'],
    validPatterns: [/clear\s*\(\s*numbers\s*\)/],
    tags: ['slice', 'clear', 'builtin', 'Go1.21'],
  },

  // --- MEDIUM (12 problems) ---

  {
    id: 'go-slice-capacity-growth-1',
    category: 'Slice Advanced Operations',
    difficulty: 'medium',
    title: 'Understand Capacity Growth',
    text: 'Starting with empty slice, append 5 elements and check if cap > len.',
    setup: 'var s []int\nfor i := 0; i < 5; i++ { s = append(s, i) }',
    setupCode: 'var s []int\nfor i := 0; i < 5; i++ { s = append(s, i) }',
    expected: true,
    sample: 'cap(s) > len(s)',
    hints: ['Go over-allocates on append', 'Typically doubles capacity'],
    validPatterns: [/cap\s*\(\s*s\s*\)\s*>\s*len\s*\(\s*s\s*\)/],
    tags: ['slice', 'capacity', 'growth', 'append'],
  },
  {
    id: 'go-slice-preallocate-1',
    category: 'Slice Advanced Operations',
    difficulty: 'medium',
    title: 'Preallocate for Performance',
    text: 'Create a slice to hold exactly 1000 elements with no reallocation during append.',
    setup: '// Create slice that can hold 1000 elements',
    setupCode: '// Create slice that can hold 1000 elements',
    expected: 'make([]int, 0, 1000)',
    sample: 'make([]int, 0, 1000)',
    hints: ['Length 0, capacity 1000', 'Prevents reallocations during append'],
    validPatterns: [/make\s*\(\s*\[\s*\]\s*int\s*,\s*0\s*,\s*1000\s*\)/],
    tags: ['slice', 'preallocate', 'performance', 'make'],
  },
  {
    id: 'go-slice-filter-generic-1',
    category: 'Slice Advanced Operations',
    difficulty: 'medium',
    title: 'Generic Filter Function',
    text: 'Use `slices.DeleteFunc()` to remove all negative numbers from the slice.',
    setup: 'import "slices"\nnumbers := []int{-2, 3, -5, 8, -1, 4}',
    setupCode: 'import "slices"\nnumbers := []int{-2, 3, -5, 8, -1, 4}',
    expected: [3, 8, 4],
    sample: 'slices.DeleteFunc(numbers, func(n int) bool { return n < 0 })',
    hints: ['DeleteFunc removes elements matching predicate', 'Return true to delete'],
    validPatterns: [/slices\.DeleteFunc\s*\(\s*numbers\s*,\s*func\s*\(\s*n\s+int\s*\)\s*bool/],
    tags: ['slices', 'DeleteFunc', 'filter', 'generic', 'Go1.21'],
  },
  {
    id: 'go-slice-transform-1',
    category: 'Slice Advanced Operations',
    difficulty: 'medium',
    title: 'Transform Slice Elements',
    text: 'Double each element in the slice in-place using a for loop with index.',
    setup: 'numbers := []int{1, 2, 3, 4, 5}',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5}',
    expected: [2, 4, 6, 8, 10],
    sample: 'for i := range numbers { numbers[i] *= 2 }',
    hints: ['Use index-based range', 'Modify in place using index'],
    validPatterns: [/for\s+\w+\s*:=\s*range\s+numbers/, /numbers\s*\[\s*\w+\s*\]\s*\*=\s*2/],
    tags: ['slice', 'transform', 'in-place', 'loop'],
  },
  {
    id: 'go-slice-2d-create-1',
    category: 'Slice Advanced Operations',
    difficulty: 'medium',
    title: 'Create 2D Slice',
    text: 'Create a 3x4 matrix (3 rows, 4 columns) of integers initialized to zero.',
    setup: '// Create 3x4 matrix',
    setupCode: '// Create 3x4 matrix',
    expected: '3 rows, 4 columns each',
    sample: 'matrix := make([][]int, 3); for i := range matrix { matrix[i] = make([]int, 4) }',
    hints: ['Create outer slice first', 'Initialize each row separately'],
    validPatterns: [
      /make\s*\(\s*\[\s*\]\s*\[\s*\]\s*int\s*,\s*3\s*\)/,
      /make\s*\(\s*\[\s*\]\s*int\s*,\s*4\s*\)/,
    ],
    tags: ['slice', '2d', 'matrix', 'multidimensional'],
  },
  {
    id: 'go-slice-to-array-1',
    category: 'Slice Advanced Operations',
    difficulty: 'medium',
    title: 'Convert Slice to Array (Go 1.20+)',
    text: 'Convert the slice to a fixed-size array of 3 elements.',
    setup: 's := []int{10, 20, 30, 40, 50}',
    setupCode: 's := []int{10, 20, 30, 40, 50}',
    expected: [10, 20, 30],
    sample: '[3]int(s)',
    hints: ['Go 1.20+ allows direct conversion', 'Array size must be <= slice length'],
    validPatterns: [/\[\s*3\s*\]\s*int\s*\(\s*s\s*\)/, /\(\*\[\s*3\s*\]\s*int\)\s*\(\s*s\s*\)/],
    tags: ['slice', 'array', 'conversion', 'Go1.20'],
  },
  {
    id: 'go-slice-binary-search-1',
    category: 'Slice Advanced Operations',
    difficulty: 'medium',
    title: 'Binary Search in Sorted Slice',
    text: 'Use `slices.BinarySearch()` to find the index of value 30 in the sorted slice.',
    setup: 'import "slices"\nnumbers := []int{10, 20, 30, 40, 50}',
    setupCode: 'import "slices"\nnumbers := []int{10, 20, 30, 40, 50}',
    expected: 2,
    sample: 'idx, _ := slices.BinarySearch(numbers, 30); idx',
    hints: ['Returns (index, found)', 'Slice must be sorted'],
    validPatterns: [/slices\.BinarySearch\s*\(\s*numbers\s*,\s*30\s*\)/],
    tags: ['slices', 'BinarySearch', 'sorted', 'Go1.21'],
  },
  {
    id: 'go-slice-sortfunc-1',
    category: 'Slice Advanced Operations',
    difficulty: 'medium',
    title: 'Sort with Custom Comparison (slices package)',
    text: 'Use `slices.SortFunc()` to sort strings by length (shortest first).',
    setup: 'import "slices"\nimport "cmp"\nwords := []string{"golang", "is", "awesome"}',
    setupCode: 'import "slices"\nimport "cmp"\nwords := []string{"golang", "is", "awesome"}',
    expected: ['is', 'golang', 'awesome'],
    sample: 'slices.SortFunc(words, func(a, b string) int { return cmp.Compare(len(a), len(b)) })',
    hints: ['SortFunc takes comparison function', 'Return negative/zero/positive like cmp.Compare'],
    validPatterns: [/slices\.SortFunc\s*\(\s*words\s*,\s*func\s*\(/],
    tags: ['slices', 'SortFunc', 'custom', 'Go1.21'],
  },
  {
    id: 'go-slice-equal-1',
    category: 'Slice Advanced Operations',
    difficulty: 'medium',
    title: 'Compare Two Slices for Equality',
    text: 'Use `slices.Equal()` to check if two slices have the same elements.',
    setup: 'import "slices"\na := []int{1, 2, 3}\nb := []int{1, 2, 3}',
    setupCode: 'import "slices"\na := []int{1, 2, 3}\nb := []int{1, 2, 3}',
    expected: true,
    sample: 'slices.Equal(a, b)',
    hints: ['slices.Equal compares length and elements', 'Element-by-element comparison'],
    validPatterns: [/slices\.Equal\s*\(\s*a\s*,\s*b\s*\)/],
    tags: ['slices', 'Equal', 'compare', 'Go1.21'],
  },
  {
    id: 'go-slice-concat-1',
    category: 'Slice Advanced Operations',
    difficulty: 'medium',
    title: 'Concatenate Multiple Slices',
    text: 'Use `slices.Concat()` to combine three slices into one.',
    setup: 'import "slices"\na := []int{1, 2}\nb := []int{3, 4}\nc := []int{5, 6}',
    setupCode: 'import "slices"\na := []int{1, 2}\nb := []int{3, 4}\nc := []int{5, 6}',
    expected: [1, 2, 3, 4, 5, 6],
    sample: 'slices.Concat(a, b, c)',
    hints: ['slices.Concat is variadic', 'Returns new slice with all elements'],
    validPatterns: [/slices\.Concat\s*\(\s*a\s*,\s*b\s*,\s*c\s*\)/],
    tags: ['slices', 'Concat', 'combine', 'Go1.22'],
  },
  {
    id: 'go-slice-clip-1',
    category: 'Slice Advanced Operations',
    difficulty: 'medium',
    title: 'Clip Slice Capacity',
    text: 'Use `slices.Clip()` to reduce the slice capacity to match its length.',
    setup: 'import "slices"\ns := make([]int, 3, 100)\ns[0], s[1], s[2] = 1, 2, 3',
    setupCode: 'import "slices"\ns := make([]int, 3, 100)\ns[0], s[1], s[2] = 1, 2, 3',
    expected: 'cap(s) == len(s)',
    sample: 's = slices.Clip(s); cap(s) == len(s)',
    hints: ['Clip sets capacity equal to length', 'Frees excess capacity memory'],
    validPatterns: [/slices\.Clip\s*\(\s*s\s*\)/],
    tags: ['slices', 'Clip', 'memory', 'Go1.21'],
  },
  {
    id: 'go-slice-replace-1',
    category: 'Slice Advanced Operations',
    difficulty: 'medium',
    title: 'Replace Slice Elements',
    text: 'Use `slices.Replace()` to replace elements at indices 1-3 with 99, 88.',
    setup: 'import "slices"\ns := []int{1, 2, 3, 4, 5}',
    setupCode: 'import "slices"\ns := []int{1, 2, 3, 4, 5}',
    expected: [1, 99, 88, 4, 5],
    sample: 'slices.Replace(s, 1, 3, 99, 88)',
    hints: ['Replace(s, i, j, v...) replaces s[i:j]', 'Can change length of slice'],
    validPatterns: [/slices\.Replace\s*\(\s*s\s*,\s*1\s*,\s*3\s*,\s*99\s*,\s*88\s*\)/],
    tags: ['slices', 'Replace', 'modify', 'Go1.21'],
  },

  // --- HARD (5 problems) ---

  {
    id: 'go-slice-memory-leak-1',
    category: 'Slice Advanced Operations',
    difficulty: 'hard',
    title: 'Avoid Memory Leak with Subslice',
    text: 'Copy the first 2 elements to a new slice to avoid holding reference to large backing array.',
    setup: 'bigSlice := make([]int, 1000000)\nbigSlice[0], bigSlice[1] = 1, 2',
    setupCode: 'bigSlice := make([]int, 1000000)\nbigSlice[0], bigSlice[1] = 1, 2',
    expected: [1, 2],
    sample: 'small := make([]int, 2); copy(small, bigSlice[:2]); small',
    hints: [
      'Subslice shares backing array',
      'Copy to new slice to release memory',
      'Or use slices.Clone',
    ],
    validPatterns: [
      /copy\s*\(\s*\w+\s*,\s*bigSlice\s*\[\s*:\s*2\s*\]\s*\)/,
      /slices\.Clone\s*\(\s*bigSlice\s*\[\s*:\s*2\s*\]\s*\)/,
      /append\s*\(\s*\[\s*\]\s*int\s*\(\s*nil\s*\)\s*,\s*bigSlice\s*\[\s*:\s*2\s*\]\s*\.\.\.\s*\)/,
    ],
    tags: ['slice', 'memory', 'leak', 'copy'],
  },
  {
    id: 'go-slice-delete-preserve-1',
    category: 'Slice Advanced Operations',
    difficulty: 'hard',
    title: 'Delete Without Preserving Order',
    text: 'Delete element at index 2 efficiently by swapping with last element (order not important).',
    setup: 's := []int{1, 2, 3, 4, 5}',
    setupCode: 's := []int{1, 2, 3, 4, 5}',
    expected: [1, 2, 5, 4],
    sample: 's[2] = s[len(s)-1]; s = s[:len(s)-1]',
    hints: ['Swap with last element', 'Truncate slice by 1', 'O(1) instead of O(n)'],
    validPatterns: [
      /s\s*\[\s*2\s*\]\s*=\s*s\s*\[\s*len\s*\(\s*s\s*\)\s*-\s*1\s*\]/,
      /s\s*=\s*s\s*\[\s*:\s*len\s*\(\s*s\s*\)\s*-\s*1\s*\]/,
    ],
    tags: ['slice', 'delete', 'performance', 'swap'],
  },
  {
    id: 'go-slice-stack-1',
    category: 'Slice Advanced Operations',
    difficulty: 'hard',
    title: 'Implement Stack with Slice',
    text: 'Pop the last element from the slice (implement stack pop operation).',
    setup: 'stack := []int{1, 2, 3, 4, 5}',
    setupCode: 'stack := []int{1, 2, 3, 4, 5}',
    expected: [5, [1, 2, 3, 4]],
    sample: 'top := stack[len(stack)-1]; stack = stack[:len(stack)-1]',
    hints: [
      'Get last element first',
      'Then reslice to remove it',
      'Two operations: read then shrink',
    ],
    validPatterns: [
      /\w+\s*:=\s*stack\s*\[\s*len\s*\(\s*stack\s*\)\s*-\s*1\s*\]/,
      /stack\s*=\s*stack\s*\[\s*:\s*len\s*\(\s*stack\s*\)\s*-\s*1\s*\]/,
    ],
    tags: ['slice', 'stack', 'pop', 'data-structure'],
  },
  {
    id: 'go-slice-chunk-1',
    category: 'Slice Advanced Operations',
    difficulty: 'hard',
    title: 'Chunk Slice into Batches',
    text: 'Use `slices.Chunk()` to split the slice into chunks of size 3.',
    setup: 'import "slices"\nnumbers := []int{1, 2, 3, 4, 5, 6, 7, 8}',
    setupCode: 'import "slices"\nnumbers := []int{1, 2, 3, 4, 5, 6, 7, 8}',
    expected: [
      [1, 2, 3],
      [4, 5, 6],
      [7, 8],
    ],
    sample: 'chunks := slices.Collect(slices.Chunk(numbers, 3))',
    hints: [
      'Chunk returns an iterator',
      'Use slices.Collect to get slice of slices',
      'Last chunk may be smaller',
    ],
    validPatterns: [
      /slices\.Chunk\s*\(\s*numbers\s*,\s*3\s*\)/,
      /slices\.Collect\s*\(\s*slices\.Chunk/,
    ],
    tags: ['slices', 'Chunk', 'batch', 'iterator', 'Go1.23'],
  },
  {
    id: 'go-slice-generic-map-1',
    category: 'Slice Advanced Operations',
    difficulty: 'hard',
    title: 'Generic Map Function Pattern',
    text: 'Write a generic map function signature and use it to square all numbers.',
    setup: 'numbers := []int{1, 2, 3, 4, 5}',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5}',
    expected: [1, 4, 9, 16, 25],
    sample:
      'func Map[T, U any](s []T, f func(T) U) []U { r := make([]U, len(s)); for i, v := range s { r[i] = f(v) }; return r }; Map(numbers, func(n int) int { return n * n })',
    hints: [
      'Use type parameters [T, U any]',
      'Accept slice and transform function',
      'Return new slice of transformed elements',
    ],
    validPatterns: [
      /func\s+\w*\s*\[\s*\w+\s*,\s*\w+\s+any\s*\]/,
      /func\s*\(\s*\w+\s+int\s*\)\s*int\s*\{\s*return\s+\w+\s*\*\s*\w+/,
      /make\s*\(\s*\[\s*\]\s*\w+\s*,\s*len\s*\(/,
    ],
    tags: ['slice', 'generic', 'map', 'transform', 'Go1.18'],
  },

  // ============================================================
  // Go Patterns and Idioms
  // ============================================================

  // --- EASY (8 problems) ---

  {
    id: 'go-patterns-slice-filter-1',
    category: 'Go Patterns',
    difficulty: 'easy',
    title: 'Filter Slice with Range',
    text: 'Use a range loop to filter and keep only even numbers in a new slice.',
    setup: 'numbers := []int{1, 2, 3, 4, 5, 6, 7, 8}\nvar result []int',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5, 6, 7, 8}\nvar result []int',
    expected: [2, 4, 6, 8],
    sample: 'for _, n := range numbers { if n%2 == 0 { result = append(result, n) } }',
    hints: ['Use modulo to check for even numbers', 'Append matching elements to result'],
    validPatterns: [
      /for\s*(?:_\s*,)?\s*\w+\s*:=\s*range\s+numbers\s*\{[^}]*%\s*2\s*==\s*0[^}]*append/,
    ],
    tags: ['slice', 'filter', 'range', 'pattern'],
  },
  {
    id: 'go-patterns-slice-transform-1',
    category: 'Go Patterns',
    difficulty: 'easy',
    title: 'Transform Slice Elements In-Place',
    text: 'Double each element in the slice using range with index.',
    setup: 'numbers := []int{1, 2, 3, 4, 5}',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5}',
    expected: [2, 4, 6, 8, 10],
    sample: 'for i := range numbers { numbers[i] *= 2 }',
    hints: ['Use index to modify slice in place', 'Multiply each element by 2'],
    validPatterns: [/for\s+\w+\s*:=\s*range\s+numbers\s*\{[^}]*\*=\s*2/],
    tags: ['slice', 'transform', 'range', 'index'],
  },
  {
    id: 'go-patterns-slice-sum-1',
    category: 'Go Patterns',
    difficulty: 'easy',
    title: 'Sum Slice Elements',
    text: 'Calculate the sum of all elements in the slice using range.',
    setup: 'numbers := []int{1, 2, 3, 4, 5}\nsum := 0',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5}\nsum := 0',
    expected: 15,
    sample: 'for _, n := range numbers { sum += n }',
    hints: ['Use range to iterate', 'Accumulate into sum variable'],
    validPatterns: [/for\s*(?:_\s*,)?\s*\w+\s*:=\s*range\s+numbers\s*\{[^}]*\+=\s*\w+/],
    tags: ['slice', 'sum', 'range', 'accumulate'],
  },
  {
    id: 'go-patterns-map-values-1',
    category: 'Go Patterns',
    difficulty: 'easy',
    title: 'Collect Map Values into Slice',
    text: 'Extract all values from the map into a slice.',
    setup: 'm := map[string]int{"a": 1, "b": 2, "c": 3}\nvar values []int',
    setupCode: 'm := map[string]int{"a": 1, "b": 2, "c": 3}\nvar values []int',
    expected: 'values contains 1, 2, 3',
    sample: 'for _, v := range m { values = append(values, v) }',
    hints: ['Use _ to ignore the key', 'Append each value to the slice'],
    validPatterns: [/for\s*_\s*,\s*\w+\s*:=\s*range\s+m\s*\{[^}]*append\s*\([^)]*\)/],
    tags: ['map', 'values', 'range', 'pattern'],
  },
  {
    id: 'go-patterns-map-keys-collect-1',
    category: 'Go Patterns',
    difficulty: 'easy',
    title: 'Collect Map Keys into Slice',
    text: 'Extract all keys from the map into a slice.',
    setup: 'm := map[string]int{"x": 10, "y": 20, "z": 30}\nvar keys []string',
    setupCode: 'm := map[string]int{"x": 10, "y": 20, "z": 30}\nvar keys []string',
    expected: 'keys contains x, y, z',
    sample: 'for k := range m { keys = append(keys, k) }',
    hints: ['Use single variable in range', 'Append each key to the slice'],
    validPatterns: [/for\s+\w+\s*:=\s*range\s+m\s*\{[^}]*append\s*\([^)]*\)/],
    tags: ['map', 'keys', 'range', 'pattern'],
  },
  {
    id: 'go-patterns-error-check-1',
    category: 'Go Patterns',
    difficulty: 'easy',
    title: 'Basic Error Check Pattern',
    text: 'Write the idiomatic Go error check that returns early on error.',
    setup: 'func process() error {\n    err := doSomething()\n    // Check error here',
    setupCode: 'func process() error {\n    err := doSomething()\n    // Check error here',
    expected: 'if err != nil { return err }',
    sample: 'if err != nil { return err }',
    hints: ['Check if err is not nil', 'Return early with the error'],
    validPatterns: [/if\s+err\s*!=\s*nil\s*\{\s*return\s+err\s*\}/],
    tags: ['error', 'check', 'idiom', 'pattern'],
  },
  {
    id: 'go-patterns-error-sentinel-1',
    category: 'Go Patterns',
    difficulty: 'easy',
    title: 'Define Sentinel Error',
    text: 'Define a package-level sentinel error for "not found" condition.',
    setup: 'import "errors"\n// Define sentinel error here',
    setupCode: 'import "errors"\n// Define sentinel error here',
    expected: 'var ErrNotFound = errors.New("not found")',
    sample: 'var ErrNotFound = errors.New("not found")',
    hints: ['Use var for package-level errors', 'Start name with Err prefix'],
    validPatterns: [/var\s+Err\w+\s*=\s*errors\.New\s*\(/],
    tags: ['error', 'sentinel', 'idiom', 'pattern'],
  },
  {
    id: 'go-patterns-interface-stringer-1',
    category: 'Go Patterns',
    difficulty: 'easy',
    title: 'Implement Stringer Interface',
    text: 'Implement the String() method to make Person satisfy fmt.Stringer.',
    setup: 'type Person struct { Name string; Age int }\n// Implement String() method',
    setupCode: 'type Person struct { Name string; Age int }\n// Implement String() method',
    expected: 'func (p Person) String() string',
    sample: 'func (p Person) String() string { return fmt.Sprintf("%s (%d)", p.Name, p.Age) }',
    hints: ['String() must return string', 'Use value receiver for small structs'],
    validPatterns: [/func\s*\(\s*\w+\s+Person\s*\)\s*String\s*\(\s*\)\s*string/],
    tags: ['interface', 'stringer', 'method', 'pattern'],
  },

  // --- MEDIUM (12 problems) ---

  {
    id: 'go-patterns-method-pointer-1',
    category: 'Go Patterns',
    difficulty: 'medium',
    title: 'Method with Pointer Receiver',
    text: 'Add a method to increment the counter using a pointer receiver.',
    setup: 'type Counter struct { value int }\n// Add Increment method',
    setupCode: 'type Counter struct { value int }\n// Add Increment method',
    expected: 'func (c *Counter) Increment()',
    sample: 'func (c *Counter) Increment() { c.value++ }',
    hints: ['Use pointer receiver to modify struct', '*Counter instead of Counter'],
    validPatterns: [/func\s*\(\s*\w+\s+\*Counter\s*\)\s*Increment\s*\(\s*\)/],
    tags: ['method', 'pointer', 'receiver', 'pattern'],
  },
  {
    id: 'go-patterns-method-chain-1',
    category: 'Go Patterns',
    difficulty: 'medium',
    title: 'Method Chaining Pattern',
    text: 'Implement SetName that returns *Builder for method chaining.',
    setup: 'type Builder struct { name string }\n// Add SetName method that returns *Builder',
    setupCode: 'type Builder struct { name string }\n// Add SetName method that returns *Builder',
    expected: 'func (b *Builder) SetName(name string) *Builder',
    sample: 'func (b *Builder) SetName(name string) *Builder { b.name = name; return b }',
    hints: ['Return pointer to receiver for chaining', 'Allows b.SetName("x").SetAge(20)'],
    validPatterns: [
      /func\s*\(\s*\w+\s+\*Builder\s*\)\s*SetName\s*\(\s*\w+\s+string\s*\)\s*\*Builder/,
    ],
    tags: ['method', 'chain', 'builder', 'pattern'],
  },
  {
    id: 'go-patterns-defer-close-1',
    category: 'Go Patterns',
    difficulty: 'medium',
    title: 'Defer Resource Cleanup',
    text: 'Use defer to ensure the file is closed after opening.',
    setup:
      'import "os"\nf, err := os.Open("file.txt")\nif err != nil { return err }\n// Defer close here',
    setupCode:
      'import "os"\nf, err := os.Open("file.txt")\nif err != nil { return err }\n// Defer close here',
    expected: 'defer f.Close()',
    sample: 'defer f.Close()',
    hints: ['defer executes when function returns', 'Place defer right after error check'],
    validPatterns: [/defer\s+\w+\.Close\s*\(\s*\)/],
    tags: ['defer', 'close', 'resource', 'pattern'],
  },
  {
    id: 'go-patterns-defer-unlock-1',
    category: 'Go Patterns',
    difficulty: 'medium',
    title: 'Defer Mutex Unlock',
    text: 'Lock the mutex and defer its unlock.',
    setup: 'import "sync"\nvar mu sync.Mutex\n// Lock and defer unlock',
    setupCode: 'import "sync"\nvar mu sync.Mutex\n// Lock and defer unlock',
    expected: 'mu.Lock(); defer mu.Unlock()',
    sample: 'mu.Lock()\ndefer mu.Unlock()',
    hints: ['Lock first, then defer unlock', 'Ensures unlock even on panic'],
    validPatterns: [/mu\.Lock\s*\(\s*\)[;\s]*defer\s+mu\.Unlock\s*\(\s*\)/],
    tags: ['defer', 'mutex', 'sync', 'pattern'],
  },
  {
    id: 'go-patterns-defer-recover-1',
    category: 'Go Patterns',
    difficulty: 'medium',
    title: 'Defer with Recover',
    text: 'Use defer with recover to catch panics.',
    setup: 'func safeCall() {\n    // Add defer recover pattern',
    setupCode: 'func safeCall() {\n    // Add defer recover pattern',
    expected: 'defer func() { if r := recover(); r != nil { /* handle */ } }()',
    sample: 'defer func() { if r := recover(); r != nil { fmt.Println("recovered:", r) } }()',
    hints: ['recover() must be in deferred function', 'Returns nil if no panic'],
    validPatterns: [/defer\s+func\s*\(\s*\)\s*\{[^}]*recover\s*\(\s*\)/],
    tags: ['defer', 'recover', 'panic', 'pattern'],
  },
  {
    id: 'go-patterns-range-index-1',
    category: 'Go Patterns',
    difficulty: 'medium',
    title: 'Range with Conditional Index Skip',
    text: 'Iterate slice and build new slice keeping elements at even indices (0, 2, 4...).',
    setup: 'numbers := []int{1, 2, 3, 4, 5, 6}\nvar result []int',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5, 6}\nvar result []int',
    expected: [1, 3, 5],
    sample: 'for i, n := range numbers { if i%2 == 0 { result = append(result, n) } }',
    hints: ['Use index to determine which elements to keep', 'Even indices are 0, 2, 4...'],
    validPatterns: [
      /for\s+\w+\s*,\s*\w+\s*:=\s*range\s+numbers\s*\{[^}]*%\s*2\s*==\s*0[^}]*append/,
    ],
    tags: ['range', 'index', 'filter', 'pattern'],
  },
  {
    id: 'go-patterns-range-reverse-1',
    category: 'Go Patterns',
    difficulty: 'medium',
    title: 'Iterate Slice in Reverse',
    text: 'Iterate the slice in reverse order using index.',
    setup: 'numbers := []int{1, 2, 3, 4, 5}\nvar result []int',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5}\nvar result []int',
    expected: [5, 4, 3, 2, 1],
    sample: 'for i := len(numbers) - 1; i >= 0; i-- { result = append(result, numbers[i]) }',
    hints: ['Start from len-1, go down to 0', 'Classic for loop, not range'],
    validPatterns: [
      /for\s+\w+\s*:=\s*len\s*\(\s*numbers\s*\)\s*-\s*1\s*;\s*\w+\s*>=\s*0\s*;\s*\w+\s*--/,
    ],
    tags: ['range', 'reverse', 'index', 'pattern'],
  },
  {
    id: 'go-patterns-range-enumerate-1',
    category: 'Go Patterns',
    difficulty: 'medium',
    title: 'Enumerate with Custom Start Index',
    text: 'Create enumerated pairs starting from 1 instead of 0.',
    setup:
      'items := []string{"a", "b", "c"}\ntype Enum struct { Index int; Value string }\nvar result []Enum',
    setupCode:
      'items := []string{"a", "b", "c"}\ntype Enum struct { Index int; Value string }\nvar result []Enum',
    expected: [
      { Index: 1, Value: 'a' },
      { Index: 2, Value: 'b' },
      { Index: 3, Value: 'c' },
    ],
    sample: 'for i, v := range items { result = append(result, Enum{i + 1, v}) }',
    hints: ['Add 1 to index in the loop', 'Create struct with adjusted index'],
    validPatterns: [/for\s+\w+\s*,\s*\w+\s*:=\s*range\s+items\s*\{[^}]*\w+\s*\+\s*1/],
    tags: ['range', 'enumerate', 'index', 'pattern'],
  },
  {
    id: 'go-patterns-range-window-1',
    category: 'Go Patterns',
    difficulty: 'medium',
    title: 'Sliding Window with Range',
    text: 'Iterate with a sliding window of size 2 to get consecutive pairs.',
    setup: 'numbers := []int{1, 2, 3, 4, 5}\ntype Pair struct { A, B int }\nvar pairs []Pair',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5}\ntype Pair struct { A, B int }\nvar pairs []Pair',
    expected: [
      { A: 1, B: 2 },
      { A: 2, B: 3 },
      { A: 3, B: 4 },
      { A: 4, B: 5 },
    ],
    sample:
      'for i := 0; i < len(numbers)-1; i++ { pairs = append(pairs, Pair{numbers[i], numbers[i+1]}) }',
    hints: ['Stop at len-1 to avoid out of bounds', 'Access current and next element'],
    validPatterns: [/for\s+\w+\s*:=\s*0\s*;\s*\w+\s*<\s*len\s*\(\s*numbers\s*\)\s*-\s*1/],
    tags: ['range', 'window', 'pairs', 'pattern'],
  },
  {
    id: 'go-patterns-map-groupby-1',
    category: 'Go Patterns',
    difficulty: 'medium',
    title: 'Group By Pattern',
    text: 'Group people by their age into a map of slices.',
    setup:
      'type Person struct { Name string; Age int }\npeople := []Person{{"Alice", 30}, {"Bob", 25}, {"Carol", 30}}\ngrouped := make(map[int][]Person)',
    setupCode:
      'type Person struct { Name string; Age int }\npeople := []Person{{"Alice", 30}, {"Bob", 25}, {"Carol", 30}}\ngrouped := make(map[int][]Person)',
    expected: {
      25: [{ Name: 'Bob', Age: 25 }],
      30: [
        { Name: 'Alice', Age: 30 },
        { Name: 'Carol', Age: 30 },
      ],
    },
    sample: 'for _, p := range people { grouped[p.Age] = append(grouped[p.Age], p) }',
    hints: ['Use the grouping key as map key', 'Append to slice value in map'],
    validPatterns: [
      /for\s*(?:_\s*,)?\s*\w+\s*:=\s*range\s+people\s*\{[^}]*grouped\s*\[\s*\w+\.Age\s*\]\s*=\s*append/,
    ],
    tags: ['map', 'groupby', 'pattern', 'slice'],
  },
  {
    id: 'go-patterns-map-invert-1',
    category: 'Go Patterns',
    difficulty: 'medium',
    title: 'Invert Map Keys and Values',
    text: 'Swap keys and values of the map (assumes unique values).',
    setup: 'm := map[string]int{"a": 1, "b": 2}\ninverted := make(map[int]string)',
    setupCode: 'm := map[string]int{"a": 1, "b": 2}\ninverted := make(map[int]string)',
    expected: { 1: 'a', 2: 'b' },
    sample: 'for k, v := range m { inverted[v] = k }',
    hints: ['Iterate over original map', 'Use value as new key, key as new value'],
    validPatterns: [
      /for\s+\w+\s*,\s*\w+\s*:=\s*range\s+m\s*\{[^}]*inverted\s*\[\s*\w+\s*\]\s*=\s*\w+/,
    ],
    tags: ['map', 'invert', 'range', 'pattern'],
  },
  {
    id: 'go-patterns-interface-typeswitch-1',
    category: 'Go Patterns',
    difficulty: 'medium',
    title: 'Type Switch Pattern',
    text: 'Use type switch to handle different types in an any value.',
    setup: 'var v any = 42\nvar result string',
    setupCode: 'var v any = 42\nvar result string',
    expected: 'int',
    sample:
      'switch v.(type) { case int: result = "int"; case string: result = "string"; default: result = "unknown" }',
    hints: ['Use switch v.(type)', 'Each case handles a specific type'],
    validPatterns: [/switch\s+\w+\.\(type\)\s*\{[^}]*case\s+int:/],
    tags: ['interface', 'type-switch', 'any', 'pattern'],
  },

  // --- HARD (5 problems) ---

  {
    id: 'go-patterns-slice-unique-1',
    category: 'Go Patterns',
    difficulty: 'hard',
    title: 'Remove Duplicates from Slice',
    text: 'Remove duplicate integers using a map to track seen values.',
    setup: 'numbers := []int{1, 2, 2, 3, 3, 3, 4}\nseen := make(map[int]bool)\nvar result []int',
    setupCode:
      'numbers := []int{1, 2, 2, 3, 3, 3, 4}\nseen := make(map[int]bool)\nvar result []int',
    expected: [1, 2, 3, 4],
    sample:
      'for _, n := range numbers { if !seen[n] { seen[n] = true; result = append(result, n) } }',
    hints: ['Use map to track seen elements', 'Only append if not seen before'],
    validPatterns: [
      /for\s*(?:_\s*,)?\s*\w+\s*:=\s*range\s+numbers\s*\{[^}]*seen\s*\[\s*\w+\s*\][^}]*append/,
    ],
    tags: ['slice', 'unique', 'dedupe', 'pattern'],
  },
  {
    id: 'go-patterns-slice-chunk-1',
    category: 'Go Patterns',
    difficulty: 'hard',
    title: 'Chunk Slice into Batches',
    text: 'Split slice into chunks of size 3.',
    setup: 'numbers := []int{1, 2, 3, 4, 5, 6, 7, 8}\nchunkSize := 3\nvar chunks [][]int',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5, 6, 7, 8}\nchunkSize := 3\nvar chunks [][]int',
    expected: [
      [1, 2, 3],
      [4, 5, 6],
      [7, 8],
    ],
    sample:
      'for i := 0; i < len(numbers); i += chunkSize { end := i + chunkSize; if end > len(numbers) { end = len(numbers) }; chunks = append(chunks, numbers[i:end]) }',
    hints: ['Iterate with step size equal to chunk size', 'Handle last chunk that may be smaller'],
    validPatterns: [
      /for\s+\w+\s*:=\s*0\s*;\s*\w+\s*<\s*len\s*\(\s*numbers\s*\)\s*;\s*\w+\s*\+=\s*chunkSize/,
    ],
    tags: ['slice', 'chunk', 'batch', 'pattern'],
  },
  {
    id: 'go-patterns-slice-zip-1',
    category: 'Go Patterns',
    difficulty: 'hard',
    title: 'Zip Two Slices Together',
    text: 'Combine two slices into pairs (stop at shorter slice length).',
    setup:
      'a := []string{"x", "y", "z"}\nb := []int{1, 2, 3}\ntype Pair struct { S string; N int }\nvar result []Pair',
    setupCode:
      'a := []string{"x", "y", "z"}\nb := []int{1, 2, 3}\ntype Pair struct { S string; N int }\nvar result []Pair',
    expected: [
      { S: 'x', N: 1 },
      { S: 'y', N: 2 },
      { S: 'z', N: 3 },
    ],
    sample:
      'n := len(a); if len(b) < n { n = len(b) }; for i := 0; i < n; i++ { result = append(result, Pair{a[i], b[i]}) }',
    hints: ['Find minimum length of both slices', 'Iterate using index to access both slices'],
    validPatterns: [/for\s+\w+\s*:=\s*0\s*;\s*\w+\s*<\s*\w+\s*;\s*\w+\+\+\s*\{[^}]*Pair\s*\{/],
    tags: ['slice', 'zip', 'combine', 'pattern'],
  },
  {
    id: 'go-patterns-error-custom-1',
    category: 'Go Patterns',
    difficulty: 'hard',
    title: 'Custom Error Type with Context',
    text: 'Define a custom error type that includes operation name and underlying error.',
    setup:
      '// Define OpError struct with Op string and Err error fields\n// Implement Error() and Unwrap() methods',
    setupCode:
      '// Define OpError struct with Op string and Err error fields\n// Implement Error() and Unwrap() methods',
    expected:
      'type OpError struct { Op string; Err error }; func (e *OpError) Error() string; func (e *OpError) Unwrap() error',
    sample:
      'type OpError struct { Op string; Err error }\nfunc (e *OpError) Error() string { return e.Op + ": " + e.Err.Error() }\nfunc (e *OpError) Unwrap() error { return e.Err }',
    hints: ['Implement Error() for error interface', 'Implement Unwrap() for error chaining'],
    validPatterns: [
      /type\s+OpError\s+struct\s*\{[^}]*Op\s+string[^}]*Err\s+error/,
      /func\s*\(\s*\w+\s+\*?OpError\s*\)\s*Error\s*\(\s*\)\s*string/,
    ],
    tags: ['error', 'custom', 'unwrap', 'pattern'],
  },
  {
    id: 'go-patterns-error-multi-1',
    category: 'Go Patterns',
    difficulty: 'hard',
    title: 'Join Multiple Errors',
    text: 'Use errors.Join to combine multiple errors into one (Go 1.20+).',
    setup:
      'import "errors"\nerr1 := errors.New("error 1")\nerr2 := errors.New("error 2")\nerr3 := errors.New("error 3")',
    setupCode:
      'import "errors"\nerr1 := errors.New("error 1")\nerr2 := errors.New("error 2")\nerr3 := errors.New("error 3")',
    expected: 'combined error with all three',
    sample: 'errors.Join(err1, err2, err3)',
    hints: ['errors.Join combines multiple errors', 'Result works with errors.Is for any of them'],
    validPatterns: [/errors\.Join\s*\(\s*err1\s*,\s*err2\s*,\s*err3\s*\)/],
    tags: ['error', 'join', 'multiple', 'Go1.20'],
  },

  // ============================================================
  // NEW PROBLEMS - Batch 1: Time Package
  // ============================================================

  {
    id: 'go-time-200',
    category: 'Time Package',
    difficulty: 'easy',
    title: 'Get Current Time',
    text: 'Use `time.Now()` to get the current time.',
    setup: 'import "time"',
    setupCode: 'import "time"',
    expected: 'time.Time value',
    sample: 'time.Now()',
    hints: ['time.Now() returns current local time', 'Returns a time.Time value'],
    tags: ['time', 'Now', 'current'],
  },
  {
    id: 'go-time-201',
    category: 'Time Package',
    difficulty: 'easy',
    title: 'Create Specific Time',
    text: 'Use `time.Date()` to create a time for January 15, 2024, 10:30:00 UTC.',
    setup: 'import "time"',
    setupCode: 'import "time"',
    expected: '2024-01-15 10:30:00 +0000 UTC',
    sample: 'time.Date(2024, time.January, 15, 10, 30, 0, 0, time.UTC)',
    hints: [
      'time.Date(year, month, day, hour, min, sec, nsec, loc)',
      'Use time.UTC for UTC timezone',
    ],
    tags: ['time', 'Date', 'create'],
  },
  {
    id: 'go-time-202',
    category: 'Time Package',
    difficulty: 'easy',
    title: 'Get Year from Time',
    text: 'Extract the year from the given time.',
    setup: 'import "time"\nt := time.Date(2024, time.March, 15, 0, 0, 0, 0, time.UTC)',
    setupCode: 'import "time"\nt := time.Date(2024, time.March, 15, 0, 0, 0, 0, time.UTC)',
    expected: 2024,
    sample: 't.Year()',
    hints: ['Use the Year() method', 'Returns an int'],
    tags: ['time', 'Year', 'extract'],
  },
  {
    id: 'go-time-203',
    category: 'Time Package',
    difficulty: 'easy',
    title: 'Get Month from Time',
    text: 'Extract the month from the given time.',
    setup: 'import "time"\nt := time.Date(2024, time.March, 15, 0, 0, 0, 0, time.UTC)',
    setupCode: 'import "time"\nt := time.Date(2024, time.March, 15, 0, 0, 0, 0, time.UTC)',
    expected: 3,
    sample: 'int(t.Month())',
    hints: ['Use the Month() method', 'Returns time.Month, convert to int'],
    tags: ['time', 'Month', 'extract'],
  },
  {
    id: 'go-time-204',
    category: 'Time Package',
    difficulty: 'easy',
    title: 'Get Day from Time',
    text: 'Extract the day of month from the given time.',
    setup: 'import "time"\nt := time.Date(2024, time.March, 15, 0, 0, 0, 0, time.UTC)',
    setupCode: 'import "time"\nt := time.Date(2024, time.March, 15, 0, 0, 0, 0, time.UTC)',
    expected: 15,
    sample: 't.Day()',
    hints: ['Use the Day() method', 'Returns an int from 1 to 31'],
    tags: ['time', 'Day', 'extract'],
  },
  {
    id: 'go-time-205',
    category: 'Time Package',
    difficulty: 'easy',
    title: 'Get Weekday',
    text: 'Get the day of the week from the given time.',
    setup: 'import "time"\nt := time.Date(2024, time.January, 1, 0, 0, 0, 0, time.UTC)',
    setupCode: 'import "time"\nt := time.Date(2024, time.January, 1, 0, 0, 0, 0, time.UTC)',
    expected: 'Monday',
    sample: 't.Weekday().String()',
    hints: ['Use Weekday() method', 'Returns time.Weekday type'],
    tags: ['time', 'Weekday', 'extract'],
  },
  {
    id: 'go-time-206',
    category: 'Time Package',
    difficulty: 'easy',
    title: 'Create Duration in Seconds',
    text: 'Create a duration of 30 seconds.',
    setup: 'import "time"',
    setupCode: 'import "time"',
    expected: '30s',
    sample: '30 * time.Second',
    hints: ['Multiply number by time.Second', 'time.Second is a duration constant'],
    tags: ['time', 'Duration', 'Second'],
  },
  {
    id: 'go-time-207',
    category: 'Time Package',
    difficulty: 'easy',
    title: 'Create Duration in Minutes',
    text: 'Create a duration of 5 minutes.',
    setup: 'import "time"',
    setupCode: 'import "time"',
    expected: '5m0s',
    sample: '5 * time.Minute',
    hints: ['Multiply number by time.Minute', 'time.Minute equals 60 * time.Second'],
    tags: ['time', 'Duration', 'Minute'],
  },
  {
    id: 'go-time-208',
    category: 'Time Package',
    difficulty: 'medium',
    title: 'Add Duration to Time',
    text: 'Add 2 hours to the given time.',
    setup: 'import "time"\nt := time.Date(2024, time.January, 1, 10, 0, 0, 0, time.UTC)',
    setupCode: 'import "time"\nt := time.Date(2024, time.January, 1, 10, 0, 0, 0, time.UTC)',
    expected: '2024-01-01 12:00:00',
    sample: 't.Add(2 * time.Hour)',
    hints: ['Use Add() method with duration', 'Returns a new time.Time'],
    tags: ['time', 'Add', 'Duration'],
  },
  {
    id: 'go-time-209',
    category: 'Time Package',
    difficulty: 'medium',
    title: 'Subtract Duration from Time',
    text: 'Subtract 30 minutes from the given time.',
    setup: 'import "time"\nt := time.Date(2024, time.January, 1, 10, 0, 0, 0, time.UTC)',
    setupCode: 'import "time"\nt := time.Date(2024, time.January, 1, 10, 0, 0, 0, time.UTC)',
    expected: '2024-01-01 09:30:00',
    sample: 't.Add(-30 * time.Minute)',
    hints: ['Use negative duration with Add()', 'Or use Add with negated duration'],
    tags: ['time', 'Add', 'subtract'],
  },
  {
    id: 'go-time-210',
    category: 'Time Package',
    difficulty: 'medium',
    title: 'Calculate Duration Between Times',
    text: 'Calculate the duration between two times using Sub().',
    setup:
      'import "time"\nt1 := time.Date(2024, 1, 1, 10, 0, 0, 0, time.UTC)\nt2 := time.Date(2024, 1, 1, 12, 30, 0, 0, time.UTC)',
    setupCode:
      'import "time"\nt1 := time.Date(2024, 1, 1, 10, 0, 0, 0, time.UTC)\nt2 := time.Date(2024, 1, 1, 12, 30, 0, 0, time.UTC)',
    expected: '2h30m0s',
    sample: 't2.Sub(t1)',
    hints: ['Use Sub() method', 't2.Sub(t1) gives duration from t1 to t2'],
    tags: ['time', 'Sub', 'Duration'],
  },
  {
    id: 'go-time-211',
    category: 'Time Package',
    difficulty: 'medium',
    title: 'Format Time with Layout',
    text: 'Format the time as "2006-01-02 15:04:05".',
    setup: 'import "time"\nt := time.Date(2024, time.March, 15, 14, 30, 45, 0, time.UTC)',
    setupCode: 'import "time"\nt := time.Date(2024, time.March, 15, 14, 30, 45, 0, time.UTC)',
    expected: '2024-03-15 14:30:45',
    sample: 't.Format("2006-01-02 15:04:05")',
    hints: ['Use reference time Mon Jan 2 15:04:05 MST 2006', 'Format() returns formatted string'],
    tags: ['time', 'Format', 'layout'],
  },
  {
    id: 'go-time-212',
    category: 'Time Package',
    difficulty: 'medium',
    title: 'Parse Time from String',
    text: 'Parse the string "2024-03-15" into a time.Time.',
    setup: 'import "time"\ns := "2024-03-15"',
    setupCode: 'import "time"\ns := "2024-03-15"',
    expected: '2024-03-15 00:00:00 +0000 UTC',
    sample: 't, err := time.Parse("2006-01-02", s)',
    hints: ['Use time.Parse(layout, value)', 'Layout must match the format of input'],
    tags: ['time', 'Parse', 'string'],
  },
  {
    id: 'go-time-213',
    category: 'Time Package',
    difficulty: 'medium',
    title: 'Check if Time is Before',
    text: 'Check if t1 is before t2.',
    setup:
      'import "time"\nt1 := time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)\nt2 := time.Date(2024, 12, 31, 0, 0, 0, 0, time.UTC)',
    setupCode:
      'import "time"\nt1 := time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)\nt2 := time.Date(2024, 12, 31, 0, 0, 0, 0, time.UTC)',
    expected: true,
    sample: 't1.Before(t2)',
    hints: ['Use Before() method', 'Returns bool'],
    tags: ['time', 'Before', 'compare'],
  },
  {
    id: 'go-time-214',
    category: 'Time Package',
    difficulty: 'medium',
    title: 'Check if Time is After',
    text: 'Check if t2 is after t1.',
    setup:
      'import "time"\nt1 := time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)\nt2 := time.Date(2024, 12, 31, 0, 0, 0, 0, time.UTC)',
    setupCode:
      'import "time"\nt1 := time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)\nt2 := time.Date(2024, 12, 31, 0, 0, 0, 0, time.UTC)',
    expected: true,
    sample: 't2.After(t1)',
    hints: ['Use After() method', 'Returns bool'],
    tags: ['time', 'After', 'compare'],
  },
  {
    id: 'go-time-215',
    category: 'Time Package',
    difficulty: 'medium',
    title: 'Get Unix Timestamp',
    text: 'Get the Unix timestamp (seconds since epoch) from the time.',
    setup: 'import "time"\nt := time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)',
    setupCode: 'import "time"\nt := time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)',
    expected: 1704067200,
    sample: 't.Unix()',
    hints: ['Use Unix() method', 'Returns int64 seconds since Jan 1, 1970 UTC'],
    tags: ['time', 'Unix', 'timestamp'],
  },
  {
    id: 'go-time-216',
    category: 'Time Package',
    difficulty: 'medium',
    title: 'Create Time from Unix Timestamp',
    text: 'Create a time from Unix timestamp 1704067200.',
    setup: 'import "time"\ntimestamp := int64(1704067200)',
    setupCode: 'import "time"\ntimestamp := int64(1704067200)',
    expected: '2024-01-01 00:00:00 +0000 UTC',
    sample: 'time.Unix(timestamp, 0)',
    hints: ['Use time.Unix(sec, nsec)', 'Second parameter is nanoseconds'],
    tags: ['time', 'Unix', 'create'],
  },
  {
    id: 'go-time-217',
    category: 'Time Package',
    difficulty: 'hard',
    title: 'Sleep for Duration',
    text: 'Pause execution for 100 milliseconds.',
    setup: 'import "time"',
    setupCode: 'import "time"',
    expected: 'pauses for 100ms',
    sample: 'time.Sleep(100 * time.Millisecond)',
    hints: ['Use time.Sleep(duration)', 'Blocks the current goroutine'],
    tags: ['time', 'Sleep', 'pause'],
  },
  {
    id: 'go-time-218',
    category: 'Time Package',
    difficulty: 'hard',
    title: 'Create Timer',
    text: 'Create a timer that fires after 1 second.',
    setup: 'import "time"',
    setupCode: 'import "time"',
    expected: 'timer that fires after 1s',
    sample: 'timer := time.NewTimer(1 * time.Second)',
    hints: ['Use time.NewTimer(duration)', 'Read from timer.C to wait'],
    tags: ['time', 'Timer', 'NewTimer'],
  },
  {
    id: 'go-time-219',
    category: 'Time Package',
    difficulty: 'hard',
    title: 'Create Ticker',
    text: 'Create a ticker that ticks every 500 milliseconds.',
    setup: 'import "time"',
    setupCode: 'import "time"',
    expected: 'ticker that ticks every 500ms',
    sample: 'ticker := time.NewTicker(500 * time.Millisecond)',
    hints: ['Use time.NewTicker(duration)', 'Remember to call ticker.Stop() when done'],
    tags: ['time', 'Ticker', 'NewTicker'],
  },
  {
    id: 'go-time-220',
    category: 'Time Package',
    difficulty: 'hard',
    title: 'Use time.After',
    text: 'Create a channel that receives after 2 seconds using time.After.',
    setup: 'import "time"',
    setupCode: 'import "time"',
    expected: 'channel receiving after 2s',
    sample: '<-time.After(2 * time.Second)',
    hints: ['time.After returns a channel', 'Useful in select statements'],
    tags: ['time', 'After', 'channel'],
  },
  {
    id: 'go-time-221',
    category: 'Time Package',
    difficulty: 'hard',
    title: 'Format Time as RFC3339',
    text: 'Format the time using RFC3339 format.',
    setup: 'import "time"\nt := time.Date(2024, time.March, 15, 14, 30, 0, 0, time.UTC)',
    setupCode: 'import "time"\nt := time.Date(2024, time.March, 15, 14, 30, 0, 0, time.UTC)',
    expected: '2024-03-15T14:30:00Z',
    sample: 't.Format(time.RFC3339)',
    hints: ['Use predefined layout time.RFC3339', 'Standard format for APIs'],
    tags: ['time', 'Format', 'RFC3339'],
  },
  {
    id: 'go-time-222',
    category: 'Time Package',
    difficulty: 'hard',
    title: 'Truncate Time to Day',
    text: 'Truncate the time to the start of the day (midnight).',
    setup: 'import "time"\nt := time.Date(2024, time.March, 15, 14, 30, 45, 0, time.UTC)',
    setupCode: 'import "time"\nt := time.Date(2024, time.March, 15, 14, 30, 45, 0, time.UTC)',
    expected: '2024-03-15 00:00:00',
    sample: 't.Truncate(24 * time.Hour)',
    hints: ['Use Truncate() method', 'Truncate to 24 hours rounds to midnight'],
    tags: ['time', 'Truncate', 'day'],
  },
  {
    id: 'go-time-223',
    category: 'Time Package',
    difficulty: 'hard',
    title: 'Get Time in Different Timezone',
    text: 'Convert the time to New York timezone.',
    setup: 'import "time"\nt := time.Date(2024, time.March, 15, 14, 0, 0, 0, time.UTC)',
    setupCode: 'import "time"\nt := time.Date(2024, time.March, 15, 14, 0, 0, 0, time.UTC)',
    expected: '2024-03-15 10:00:00 -0400 EDT',
    sample: 'loc, _ := time.LoadLocation("America/New_York"); t.In(loc)',
    hints: ['Use time.LoadLocation() to get timezone', 'Use In() method to convert'],
    tags: ['time', 'timezone', 'Location'],
  },
  {
    id: 'go-time-224',
    category: 'Time Package',
    difficulty: 'hard',
    title: 'Calculate Days Between Dates',
    text: 'Calculate the number of days between two dates.',
    setup:
      'import "time"\nt1 := time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)\nt2 := time.Date(2024, 1, 15, 0, 0, 0, 0, time.UTC)',
    setupCode:
      'import "time"\nt1 := time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)\nt2 := time.Date(2024, 1, 15, 0, 0, 0, 0, time.UTC)',
    expected: 14,
    sample: 'int(t2.Sub(t1).Hours() / 24)',
    hints: ['Get duration, convert to hours, divide by 24', 'Or use duration.Hours()/24'],
    tags: ['time', 'days', 'difference'],
  },

  // ============================================================
  // NEW PROBLEMS - Batch 2: Context Package
  // ============================================================

  {
    id: 'go-ctx-225',
    category: 'Context Package',
    difficulty: 'easy',
    title: 'Create Background Context',
    text: 'Create a background context using context.Background().',
    setup: 'import "context"',
    setupCode: 'import "context"',
    expected: 'context.Background',
    sample: 'ctx := context.Background()',
    hints: ['context.Background() is the root context', 'Used when no parent context exists'],
    tags: ['context', 'Background', 'create'],
  },
  {
    id: 'go-ctx-226',
    category: 'Context Package',
    difficulty: 'easy',
    title: 'Create TODO Context',
    text: 'Create a TODO context for placeholder purposes.',
    setup: 'import "context"',
    setupCode: 'import "context"',
    expected: 'context.TODO',
    sample: 'ctx := context.TODO()',
    hints: ['Use when unsure which context to use', 'Placeholder during development'],
    tags: ['context', 'TODO', 'create'],
  },
  {
    id: 'go-ctx-227',
    category: 'Context Package',
    difficulty: 'medium',
    title: 'Create Context with Cancel',
    text: 'Create a cancellable context from background context.',
    setup: 'import "context"',
    setupCode: 'import "context"',
    expected: 'cancellable context',
    sample: 'ctx, cancel := context.WithCancel(context.Background())',
    hints: ['WithCancel returns context and cancel function', 'Call cancel() to cancel'],
    tags: ['context', 'WithCancel', 'cancel'],
  },
  {
    id: 'go-ctx-228',
    category: 'Context Package',
    difficulty: 'medium',
    title: 'Create Context with Timeout',
    text: 'Create a context that times out after 5 seconds.',
    setup: 'import "context"\nimport "time"',
    setupCode: 'import "context"\nimport "time"',
    expected: 'context with 5s timeout',
    sample: 'ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)',
    hints: ['WithTimeout sets automatic cancellation', 'Always defer cancel()'],
    tags: ['context', 'WithTimeout', 'timeout'],
  },
  {
    id: 'go-ctx-229',
    category: 'Context Package',
    difficulty: 'medium',
    title: 'Create Context with Deadline',
    text: 'Create a context with a deadline at a specific time.',
    setup: 'import "context"\nimport "time"\ndeadline := time.Now().Add(10 * time.Second)',
    setupCode: 'import "context"\nimport "time"\ndeadline := time.Now().Add(10 * time.Second)',
    expected: 'context with deadline',
    sample: 'ctx, cancel := context.WithDeadline(context.Background(), deadline)',
    hints: ['WithDeadline uses absolute time', 'Context cancelled at deadline'],
    tags: ['context', 'WithDeadline', 'deadline'],
  },
  {
    id: 'go-ctx-230',
    category: 'Context Package',
    difficulty: 'medium',
    title: 'Add Value to Context',
    text: 'Create a context with a key-value pair for user ID.',
    setup: 'import "context"\ntype ctxKey string\nconst userIDKey ctxKey = "userID"',
    setupCode: 'import "context"\ntype ctxKey string\nconst userIDKey ctxKey = "userID"',
    expected: 'context with value',
    sample: 'ctx := context.WithValue(context.Background(), userIDKey, "user123")',
    hints: ['WithValue adds a value to context', 'Use custom type for keys to avoid collisions'],
    tags: ['context', 'WithValue', 'value'],
  },
  {
    id: 'go-ctx-231',
    category: 'Context Package',
    difficulty: 'medium',
    title: 'Retrieve Value from Context',
    text: 'Get the user ID value from the context.',
    setup:
      'import "context"\ntype ctxKey string\nconst userIDKey ctxKey = "userID"\nctx := context.WithValue(context.Background(), userIDKey, "user123")',
    setupCode:
      'import "context"\ntype ctxKey string\nconst userIDKey ctxKey = "userID"\nctx := context.WithValue(context.Background(), userIDKey, "user123")',
    expected: 'user123',
    sample: 'ctx.Value(userIDKey).(string)',
    hints: ['Use Value() method with key', 'Type assert the result'],
    tags: ['context', 'Value', 'retrieve'],
  },
  {
    id: 'go-ctx-232',
    category: 'Context Package',
    difficulty: 'hard',
    title: 'Check if Context is Done',
    text: 'Check if the context has been cancelled using the Done channel.',
    setup: 'import "context"\nctx, cancel := context.WithCancel(context.Background())\ncancel()',
    setupCode:
      'import "context"\nctx, cancel := context.WithCancel(context.Background())\ncancel()',
    expected: 'context is done',
    sample: 'select { case <-ctx.Done(): return "cancelled" default: return "running" }',
    hints: ['ctx.Done() returns a channel', 'Channel closes when context is cancelled'],
    tags: ['context', 'Done', 'cancel'],
  },
  {
    id: 'go-ctx-233',
    category: 'Context Package',
    difficulty: 'hard',
    title: 'Get Context Error',
    text: 'Get the error from a cancelled context.',
    setup: 'import "context"\nctx, cancel := context.WithCancel(context.Background())\ncancel()',
    setupCode:
      'import "context"\nctx, cancel := context.WithCancel(context.Background())\ncancel()',
    expected: 'context canceled',
    sample: 'ctx.Err().Error()',
    hints: ['Err() returns the cancellation reason', 'Returns nil if not cancelled'],
    tags: ['context', 'Err', 'error'],
  },
  {
    id: 'go-ctx-234',
    category: 'Context Package',
    difficulty: 'hard',
    title: 'Context with Timeout Error',
    text: 'Check error type for deadline exceeded.',
    setup:
      'import "context"\nimport "time"\nctx, _ := context.WithTimeout(context.Background(), 1*time.Nanosecond)\ntime.Sleep(1*time.Millisecond)',
    setupCode:
      'import "context"\nimport "time"\nctx, _ := context.WithTimeout(context.Background(), 1*time.Nanosecond)\ntime.Sleep(1*time.Millisecond)',
    expected: true,
    sample: 'ctx.Err() == context.DeadlineExceeded',
    hints: ['context.DeadlineExceeded for timeout', 'context.Canceled for manual cancel'],
    tags: ['context', 'DeadlineExceeded', 'timeout'],
  },

  // ============================================================
  // NEW PROBLEMS - Batch 3: Sync Package
  // ============================================================

  {
    id: 'go-sync-235',
    category: 'Sync Package',
    difficulty: 'easy',
    title: 'Create Mutex',
    text: 'Declare a sync.Mutex for protecting shared data.',
    setup: 'import "sync"',
    setupCode: 'import "sync"',
    expected: 'sync.Mutex{}',
    sample: 'var mu sync.Mutex',
    hints: ['Zero value is ready to use', 'No initialization needed'],
    tags: ['sync', 'Mutex', 'create'],
  },
  {
    id: 'go-sync-236',
    category: 'Sync Package',
    difficulty: 'easy',
    title: 'Lock and Unlock Mutex',
    text: 'Lock the mutex, do work, then unlock.',
    setup: 'import "sync"\nvar mu sync.Mutex\nvar counter int',
    setupCode: 'import "sync"\nvar mu sync.Mutex\nvar counter int',
    expected: 'protected increment',
    sample: 'mu.Lock(); counter++; mu.Unlock()',
    hints: ['Lock before accessing shared data', 'Always unlock after'],
    tags: ['sync', 'Mutex', 'Lock', 'Unlock'],
  },
  {
    id: 'go-sync-237',
    category: 'Sync Package',
    difficulty: 'medium',
    title: 'Defer Mutex Unlock',
    text: 'Use defer to ensure mutex is always unlocked.',
    setup: 'import "sync"\nvar mu sync.Mutex',
    setupCode: 'import "sync"\nvar mu sync.Mutex',
    expected: 'safe unlock pattern',
    sample: 'mu.Lock(); defer mu.Unlock()',
    hints: ['defer ensures unlock on any return path', 'Common pattern for mutex'],
    tags: ['sync', 'Mutex', 'defer'],
  },
  {
    id: 'go-sync-238',
    category: 'Sync Package',
    difficulty: 'medium',
    title: 'Create RWMutex',
    text: 'Create a RWMutex for read-heavy workloads.',
    setup: 'import "sync"',
    setupCode: 'import "sync"',
    expected: 'sync.RWMutex{}',
    sample: 'var rwmu sync.RWMutex',
    hints: ['RWMutex allows multiple readers', 'Single writer at a time'],
    tags: ['sync', 'RWMutex', 'create'],
  },
  {
    id: 'go-sync-239',
    category: 'Sync Package',
    difficulty: 'medium',
    title: 'RWMutex Read Lock',
    text: 'Acquire a read lock on the RWMutex.',
    setup: 'import "sync"\nvar rwmu sync.RWMutex\nvar data = "shared"',
    setupCode: 'import "sync"\nvar rwmu sync.RWMutex\nvar data = "shared"',
    expected: 'read lock acquired',
    sample: 'rwmu.RLock(); defer rwmu.RUnlock(); return data',
    hints: ['RLock for read access', 'RUnlock to release read lock'],
    tags: ['sync', 'RWMutex', 'RLock'],
  },
  {
    id: 'go-sync-240',
    category: 'Sync Package',
    difficulty: 'easy',
    title: 'Create WaitGroup',
    text: 'Create a WaitGroup to wait for goroutines.',
    setup: 'import "sync"',
    setupCode: 'import "sync"',
    expected: 'sync.WaitGroup{}',
    sample: 'var wg sync.WaitGroup',
    hints: ['WaitGroup waits for goroutines to finish', 'Zero value is ready to use'],
    tags: ['sync', 'WaitGroup', 'create'],
  },
  {
    id: 'go-sync-241',
    category: 'Sync Package',
    difficulty: 'medium',
    title: 'WaitGroup Add and Done',
    text: 'Add 1 to WaitGroup before goroutine, call Done when finished.',
    setup: 'import "sync"\nvar wg sync.WaitGroup',
    setupCode: 'import "sync"\nvar wg sync.WaitGroup',
    expected: 'wg.Add(1); go func() { defer wg.Done(); /* work */ }()',
    sample: 'wg.Add(1); go func() { defer wg.Done(); doWork() }()',
    hints: ['Add before starting goroutine', 'Done decrements counter'],
    tags: ['sync', 'WaitGroup', 'Add', 'Done'],
  },
  {
    id: 'go-sync-242',
    category: 'Sync Package',
    difficulty: 'medium',
    title: 'WaitGroup Wait',
    text: 'Wait for all goroutines in WaitGroup to complete.',
    setup: 'import "sync"\nvar wg sync.WaitGroup\nwg.Add(3)',
    setupCode: 'import "sync"\nvar wg sync.WaitGroup\nwg.Add(3)',
    expected: 'blocks until counter is 0',
    sample: 'wg.Wait()',
    hints: ['Wait blocks until counter reaches 0', 'Call after starting all goroutines'],
    tags: ['sync', 'WaitGroup', 'Wait'],
  },
  {
    id: 'go-sync-243',
    category: 'Sync Package',
    difficulty: 'medium',
    title: 'Create Once',
    text: 'Create a sync.Once for one-time initialization.',
    setup: 'import "sync"',
    setupCode: 'import "sync"',
    expected: 'sync.Once{}',
    sample: 'var once sync.Once',
    hints: ['Once ensures function runs exactly once', 'Thread-safe initialization'],
    tags: ['sync', 'Once', 'create'],
  },
  {
    id: 'go-sync-244',
    category: 'Sync Package',
    difficulty: 'hard',
    title: 'Use sync.Once for Singleton',
    text: 'Use sync.Once to initialize a singleton exactly once.',
    setup:
      'import "sync"\nvar once sync.Once\nvar instance *Config\ntype Config struct { Value string }',
    setupCode:
      'import "sync"\nvar once sync.Once\nvar instance *Config\ntype Config struct { Value string }',
    expected: 'singleton pattern',
    sample: 'once.Do(func() { instance = &Config{Value: "initialized"} })',
    hints: ['Do() runs function only once', 'Safe for concurrent calls'],
    tags: ['sync', 'Once', 'singleton'],
  },
  {
    id: 'go-sync-245',
    category: 'Sync Package',
    difficulty: 'hard',
    title: 'Create sync.Pool',
    text: 'Create a sync.Pool with a New function for byte slices.',
    setup: 'import "sync"',
    setupCode: 'import "sync"',
    expected: 'pool with New func',
    sample: 'pool := &sync.Pool{New: func() any { return make([]byte, 1024) }}',
    hints: ['Pool reuses objects to reduce allocations', 'New creates object when pool is empty'],
    tags: ['sync', 'Pool', 'New'],
  },
  {
    id: 'go-sync-246',
    category: 'Sync Package',
    difficulty: 'hard',
    title: 'Get and Put with sync.Pool',
    text: 'Get an object from pool, use it, then put it back.',
    setup: 'import "sync"\npool := &sync.Pool{New: func() any { return make([]byte, 1024) }}',
    setupCode: 'import "sync"\npool := &sync.Pool{New: func() any { return make([]byte, 1024) }}',
    expected: 'reused buffer',
    sample: 'buf := pool.Get().([]byte); /* use buf */; pool.Put(buf)',
    hints: ['Get retrieves or creates object', 'Put returns object to pool'],
    tags: ['sync', 'Pool', 'Get', 'Put'],
  },
  {
    id: 'go-sync-247',
    category: 'Sync Package',
    difficulty: 'hard',
    title: 'Create sync.Map',
    text: 'Create a sync.Map for concurrent map access.',
    setup: 'import "sync"',
    setupCode: 'import "sync"',
    expected: 'sync.Map{}',
    sample: 'var m sync.Map',
    hints: ['sync.Map is concurrent-safe', 'Use for high contention scenarios'],
    tags: ['sync', 'Map', 'concurrent'],
  },
  {
    id: 'go-sync-248',
    category: 'Sync Package',
    difficulty: 'hard',
    title: 'sync.Map Store and Load',
    text: 'Store and load a value from sync.Map.',
    setup: 'import "sync"\nvar m sync.Map',
    setupCode: 'import "sync"\nvar m sync.Map',
    expected: 'stored and loaded value',
    sample: 'm.Store("key", "value"); v, ok := m.Load("key")',
    hints: ['Store adds key-value pair', 'Load retrieves value'],
    tags: ['sync', 'Map', 'Store', 'Load'],
  },
  {
    id: 'go-sync-249',
    category: 'Sync Package',
    difficulty: 'hard',
    title: 'sync.Map Delete',
    text: 'Delete a key from sync.Map.',
    setup: 'import "sync"\nvar m sync.Map\nm.Store("key", "value")',
    setupCode: 'import "sync"\nvar m sync.Map\nm.Store("key", "value")',
    expected: 'key deleted',
    sample: 'm.Delete("key")',
    hints: ['Delete removes key-value pair', 'No-op if key does not exist'],
    tags: ['sync', 'Map', 'Delete'],
  },

  // ============================================================
  // NEW PROBLEMS - Batch 4: Channels
  // ============================================================

  {
    id: 'go-chan-250',
    category: 'Channels',
    difficulty: 'easy',
    title: 'Create Unbuffered Channel',
    text: 'Create an unbuffered channel of integers.',
    setup: '// Create channel',
    setupCode: '// Create channel',
    expected: 'chan int',
    sample: 'ch := make(chan int)',
    hints: ['make(chan Type) creates unbuffered channel', 'Synchronous send/receive'],
    tags: ['channel', 'unbuffered', 'make'],
  },
  {
    id: 'go-chan-251',
    category: 'Channels',
    difficulty: 'easy',
    title: 'Create Buffered Channel',
    text: 'Create a buffered channel of strings with capacity 10.',
    setup: '// Create buffered channel',
    setupCode: '// Create buffered channel',
    expected: 'chan string with cap 10',
    sample: 'ch := make(chan string, 10)',
    hints: [
      'make(chan Type, size) creates buffered channel',
      'Can hold size values without blocking',
    ],
    tags: ['channel', 'buffered', 'make'],
  },
  {
    id: 'go-chan-252',
    category: 'Channels',
    difficulty: 'easy',
    title: 'Send Value to Channel',
    text: 'Send the value 42 to the channel.',
    setup: 'ch := make(chan int, 1)',
    setupCode: 'ch := make(chan int, 1)',
    expected: '42 sent to channel',
    sample: 'ch <- 42',
    hints: ['Use <- operator to send', 'Blocks if channel is full (unbuffered or full buffer)'],
    tags: ['channel', 'send', 'operator'],
  },
  {
    id: 'go-chan-253',
    category: 'Channels',
    difficulty: 'easy',
    title: 'Receive Value from Channel',
    text: 'Receive a value from the channel.',
    setup: 'ch := make(chan int, 1)\nch <- 42',
    setupCode: 'ch := make(chan int, 1)\nch <- 42',
    expected: 42,
    sample: 'v := <-ch',
    hints: ['Use <-ch to receive', 'Blocks if channel is empty'],
    tags: ['channel', 'receive', 'operator'],
  },
  {
    id: 'go-chan-254',
    category: 'Channels',
    difficulty: 'easy',
    title: 'Close Channel',
    text: 'Close the channel after sending all values.',
    setup: 'ch := make(chan int, 3)\nch <- 1; ch <- 2; ch <- 3',
    setupCode: 'ch := make(chan int, 3)\nch <- 1; ch <- 2; ch <- 3',
    expected: 'channel closed',
    sample: 'close(ch)',
    hints: ['close() signals no more values', 'Receivers can still read remaining values'],
    tags: ['channel', 'close'],
  },
  {
    id: 'go-chan-255',
    category: 'Channels',
    difficulty: 'medium',
    title: 'Check if Channel is Closed',
    text: 'Receive from channel and check if it was closed.',
    setup: 'ch := make(chan int, 1)\nch <- 42\nclose(ch)',
    setupCode: 'ch := make(chan int, 1)\nch <- 42\nclose(ch)',
    expected: 'value and ok status',
    sample: 'v, ok := <-ch',
    hints: [
      'Second return value indicates if channel is open',
      'ok is false when channel is closed and empty',
    ],
    tags: ['channel', 'closed', 'comma-ok'],
  },
  {
    id: 'go-chan-256',
    category: 'Channels',
    difficulty: 'medium',
    title: 'Range Over Channel',
    text: 'Use range to receive all values from channel until closed.',
    setup: 'ch := make(chan int, 3)\nch <- 1; ch <- 2; ch <- 3\nclose(ch)\nvar sum int',
    setupCode: 'ch := make(chan int, 3)\nch <- 1; ch <- 2; ch <- 3\nclose(ch)\nvar sum int',
    expected: 6,
    sample: 'for v := range ch { sum += v }',
    hints: ['range on channel reads until closed', 'Loop exits when channel closes'],
    tags: ['channel', 'range', 'iterate'],
  },
  {
    id: 'go-chan-257',
    category: 'Channels',
    difficulty: 'medium',
    title: 'Get Channel Length',
    text: 'Get the number of elements currently in the buffered channel.',
    setup: 'ch := make(chan int, 10)\nch <- 1; ch <- 2; ch <- 3',
    setupCode: 'ch := make(chan int, 10)\nch <- 1; ch <- 2; ch <- 3',
    expected: 3,
    sample: 'len(ch)',
    hints: ['len() returns number of queued elements', 'cap() returns buffer capacity'],
    tags: ['channel', 'len', 'buffered'],
  },
  {
    id: 'go-chan-258',
    category: 'Channels',
    difficulty: 'medium',
    title: 'Get Channel Capacity',
    text: 'Get the capacity of the buffered channel.',
    setup: 'ch := make(chan int, 10)\nch <- 1; ch <- 2; ch <- 3',
    setupCode: 'ch := make(chan int, 10)\nch <- 1; ch <- 2; ch <- 3',
    expected: 10,
    sample: 'cap(ch)',
    hints: ['cap() returns buffer size', 'Returns 0 for unbuffered channels'],
    tags: ['channel', 'cap', 'buffered'],
  },
  {
    id: 'go-chan-259',
    category: 'Channels',
    difficulty: 'medium',
    title: 'Select with Default',
    text: 'Use select with default for non-blocking channel operation.',
    setup: 'ch := make(chan int)',
    setupCode: 'ch := make(chan int)',
    expected: 'non-blocking receive',
    sample: 'select { case v := <-ch: fmt.Println(v); default: fmt.Println("no value") }',
    hints: ['default case executes if no channel ready', 'Makes select non-blocking'],
    tags: ['channel', 'select', 'default'],
  },
  {
    id: 'go-chan-260',
    category: 'Channels',
    difficulty: 'hard',
    title: 'Select Multiple Channels',
    text: 'Use select to receive from whichever channel is ready first.',
    setup: 'ch1 := make(chan int, 1)\nch2 := make(chan string, 1)\nch1 <- 42',
    setupCode: 'ch1 := make(chan int, 1)\nch2 := make(chan string, 1)\nch1 <- 42',
    expected: 'received from ch1',
    sample: 'select { case v := <-ch1: fmt.Println(v); case s := <-ch2: fmt.Println(s) }',
    hints: ['select waits on multiple channels', 'First ready case executes'],
    tags: ['channel', 'select', 'multiple'],
  },
  {
    id: 'go-chan-261',
    category: 'Channels',
    difficulty: 'hard',
    title: 'Receive-Only Channel Type',
    text: 'Create a function that accepts a receive-only channel.',
    setup: '// Define function with receive-only channel parameter',
    setupCode: '// Define function with receive-only channel parameter',
    expected: 'func(ch <-chan int)',
    sample: 'func consume(ch <-chan int) { for v := range ch { fmt.Println(v) } }',
    hints: ['<-chan T is receive-only', 'Prevents accidental sends'],
    tags: ['channel', 'receive-only', 'type'],
  },
  {
    id: 'go-chan-262',
    category: 'Channels',
    difficulty: 'hard',
    title: 'Send-Only Channel Type',
    text: 'Create a function that accepts a send-only channel.',
    setup: '// Define function with send-only channel parameter',
    setupCode: '// Define function with send-only channel parameter',
    expected: 'func(ch chan<- int)',
    sample: 'func produce(ch chan<- int) { ch <- 42 }',
    hints: ['chan<- T is send-only', 'Prevents accidental receives'],
    tags: ['channel', 'send-only', 'type'],
  },
  {
    id: 'go-chan-263',
    category: 'Channels',
    difficulty: 'hard',
    title: 'Fan-Out Pattern',
    text: 'Create multiple goroutines to process from a single channel.',
    setup: 'jobs := make(chan int, 100)\nfor i := 0; i < 100; i++ { jobs <- i }\nclose(jobs)',
    setupCode: 'jobs := make(chan int, 100)\nfor i := 0; i < 100; i++ { jobs <- i }\nclose(jobs)',
    expected: 'multiple workers processing',
    sample: 'for w := 0; w < 3; w++ { go func() { for j := range jobs { process(j) } }() }',
    hints: ['Multiple goroutines read from same channel', 'Work is distributed automatically'],
    tags: ['channel', 'fan-out', 'pattern'],
  },
  {
    id: 'go-chan-264',
    category: 'Channels',
    difficulty: 'hard',
    title: 'Fan-In Pattern',
    text: 'Merge multiple channels into one.',
    setup: 'ch1 := make(chan int)\nch2 := make(chan int)\nmerged := make(chan int)',
    setupCode: 'ch1 := make(chan int)\nch2 := make(chan int)\nmerged := make(chan int)',
    expected: 'merged channel',
    sample:
      'go func() { for v := range ch1 { merged <- v } }(); go func() { for v := range ch2 { merged <- v } }()',
    hints: ['Multiple goroutines send to same channel', 'Combines multiple sources'],
    tags: ['channel', 'fan-in', 'pattern'],
  },

  // ============================================================
  // NEW PROBLEMS - Batch 5: Atomic Package
  // ============================================================

  {
    id: 'go-atomic-265',
    category: 'Atomic Package',
    difficulty: 'medium',
    title: 'Atomic Add Int64',
    text: 'Use atomic.AddInt64 to safely increment a counter.',
    setup: 'import "sync/atomic"\nvar counter int64 = 0',
    setupCode: 'import "sync/atomic"\nvar counter int64 = 0',
    expected: 1,
    sample: 'atomic.AddInt64(&counter, 1)',
    hints: ['AddInt64 returns new value', 'Pass pointer to variable'],
    tags: ['atomic', 'AddInt64', 'counter'],
  },
  {
    id: 'go-atomic-266',
    category: 'Atomic Package',
    difficulty: 'medium',
    title: 'Atomic Load Int64',
    text: 'Use atomic.LoadInt64 to safely read a shared counter.',
    setup: 'import "sync/atomic"\nvar counter int64 = 42',
    setupCode: 'import "sync/atomic"\nvar counter int64 = 42',
    expected: 42,
    sample: 'atomic.LoadInt64(&counter)',
    hints: ['LoadInt64 reads atomically', 'Prevents torn reads'],
    tags: ['atomic', 'LoadInt64', 'read'],
  },
  {
    id: 'go-atomic-267',
    category: 'Atomic Package',
    difficulty: 'medium',
    title: 'Atomic Store Int64',
    text: 'Use atomic.StoreInt64 to safely set a value.',
    setup: 'import "sync/atomic"\nvar counter int64 = 0',
    setupCode: 'import "sync/atomic"\nvar counter int64 = 0',
    expected: 100,
    sample: 'atomic.StoreInt64(&counter, 100)',
    hints: ['StoreInt64 writes atomically', 'Prevents torn writes'],
    tags: ['atomic', 'StoreInt64', 'write'],
  },
  {
    id: 'go-atomic-268',
    category: 'Atomic Package',
    difficulty: 'hard',
    title: 'Compare and Swap',
    text: 'Use atomic.CompareAndSwapInt64 to update only if current value matches.',
    setup: 'import "sync/atomic"\nvar counter int64 = 5',
    setupCode: 'import "sync/atomic"\nvar counter int64 = 5',
    expected: true,
    sample: 'atomic.CompareAndSwapInt64(&counter, 5, 10)',
    hints: ['CAS returns true if swap succeeded', 'Only swaps if old value matches'],
    tags: ['atomic', 'CompareAndSwap', 'CAS'],
  },
  {
    id: 'go-atomic-269',
    category: 'Atomic Package',
    difficulty: 'hard',
    title: 'Atomic Value Store',
    text: 'Use atomic.Value to store a struct atomically.',
    setup: 'import "sync/atomic"\ntype Config struct { Host string }\nvar config atomic.Value',
    setupCode: 'import "sync/atomic"\ntype Config struct { Host string }\nvar config atomic.Value',
    expected: 'config stored',
    sample: 'config.Store(Config{Host: "localhost"})',
    hints: ['atomic.Value can store any type', 'Type must be consistent'],
    tags: ['atomic', 'Value', 'Store'],
  },
  {
    id: 'go-atomic-270',
    category: 'Atomic Package',
    difficulty: 'hard',
    title: 'Atomic Value Load',
    text: 'Load a value from atomic.Value and type assert.',
    setup:
      'import "sync/atomic"\ntype Config struct { Host string }\nvar config atomic.Value\nconfig.Store(Config{Host: "localhost"})',
    setupCode:
      'import "sync/atomic"\ntype Config struct { Host string }\nvar config atomic.Value\nconfig.Store(Config{Host: "localhost"})',
    expected: 'localhost',
    sample: 'config.Load().(Config).Host',
    hints: ['Load returns interface{}', 'Type assert to get actual value'],
    tags: ['atomic', 'Value', 'Load'],
  },
  {
    id: 'go-atomic-271',
    category: 'Atomic Package',
    difficulty: 'medium',
    title: 'Atomic Bool (Go 1.19+)',
    text: 'Use atomic.Bool for thread-safe boolean flag.',
    setup: 'import "sync/atomic"\nvar flag atomic.Bool',
    setupCode: 'import "sync/atomic"\nvar flag atomic.Bool',
    expected: 'true',
    sample: 'flag.Store(true); flag.Load()',
    hints: ['atomic.Bool is type-safe', 'Added in Go 1.19'],
    tags: ['atomic', 'Bool', 'Go1.19'],
  },
  {
    id: 'go-atomic-272',
    category: 'Atomic Package',
    difficulty: 'medium',
    title: 'Atomic Int64 Type (Go 1.19+)',
    text: 'Use the atomic.Int64 type for cleaner atomic operations.',
    setup: 'import "sync/atomic"\nvar counter atomic.Int64',
    setupCode: 'import "sync/atomic"\nvar counter atomic.Int64',
    expected: 1,
    sample: 'counter.Add(1)',
    hints: ['atomic.Int64 has methods', 'Cleaner than functions'],
    tags: ['atomic', 'Int64', 'Go1.19'],
  },

  // ============================================================
  // NEW PROBLEMS - Batch 6: Encoding/JSON
  // ============================================================

  {
    id: 'go-json-273',
    category: 'Encoding/JSON',
    difficulty: 'easy',
    title: 'Marshal Struct to JSON',
    text: 'Use json.Marshal to convert a struct to JSON bytes.',
    setup:
      'import "encoding/json"\ntype Person struct { Name string; Age int }\np := Person{Name: "Alice", Age: 30}',
    setupCode:
      'import "encoding/json"\ntype Person struct { Name string; Age int }\np := Person{Name: "Alice", Age: 30}',
    expected: '{"Name":"Alice","Age":30}',
    sample: 'data, err := json.Marshal(p)',
    hints: ['Marshal returns []byte and error', 'Exported fields are included'],
    tags: ['json', 'Marshal', 'struct'],
  },
  {
    id: 'go-json-274',
    category: 'Encoding/JSON',
    difficulty: 'easy',
    title: 'Unmarshal JSON to Struct',
    text: 'Use json.Unmarshal to parse JSON into a struct.',
    setup:
      'import "encoding/json"\ntype Person struct { Name string; Age int }\ndata := []byte(`{"Name":"Bob","Age":25}`)\nvar p Person',
    setupCode:
      'import "encoding/json"\ntype Person struct { Name string; Age int }\ndata := []byte(`{"Name":"Bob","Age":25}`)\nvar p Person',
    expected: 'Person{Name:"Bob", Age:25}',
    sample: 'json.Unmarshal(data, &p)',
    hints: ['Pass pointer to destination', 'Returns error if invalid JSON'],
    tags: ['json', 'Unmarshal', 'parse'],
  },
  {
    id: 'go-json-275',
    category: 'Encoding/JSON',
    difficulty: 'medium',
    title: 'JSON Tag for Field Name',
    text: 'Define a struct with JSON tag to change field name.',
    setup: 'import "encoding/json"',
    setupCode: 'import "encoding/json"',
    expected: '{"full_name":"Alice"}',
    sample: 'type Person struct { Name string `json:"full_name"` }',
    hints: ['Use backticks for struct tags', 'json:"name" sets JSON key'],
    tags: ['json', 'tag', 'field'],
  },
  {
    id: 'go-json-276',
    category: 'Encoding/JSON',
    difficulty: 'medium',
    title: 'Omit Empty Fields',
    text: 'Define a struct tag to omit empty fields from JSON.',
    setup: 'import "encoding/json"',
    setupCode: 'import "encoding/json"',
    expected: '{}',
    sample: 'type Person struct { Name string `json:"name,omitempty"` }',
    hints: ['Use omitempty option', 'Empty string/zero values are omitted'],
    tags: ['json', 'omitempty', 'tag'],
  },
  {
    id: 'go-json-277',
    category: 'Encoding/JSON',
    difficulty: 'medium',
    title: 'Ignore Field in JSON',
    text: 'Define a struct tag to exclude a field from JSON entirely.',
    setup: 'import "encoding/json"',
    setupCode: 'import "encoding/json"',
    expected: 'field excluded',
    sample: 'type User struct { Name string; Password string `json:"-"` }',
    hints: ['Use json:"-" to ignore field', 'Field is never marshaled'],
    tags: ['json', 'ignore', 'tag'],
  },
  {
    id: 'go-json-278',
    category: 'Encoding/JSON',
    difficulty: 'medium',
    title: 'Marshal to Indented JSON',
    text: 'Use json.MarshalIndent for pretty-printed JSON.',
    setup:
      'import "encoding/json"\ntype Person struct { Name string; Age int }\np := Person{Name: "Alice", Age: 30}',
    setupCode:
      'import "encoding/json"\ntype Person struct { Name string; Age int }\np := Person{Name: "Alice", Age: 30}',
    expected: 'indented JSON',
    sample: 'data, err := json.MarshalIndent(p, "", "  ")',
    hints: ['MarshalIndent(v, prefix, indent)', 'Use "  " for 2-space indent'],
    tags: ['json', 'MarshalIndent', 'pretty'],
  },
  {
    id: 'go-json-279',
    category: 'Encoding/JSON',
    difficulty: 'medium',
    title: 'Unmarshal into Map',
    text: 'Unmarshal JSON into a map for dynamic data.',
    setup:
      'import "encoding/json"\ndata := []byte(`{"name":"Alice","age":30}`)\nvar m map[string]interface{}',
    setupCode:
      'import "encoding/json"\ndata := []byte(`{"name":"Alice","age":30}`)\nvar m map[string]interface{}',
    expected: 'map with name and age',
    sample: 'json.Unmarshal(data, &m)',
    hints: ['map[string]interface{} for unknown structure', 'Type assert values'],
    tags: ['json', 'Unmarshal', 'map'],
  },
  {
    id: 'go-json-280',
    category: 'Encoding/JSON',
    difficulty: 'hard',
    title: 'Custom JSON Marshaler',
    text: 'Implement MarshalJSON for custom serialization.',
    setup: 'import "encoding/json"\ntype Status int\nconst Active Status = 1',
    setupCode: 'import "encoding/json"\ntype Status int\nconst Active Status = 1',
    expected: '"active"',
    sample:
      'func (s Status) MarshalJSON() ([]byte, error) { if s == Active { return []byte(`"active"`), nil }; return []byte(`"inactive"`), nil }',
    hints: ['Implement MarshalJSON method', 'Return JSON bytes'],
    tags: ['json', 'MarshalJSON', 'custom'],
  },
  {
    id: 'go-json-281',
    category: 'Encoding/JSON',
    difficulty: 'hard',
    title: 'Custom JSON Unmarshaler',
    text: 'Implement UnmarshalJSON for custom parsing.',
    setup: 'import "encoding/json"\ntype Status int',
    setupCode: 'import "encoding/json"\ntype Status int',
    expected: 'parsed status',
    sample:
      'func (s *Status) UnmarshalJSON(data []byte) error { if string(data) == `"active"` { *s = 1 }; return nil }',
    hints: ['Implement UnmarshalJSON on pointer receiver', 'Parse data bytes'],
    tags: ['json', 'UnmarshalJSON', 'custom'],
  },
  {
    id: 'go-json-282',
    category: 'Encoding/JSON',
    difficulty: 'hard',
    title: 'JSON Encoder to Writer',
    text: 'Use json.Encoder to write JSON to an io.Writer.',
    setup:
      'import "encoding/json"\nimport "bytes"\ntype Person struct { Name string }\nvar buf bytes.Buffer',
    setupCode:
      'import "encoding/json"\nimport "bytes"\ntype Person struct { Name string }\nvar buf bytes.Buffer',
    expected: 'JSON written to buffer',
    sample: 'enc := json.NewEncoder(&buf); enc.Encode(Person{Name: "Alice"})',
    hints: ['NewEncoder wraps an io.Writer', 'Encode writes JSON directly'],
    tags: ['json', 'Encoder', 'stream'],
  },
  {
    id: 'go-json-283',
    category: 'Encoding/JSON',
    difficulty: 'hard',
    title: 'JSON Decoder from Reader',
    text: 'Use json.Decoder to read JSON from an io.Reader.',
    setup:
      'import "encoding/json"\nimport "strings"\ntype Person struct { Name string }\nr := strings.NewReader(`{"Name":"Bob"}`)\nvar p Person',
    setupCode:
      'import "encoding/json"\nimport "strings"\ntype Person struct { Name string }\nr := strings.NewReader(`{"Name":"Bob"}`)\nvar p Person',
    expected: 'Person{Name:"Bob"}',
    sample: 'dec := json.NewDecoder(r); dec.Decode(&p)',
    hints: ['NewDecoder wraps an io.Reader', 'Decode reads and parses'],
    tags: ['json', 'Decoder', 'stream'],
  },
  {
    id: 'go-json-284',
    category: 'Encoding/JSON',
    difficulty: 'medium',
    title: 'Handle JSON Number',
    text: 'Use json.Number to preserve numeric precision.',
    setup: 'import "encoding/json"\ndata := []byte(`{"value": 12345678901234567890}`)',
    setupCode: 'import "encoding/json"\ndata := []byte(`{"value": 12345678901234567890}`)',
    expected: 'preserved number',
    sample: 'dec := json.NewDecoder(bytes.NewReader(data)); dec.UseNumber()',
    hints: ['UseNumber prevents float64 conversion', 'json.Number is a string'],
    tags: ['json', 'Number', 'precision'],
  },

  // ============================================================
  // NEW PROBLEMS - Batch 7: Generics
  // ============================================================

  {
    id: 'go-generic-285',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Function with any',
    text: 'Create a generic function that prints any value.',
    setup: '// Define generic print function',
    setupCode: '// Define generic print function',
    expected: 'func Print[T any](v T)',
    sample: 'func Print[T any](v T) { fmt.Println(v) }',
    hints: ['[T any] declares type parameter', 'any is alias for interface{}'],
    tags: ['generics', 'any', 'function'],
  },
  {
    id: 'go-generic-286',
    category: 'Generics',
    difficulty: 'easy',
    title: 'Generic Slice Function',
    text: 'Create a generic function to get first element of any slice.',
    setup: '// Define generic First function',
    setupCode: '// Define generic First function',
    expected: 'func First[T any](s []T) T',
    sample: 'func First[T any](s []T) T { return s[0] }',
    hints: ['Use []T for generic slice', 'Returns type T'],
    tags: ['generics', 'slice', 'function'],
  },
  {
    id: 'go-generic-287',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Comparable Constraint',
    text: 'Create a generic function that checks equality, requiring comparable types.',
    setup: '// Define generic Equal function',
    setupCode: '// Define generic Equal function',
    expected: 'func Equal[T comparable](a, b T) bool',
    sample: 'func Equal[T comparable](a, b T) bool { return a == b }',
    hints: ['comparable allows == and !=', 'Built-in constraint'],
    tags: ['generics', 'comparable', 'constraint'],
  },
  {
    id: 'go-generic-288',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Ordered Constraint with cmp',
    text: 'Create a generic Max function using cmp.Ordered constraint.',
    setup: 'import "cmp"',
    setupCode: 'import "cmp"',
    expected: 'func Max[T cmp.Ordered](a, b T) T',
    sample: 'func Max[T cmp.Ordered](a, b T) T { if a > b { return a }; return b }',
    hints: ['cmp.Ordered allows < > <= >=', 'Works with int, float, string'],
    tags: ['generics', 'Ordered', 'constraint'],
  },
  {
    id: 'go-generic-289',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Generic Stack Type',
    text: 'Define a generic Stack type.',
    setup: '// Define generic Stack',
    setupCode: '// Define generic Stack',
    expected: 'type Stack[T any] struct',
    sample: 'type Stack[T any] struct { items []T }',
    hints: ['Type parameters work on types too', 'Use [T any] after type name'],
    tags: ['generics', 'type', 'stack'],
  },
  {
    id: 'go-generic-290',
    category: 'Generics',
    difficulty: 'medium',
    title: 'Generic Method',
    text: 'Add a Push method to the generic Stack.',
    setup: 'type Stack[T any] struct { items []T }',
    setupCode: 'type Stack[T any] struct { items []T }',
    expected: 'func (s *Stack[T]) Push(v T)',
    sample: 'func (s *Stack[T]) Push(v T) { s.items = append(s.items, v) }',
    hints: ['Receiver includes type parameter', 'Use *Stack[T] for pointer receiver'],
    tags: ['generics', 'method', 'stack'],
  },
  {
    id: 'go-generic-291',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Custom Type Constraint',
    text: 'Define a custom constraint interface for numeric types.',
    setup: '// Define Number constraint',
    setupCode: '// Define Number constraint',
    expected: 'type Number interface { int | float64 }',
    sample: 'type Number interface { int | int64 | float64 }',
    hints: ['Use | for type union', 'Interface defines allowed types'],
    tags: ['generics', 'constraint', 'interface'],
  },
  {
    id: 'go-generic-292',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Generic Map Function',
    text: 'Create a generic Map function that transforms slice elements.',
    setup: '// Define generic Map function',
    setupCode: '// Define generic Map function',
    expected: 'func Map[T, U any](s []T, f func(T) U) []U',
    sample:
      'func Map[T, U any](s []T, f func(T) U) []U { r := make([]U, len(s)); for i, v := range s { r[i] = f(v) }; return r }',
    hints: ['Two type parameters T and U', 'Transform function maps T to U'],
    tags: ['generics', 'map', 'transform'],
  },
  {
    id: 'go-generic-293',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Generic Filter Function',
    text: 'Create a generic Filter function with predicate.',
    setup: '// Define generic Filter function',
    setupCode: '// Define generic Filter function',
    expected: 'func Filter[T any](s []T, pred func(T) bool) []T',
    sample:
      'func Filter[T any](s []T, pred func(T) bool) []T { var r []T; for _, v := range s { if pred(v) { r = append(r, v) } }; return r }',
    hints: ['Predicate returns bool', 'Keep elements where pred returns true'],
    tags: ['generics', 'filter', 'predicate'],
  },
  {
    id: 'go-generic-294',
    category: 'Generics',
    difficulty: 'hard',
    title: 'Generic Reduce Function',
    text: 'Create a generic Reduce function for aggregation.',
    setup: '// Define generic Reduce function',
    setupCode: '// Define generic Reduce function',
    expected: 'func Reduce[T, U any](s []T, init U, f func(U, T) U) U',
    sample:
      'func Reduce[T, U any](s []T, init U, f func(U, T) U) U { acc := init; for _, v := range s { acc = f(acc, v) }; return acc }',
    hints: ['Accumulator type U, element type T', 'Start with initial value'],
    tags: ['generics', 'reduce', 'aggregate'],
  },

  // ============================================================
  // NEW PROBLEMS - Batch 8: Error Handling
  // ============================================================

  {
    id: 'go-err-295',
    category: 'Error Handling',
    difficulty: 'easy',
    title: 'Create Error with New',
    text: 'Create a simple error using errors.New.',
    setup: 'import "errors"',
    setupCode: 'import "errors"',
    expected: 'not found',
    sample: 'err := errors.New("not found")',
    hints: ['errors.New creates basic error', 'Returns error interface'],
    tags: ['error', 'New', 'create'],
  },
  {
    id: 'go-err-296',
    category: 'Error Handling',
    difficulty: 'easy',
    title: 'Create Formatted Error',
    text: 'Create an error with formatted message using fmt.Errorf.',
    setup: 'import "fmt"\nid := 123',
    setupCode: 'import "fmt"\nid := 123',
    expected: 'user 123 not found',
    sample: 'err := fmt.Errorf("user %d not found", id)',
    hints: ['fmt.Errorf supports format verbs', 'Returns error interface'],
    tags: ['error', 'Errorf', 'format'],
  },
  {
    id: 'go-err-297',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Wrap Error with Context',
    text: 'Wrap an existing error with additional context using %w.',
    setup: 'import "fmt"\nimport "errors"\norigErr := errors.New("connection refused")',
    setupCode: 'import "fmt"\nimport "errors"\norigErr := errors.New("connection refused")',
    expected: 'wrapped error',
    sample: 'err := fmt.Errorf("database error: %w", origErr)',
    hints: ['Use %w verb for wrapping', 'Preserves original error'],
    tags: ['error', 'wrap', 'Errorf'],
  },
  {
    id: 'go-err-298',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Check Error with Is',
    text: 'Use errors.Is to check if error matches a sentinel error.',
    setup: 'import "errors"\nimport "os"\nerr := fmt.Errorf("open failed: %w", os.ErrNotExist)',
    setupCode: 'import "errors"\nimport "os"\nerr := fmt.Errorf("open failed: %w", os.ErrNotExist)',
    expected: true,
    sample: 'errors.Is(err, os.ErrNotExist)',
    hints: ['Is checks error chain', 'Works with wrapped errors'],
    tags: ['error', 'Is', 'check'],
  },
  {
    id: 'go-err-299',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Extract Error with As',
    text: 'Use errors.As to extract a specific error type.',
    setup:
      'import "errors"\nimport "os"\n_, err := os.Open("nonexistent")\nvar pathErr *os.PathError',
    setupCode:
      'import "errors"\nimport "os"\n_, err := os.Open("nonexistent")\nvar pathErr *os.PathError',
    expected: 'extracted PathError',
    sample: 'errors.As(err, &pathErr)',
    hints: ['As extracts error of specific type', 'Second arg is pointer to target'],
    tags: ['error', 'As', 'extract'],
  },
  {
    id: 'go-err-300',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Unwrap Error',
    text: 'Use errors.Unwrap to get the underlying error.',
    setup:
      'import "errors"\nimport "fmt"\ninner := errors.New("inner")\nouter := fmt.Errorf("outer: %w", inner)',
    setupCode:
      'import "errors"\nimport "fmt"\ninner := errors.New("inner")\nouter := fmt.Errorf("outer: %w", inner)',
    expected: 'inner',
    sample: 'errors.Unwrap(outer)',
    hints: ['Unwrap returns wrapped error', 'Returns nil if no wrapped error'],
    tags: ['error', 'Unwrap', 'chain'],
  },
  {
    id: 'go-err-301',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Define Custom Error Type',
    text: 'Create a custom error type with additional context.',
    setup: '// Define ValidationError type',
    setupCode: '// Define ValidationError type',
    expected: 'type ValidationError struct',
    sample:
      'type ValidationError struct { Field string; Message string }; func (e ValidationError) Error() string { return e.Field + ": " + e.Message }',
    hints: ['Implement Error() method', 'Add relevant fields'],
    tags: ['error', 'custom', 'type'],
  },
  {
    id: 'go-err-302',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Error with Unwrap Method',
    text: 'Add Unwrap method to custom error for error chaining.',
    setup: 'type AppError struct { Op string; Err error }',
    setupCode: 'type AppError struct { Op string; Err error }',
    expected: 'error with Unwrap',
    sample: 'func (e *AppError) Unwrap() error { return e.Err }',
    hints: ['Unwrap returns wrapped error', 'Enables errors.Is/As'],
    tags: ['error', 'Unwrap', 'method'],
  },
  {
    id: 'go-err-303',
    category: 'Error Handling',
    difficulty: 'hard',
    title: 'Join Multiple Errors',
    text: 'Use errors.Join to combine multiple errors (Go 1.20+).',
    setup: 'import "errors"\nerr1 := errors.New("error 1")\nerr2 := errors.New("error 2")',
    setupCode: 'import "errors"\nerr1 := errors.New("error 1")\nerr2 := errors.New("error 2")',
    expected: 'joined error',
    sample: 'err := errors.Join(err1, err2)',
    hints: ['Join combines errors', 'errors.Is works for any joined error'],
    tags: ['error', 'Join', 'Go1.20'],
  },
  {
    id: 'go-err-304',
    category: 'Error Handling',
    difficulty: 'easy',
    title: 'Check Error is Nil',
    text: 'Write idiomatic error check pattern.',
    setup: 'result, err := someFunction()',
    setupCode: 'result, err := someFunction()',
    expected: 'if err != nil { return err }',
    sample: 'if err != nil { return err }',
    hints: ['Check err immediately after call', 'Return early on error'],
    tags: ['error', 'check', 'idiom'],
  },

  // ============================================================
  // NEW PROBLEMS - Batch 9: Testing
  // ============================================================

  {
    id: 'go-test-305',
    category: 'Testing',
    difficulty: 'easy',
    title: 'Basic Test Function',
    text: 'Write a basic test function signature.',
    setup: 'import "testing"',
    setupCode: 'import "testing"',
    expected: 'func TestAdd(t *testing.T)',
    sample:
      'func TestAdd(t *testing.T) { result := Add(2, 3); if result != 5 { t.Errorf("got %d, want 5", result) } }',
    hints: ['Test functions start with Test', 'Take *testing.T parameter'],
    tags: ['testing', 'function', 'basic'],
  },
  {
    id: 'go-test-306',
    category: 'Testing',
    difficulty: 'easy',
    title: 'Report Test Error',
    text: 'Use t.Errorf to report a test failure.',
    setup: 'import "testing"\nfunc TestExample(t *testing.T) {\n    got := 4\n    want := 5',
    setupCode: 'import "testing"\nfunc TestExample(t *testing.T) {\n    got := 4\n    want := 5',
    expected: 't.Errorf call',
    sample: 't.Errorf("got %d, want %d", got, want)',
    hints: ['Errorf formats like Printf', 'Test continues after Errorf'],
    tags: ['testing', 'Errorf', 'error'],
  },
  {
    id: 'go-test-307',
    category: 'Testing',
    difficulty: 'easy',
    title: 'Fatal Test Error',
    text: 'Use t.Fatalf to stop test immediately on failure.',
    setup: 'import "testing"\nfunc TestExample(t *testing.T) {\n    err := setup()',
    setupCode: 'import "testing"\nfunc TestExample(t *testing.T) {\n    err := setup()',
    expected: 't.Fatalf call',
    sample: 'if err != nil { t.Fatalf("setup failed: %v", err) }',
    hints: ['Fatalf stops the test', 'Use for setup errors'],
    tags: ['testing', 'Fatalf', 'fatal'],
  },
  {
    id: 'go-test-308',
    category: 'Testing',
    difficulty: 'medium',
    title: 'Table-Driven Test',
    text: 'Create a table-driven test with test cases.',
    setup: 'import "testing"',
    setupCode: 'import "testing"',
    expected: 'table-driven test pattern',
    sample:
      'func TestAdd(t *testing.T) { tests := []struct{ a, b, want int }{{1, 2, 3}, {0, 0, 0}}; for _, tt := range tests { got := Add(tt.a, tt.b); if got != tt.want { t.Errorf("Add(%d,%d)=%d, want %d", tt.a, tt.b, got, tt.want) } } }',
    hints: ['Define slice of test cases', 'Loop over cases'],
    tags: ['testing', 'table-driven', 'pattern'],
  },
  {
    id: 'go-test-309',
    category: 'Testing',
    difficulty: 'medium',
    title: 'Subtest with t.Run',
    text: 'Use t.Run to create named subtests.',
    setup: 'import "testing"',
    setupCode: 'import "testing"',
    expected: 't.Run subtest',
    sample:
      't.Run("positive numbers", func(t *testing.T) { if Add(1, 2) != 3 { t.Error("failed") } })',
    hints: ['t.Run creates named subtest', 'Allows running specific tests'],
    tags: ['testing', 'Run', 'subtest'],
  },
  {
    id: 'go-test-310',
    category: 'Testing',
    difficulty: 'medium',
    title: 'Skip Test Conditionally',
    text: 'Skip a test based on a condition.',
    setup: 'import "testing"\nimport "runtime"',
    setupCode: 'import "testing"\nimport "runtime"',
    expected: 't.Skip call',
    sample: 'if runtime.GOOS == "windows" { t.Skip("skipping on Windows") }',
    hints: ['Skip stops test without failure', 'Use for platform-specific tests'],
    tags: ['testing', 'Skip', 'conditional'],
  },
  {
    id: 'go-test-311',
    category: 'Testing',
    difficulty: 'medium',
    title: 'Parallel Test',
    text: 'Mark a test to run in parallel.',
    setup: 'import "testing"',
    setupCode: 'import "testing"',
    expected: 't.Parallel()',
    sample: 'func TestParallel(t *testing.T) { t.Parallel(); /* test code */ }',
    hints: ['Call t.Parallel() at start', 'Tests run concurrently'],
    tags: ['testing', 'Parallel', 'concurrent'],
  },
  {
    id: 'go-test-312',
    category: 'Testing',
    difficulty: 'hard',
    title: 'Benchmark Function',
    text: 'Write a benchmark function.',
    setup: 'import "testing"',
    setupCode: 'import "testing"',
    expected: 'func BenchmarkAdd(b *testing.B)',
    sample: 'func BenchmarkAdd(b *testing.B) { for i := 0; i < b.N; i++ { Add(1, 2) } }',
    hints: ['Benchmark functions start with Benchmark', 'Loop b.N times'],
    tags: ['testing', 'Benchmark', 'performance'],
  },
  {
    id: 'go-test-313',
    category: 'Testing',
    difficulty: 'hard',
    title: 'Reset Benchmark Timer',
    text: 'Reset the benchmark timer after setup.',
    setup: 'import "testing"',
    setupCode: 'import "testing"',
    expected: 'b.ResetTimer()',
    sample:
      'func BenchmarkProcess(b *testing.B) { data := setup(); b.ResetTimer(); for i := 0; i < b.N; i++ { Process(data) } }',
    hints: ['ResetTimer excludes setup time', 'Call after expensive setup'],
    tags: ['testing', 'Benchmark', 'ResetTimer'],
  },
  {
    id: 'go-test-314',
    category: 'Testing',
    difficulty: 'hard',
    title: 'Example Function',
    text: 'Write a testable example with output comment.',
    setup: 'import "fmt"',
    setupCode: 'import "fmt"',
    expected: 'func ExampleAdd()',
    sample: 'func ExampleAdd() { fmt.Println(Add(2, 3)); // Output: 5 }',
    hints: ['Example functions start with Example', 'Output comment is verified'],
    tags: ['testing', 'Example', 'documentation'],
  },
  {
    id: 'go-test-315',
    category: 'Testing',
    difficulty: 'hard',
    title: 'Test Helper Function',
    text: 'Mark a function as a test helper.',
    setup: 'import "testing"',
    setupCode: 'import "testing"',
    expected: 't.Helper()',
    sample:
      'func assertEqual(t *testing.T, got, want int) { t.Helper(); if got != want { t.Errorf("got %d, want %d", got, want) } }',
    hints: ['t.Helper() improves error reporting', 'Shows caller location'],
    tags: ['testing', 'Helper', 'utility'],
  },
  {
    id: 'go-test-316',
    category: 'Testing',
    difficulty: 'medium',
    title: 'Test Cleanup',
    text: 'Register cleanup function for test.',
    setup: 'import "testing"',
    setupCode: 'import "testing"',
    expected: 't.Cleanup call',
    sample: 't.Cleanup(func() { os.Remove(tempFile) })',
    hints: ['Cleanup runs after test completes', 'Even on failure'],
    tags: ['testing', 'Cleanup', 'teardown'],
  },

  // ============================================================
  // NEW PROBLEMS - Batch 10: HTTP Package
  // ============================================================

  {
    id: 'go-http-317',
    category: 'HTTP Package',
    difficulty: 'easy',
    title: 'Simple HTTP Handler',
    text: 'Create a simple HTTP handler function.',
    setup: 'import "net/http"',
    setupCode: 'import "net/http"',
    expected: 'handler function',
    sample: 'func handler(w http.ResponseWriter, r *http.Request) { w.Write([]byte("Hello")) }',
    hints: ['Handler takes ResponseWriter and Request', 'Write response with w.Write'],
    tags: ['http', 'handler', 'basic'],
  },
  {
    id: 'go-http-318',
    category: 'HTTP Package',
    difficulty: 'easy',
    title: 'Register Handler',
    text: 'Register a handler function for a path.',
    setup: 'import "net/http"\nfunc handler(w http.ResponseWriter, r *http.Request) {}',
    setupCode: 'import "net/http"\nfunc handler(w http.ResponseWriter, r *http.Request) {}',
    expected: 'http.HandleFunc call',
    sample: 'http.HandleFunc("/hello", handler)',
    hints: ['HandleFunc registers handler for path', 'Uses default ServeMux'],
    tags: ['http', 'HandleFunc', 'route'],
  },
  {
    id: 'go-http-319',
    category: 'HTTP Package',
    difficulty: 'easy',
    title: 'Start HTTP Server',
    text: 'Start an HTTP server on port 8080.',
    setup: 'import "net/http"',
    setupCode: 'import "net/http"',
    expected: 'http.ListenAndServe call',
    sample: 'http.ListenAndServe(":8080", nil)',
    hints: ['nil uses default ServeMux', 'Blocks until error'],
    tags: ['http', 'ListenAndServe', 'server'],
  },
  {
    id: 'go-http-320',
    category: 'HTTP Package',
    difficulty: 'medium',
    title: 'Set Response Header',
    text: 'Set Content-Type header to application/json.',
    setup: 'import "net/http"\nfunc handler(w http.ResponseWriter, r *http.Request) {',
    setupCode: 'import "net/http"\nfunc handler(w http.ResponseWriter, r *http.Request) {',
    expected: 'header set',
    sample: 'w.Header().Set("Content-Type", "application/json")',
    hints: ['Use Header().Set()', 'Set before writing body'],
    tags: ['http', 'Header', 'Set'],
  },
  {
    id: 'go-http-321',
    category: 'HTTP Package',
    difficulty: 'medium',
    title: 'Set Status Code',
    text: 'Set HTTP status code to 201 Created.',
    setup: 'import "net/http"\nfunc handler(w http.ResponseWriter, r *http.Request) {',
    setupCode: 'import "net/http"\nfunc handler(w http.ResponseWriter, r *http.Request) {',
    expected: 'status set',
    sample: 'w.WriteHeader(http.StatusCreated)',
    hints: ['Use WriteHeader for status', 'Call before Write'],
    tags: ['http', 'WriteHeader', 'status'],
  },
  {
    id: 'go-http-322',
    category: 'HTTP Package',
    difficulty: 'medium',
    title: 'Get Request Method',
    text: 'Check if request method is POST.',
    setup: 'import "net/http"\nfunc handler(w http.ResponseWriter, r *http.Request) {',
    setupCode: 'import "net/http"\nfunc handler(w http.ResponseWriter, r *http.Request) {',
    expected: 'method check',
    sample:
      'if r.Method != http.MethodPost { http.Error(w, "Method not allowed", http.StatusMethodNotAllowed); return }',
    hints: ['r.Method contains HTTP method', 'Use http.Method* constants'],
    tags: ['http', 'Method', 'request'],
  },
  {
    id: 'go-http-323',
    category: 'HTTP Package',
    difficulty: 'medium',
    title: 'Get URL Query Parameter',
    text: 'Get the "id" query parameter from the request URL.',
    setup: 'import "net/http"\nfunc handler(w http.ResponseWriter, r *http.Request) {',
    setupCode: 'import "net/http"\nfunc handler(w http.ResponseWriter, r *http.Request) {',
    expected: 'query parameter',
    sample: 'id := r.URL.Query().Get("id")',
    hints: ['URL.Query() returns url.Values', 'Get returns empty string if missing'],
    tags: ['http', 'Query', 'parameter'],
  },
  {
    id: 'go-http-324',
    category: 'HTTP Package',
    difficulty: 'medium',
    title: 'Read Request Body',
    text: 'Read the request body as bytes.',
    setup: 'import "net/http"\nimport "io"\nfunc handler(w http.ResponseWriter, r *http.Request) {',
    setupCode:
      'import "net/http"\nimport "io"\nfunc handler(w http.ResponseWriter, r *http.Request) {',
    expected: 'body bytes',
    sample: 'body, err := io.ReadAll(r.Body)',
    hints: ['r.Body is io.ReadCloser', 'Use io.ReadAll to read all'],
    tags: ['http', 'Body', 'read'],
  },
  {
    id: 'go-http-325',
    category: 'HTTP Package',
    difficulty: 'hard',
    title: 'Create HTTP Client',
    text: 'Create an HTTP client with 10 second timeout.',
    setup: 'import "net/http"\nimport "time"',
    setupCode: 'import "net/http"\nimport "time"',
    expected: 'client with timeout',
    sample: 'client := &http.Client{Timeout: 10 * time.Second}',
    hints: ['Configure Timeout on Client', 'Default client has no timeout'],
    tags: ['http', 'Client', 'timeout'],
  },
  {
    id: 'go-http-326',
    category: 'HTTP Package',
    difficulty: 'hard',
    title: 'Make GET Request',
    text: 'Make a GET request and read response body.',
    setup: 'import "net/http"\nimport "io"',
    setupCode: 'import "net/http"\nimport "io"',
    expected: 'GET request',
    sample:
      'resp, err := http.Get("https://api.example.com"); if err != nil { return err }; defer resp.Body.Close(); body, _ := io.ReadAll(resp.Body)',
    hints: ['http.Get for simple GET', 'Always close response body'],
    tags: ['http', 'Get', 'client'],
  },
  {
    id: 'go-http-327',
    category: 'HTTP Package',
    difficulty: 'hard',
    title: 'Make POST Request with JSON',
    text: 'Make a POST request with JSON body.',
    setup: 'import "net/http"\nimport "bytes"',
    setupCode: 'import "net/http"\nimport "bytes"',
    expected: 'POST request',
    sample:
      'jsonBody := []byte(`{"name":"test"}`); resp, err := http.Post("https://api.example.com", "application/json", bytes.NewBuffer(jsonBody))',
    hints: ['http.Post takes content-type', 'Use bytes.NewBuffer for body'],
    tags: ['http', 'Post', 'JSON'],
  },
  {
    id: 'go-http-328',
    category: 'HTTP Package',
    difficulty: 'hard',
    title: 'Create Custom Request',
    text: 'Create a custom HTTP request with headers.',
    setup: 'import "net/http"',
    setupCode: 'import "net/http"',
    expected: 'custom request',
    sample:
      'req, err := http.NewRequest("GET", "https://api.example.com", nil); req.Header.Set("Authorization", "Bearer token")',
    hints: ['NewRequest for custom requests', 'Set headers before sending'],
    tags: ['http', 'NewRequest', 'headers'],
  },

  // ============================================================
  // NEW PROBLEMS - Batch 11: IO Package
  // ============================================================

  {
    id: 'go-io-329',
    category: 'IO Package',
    difficulty: 'easy',
    title: 'Read All from Reader',
    text: 'Read all bytes from an io.Reader.',
    setup: 'import "io"\nimport "strings"\nr := strings.NewReader("hello world")',
    setupCode: 'import "io"\nimport "strings"\nr := strings.NewReader("hello world")',
    expected: 'hello world',
    sample: 'data, err := io.ReadAll(r)',
    hints: ['io.ReadAll reads until EOF', 'Returns []byte'],
    tags: ['io', 'ReadAll', 'reader'],
  },
  {
    id: 'go-io-330',
    category: 'IO Package',
    difficulty: 'easy',
    title: 'Copy Reader to Writer',
    text: 'Copy all data from reader to writer.',
    setup:
      'import "io"\nimport "strings"\nimport "bytes"\nr := strings.NewReader("hello")\nvar w bytes.Buffer',
    setupCode:
      'import "io"\nimport "strings"\nimport "bytes"\nr := strings.NewReader("hello")\nvar w bytes.Buffer',
    expected: 'hello copied',
    sample: 'io.Copy(&w, r)',
    hints: ['io.Copy copies until EOF', 'Returns bytes written'],
    tags: ['io', 'Copy', 'reader', 'writer'],
  },
  {
    id: 'go-io-331',
    category: 'IO Package',
    difficulty: 'medium',
    title: 'Limit Reader',
    text: 'Create a reader that reads at most N bytes.',
    setup: 'import "io"\nimport "strings"\nr := strings.NewReader("hello world")',
    setupCode: 'import "io"\nimport "strings"\nr := strings.NewReader("hello world")',
    expected: 'limited reader',
    sample: 'limited := io.LimitReader(r, 5)',
    hints: ['LimitReader wraps reader', 'Returns EOF after N bytes'],
    tags: ['io', 'LimitReader', 'limit'],
  },
  {
    id: 'go-io-332',
    category: 'IO Package',
    difficulty: 'medium',
    title: 'Multi Reader',
    text: 'Combine multiple readers into one sequential reader.',
    setup:
      'import "io"\nimport "strings"\nr1 := strings.NewReader("hello ")\nr2 := strings.NewReader("world")',
    setupCode:
      'import "io"\nimport "strings"\nr1 := strings.NewReader("hello ")\nr2 := strings.NewReader("world")',
    expected: 'combined reader',
    sample: 'combined := io.MultiReader(r1, r2)',
    hints: ['MultiReader concatenates readers', 'Reads in sequence'],
    tags: ['io', 'MultiReader', 'combine'],
  },
  {
    id: 'go-io-333',
    category: 'IO Package',
    difficulty: 'medium',
    title: 'Multi Writer',
    text: 'Create a writer that writes to multiple destinations.',
    setup: 'import "io"\nimport "bytes"\nvar w1, w2 bytes.Buffer',
    setupCode: 'import "io"\nimport "bytes"\nvar w1, w2 bytes.Buffer',
    expected: 'multi writer',
    sample: 'multi := io.MultiWriter(&w1, &w2)',
    hints: ['MultiWriter writes to all', 'Like Unix tee'],
    tags: ['io', 'MultiWriter', 'tee'],
  },
  {
    id: 'go-io-334',
    category: 'IO Package',
    difficulty: 'medium',
    title: 'TeeReader',
    text: 'Create a reader that copies to writer while reading.',
    setup:
      'import "io"\nimport "strings"\nimport "bytes"\nr := strings.NewReader("hello")\nvar buf bytes.Buffer',
    setupCode:
      'import "io"\nimport "strings"\nimport "bytes"\nr := strings.NewReader("hello")\nvar buf bytes.Buffer',
    expected: 'tee reader',
    sample: 'tee := io.TeeReader(r, &buf)',
    hints: ['TeeReader copies while reading', 'Useful for logging'],
    tags: ['io', 'TeeReader', 'copy'],
  },
  {
    id: 'go-io-335',
    category: 'IO Package',
    difficulty: 'hard',
    title: 'Create Pipe',
    text: 'Create an io.Pipe for synchronous in-memory pipe.',
    setup: 'import "io"',
    setupCode: 'import "io"',
    expected: 'pipe reader and writer',
    sample: 'pr, pw := io.Pipe()',
    hints: ['Pipe connects reader and writer', 'Writes block until read'],
    tags: ['io', 'Pipe', 'synchronous'],
  },
  {
    id: 'go-io-336',
    category: 'IO Package',
    difficulty: 'hard',
    title: 'WriteString to Writer',
    text: 'Write a string to an io.Writer efficiently.',
    setup: 'import "io"\nimport "bytes"\nvar buf bytes.Buffer',
    setupCode: 'import "io"\nimport "bytes"\nvar buf bytes.Buffer',
    expected: 'string written',
    sample: 'io.WriteString(&buf, "hello")',
    hints: ['WriteString avoids []byte conversion', 'More efficient than Write'],
    tags: ['io', 'WriteString', 'efficient'],
  },
  {
    id: 'go-io-337',
    category: 'IO Package',
    difficulty: 'medium',
    title: 'Discard Writer',
    text: 'Use io.Discard to ignore all written data.',
    setup: 'import "io"',
    setupCode: 'import "io"',
    expected: 'io.Discard',
    sample: 'io.Copy(io.Discard, r)',
    hints: ['Discard is like /dev/null', 'Useful for benchmarks'],
    tags: ['io', 'Discard', 'null'],
  },
  {
    id: 'go-io-338',
    category: 'IO Package',
    difficulty: 'hard',
    title: 'Buffered Reader',
    text: 'Create a buffered reader for efficient reading.',
    setup: 'import "bufio"\nimport "strings"\nr := strings.NewReader("hello world")',
    setupCode: 'import "bufio"\nimport "strings"\nr := strings.NewReader("hello world")',
    expected: 'buffered reader',
    sample: 'br := bufio.NewReader(r)',
    hints: ['bufio.NewReader adds buffering', 'More efficient for many small reads'],
    tags: ['bufio', 'Reader', 'buffer'],
  },
  {
    id: 'go-io-339',
    category: 'IO Package',
    difficulty: 'hard',
    title: 'Read Line from Buffered Reader',
    text: 'Read a line from buffered reader.',
    setup:
      'import "bufio"\nimport "strings"\nr := strings.NewReader("line1\\nline2")\nbr := bufio.NewReader(r)',
    setupCode:
      'import "bufio"\nimport "strings"\nr := strings.NewReader("line1\\nline2")\nbr := bufio.NewReader(r)',
    expected: 'line1',
    sample: "line, err := br.ReadString('\\n')",
    hints: ['ReadString reads until delimiter', 'Includes delimiter in result'],
    tags: ['bufio', 'ReadString', 'line'],
  },

  // ============================================================
  // NEW PROBLEMS - Batch 12: Regexp Package
  // ============================================================

  {
    id: 'go-regexp-340',
    category: 'Regexp Package',
    difficulty: 'easy',
    title: 'Compile Regex Pattern',
    text: 'Compile a regex pattern for matching digits.',
    setup: 'import "regexp"',
    setupCode: 'import "regexp"',
    expected: 'compiled regex',
    sample: 're := regexp.MustCompile(`\\d+`)',
    hints: ['MustCompile panics on error', 'Use Compile for error handling'],
    tags: ['regexp', 'MustCompile', 'pattern'],
  },
  {
    id: 'go-regexp-341',
    category: 'Regexp Package',
    difficulty: 'easy',
    title: 'Check if String Matches',
    text: 'Check if the string matches the regex pattern.',
    setup: 'import "regexp"\nre := regexp.MustCompile(`^[a-z]+$`)\ns := "hello"',
    setupCode: 'import "regexp"\nre := regexp.MustCompile(`^[a-z]+$`)\ns := "hello"',
    expected: true,
    sample: 're.MatchString(s)',
    hints: ['MatchString returns bool', 'Tests entire match'],
    tags: ['regexp', 'MatchString', 'check'],
  },
  {
    id: 'go-regexp-342',
    category: 'Regexp Package',
    difficulty: 'medium',
    title: 'Find First Match',
    text: 'Find the first number in the string.',
    setup: 'import "regexp"\nre := regexp.MustCompile(`\\d+`)\ns := "abc123def456"',
    setupCode: 'import "regexp"\nre := regexp.MustCompile(`\\d+`)\ns := "abc123def456"',
    expected: '123',
    sample: 're.FindString(s)',
    hints: ['FindString returns first match', 'Empty string if no match'],
    tags: ['regexp', 'FindString', 'first'],
  },
  {
    id: 'go-regexp-343',
    category: 'Regexp Package',
    difficulty: 'medium',
    title: 'Find All Matches',
    text: 'Find all numbers in the string.',
    setup: 'import "regexp"\nre := regexp.MustCompile(`\\d+`)\ns := "a1b22c333"',
    setupCode: 'import "regexp"\nre := regexp.MustCompile(`\\d+`)\ns := "a1b22c333"',
    expected: ['1', '22', '333'],
    sample: 're.FindAllString(s, -1)',
    hints: ['FindAllString returns all matches', '-1 for unlimited matches'],
    tags: ['regexp', 'FindAllString', 'all'],
  },
  {
    id: 'go-regexp-344',
    category: 'Regexp Package',
    difficulty: 'medium',
    title: 'Replace All Matches',
    text: 'Replace all digits with X.',
    setup: 'import "regexp"\nre := regexp.MustCompile(`\\d`)\ns := "Phone: 123-456"',
    setupCode: 'import "regexp"\nre := regexp.MustCompile(`\\d`)\ns := "Phone: 123-456"',
    expected: 'Phone: XXX-XXX',
    sample: 're.ReplaceAllString(s, "X")',
    hints: ['ReplaceAllString replaces all matches', 'Returns new string'],
    tags: ['regexp', 'ReplaceAllString', 'replace'],
  },
  {
    id: 'go-regexp-345',
    category: 'Regexp Package',
    difficulty: 'hard',
    title: 'Extract Submatches',
    text: 'Extract username and domain from email using groups.',
    setup:
      'import "regexp"\nre := regexp.MustCompile(`(\\w+)@(\\w+\\.\\w+)`)\nemail := "user@example.com"',
    setupCode:
      'import "regexp"\nre := regexp.MustCompile(`(\\w+)@(\\w+\\.\\w+)`)\nemail := "user@example.com"',
    expected: ['user@example.com', 'user', 'example.com'],
    sample: 're.FindStringSubmatch(email)',
    hints: ['FindStringSubmatch includes groups', 'Index 0 is full match'],
    tags: ['regexp', 'FindStringSubmatch', 'groups'],
  },
  {
    id: 'go-regexp-346',
    category: 'Regexp Package',
    difficulty: 'hard',
    title: 'Named Capture Groups',
    text: 'Use named capture groups to extract parts.',
    setup:
      'import "regexp"\nre := regexp.MustCompile(`(?P<year>\\d{4})-(?P<month>\\d{2})-(?P<day>\\d{2})`)\ndate := "2024-03-15"',
    setupCode:
      'import "regexp"\nre := regexp.MustCompile(`(?P<year>\\d{4})-(?P<month>\\d{2})-(?P<day>\\d{2})`)\ndate := "2024-03-15"',
    expected: 'named groups extracted',
    sample: 'match := re.FindStringSubmatch(date); names := re.SubexpNames()',
    hints: ['Use (?P<name>...) for named groups', 'SubexpNames returns group names'],
    tags: ['regexp', 'named', 'groups'],
  },
  {
    id: 'go-regexp-347',
    category: 'Regexp Package',
    difficulty: 'hard',
    title: 'Replace with Function',
    text: 'Replace matches using a function for dynamic replacement.',
    setup:
      'import "regexp"\nimport "strings"\nre := regexp.MustCompile(`\\w+`)\ns := "hello world"',
    setupCode:
      'import "regexp"\nimport "strings"\nre := regexp.MustCompile(`\\w+`)\ns := "hello world"',
    expected: 'HELLO WORLD',
    sample: 're.ReplaceAllStringFunc(s, strings.ToUpper)',
    hints: ['ReplaceAllStringFunc takes function', 'Function receives match'],
    tags: ['regexp', 'ReplaceAllStringFunc', 'function'],
  },
  {
    id: 'go-regexp-348',
    category: 'Regexp Package',
    difficulty: 'medium',
    title: 'Split String by Regex',
    text: 'Split string by one or more whitespace characters.',
    setup: 'import "regexp"\nre := regexp.MustCompile(`\\s+`)\ns := "hello   world  go"',
    setupCode: 'import "regexp"\nre := regexp.MustCompile(`\\s+`)\ns := "hello   world  go"',
    expected: ['hello', 'world', 'go'],
    sample: 're.Split(s, -1)',
    hints: ['Split by regex pattern', '-1 for all splits'],
    tags: ['regexp', 'Split', 'whitespace'],
  },
  {
    id: 'go-regexp-349',
    category: 'Regexp Package',
    difficulty: 'medium',
    title: 'Find Match Index',
    text: 'Find the start and end index of first match.',
    setup: 'import "regexp"\nre := regexp.MustCompile(`\\d+`)\ns := "abc123def"',
    setupCode: 'import "regexp"\nre := regexp.MustCompile(`\\d+`)\ns := "abc123def"',
    expected: [3, 6],
    sample: 're.FindStringIndex(s)',
    hints: ['FindStringIndex returns [start, end]', 'nil if no match'],
    tags: ['regexp', 'FindStringIndex', 'index'],
  },

  // ============================================================
  // NEW PROBLEMS - Batch 13: Reflect Package
  // ============================================================

  {
    id: 'go-reflect-350',
    category: 'Reflect Package',
    difficulty: 'medium',
    title: 'Get Type of Value',
    text: 'Use reflect to get the type of a value.',
    setup: 'import "reflect"\nvar x int = 42',
    setupCode: 'import "reflect"\nvar x int = 42',
    expected: 'int',
    sample: 'reflect.TypeOf(x).String()',
    hints: ['TypeOf returns reflect.Type', 'String() gives type name'],
    tags: ['reflect', 'TypeOf', 'type'],
  },
  {
    id: 'go-reflect-351',
    category: 'Reflect Package',
    difficulty: 'medium',
    title: 'Get Value Kind',
    text: 'Get the kind of a value using reflect.',
    setup: 'import "reflect"\nvar s = "hello"',
    setupCode: 'import "reflect"\nvar s = "hello"',
    expected: 'string',
    sample: 'reflect.TypeOf(s).Kind().String()',
    hints: ['Kind is the underlying type', 'Different from named type'],
    tags: ['reflect', 'Kind', 'type'],
  },
  {
    id: 'go-reflect-352',
    category: 'Reflect Package',
    difficulty: 'medium',
    title: 'Get Reflect Value',
    text: 'Get the reflect.Value of a variable.',
    setup: 'import "reflect"\nvar n = 42',
    setupCode: 'import "reflect"\nvar n = 42',
    expected: '42',
    sample: 'reflect.ValueOf(n).Int()',
    hints: ['ValueOf returns reflect.Value', 'Use Int() for int values'],
    tags: ['reflect', 'ValueOf', 'value'],
  },
  {
    id: 'go-reflect-353',
    category: 'Reflect Package',
    difficulty: 'hard',
    title: 'Set Value via Reflect',
    text: 'Modify a value using reflection.',
    setup: 'import "reflect"\nvar n int = 10',
    setupCode: 'import "reflect"\nvar n int = 10',
    expected: 42,
    sample: 'v := reflect.ValueOf(&n).Elem(); v.SetInt(42)',
    hints: ['Need pointer for settable value', 'Use Elem() to dereference'],
    tags: ['reflect', 'SetInt', 'modify'],
  },
  {
    id: 'go-reflect-354',
    category: 'Reflect Package',
    difficulty: 'hard',
    title: 'Iterate Struct Fields',
    text: 'Iterate over struct fields using reflection.',
    setup:
      'import "reflect"\ntype Person struct { Name string; Age int }\np := Person{"Alice", 30}',
    setupCode:
      'import "reflect"\ntype Person struct { Name string; Age int }\np := Person{"Alice", 30}',
    expected: 'field names',
    sample:
      't := reflect.TypeOf(p); for i := 0; i < t.NumField(); i++ { fmt.Println(t.Field(i).Name) }',
    hints: ['NumField returns field count', 'Field(i) returns FieldInfo'],
    tags: ['reflect', 'struct', 'fields'],
  },
  {
    id: 'go-reflect-355',
    category: 'Reflect Package',
    difficulty: 'hard',
    title: 'Get Struct Tag',
    text: 'Get the json tag from a struct field.',
    setup: 'import "reflect"\ntype User struct { Name string `json:"name"` }',
    setupCode: 'import "reflect"\ntype User struct { Name string `json:"name"` }',
    expected: 'name',
    sample: 't := reflect.TypeOf(User{}); f, _ := t.FieldByName("Name"); f.Tag.Get("json")',
    hints: ['FieldByName finds field', 'Tag.Get gets specific tag'],
    tags: ['reflect', 'tag', 'struct'],
  },
  {
    id: 'go-reflect-356',
    category: 'Reflect Package',
    difficulty: 'hard',
    title: 'Check if Value is Nil',
    text: 'Check if an interface value is nil using reflect.',
    setup: 'import "reflect"\nvar p *int = nil',
    setupCode: 'import "reflect"\nvar p *int = nil',
    expected: true,
    sample: 'v := reflect.ValueOf(p); v.IsNil()',
    hints: ['IsNil checks for nil pointer', 'Only valid for pointer/chan/map/func'],
    tags: ['reflect', 'IsNil', 'nil'],
  },
  {
    id: 'go-reflect-357',
    category: 'Reflect Package',
    difficulty: 'hard',
    title: 'Call Method via Reflect',
    text: 'Call a method on an object using reflection.',
    setup:
      'import "reflect"\ntype Greeter struct{}\nfunc (g Greeter) Hello() string { return "Hi" }\ng := Greeter{}',
    setupCode:
      'import "reflect"\ntype Greeter struct{}\nfunc (g Greeter) Hello() string { return "Hi" }\ng := Greeter{}',
    expected: 'Hi',
    sample: 'v := reflect.ValueOf(g); m := v.MethodByName("Hello"); result := m.Call(nil)',
    hints: ['MethodByName finds method', 'Call invokes with args'],
    tags: ['reflect', 'Call', 'method'],
  },
  {
    id: 'go-reflect-358',
    category: 'Reflect Package',
    difficulty: 'medium',
    title: 'Create New Instance',
    text: 'Create a new instance of a type using reflect.',
    setup: 'import "reflect"\ntype Config struct { Value int }',
    setupCode: 'import "reflect"\ntype Config struct { Value int }',
    expected: 'new instance',
    sample: 't := reflect.TypeOf(Config{}); v := reflect.New(t)',
    hints: ['New creates pointer to new value', 'Returns reflect.Value'],
    tags: ['reflect', 'New', 'create'],
  },
  {
    id: 'go-reflect-359',
    category: 'Reflect Package',
    difficulty: 'hard',
    title: 'Deep Equal',
    text: 'Compare two values for deep equality.',
    setup: 'import "reflect"\na := []int{1, 2, 3}\nb := []int{1, 2, 3}',
    setupCode: 'import "reflect"\na := []int{1, 2, 3}\nb := []int{1, 2, 3}',
    expected: true,
    sample: 'reflect.DeepEqual(a, b)',
    hints: ['DeepEqual compares recursively', 'Works with any types'],
    tags: ['reflect', 'DeepEqual', 'compare'],
  },

  // ============================================================
  // NEW PROBLEMS - Batch 14: More Strconv
  // ============================================================

  {
    id: 'go-strconv-360',
    category: 'Strconv Package',
    difficulty: 'easy',
    title: 'Parse Integer Base 10',
    text: 'Parse a decimal string to integer using Atoi.',
    setup: 'import "strconv"\ns := "123"',
    setupCode: 'import "strconv"\ns := "123"',
    expected: 123,
    sample: 'n, err := strconv.Atoi(s)',
    hints: ['Atoi is shorthand for Atoi(s, 10, 0)', 'Returns (int, error)'],
    tags: ['strconv', 'Atoi', 'parse'],
  },
  {
    id: 'go-strconv-361',
    category: 'Strconv Package',
    difficulty: 'medium',
    title: 'Parse Octal Number',
    text: 'Parse an octal string "755" to integer.',
    setup: 'import "strconv"\ns := "755"',
    setupCode: 'import "strconv"\ns := "755"',
    expected: 493,
    sample: 'n, err := strconv.ParseInt(s, 8, 64)',
    hints: ['Base 8 for octal', 'ParseInt for non-decimal'],
    tags: ['strconv', 'ParseInt', 'octal'],
  },
  {
    id: 'go-strconv-362',
    category: 'Strconv Package',
    difficulty: 'medium',
    title: 'Format Integer as Hex',
    text: 'Format integer 255 as hexadecimal string.',
    setup: 'import "strconv"\nn := int64(255)',
    setupCode: 'import "strconv"\nn := int64(255)',
    expected: 'ff',
    sample: 'strconv.FormatInt(n, 16)',
    hints: ['FormatInt(n, base)', 'Base 16 for hex'],
    tags: ['strconv', 'FormatInt', 'hex'],
  },
  {
    id: 'go-strconv-363',
    category: 'Strconv Package',
    difficulty: 'medium',
    title: 'Parse Unsigned Integer',
    text: 'Parse an unsigned integer string.',
    setup: 'import "strconv"\ns := "4294967295"',
    setupCode: 'import "strconv"\ns := "4294967295"',
    expected: 4294967295,
    sample: 'n, err := strconv.ParseUint(s, 10, 64)',
    hints: ['ParseUint for unsigned', 'Returns (uint64, error)'],
    tags: ['strconv', 'ParseUint', 'unsigned'],
  },
  {
    id: 'go-strconv-364',
    category: 'Strconv Package',
    difficulty: 'hard',
    title: 'Format Float with Precision',
    text: 'Format float to string with exactly 2 decimal places.',
    setup: 'import "strconv"\nf := 3.14159',
    setupCode: 'import "strconv"\nf := 3.14159',
    expected: '3.14',
    sample: "strconv.FormatFloat(f, 'f', 2, 64)",
    hints: ['f format for decimal', 'Precision 2 for decimal places'],
    tags: ['strconv', 'FormatFloat', 'precision'],
  },
  {
    id: 'go-strconv-365',
    category: 'Strconv Package',
    difficulty: 'hard',
    title: 'Format Float in Scientific Notation',
    text: 'Format float in scientific notation.',
    setup: 'import "strconv"\nf := 12345.6789',
    setupCode: 'import "strconv"\nf := 12345.6789',
    expected: '1.23e+04',
    sample: "strconv.FormatFloat(f, 'e', 2, 64)",
    hints: ['e format for scientific', 'Precision controls significant digits'],
    tags: ['strconv', 'FormatFloat', 'scientific'],
  },
  {
    id: 'go-strconv-366',
    category: 'Strconv Package',
    difficulty: 'medium',
    title: 'Unquote String',
    text: 'Unquote a quoted string literal.',
    setup: 'import "strconv"\ns := `"hello\\nworld"`',
    setupCode: 'import "strconv"\ns := `"hello\\nworld"`',
    expected: 'hello\nworld',
    sample: 'strconv.Unquote(s)',
    hints: ['Unquote parses Go string literal', 'Handles escape sequences'],
    tags: ['strconv', 'Unquote', 'string'],
  },
  {
    id: 'go-strconv-367',
    category: 'Strconv Package',
    difficulty: 'easy',
    title: 'Append Integer to Bytes',
    text: 'Append integer to byte slice without allocation.',
    setup: 'import "strconv"\nbuf := []byte("count: ")',
    setupCode: 'import "strconv"\nbuf := []byte("count: ")',
    expected: 'count: 42',
    sample: 'buf = strconv.AppendInt(buf, 42, 10)',
    hints: ['AppendInt is efficient', 'Avoids string intermediate'],
    tags: ['strconv', 'AppendInt', 'efficient'],
  },
  {
    id: 'go-strconv-368',
    category: 'Strconv Package',
    difficulty: 'medium',
    title: 'Append Bool to Bytes',
    text: 'Append boolean to byte slice.',
    setup: 'import "strconv"\nbuf := []byte("enabled: ")',
    setupCode: 'import "strconv"\nbuf := []byte("enabled: ")',
    expected: 'enabled: true',
    sample: 'buf = strconv.AppendBool(buf, true)',
    hints: ['AppendBool appends "true" or "false"', 'More efficient than FormatBool'],
    tags: ['strconv', 'AppendBool', 'efficient'],
  },
  {
    id: 'go-strconv-369',
    category: 'Strconv Package',
    difficulty: 'hard',
    title: 'Check if Valid Integer',
    text: 'Check if string is a valid integer without converting.',
    setup: 'import "strconv"\ns := "12345"',
    setupCode: 'import "strconv"\ns := "12345"',
    expected: true,
    sample: '_, err := strconv.Atoi(s); err == nil',
    hints: ['Parse and check error', 'No direct validation function'],
    tags: ['strconv', 'validate', 'integer'],
  },

  // ============================================================
  // NEW PROBLEMS - Batch 15: More String Operations
  // ============================================================

  {
    id: 'go-str-370',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Compare Strings',
    text: 'Compare two strings for equality ignoring case.',
    setup: 'import "strings"\na := "Hello"\nb := "hello"',
    setupCode: 'import "strings"\na := "Hello"\nb := "hello"',
    expected: true,
    sample: 'strings.EqualFold(a, b)',
    hints: ['EqualFold is case-insensitive', 'More efficient than ToLower'],
    tags: ['strings', 'EqualFold', 'compare'],
  },
  {
    id: 'go-str-371',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Find Last Index',
    text: 'Find the last occurrence of substring.',
    setup: 'import "strings"\ns := "go go go"',
    setupCode: 'import "strings"\ns := "go go go"',
    expected: 6,
    sample: 'strings.LastIndex(s, "go")',
    hints: ['LastIndex searches from end', 'Returns -1 if not found'],
    tags: ['strings', 'LastIndex', 'search'],
  },
  {
    id: 'go-str-372',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Map String Characters',
    text: 'Transform each character using strings.Map.',
    setup: 'import "strings"\ns := "hello"',
    setupCode: 'import "strings"\ns := "hello"',
    expected: 'HELLO',
    sample: 'strings.Map(func(r rune) rune { return r - 32 }, s)',
    hints: ['Map applies function to each rune', 'Return -1 to delete rune'],
    tags: ['strings', 'Map', 'transform'],
  },
  {
    id: 'go-str-373',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Trim Left Characters',
    text: 'Remove leading dashes from string.',
    setup: 'import "strings"\ns := "---hello---"',
    setupCode: 'import "strings"\ns := "---hello---"',
    expected: 'hello---',
    sample: 'strings.TrimLeft(s, "-")',
    hints: ['TrimLeft removes from start', 'Cutset is chars to remove'],
    tags: ['strings', 'TrimLeft', 'trim'],
  },
  {
    id: 'go-str-374',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Trim Right Characters',
    text: 'Remove trailing dashes from string.',
    setup: 'import "strings"\ns := "---hello---"',
    setupCode: 'import "strings"\ns := "---hello---"',
    expected: '---hello',
    sample: 'strings.TrimRight(s, "-")',
    hints: ['TrimRight removes from end', 'Cutset is chars to remove'],
    tags: ['strings', 'TrimRight', 'trim'],
  },
  {
    id: 'go-str-375',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Trim Suffix',
    text: 'Remove file extension suffix.',
    setup: 'import "strings"\nfilename := "document.pdf"',
    setupCode: 'import "strings"\nfilename := "document.pdf"',
    expected: 'document',
    sample: 'strings.TrimSuffix(filename, ".pdf")',
    hints: ['TrimSuffix removes exact suffix', 'Returns original if no match'],
    tags: ['strings', 'TrimSuffix', 'trim'],
  },
  {
    id: 'go-str-376',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Split After N',
    text: 'Split string into at most N parts.',
    setup: 'import "strings"\ns := "a:b:c:d:e"',
    setupCode: 'import "strings"\ns := "a:b:c:d:e"',
    expected: ['a', 'b', 'c:d:e'],
    sample: 'strings.SplitN(s, ":", 3)',
    hints: ['SplitN limits number of parts', 'Last part contains remainder'],
    tags: ['strings', 'SplitN', 'split'],
  },
  {
    id: 'go-str-377',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Cut After',
    text: 'Cut string at last occurrence of separator.',
    setup: 'import "strings"\npath := "/home/user/docs/file.txt"',
    setupCode: 'import "strings"\npath := "/home/user/docs/file.txt"',
    expected: ['/home/user/docs', 'file.txt'],
    sample: 'before, after, _ := strings.Cut(path[strings.LastIndex(path, "/"):], "/")',
    hints: ['Combine LastIndex with Cut', 'Or use path.Split for paths'],
    tags: ['strings', 'Cut', 'LastIndex'],
  },
  {
    id: 'go-str-378',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Check Contains Any',
    text: 'Check if string contains any vowels.',
    setup: 'import "strings"\ns := "xyz"',
    setupCode: 'import "strings"\ns := "xyz"',
    expected: false,
    sample: 'strings.ContainsAny(s, "aeiou")',
    hints: ['ContainsAny checks for any char', 'Returns true if any char found'],
    tags: ['strings', 'ContainsAny', 'check'],
  },
  {
    id: 'go-str-379',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Index of Any Character',
    text: 'Find index of first vowel in string.',
    setup: 'import "strings"\ns := "rhythms"',
    setupCode: 'import "strings"\ns := "rhythms"',
    expected: -1,
    sample: 'strings.IndexAny(s, "aeiou")',
    hints: ['IndexAny finds first of any char', 'Returns -1 if none found'],
    tags: ['strings', 'IndexAny', 'search'],
  },
];

export default goProblems;
