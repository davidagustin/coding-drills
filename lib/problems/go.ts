/**
 * Go coding drill problems
 * Covers Slice, String, Map, and Sort operations
 */

import type { Problem } from '../types';

export const goProblems: Problem[] = [
  // ============================================================
  // Slice Operations
  // ============================================================

  // append()
  {
    id: 'go-slice-append-1',
    category: 'Slice Operations',
    difficulty: 'easy',
    title: 'Append Element to Slice',
    text: 'Use `append()` to add the number 4 to the slice.',
    setup: 'numbers := []int{1, 2, 3}',
    setupCode: 'numbers := []int{1, 2, 3}',
    expected: [1, 2, 3, 4],
    sample: 'append(numbers, 4)',
    hints: ['append returns a new slice', 'First arg is slice, rest are elements to add'],
    validPatterns: [/append\s*\(\s*numbers\s*,\s*4\s*\)/],
    tags: ['append', 'add', 'slice'],
  },
  {
    id: 'go-slice-append-2',
    category: 'Slice Operations',
    difficulty: 'easy',
    title: 'Append Multiple Elements',
    text: 'Use `append()` to add 4, 5, and 6 to the slice.',
    setup: 'numbers := []int{1, 2, 3}',
    setupCode: 'numbers := []int{1, 2, 3}',
    expected: [1, 2, 3, 4, 5, 6],
    sample: 'append(numbers, 4, 5, 6)',
    hints: ['append can take multiple values', 'All values are added at the end'],
    validPatterns: [/append\s*\(\s*numbers\s*,\s*4\s*,\s*5\s*,\s*6\s*\)/],
    tags: ['append', 'variadic', 'slice'],
  },
  {
    id: 'go-slice-append-3',
    category: 'Slice Operations',
    difficulty: 'medium',
    title: 'Append Slice to Slice',
    text: 'Use `append()` with variadic expansion (`...`) to combine two slices.',
    setup: 'a := []int{1, 2}\nb := []int{3, 4}',
    setupCode: 'a := []int{1, 2}\nb := []int{3, 4}',
    expected: [1, 2, 3, 4],
    sample: 'append(a, b...)',
    hints: ['Use ... to unpack a slice', 'This expands b into individual elements'],
    validPatterns: [/append\s*\(\s*a\s*,\s*b\s*\.\.\.\s*\)/],
    tags: ['append', 'spread', 'concat'],
  },

  // len() / cap()
  {
    id: 'go-slice-len-1',
    category: 'Slice Operations',
    difficulty: 'easy',
    title: 'Get Slice Length',
    text: 'Use `len()` to get the number of elements in the slice.',
    setup: 'numbers := []int{10, 20, 30, 40, 50}',
    setupCode: 'numbers := []int{10, 20, 30, 40, 50}',
    expected: 5,
    sample: 'len(numbers)',
    hints: ['len() returns the number of elements'],
    validPatterns: [/len\s*\(\s*numbers\s*\)/],
    tags: ['len', 'length', 'size'],
  },
  {
    id: 'go-slice-cap-1',
    category: 'Slice Operations',
    difficulty: 'medium',
    title: 'Get Slice Capacity',
    text: 'Use `cap()` to get the capacity of the slice.',
    setup: 'numbers := make([]int, 3, 10)',
    setupCode: 'numbers := make([]int, 3, 10)',
    expected: 10,
    sample: 'cap(numbers)',
    hints: ['cap() returns the capacity', 'Capacity is max elements before reallocation'],
    validPatterns: [/cap\s*\(\s*numbers\s*\)/],
    tags: ['cap', 'capacity'],
  },

  // copy()
  {
    id: 'go-slice-copy-1',
    category: 'Slice Operations',
    difficulty: 'medium',
    title: 'Copy Slice Elements',
    text: 'Use `copy()` to copy elements from src to dst. Return number copied.',
    setup: 'src := []int{1, 2, 3}\ndst := make([]int, 3)',
    setupCode: 'src := []int{1, 2, 3}\ndst := make([]int, 3)',
    expected: 3,
    sample: 'copy(dst, src)',
    hints: ['copy(dst, src) copies from src to dst', 'Returns number of elements copied'],
    validPatterns: [/copy\s*\(\s*dst\s*,\s*src\s*\)/],
    tags: ['copy', 'duplicate'],
  },
  {
    id: 'go-slice-copy-2',
    category: 'Slice Operations',
    difficulty: 'medium',
    title: 'Partial Copy',
    text: 'Copy only 2 elements from src to dst using copy().',
    setup: 'src := []int{1, 2, 3, 4, 5}\ndst := make([]int, 2)',
    setupCode: 'src := []int{1, 2, 3, 4, 5}\ndst := make([]int, 2)',
    expected: 2,
    sample: 'copy(dst, src)',
    hints: ['copy copies min(len(dst), len(src)) elements', 'dst length limits the copy'],
    validPatterns: [/copy\s*\(\s*dst\s*,\s*src\s*\)/, /copy\s*\(\s*dst\s*,\s*src\[:2\]\s*\)/],
    tags: ['copy', 'partial'],
  },

  // slicing [start:end]
  {
    id: 'go-slice-slicing-1',
    category: 'Slice Operations',
    difficulty: 'easy',
    title: 'Slice from Index',
    text: 'Get elements from index 2 to the end of the slice.',
    setup: 'numbers := []int{10, 20, 30, 40, 50}',
    setupCode: 'numbers := []int{10, 20, 30, 40, 50}',
    expected: [30, 40, 50],
    sample: 'numbers[2:]',
    hints: ['[start:] gives elements from start to end', 'Index is 0-based'],
    validPatterns: [/numbers\s*\[\s*2\s*:\s*\]/],
    tags: ['slice', 'range'],
  },
  {
    id: 'go-slice-slicing-2',
    category: 'Slice Operations',
    difficulty: 'easy',
    title: 'Slice to Index',
    text: 'Get the first 3 elements of the slice.',
    setup: 'numbers := []int{10, 20, 30, 40, 50}',
    setupCode: 'numbers := []int{10, 20, 30, 40, 50}',
    expected: [10, 20, 30],
    sample: 'numbers[:3]',
    hints: ['[:end] gives elements from 0 to end-1', 'End index is exclusive'],
    validPatterns: [/numbers\s*\[\s*:\s*3\s*\]/],
    tags: ['slice', 'range'],
  },
  {
    id: 'go-slice-slicing-3',
    category: 'Slice Operations',
    difficulty: 'easy',
    title: 'Slice Range',
    text: 'Get elements from index 1 to 3 (exclusive).',
    setup: 'numbers := []int{10, 20, 30, 40, 50}',
    setupCode: 'numbers := []int{10, 20, 30, 40, 50}',
    expected: [20, 30],
    sample: 'numbers[1:3]',
    hints: ['[start:end] gives elements from start to end-1', 'Both indices are provided'],
    validPatterns: [/numbers\s*\[\s*1\s*:\s*3\s*\]/],
    tags: ['slice', 'range', 'subslice'],
  },
  {
    id: 'go-slice-slicing-4',
    category: 'Slice Operations',
    difficulty: 'medium',
    title: 'Get Last Element',
    text: 'Get the last element of the slice using len().',
    setup: 'numbers := []int{10, 20, 30, 40, 50}',
    setupCode: 'numbers := []int{10, 20, 30, 40, 50}',
    expected: 50,
    sample: 'numbers[len(numbers)-1]',
    hints: ['Use len() to get the length', 'Last index is len - 1'],
    validPatterns: [/numbers\s*\[\s*len\s*\(\s*numbers\s*\)\s*-\s*1\s*\]/],
    tags: ['slice', 'last', 'len'],
  },

  // make()
  {
    id: 'go-slice-make-1',
    category: 'Slice Operations',
    difficulty: 'easy',
    title: 'Create Slice with make',
    text: 'Use `make()` to create an int slice with length 5.',
    setup: '// Create a slice of 5 integers',
    setupCode: '// Create a slice of 5 integers',
    expected: [0, 0, 0, 0, 0],
    sample: 'make([]int, 5)',
    hints: ['make(type, length) creates a slice', 'Elements are initialized to zero value'],
    validPatterns: [/make\s*\(\s*\[\s*\]\s*int\s*,\s*5\s*\)/],
    tags: ['make', 'create', 'initialize'],
  },
  {
    id: 'go-slice-make-2',
    category: 'Slice Operations',
    difficulty: 'medium',
    title: 'Create Slice with Capacity',
    text: 'Use `make()` to create a string slice with length 3 and capacity 10.',
    setup: '// Create a slice with specific length and capacity',
    setupCode: '// Create a slice with specific length and capacity',
    expected: 'make([]string, 3, 10)',
    sample: 'make([]string, 3, 10)',
    hints: ['make(type, length, capacity)', 'Capacity pre-allocates memory'],
    validPatterns: [/make\s*\(\s*\[\s*\]\s*string\s*,\s*3\s*,\s*10\s*\)/],
    tags: ['make', 'capacity', 'preallocate'],
  },

  // ============================================================
  // String Operations
  // ============================================================

  // strings.Split() / strings.Join()
  {
    id: 'go-string-split-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Split String by Separator',
    text: 'Use `strings.Split()` to split the string by spaces.',
    setup: 'import "strings"\ns := "hello world go"',
    setupCode: 'import "strings"\ns := "hello world go"',
    expected: ['hello', 'world', 'go'],
    sample: 'strings.Split(s, " ")',
    hints: ['strings.Split(str, separator)', 'Returns a slice of strings'],
    validPatterns: [/strings\.Split\s*\(\s*s\s*,\s*["'] ["']\s*\)/],
    tags: ['Split', 'tokenize', 'strings'],
  },
  {
    id: 'go-string-split-2',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Split by Comma',
    text: 'Use `strings.Split()` to split the CSV string.',
    setup: 'import "strings"\ncsv := "a,b,c,d"',
    setupCode: 'import "strings"\ncsv := "a,b,c,d"',
    expected: ['a', 'b', 'c', 'd'],
    sample: 'strings.Split(csv, ",")',
    hints: ['Use comma as separator'],
    validPatterns: [/strings\.Split\s*\(\s*csv\s*,\s*["'],["']\s*\)/],
    tags: ['Split', 'CSV'],
  },
  {
    id: 'go-string-join-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Join Strings with Separator',
    text: 'Use `strings.Join()` to combine the words with a dash.',
    setup: 'import "strings"\nwords := []string{"go", "is", "fun"}',
    setupCode: 'import "strings"\nwords := []string{"go", "is", "fun"}',
    expected: 'go-is-fun',
    sample: 'strings.Join(words, "-")',
    hints: ['strings.Join(slice, separator)', 'Returns a single string'],
    validPatterns: [/strings\.Join\s*\(\s*words\s*,\s*["']-["']\s*\)/],
    tags: ['Join', 'concatenate'],
  },

  // strings.Contains()
  {
    id: 'go-string-contains-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Check Substring',
    text: 'Use `strings.Contains()` to check if the string contains "world".',
    setup: 'import "strings"\ns := "hello world"',
    setupCode: 'import "strings"\ns := "hello world"',
    expected: true,
    sample: 'strings.Contains(s, "world")',
    hints: ['strings.Contains(str, substr)', 'Returns bool'],
    validPatterns: [/strings\.Contains\s*\(\s*s\s*,\s*["']world["']\s*\)/],
    tags: ['Contains', 'substring'],
  },

  // strings.HasPrefix() / strings.HasSuffix()
  {
    id: 'go-string-hasprefix-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Check String Prefix',
    text: 'Use `strings.HasPrefix()` to check if the string starts with "hello".',
    setup: 'import "strings"\ns := "hello world"',
    setupCode: 'import "strings"\ns := "hello world"',
    expected: true,
    sample: 'strings.HasPrefix(s, "hello")',
    hints: ['strings.HasPrefix(str, prefix)', 'Returns bool'],
    validPatterns: [/strings\.HasPrefix\s*\(\s*s\s*,\s*["']hello["']\s*\)/],
    tags: ['HasPrefix', 'prefix'],
  },
  {
    id: 'go-string-hassuffix-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Check String Suffix',
    text: 'Use `strings.HasSuffix()` to check if the string ends with ".go".',
    setup: 'import "strings"\nfilename := "main.go"',
    setupCode: 'import "strings"\nfilename := "main.go"',
    expected: true,
    sample: 'strings.HasSuffix(filename, ".go")',
    hints: ['strings.HasSuffix(str, suffix)', 'Returns bool'],
    validPatterns: [/strings\.HasSuffix\s*\(\s*filename\s*,\s*["']\.go["']\s*\)/],
    tags: ['HasSuffix', 'suffix'],
  },

  // strings.ToUpper() / strings.ToLower()
  {
    id: 'go-string-toupper-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Convert to Uppercase',
    text: 'Use `strings.ToUpper()` to convert the string to uppercase.',
    setup: 'import "strings"\ns := "hello"',
    setupCode: 'import "strings"\ns := "hello"',
    expected: 'HELLO',
    sample: 'strings.ToUpper(s)',
    hints: ['strings.ToUpper(str)', 'Returns uppercase string'],
    validPatterns: [/strings\.ToUpper\s*\(\s*s\s*\)/],
    tags: ['ToUpper', 'uppercase'],
  },
  {
    id: 'go-string-tolower-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Convert to Lowercase',
    text: 'Use `strings.ToLower()` to convert the string to lowercase.',
    setup: 'import "strings"\ns := "HELLO"',
    setupCode: 'import "strings"\ns := "HELLO"',
    expected: 'hello',
    sample: 'strings.ToLower(s)',
    hints: ['strings.ToLower(str)', 'Returns lowercase string'],
    validPatterns: [/strings\.ToLower\s*\(\s*s\s*\)/],
    tags: ['ToLower', 'lowercase'],
  },

  // strings.TrimSpace()
  {
    id: 'go-string-trimspace-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Trim Whitespace',
    text: 'Use `strings.TrimSpace()` to remove leading and trailing whitespace.',
    setup: 'import "strings"\ns := "  hello world  "',
    setupCode: 'import "strings"\ns := "  hello world  "',
    expected: 'hello world',
    sample: 'strings.TrimSpace(s)',
    hints: ['strings.TrimSpace(str)', 'Removes spaces, tabs, newlines'],
    validPatterns: [/strings\.TrimSpace\s*\(\s*s\s*\)/],
    tags: ['TrimSpace', 'trim'],
  },
  {
    id: 'go-string-trim-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Trim Specific Characters',
    text: 'Use `strings.Trim()` to remove leading/trailing dashes.',
    setup: 'import "strings"\ns := "--hello--"',
    setupCode: 'import "strings"\ns := "--hello--"',
    expected: 'hello',
    sample: 'strings.Trim(s, "-")',
    hints: ['strings.Trim(str, cutset)', 'cutset is characters to remove'],
    validPatterns: [/strings\.Trim\s*\(\s*s\s*,\s*["']-["']\s*\)/],
    tags: ['Trim', 'characters'],
  },

  // strings.Replace()
  {
    id: 'go-string-replace-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Replace All Occurrences',
    text: 'Use `strings.ReplaceAll()` to replace all spaces with underscores.',
    setup: 'import "strings"\ns := "hello world go"',
    setupCode: 'import "strings"\ns := "hello world go"',
    expected: 'hello_world_go',
    sample: 'strings.ReplaceAll(s, " ", "_")',
    hints: ['strings.ReplaceAll(str, old, new)', 'Replaces all occurrences'],
    validPatterns: [
      /strings\.ReplaceAll\s*\(\s*s\s*,\s*["'] ["']\s*,\s*["']_["']\s*\)/,
      /strings\.Replace\s*\(\s*s\s*,\s*["'] ["']\s*,\s*["']_["']\s*,\s*-1\s*\)/,
    ],
    tags: ['ReplaceAll', 'replace'],
  },
  {
    id: 'go-string-replace-2',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Replace First N Occurrences',
    text: 'Use `strings.Replace()` to replace only the first space.',
    setup: 'import "strings"\ns := "hello world go"',
    setupCode: 'import "strings"\ns := "hello world go"',
    expected: 'hello_world go',
    sample: 'strings.Replace(s, " ", "_", 1)',
    hints: ['strings.Replace(str, old, new, n)', 'n=1 replaces first occurrence'],
    validPatterns: [/strings\.Replace\s*\(\s*s\s*,\s*["'] ["']\s*,\s*["']_["']\s*,\s*1\s*\)/],
    tags: ['Replace', 'first'],
  },

  // len() for strings
  {
    id: 'go-string-len-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Get String Length',
    text: 'Use `len()` to get the byte length of the string.',
    setup: 's := "hello"',
    setupCode: 's := "hello"',
    expected: 5,
    sample: 'len(s)',
    hints: ['len() returns byte count for strings', 'ASCII chars are 1 byte each'],
    validPatterns: [/len\s*\(\s*s\s*\)/],
    tags: ['len', 'length', 'bytes'],
  },
  {
    id: 'go-string-rune-count-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Count Unicode Characters',
    text: 'Use `utf8.RuneCountInString()` to count Unicode characters.',
    setup: 'import "unicode/utf8"\ns := "Hello"',
    setupCode: 'import "unicode/utf8"\ns := "Hello"',
    expected: 5,
    sample: 'utf8.RuneCountInString(s)',
    hints: ['RuneCountInString counts runes not bytes', 'Important for Unicode strings'],
    validPatterns: [
      /utf8\.RuneCountInString\s*\(\s*s\s*\)/,
      /len\s*\(\s*\[\s*\]\s*rune\s*\(\s*s\s*\)\s*\)/,
    ],
    tags: ['rune', 'unicode', 'count'],
  },

  // string conversion
  {
    id: 'go-string-convert-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Convert Int to String',
    text: 'Use `strconv.Itoa()` to convert an integer to a string.',
    setup: 'import "strconv"\nn := 42',
    setupCode: 'import "strconv"\nn := 42',
    expected: '42',
    sample: 'strconv.Itoa(n)',
    hints: ['strconv.Itoa = Integer to ASCII', 'Returns string representation'],
    validPatterns: [/strconv\.Itoa\s*\(\s*n\s*\)/, /fmt\.Sprintf\s*\(\s*["']%d["']\s*,\s*n\s*\)/],
    tags: ['Itoa', 'convert', 'strconv'],
  },
  {
    id: 'go-string-convert-2',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Convert String to Int',
    text: 'Use `strconv.Atoi()` to convert a string to an integer. Handle the error.',
    setup: 'import "strconv"\ns := "42"',
    setupCode: 'import "strconv"\ns := "42"',
    expected: 42,
    sample: 'n, err := strconv.Atoi(s); if err != nil { panic(err) }; n',
    hints: ['strconv.Atoi = ASCII to Integer', 'Returns (int, error) - always check err'],
    validPatterns: [
      /strconv\.Atoi\s*\(\s*s\s*\)/,
      /\w+\s*,\s*(?:err|_)\s*:?=\s*strconv\.Atoi\s*\(\s*s\s*\)/,
    ],
    tags: ['Atoi', 'parse', 'strconv', 'error-handling'],
  },

  // ============================================================
  // Map Operations
  // ============================================================

  // make(map[K]V)
  {
    id: 'go-map-make-1',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Create Map with make',
    text: 'Use `make()` to create a map with string keys and int values.',
    setup: '// Create an empty map',
    setupCode: '// Create an empty map',
    expected: 'make(map[string]int)',
    sample: 'make(map[string]int)',
    hints: ['make(map[KeyType]ValueType)', 'Creates an empty initialized map'],
    validPatterns: [/make\s*\(\s*map\s*\[\s*string\s*\]\s*int\s*\)/],
    tags: ['make', 'map', 'create'],
  },
  {
    id: 'go-map-literal-1',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Map Literal',
    text: 'Create a map literal with "a": 1, "b": 2.',
    setup: '// Create a map with initial values',
    setupCode: '// Create a map with initial values',
    expected: { a: 1, b: 2 },
    sample: 'map[string]int{"a": 1, "b": 2}',
    hints: ['Use map[K]V{...} syntax', 'Key-value pairs separated by commas'],
    validPatterns: [
      /map\s*\[\s*string\s*\]\s*int\s*\{\s*["']a["']\s*:\s*1\s*,\s*["']b["']\s*:\s*2\s*\}/,
    ],
    tags: ['map', 'literal', 'initialize'],
  },

  // access / assignment
  {
    id: 'go-map-access-1',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Access Map Value',
    text: 'Access the value for key "name" from the map.',
    setup: 'm := map[string]string{"name": "Alice", "city": "NYC"}',
    setupCode: 'm := map[string]string{"name": "Alice", "city": "NYC"}',
    expected: 'Alice',
    sample: 'm["name"]',
    hints: ['Use m[key] to access values', 'Returns zero value if key missing'],
    validPatterns: [/m\s*\[\s*["']name["']\s*\]/],
    tags: ['map', 'access', 'read'],
  },
  {
    id: 'go-map-access-2',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Check Key Existence',
    text: 'Check if key "age" exists in the map using comma ok idiom.',
    setup: 'm := map[string]int{"score": 100, "level": 5}',
    setupCode: 'm := map[string]int{"score": 100, "level": 5}',
    expected: false,
    sample: '_, ok := m["age"]; ok',
    hints: ['Use v, ok := m[key]', 'ok is true if key exists, false otherwise'],
    validPatterns: [
      /_\s*,\s*ok\s*:=\s*m\s*\[\s*["']age["']\s*\]/,
      /if\s*_\s*,\s*ok\s*:=\s*m\s*\[\s*["']age["']\s*\]/,
    ],
    tags: ['map', 'exists', 'comma-ok'],
  },
  {
    id: 'go-map-assign-1',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Assign Map Value',
    text: 'Set the value for key "score" to 100.',
    setup: 'm := make(map[string]int)',
    setupCode: 'm := make(map[string]int)',
    expected: { score: 100 },
    sample: 'm["score"] = 100',
    hints: ['Use m[key] = value', 'Creates or updates the key'],
    validPatterns: [/m\s*\[\s*["']score["']\s*\]\s*=\s*100/],
    tags: ['map', 'assign', 'set'],
  },

  // delete()
  {
    id: 'go-map-delete-1',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Delete Map Entry',
    text: 'Use `delete()` to remove the "temp" key from the map.',
    setup: 'm := map[string]int{"score": 100, "temp": 50}',
    setupCode: 'm := map[string]int{"score": 100, "temp": 50}',
    expected: { score: 100 },
    sample: 'delete(m, "temp")',
    hints: ['delete(map, key)', 'No-op if key does not exist'],
    validPatterns: [/delete\s*\(\s*m\s*,\s*["']temp["']\s*\)/],
    tags: ['delete', 'remove', 'map'],
  },

  // range iteration
  {
    id: 'go-map-range-1',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Iterate Map with range',
    text: 'Use `range` to iterate over map keys and values.',
    setup: 'm := map[string]int{"a": 1, "b": 2}',
    setupCode: 'm := map[string]int{"a": 1, "b": 2}',
    expected: 'for k, v := range m',
    sample: 'for k, v := range m { fmt.Println(k, v) }',
    hints: ['for key, value := range map', 'Order is not guaranteed'],
    validPatterns: [/for\s+\w+\s*,\s*\w+\s*:=\s*range\s+m/],
    tags: ['range', 'iterate', 'loop'],
  },
  {
    id: 'go-map-range-2',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Iterate Map Keys Only',
    text: 'Use `range` to iterate over only the map keys.',
    setup: 'm := map[string]int{"a": 1, "b": 2}',
    setupCode: 'm := map[string]int{"a": 1, "b": 2}',
    expected: 'for k := range m',
    sample: 'for k := range m { fmt.Println(k) }',
    hints: ['for key := range map', 'Omit value variable'],
    validPatterns: [/for\s+\w+\s*:=\s*range\s+m/],
    tags: ['range', 'keys', 'loop'],
  },
  {
    id: 'go-map-len-1',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Get Map Length',
    text: 'Use `len()` to get the number of entries in the map.',
    setup: 'm := map[string]int{"a": 1, "b": 2, "c": 3}',
    setupCode: 'm := map[string]int{"a": 1, "b": 2, "c": 3}',
    expected: 3,
    sample: 'len(m)',
    hints: ['len() works on maps', 'Returns number of key-value pairs'],
    validPatterns: [/len\s*\(\s*m\s*\)/],
    tags: ['len', 'size', 'map'],
  },

  // ============================================================
  // Sort Package
  // ============================================================

  // sort.Ints()
  {
    id: 'go-sort-ints-1',
    category: 'Sort Package',
    difficulty: 'easy',
    title: 'Sort Integer Slice',
    text: 'Use `sort.Ints()` to sort the slice in ascending order.',
    setup: 'import "sort"\nnumbers := []int{5, 2, 8, 1, 9}',
    setupCode: 'import "sort"\nnumbers := []int{5, 2, 8, 1, 9}',
    expected: [1, 2, 5, 8, 9],
    sample: 'sort.Ints(numbers)',
    hints: ['sort.Ints(slice)', 'Sorts in place, ascending order'],
    validPatterns: [/sort\.Ints\s*\(\s*numbers\s*\)/],
    tags: ['sort', 'Ints', 'ascending'],
  },
  {
    id: 'go-sort-ints-2',
    category: 'Sort Package',
    difficulty: 'medium',
    title: 'Sort Integers Descending',
    text: 'Sort the slice in descending order using sort.Sort with Reverse.',
    setup: 'import "sort"\nnumbers := []int{5, 2, 8, 1, 9}',
    setupCode: 'import "sort"\nnumbers := []int{5, 2, 8, 1, 9}',
    expected: [9, 8, 5, 2, 1],
    sample: 'sort.Sort(sort.Reverse(sort.IntSlice(numbers)))',
    hints: ['Use sort.Reverse() wrapper', 'IntSlice converts []int to sortable'],
    validPatterns: [
      /sort\.Sort\s*\(\s*sort\.Reverse\s*\(\s*sort\.IntSlice\s*\(\s*numbers\s*\)\s*\)\s*\)/,
    ],
    tags: ['sort', 'descending', 'Reverse'],
  },

  // sort.Strings()
  {
    id: 'go-sort-strings-1',
    category: 'Sort Package',
    difficulty: 'easy',
    title: 'Sort String Slice',
    text: 'Use `sort.Strings()` to sort the slice alphabetically.',
    setup: 'import "sort"\nwords := []string{"go", "python", "java", "rust"}',
    setupCode: 'import "sort"\nwords := []string{"go", "python", "java", "rust"}',
    expected: ['go', 'java', 'python', 'rust'],
    sample: 'sort.Strings(words)',
    hints: ['sort.Strings(slice)', 'Sorts alphabetically in place'],
    validPatterns: [/sort\.Strings\s*\(\s*words\s*\)/],
    tags: ['sort', 'Strings', 'alphabetical'],
  },

  // sort.Slice()
  {
    id: 'go-sort-slice-1',
    category: 'Sort Package',
    difficulty: 'medium',
    title: 'Custom Sort with sort.Slice',
    text: 'Use `sort.Slice()` to sort by string length (shortest first).',
    setup: 'import "sort"\nwords := []string{"golang", "is", "awesome"}',
    setupCode: 'import "sort"\nwords := []string{"golang", "is", "awesome"}',
    expected: ['is', 'golang', 'awesome'],
    sample: 'sort.Slice(words, func(i, j int) bool { return len(words[i]) < len(words[j]) })',
    hints: ['sort.Slice(slice, lessFn)', 'lessFn returns true if i should come before j'],
    validPatterns: [
      /sort\.Slice\s*\(\s*words\s*,\s*func\s*\(\s*i\s*,\s*j\s+int\s*\)\s*bool\s*\{\s*return\s+len\s*\(\s*words\s*\[\s*i\s*\]\s*\)\s*<\s*len\s*\(\s*words\s*\[\s*j\s*\]\s*\)/,
    ],
    tags: ['sort', 'Slice', 'custom'],
  },
  {
    id: 'go-sort-slice-2',
    category: 'Sort Package',
    difficulty: 'medium',
    title: 'Sort Structs by Field',
    text: 'Use `sort.Slice()` to sort people by age.',
    setup:
      'import "sort"\ntype Person struct { Name string; Age int }\npeople := []Person{{"Alice", 30}, {"Bob", 25}, {"Carol", 35}}',
    setupCode:
      'import "sort"\ntype Person struct { Name string; Age int }\npeople := []Person{{"Alice", 30}, {"Bob", 25}, {"Carol", 35}}',
    expected: [
      { Name: 'Bob', Age: 25 },
      { Name: 'Alice', Age: 30 },
      { Name: 'Carol', Age: 35 },
    ],
    sample: 'sort.Slice(people, func(i, j int) bool { return people[i].Age < people[j].Age })',
    hints: ['Access struct fields in comparison', 'Compare .Age for sorting'],
    validPatterns: [
      /sort\.Slice\s*\(\s*people\s*,\s*func\s*\(\s*i\s*,\s*j\s+int\s*\)\s*bool\s*\{\s*return\s+people\s*\[\s*i\s*\]\.Age\s*<\s*people\s*\[\s*j\s*\]\.Age/,
    ],
    tags: ['sort', 'struct', 'custom'],
  },

  // sort.SearchInts() - binary search
  {
    id: 'go-sort-search-1',
    category: 'Sort Package',
    difficulty: 'medium',
    title: 'Binary Search in Sorted Slice',
    text: 'Use `sort.SearchInts()` to find the index where 5 should be inserted.',
    setup: 'import "sort"\nnumbers := []int{1, 3, 5, 7, 9}',
    setupCode: 'import "sort"\nnumbers := []int{1, 3, 5, 7, 9}',
    expected: 2,
    sample: 'sort.SearchInts(numbers, 5)',
    hints: ['sort.SearchInts(slice, value)', 'Slice must be sorted', 'Returns insertion index'],
    validPatterns: [/sort\.SearchInts\s*\(\s*numbers\s*,\s*5\s*\)/],
    tags: ['search', 'binary', 'SearchInts'],
  },

  // sort.IsSorted()
  {
    id: 'go-sort-issorted-1',
    category: 'Sort Package',
    difficulty: 'easy',
    title: 'Check if Slice is Sorted',
    text: 'Use `sort.IntsAreSorted()` to check if the slice is sorted.',
    setup: 'import "sort"\nnumbers := []int{1, 2, 3, 4, 5}',
    setupCode: 'import "sort"\nnumbers := []int{1, 2, 3, 4, 5}',
    expected: true,
    sample: 'sort.IntsAreSorted(numbers)',
    hints: ['sort.IntsAreSorted(slice)', 'Returns true if ascending order'],
    validPatterns: [/sort\.IntsAreSorted\s*\(\s*numbers\s*\)/],
    tags: ['sort', 'check', 'IsSorted'],
  },

  // Additional utility problems
  {
    id: 'go-slice-remove-1',
    category: 'Slice Operations',
    difficulty: 'hard',
    title: 'Remove Element from Slice',
    text: 'Remove the element at index 2 from the slice using append.',
    setup: 'numbers := []int{1, 2, 3, 4, 5}',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5}',
    expected: [1, 2, 4, 5],
    sample: 'append(numbers[:2], numbers[3:]...)',
    hints: [
      'Combine slice before and after index',
      'Use append with ... to unpack',
      'In Go 1.21+ consider slices.Delete()',
    ],
    validPatterns: [
      /append\s*\(\s*numbers\s*\[\s*:\s*2\s*\]\s*,\s*numbers\s*\[\s*3\s*:\s*\]\s*\.\.\.\s*\)/,
      /slices\.Delete\s*\(\s*numbers\s*,\s*2\s*,\s*3\s*\)/,
    ],
    tags: ['slice', 'remove', 'append'],
  },
  {
    id: 'go-slice-insert-1',
    category: 'Slice Operations',
    difficulty: 'hard',
    title: 'Insert Element into Slice',
    text: 'Insert 99 at index 2 in the slice.',
    setup: 'numbers := []int{1, 2, 3, 4}',
    setupCode: 'numbers := []int{1, 2, 3, 4}',
    expected: [1, 2, 99, 3, 4],
    sample: 'append(numbers[:2], append([]int{99}, numbers[2:]...)...)',
    hints: [
      'Create slice with new element',
      'Append rest of original slice',
      'In Go 1.21+ consider slices.Insert()',
    ],
    validPatterns: [
      /append\s*\(\s*numbers\s*\[\s*:\s*2\s*\]\s*,\s*append\s*\(\s*\[\s*\]\s*int\s*\{\s*99\s*\}\s*,\s*numbers\s*\[\s*2\s*:\s*\]\s*\.\.\.\s*\)\s*\.\.\.\s*\)/,
      /slices\.Insert\s*\(\s*numbers\s*,\s*2\s*,\s*99\s*\)/,
    ],
    tags: ['slice', 'insert', 'append'],
  },

  // ============================================================
  // Go 1.21+ slices Package
  // ============================================================

  {
    id: 'go-slices-contains-1',
    category: 'Slices Package (Go 1.21+)',
    difficulty: 'easy',
    title: 'Check if Slice Contains Value',
    text: 'Use `slices.Contains()` to check if the slice contains 3.',
    setup: 'import "slices"\nnumbers := []int{1, 2, 3, 4, 5}',
    setupCode: 'import "slices"\nnumbers := []int{1, 2, 3, 4, 5}',
    expected: true,
    sample: 'slices.Contains(numbers, 3)',
    hints: ['slices.Contains(slice, value)', 'Returns bool'],
    validPatterns: [/slices\.Contains\s*\(\s*numbers\s*,\s*3\s*\)/],
    tags: ['slices', 'contains', 'Go1.21'],
  },
  {
    id: 'go-slices-index-1',
    category: 'Slices Package (Go 1.21+)',
    difficulty: 'easy',
    title: 'Find Index of Value',
    text: 'Use `slices.Index()` to find the index of value 30.',
    setup: 'import "slices"\nnumbers := []int{10, 20, 30, 40}',
    setupCode: 'import "slices"\nnumbers := []int{10, 20, 30, 40}',
    expected: 2,
    sample: 'slices.Index(numbers, 30)',
    hints: ['slices.Index(slice, value)', 'Returns -1 if not found'],
    validPatterns: [/slices\.Index\s*\(\s*numbers\s*,\s*30\s*\)/],
    tags: ['slices', 'index', 'find', 'Go1.21'],
  },
  {
    id: 'go-slices-reverse-1',
    category: 'Slices Package (Go 1.21+)',
    difficulty: 'easy',
    title: 'Reverse Slice In-Place',
    text: 'Use `slices.Reverse()` to reverse the slice in place.',
    setup: 'import "slices"\nnumbers := []int{1, 2, 3, 4, 5}',
    setupCode: 'import "slices"\nnumbers := []int{1, 2, 3, 4, 5}',
    expected: [5, 4, 3, 2, 1],
    sample: 'slices.Reverse(numbers)',
    hints: ['slices.Reverse modifies in place', 'No return value'],
    validPatterns: [/slices\.Reverse\s*\(\s*numbers\s*\)/],
    tags: ['slices', 'reverse', 'Go1.21'],
  },
  {
    id: 'go-slices-sort-1',
    category: 'Slices Package (Go 1.21+)',
    difficulty: 'easy',
    title: 'Sort Slice with slices.Sort',
    text: 'Use `slices.Sort()` to sort the slice.',
    setup: 'import "slices"\nnumbers := []int{5, 2, 8, 1, 9}',
    setupCode: 'import "slices"\nnumbers := []int{5, 2, 8, 1, 9}',
    expected: [1, 2, 5, 8, 9],
    sample: 'slices.Sort(numbers)',
    hints: ['slices.Sort is simpler than sort.Ints', 'Works with any ordered type'],
    validPatterns: [/slices\.Sort\s*\(\s*numbers\s*\)/],
    tags: ['slices', 'sort', 'Go1.21'],
  },
  {
    id: 'go-slices-max-1',
    category: 'Slices Package (Go 1.21+)',
    difficulty: 'easy',
    title: 'Find Maximum Value',
    text: 'Use `slices.Max()` to find the maximum value in the slice.',
    setup: 'import "slices"\nnumbers := []int{5, 2, 8, 1, 9}',
    setupCode: 'import "slices"\nnumbers := []int{5, 2, 8, 1, 9}',
    expected: 9,
    sample: 'slices.Max(numbers)',
    hints: ['slices.Max returns the largest element', 'Panics on empty slice'],
    validPatterns: [/slices\.Max\s*\(\s*numbers\s*\)/],
    tags: ['slices', 'max', 'Go1.21'],
  },
  {
    id: 'go-slices-min-1',
    category: 'Slices Package (Go 1.21+)',
    difficulty: 'easy',
    title: 'Find Minimum Value',
    text: 'Use `slices.Min()` to find the minimum value in the slice.',
    setup: 'import "slices"\nnumbers := []int{5, 2, 8, 1, 9}',
    setupCode: 'import "slices"\nnumbers := []int{5, 2, 8, 1, 9}',
    expected: 1,
    sample: 'slices.Min(numbers)',
    hints: ['slices.Min returns the smallest element', 'Panics on empty slice'],
    validPatterns: [/slices\.Min\s*\(\s*numbers\s*\)/],
    tags: ['slices', 'min', 'Go1.21'],
  },
  {
    id: 'go-slices-clone-1',
    category: 'Slices Package (Go 1.21+)',
    difficulty: 'easy',
    title: 'Clone a Slice',
    text: 'Use `slices.Clone()` to create a copy of the slice.',
    setup: 'import "slices"\noriginal := []int{1, 2, 3}',
    setupCode: 'import "slices"\noriginal := []int{1, 2, 3}',
    expected: [1, 2, 3],
    sample: 'slices.Clone(original)',
    hints: ['slices.Clone creates a shallow copy', 'Changes to clone do not affect original'],
    validPatterns: [/slices\.Clone\s*\(\s*original\s*\)/],
    tags: ['slices', 'clone', 'copy', 'Go1.21'],
  },

  // ============================================================
  // Go 1.21+ maps Package
  // ============================================================

  {
    id: 'go-maps-clone-1',
    category: 'Maps Package (Go 1.21+)',
    difficulty: 'easy',
    title: 'Clone a Map',
    text: 'Use `maps.Clone()` to create a shallow copy of the map.',
    setup: 'import "maps"\noriginal := map[string]int{"a": 1, "b": 2}',
    setupCode: 'import "maps"\noriginal := map[string]int{"a": 1, "b": 2}',
    expected: { a: 1, b: 2 },
    sample: 'maps.Clone(original)',
    hints: ['maps.Clone creates a shallow copy', 'Modifying clone does not affect original'],
    validPatterns: [/maps\.Clone\s*\(\s*original\s*\)/],
    tags: ['maps', 'clone', 'copy', 'Go1.21'],
  },
  {
    id: 'go-maps-keys-1',
    category: 'Maps Package (Go 1.23+)',
    difficulty: 'easy',
    title: 'Get Map Keys',
    text: 'Use `maps.Keys()` to get all keys from the map as an iterator.',
    setup: 'import "maps"\nimport "slices"\nm := map[string]int{"a": 1, "b": 2, "c": 3}',
    setupCode: 'import "maps"\nimport "slices"\nm := map[string]int{"a": 1, "b": 2, "c": 3}',
    expected: 'slices.Collect(maps.Keys(m))',
    sample: 'slices.Collect(maps.Keys(m))',
    hints: ['maps.Keys returns an iterator', 'Use slices.Collect to get a slice'],
    validPatterns: [
      /slices\.Collect\s*\(\s*maps\.Keys\s*\(\s*m\s*\)\s*\)/,
      /maps\.Keys\s*\(\s*m\s*\)/,
    ],
    tags: ['maps', 'keys', 'iterator', 'Go1.23'],
  },

  // ============================================================
  // Error Handling Patterns
  // ============================================================

  {
    id: 'go-error-wrap-1',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Wrap Error with Context',
    text: 'Use `fmt.Errorf()` with %w to wrap an error with context.',
    setup: 'import "fmt"\nimport "errors"\noriginalErr := errors.New("file not found")',
    setupCode: 'import "fmt"\nimport "errors"\noriginalErr := errors.New("file not found")',
    expected: 'wrapped error',
    sample: 'fmt.Errorf("failed to open config: %w", originalErr)',
    hints: ['Use %w verb to wrap errors', 'Preserves original error for errors.Is/As'],
    validPatterns: [/fmt\.Errorf\s*\([^)]*%w[^)]*,\s*originalErr\s*\)/],
    tags: ['error', 'wrap', 'fmt.Errorf'],
  },
  {
    id: 'go-error-is-1',
    category: 'Error Handling',
    difficulty: 'medium',
    title: 'Check Error Type with errors.Is',
    text: 'Use `errors.Is()` to check if err matches os.ErrNotExist.',
    setup: 'import "errors"\nimport "os"\nerr := os.ErrNotExist',
    setupCode: 'import "errors"\nimport "os"\nerr := os.ErrNotExist',
    expected: true,
    sample: 'errors.Is(err, os.ErrNotExist)',
    hints: ['errors.Is checks error chain', 'Works with wrapped errors'],
    validPatterns: [/errors\.Is\s*\(\s*err\s*,\s*os\.ErrNotExist\s*\)/],
    tags: ['error', 'errors.Is', 'sentinel'],
  },
  {
    id: 'go-error-new-1',
    category: 'Error Handling',
    difficulty: 'easy',
    title: 'Create Simple Error',
    text: 'Use `errors.New()` to create a simple error with a message.',
    setup: 'import "errors"',
    setupCode: 'import "errors"',
    expected: 'invalid input',
    sample: 'errors.New("invalid input")',
    hints: ['errors.New creates a simple error', 'For formatted errors use fmt.Errorf'],
    validPatterns: [/errors\.New\s*\(\s*["']invalid input["']\s*\)/],
    tags: ['error', 'errors.New', 'create'],
  },

  // ============================================================
  // Built-in Functions
  // ============================================================

  {
    id: 'go-builtin-clear-1',
    category: 'Built-in Functions (Go 1.21+)',
    difficulty: 'easy',
    title: 'Clear Map',
    text: 'Use `clear()` to remove all entries from the map.',
    setup: 'm := map[string]int{"a": 1, "b": 2, "c": 3}',
    setupCode: 'm := map[string]int{"a": 1, "b": 2, "c": 3}',
    expected: {},
    sample: 'clear(m)',
    hints: ['clear() removes all map entries', 'Map is still usable after clear'],
    validPatterns: [/clear\s*\(\s*m\s*\)/],
    tags: ['clear', 'map', 'builtin', 'Go1.21'],
  },
  {
    id: 'go-builtin-clear-2',
    category: 'Built-in Functions (Go 1.21+)',
    difficulty: 'easy',
    title: 'Clear Slice',
    text: 'Use `clear()` to zero all elements in the slice.',
    setup: 'numbers := []int{1, 2, 3, 4, 5}',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5}',
    expected: [0, 0, 0, 0, 0],
    sample: 'clear(numbers)',
    hints: ['clear() sets slice elements to zero value', 'Length remains the same'],
    validPatterns: [/clear\s*\(\s*numbers\s*\)/],
    tags: ['clear', 'slice', 'builtin', 'Go1.21'],
  },
  {
    id: 'go-builtin-max-1',
    category: 'Built-in Functions (Go 1.21+)',
    difficulty: 'easy',
    title: 'Get Maximum of Values',
    text: 'Use `max()` to get the maximum of three integers.',
    setup: 'a, b, c := 10, 25, 15',
    setupCode: 'a, b, c := 10, 25, 15',
    expected: 25,
    sample: 'max(a, b, c)',
    hints: ['max() is a built-in since Go 1.21', 'Works with any ordered type'],
    validPatterns: [/max\s*\(\s*a\s*,\s*b\s*,\s*c\s*\)/],
    tags: ['max', 'builtin', 'Go1.21'],
  },
  {
    id: 'go-builtin-min-1',
    category: 'Built-in Functions (Go 1.21+)',
    difficulty: 'easy',
    title: 'Get Minimum of Values',
    text: 'Use `min()` to get the minimum of three integers.',
    setup: 'a, b, c := 10, 25, 15',
    setupCode: 'a, b, c := 10, 25, 15',
    expected: 10,
    sample: 'min(a, b, c)',
    hints: ['min() is a built-in since Go 1.21', 'Works with any ordered type'],
    validPatterns: [/min\s*\(\s*a\s*,\s*b\s*,\s*c\s*\)/],
    tags: ['min', 'builtin', 'Go1.21'],
  },

  // ============================================================
  // fmt Package
  // ============================================================

  {
    id: 'go-fmt-sprintf-1',
    category: 'fmt Package',
    difficulty: 'easy',
    title: 'Format String with Sprintf',
    text: 'Use `fmt.Sprintf()` to format name and age into a string.',
    setup: 'import "fmt"\nname := "Alice"\nage := 30',
    setupCode: 'import "fmt"\nname := "Alice"\nage := 30',
    expected: 'Alice is 30 years old',
    sample: 'fmt.Sprintf("%s is %d years old", name, age)',
    hints: ['%s for strings, %d for integers', 'Returns formatted string'],
    validPatterns: [/fmt\.Sprintf\s*\(\s*["']%s is %d years old["']\s*,\s*name\s*,\s*age\s*\)/],
    tags: ['fmt', 'Sprintf', 'format'],
  },
  {
    id: 'go-fmt-sprintf-2',
    category: 'fmt Package',
    difficulty: 'medium',
    title: 'Format with Type Representation',
    text: 'Use `fmt.Sprintf()` with %T to get the type of a variable.',
    setup: 'import "fmt"\nvalue := 3.14',
    setupCode: 'import "fmt"\nvalue := 3.14',
    expected: 'float64',
    sample: 'fmt.Sprintf("%T", value)',
    hints: ['%T prints the type of a value', 'Useful for debugging'],
    validPatterns: [/fmt\.Sprintf\s*\(\s*["']%T["']\s*,\s*value\s*\)/],
    tags: ['fmt', 'Sprintf', 'type'],
  },
  {
    id: 'go-fmt-sprintf-3',
    category: 'fmt Package',
    difficulty: 'medium',
    title: 'Format with Go Syntax',
    text: 'Use `fmt.Sprintf()` with %#v for Go-syntax representation.',
    setup: 'import "fmt"\ndata := []int{1, 2, 3}',
    setupCode: 'import "fmt"\ndata := []int{1, 2, 3}',
    expected: '[]int{1, 2, 3}',
    sample: 'fmt.Sprintf("%#v", data)',
    hints: ['%#v shows Go syntax representation', 'Useful for debugging complex types'],
    validPatterns: [/fmt\.Sprintf\s*\(\s*["']%#v["']\s*,\s*data\s*\)/],
    tags: ['fmt', 'Sprintf', 'debug'],
  },

  // ============================================================
  // Additional Slice Operations
  // ============================================================

  {
    id: 'go-slice-append-prepend-1',
    category: 'Slice Operations',
    difficulty: 'medium',
    title: 'Prepend Element to Slice',
    text: 'Use `append()` to add 0 at the beginning of the slice.',
    setup: 'numbers := []int{1, 2, 3}',
    setupCode: 'numbers := []int{1, 2, 3}',
    expected: [0, 1, 2, 3],
    sample: 'append([]int{0}, numbers...)',
    hints: ['Create a new slice with the element', 'Append the original slice using ...'],
    validPatterns: [/append\s*\(\s*\[\s*\]\s*int\s*\{\s*0\s*\}\s*,\s*numbers\s*\.\.\.\s*\)/],
    tags: ['append', 'prepend', 'slice'],
  },
  {
    id: 'go-slice-filter-1',
    category: 'Slice Operations',
    difficulty: 'hard',
    title: 'Filter Slice In-Place',
    text: 'Filter the slice to keep only even numbers using a for loop and slicing.',
    setup: 'numbers := []int{1, 2, 3, 4, 5, 6}',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5, 6}',
    expected: [2, 4, 6],
    sample:
      'result := numbers[:0]; for _, n := range numbers { if n%2 == 0 { result = append(result, n) } }',
    hints: [
      'Use numbers[:0] to reuse underlying array',
      'Append only elements that pass the filter',
      'This avoids extra allocation',
    ],
    validPatterns: [/numbers\s*\[\s*:\s*0\s*\]/, /for\s+.*range\s+numbers/, /n\s*%\s*2\s*==\s*0/],
    tags: ['slice', 'filter', 'in-place'],
  },
  {
    id: 'go-slice-make-zero-1',
    category: 'Slice Operations',
    difficulty: 'easy',
    title: 'Create Empty Slice with Capacity',
    text: 'Use `make()` to create an empty int slice with capacity 10.',
    setup: '// Create slice with length 0 but capacity 10',
    setupCode: '// Create slice with length 0 but capacity 10',
    expected: 'make([]int, 0, 10)',
    sample: 'make([]int, 0, 10)',
    hints: ['make(type, length, capacity)', 'Length 0 means empty slice'],
    validPatterns: [/make\s*\(\s*\[\s*\]\s*int\s*,\s*0\s*,\s*10\s*\)/],
    tags: ['make', 'capacity', 'empty'],
  },
  {
    id: 'go-slice-grow-1',
    category: 'Slice Operations',
    difficulty: 'medium',
    title: 'Grow Slice Capacity',
    text: 'Use `slices.Grow()` to ensure the slice has room for 100 more elements.',
    setup: 'import "slices"\nnumbers := []int{1, 2, 3}',
    setupCode: 'import "slices"\nnumbers := []int{1, 2, 3}',
    expected: 'slices.Grow(numbers, 100)',
    sample: 'slices.Grow(numbers, 100)',
    hints: ['slices.Grow increases capacity', 'Does not change length'],
    validPatterns: [/slices\.Grow\s*\(\s*numbers\s*,\s*100\s*\)/],
    tags: ['slices', 'grow', 'capacity', 'Go1.21'],
  },
  {
    id: 'go-slice-compact-1',
    category: 'Slice Operations',
    difficulty: 'medium',
    title: 'Remove Consecutive Duplicates',
    text: 'Use `slices.Compact()` to remove consecutive duplicate elements.',
    setup: 'import "slices"\nnumbers := []int{1, 1, 2, 2, 2, 3, 3}',
    setupCode: 'import "slices"\nnumbers := []int{1, 1, 2, 2, 2, 3, 3}',
    expected: [1, 2, 3],
    sample: 'slices.Compact(numbers)',
    hints: ['Compact removes consecutive duplicates', 'Slice must be sorted for full dedup'],
    validPatterns: [/slices\.Compact\s*\(\s*numbers\s*\)/],
    tags: ['slices', 'compact', 'dedupe', 'Go1.21'],
  },

  // ============================================================
  // Additional String Functions (strings package)
  // ============================================================

  {
    id: 'go-string-repeat-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Repeat String',
    text: 'Use `strings.Repeat()` to repeat the string 3 times.',
    setup: 'import "strings"\ns := "go"',
    setupCode: 'import "strings"\ns := "go"',
    expected: 'gogogo',
    sample: 'strings.Repeat(s, 3)',
    hints: ['strings.Repeat(str, count)', 'Returns concatenated string'],
    validPatterns: [/strings\.Repeat\s*\(\s*s\s*,\s*3\s*\)/],
    tags: ['Repeat', 'strings', 'multiply'],
  },
  {
    id: 'go-string-count-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Count Substring Occurrences',
    text: 'Use `strings.Count()` to count how many times "o" appears.',
    setup: 'import "strings"\ns := "hello world foo"',
    setupCode: 'import "strings"\ns := "hello world foo"',
    expected: 4,
    sample: 'strings.Count(s, "o")',
    hints: ['strings.Count(str, substr)', 'Returns number of non-overlapping occurrences'],
    validPatterns: [/strings\.Count\s*\(\s*s\s*,\s*["']o["']\s*\)/],
    tags: ['Count', 'strings', 'occurrences'],
  },
  {
    id: 'go-string-index-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Find Substring Index',
    text: 'Use `strings.Index()` to find the first occurrence of "world".',
    setup: 'import "strings"\ns := "hello world"',
    setupCode: 'import "strings"\ns := "hello world"',
    expected: 6,
    sample: 'strings.Index(s, "world")',
    hints: ['strings.Index(str, substr)', 'Returns -1 if not found'],
    validPatterns: [/strings\.Index\s*\(\s*s\s*,\s*["']world["']\s*\)/],
    tags: ['Index', 'strings', 'find'],
  },
  {
    id: 'go-string-fields-1',
    category: 'String Operations',
    difficulty: 'easy',
    title: 'Split on Whitespace',
    text: 'Use `strings.Fields()` to split the string by whitespace.',
    setup: 'import "strings"\ns := "  hello   world   go  "',
    setupCode: 'import "strings"\ns := "  hello   world   go  "',
    expected: ['hello', 'world', 'go'],
    sample: 'strings.Fields(s)',
    hints: ['Fields splits on any whitespace', 'Handles multiple spaces'],
    validPatterns: [/strings\.Fields\s*\(\s*s\s*\)/],
    tags: ['Fields', 'strings', 'split', 'whitespace'],
  },
  {
    id: 'go-string-trimprefix-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Trim Prefix from String',
    text: 'Use `strings.TrimPrefix()` to remove the "https://" prefix.',
    setup: 'import "strings"\nurl := "https://example.com"',
    setupCode: 'import "strings"\nurl := "https://example.com"',
    expected: 'example.com',
    sample: 'strings.TrimPrefix(url, "https://")',
    hints: ['TrimPrefix removes prefix if present', 'Returns original if no match'],
    validPatterns: [/strings\.TrimPrefix\s*\(\s*url\s*,\s*["']https:\/\/["']\s*\)/],
    tags: ['TrimPrefix', 'strings', 'trim'],
  },
  {
    id: 'go-string-cut-1',
    category: 'String Operations',
    difficulty: 'medium',
    title: 'Cut String at Separator',
    text: 'Use `strings.Cut()` to split the string at the first "=" sign.',
    setup: 'import "strings"\ns := "key=value=extra"',
    setupCode: 'import "strings"\ns := "key=value=extra"',
    expected: ['key', 'value=extra', true],
    sample: 'before, after, found := strings.Cut(s, "=")',
    hints: ['Cut splits at first occurrence', 'Returns before, after, and found bool'],
    validPatterns: [/strings\.Cut\s*\(\s*s\s*,\s*["']=["']\s*\)/],
    tags: ['Cut', 'strings', 'split', 'Go1.18'],
  },
  {
    id: 'go-string-builder-1',
    category: 'String Operations',
    difficulty: 'hard',
    title: 'Build String Efficiently',
    text: 'Use `strings.Builder` to efficiently concatenate strings.',
    setup: 'import "strings"\nwords := []string{"Go", "is", "fast"}',
    setupCode: 'import "strings"\nwords := []string{"Go", "is", "fast"}',
    expected: 'Go is fast',
    sample:
      'var b strings.Builder; for i, w := range words { if i > 0 { b.WriteString(" ") }; b.WriteString(w) }; b.String()',
    hints: [
      'Builder avoids allocations',
      'Use WriteString to append',
      'Call String() to get result',
    ],
    validPatterns: [/strings\.Builder/, /WriteString/, /\.String\s*\(\s*\)/],
    tags: ['Builder', 'strings', 'performance', 'concatenate'],
  },

  // ============================================================
  // Additional Map Operations
  // ============================================================

  {
    id: 'go-map-nested-1',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Create Nested Map',
    text: 'Create a nested map with string keys and map[string]int values.',
    setup: '// Create a map of maps',
    setupCode: '// Create a map of maps',
    expected: 'make(map[string]map[string]int)',
    sample: 'make(map[string]map[string]int)',
    hints: ['Maps can contain other maps', 'Inner maps need initialization too'],
    validPatterns: [/make\s*\(\s*map\s*\[\s*string\s*\]\s*map\s*\[\s*string\s*\]\s*int\s*\)/],
    tags: ['map', 'nested', 'make'],
  },
  {
    id: 'go-map-update-1',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Increment Map Value',
    text: 'Increment the "count" value by 1 (it exists and equals 5).',
    setup: 'm := map[string]int{"count": 5, "total": 100}',
    setupCode: 'm := map[string]int{"count": 5, "total": 100}',
    expected: 6,
    sample: 'm["count"]++',
    hints: ['Use ++ to increment', 'Zero value for int is 0'],
    validPatterns: [/m\s*\[\s*["']count["']\s*\]\s*\+\+/, /m\s*\[\s*["']count["']\s*\]\s*\+=\s*1/],
    tags: ['map', 'increment', 'update'],
  },
  {
    id: 'go-map-default-1',
    category: 'Map Operations',
    difficulty: 'medium',
    title: 'Get Value with Default',
    text: 'Get the "missing" key value, defaulting to "N/A" if not found.',
    setup: 'm := map[string]string{"name": "Alice"}',
    setupCode: 'm := map[string]string{"name": "Alice"}',
    expected: 'N/A',
    sample: 'if v, ok := m["missing"]; ok { return v } else { return "N/A" }',
    hints: ['Use comma ok idiom', 'Return default if ok is false'],
    validPatterns: [
      /if\s+\w+\s*,\s*ok\s*:=\s*m\s*\[\s*["']missing["']\s*\]/,
      /m\s*\[\s*["']missing["']\s*\]/,
    ],
    tags: ['map', 'default', 'comma-ok'],
    // Note: Sample returns literal "N/A" but demonstrates map access with comma-ok idiom
  },
  {
    id: 'go-map-equal-1',
    category: 'Map Operations',
    difficulty: 'easy',
    title: 'Compare Maps for Equality',
    text: 'Use `maps.Equal()` to check if two maps are equal.',
    setup:
      'import "maps"\nm1 := map[string]int{"a": 1, "b": 2}\nm2 := map[string]int{"a": 1, "b": 2}',
    setupCode:
      'import "maps"\nm1 := map[string]int{"a": 1, "b": 2}\nm2 := map[string]int{"a": 1, "b": 2}',
    expected: true,
    sample: 'maps.Equal(m1, m2)',
    hints: ['maps.Equal compares key-value pairs', 'Works with comparable value types'],
    validPatterns: [/maps\.Equal\s*\(\s*m1\s*,\s*m2\s*\)/],
    tags: ['maps', 'Equal', 'compare', 'Go1.21'],
  },
  {
    id: 'go-map-deleteFunc-1',
    category: 'Map Operations',
    difficulty: 'hard',
    title: 'Delete Map Entries by Condition',
    text: 'Use `maps.DeleteFunc()` to remove all entries where value < 10.',
    setup: 'import "maps"\nm := map[string]int{"a": 5, "b": 15, "c": 3, "d": 20}',
    setupCode: 'import "maps"\nm := map[string]int{"a": 5, "b": 15, "c": 3, "d": 20}',
    expected: { b: 15, d: 20 },
    sample: 'maps.DeleteFunc(m, func(k string, v int) bool { return v < 10 })',
    hints: ['DeleteFunc takes a predicate', 'Return true to delete the entry'],
    validPatterns: [/maps\.DeleteFunc\s*\(\s*m\s*,\s*func\s*\(/],
    tags: ['maps', 'DeleteFunc', 'filter', 'Go1.21'],
  },

  // ============================================================
  // Additional Sort Package
  // ============================================================

  {
    id: 'go-sort-float64s-1',
    category: 'Sort Package',
    difficulty: 'easy',
    title: 'Sort Float64 Slice',
    text: 'Use `sort.Float64s()` to sort the slice in ascending order.',
    setup: 'import "sort"\nnumbers := []float64{3.14, 1.41, 2.72, 0.58}',
    setupCode: 'import "sort"\nnumbers := []float64{3.14, 1.41, 2.72, 0.58}',
    expected: [0.58, 1.41, 2.72, 3.14],
    sample: 'sort.Float64s(numbers)',
    hints: ['sort.Float64s(slice)', 'Sorts in place, ascending order'],
    validPatterns: [/sort\.Float64s\s*\(\s*numbers\s*\)/],
    tags: ['sort', 'Float64s', 'ascending'],
  },
  {
    id: 'go-sort-stable-1',
    category: 'Sort Package',
    difficulty: 'medium',
    title: 'Stable Sort Slice',
    text: 'Use `sort.SliceStable()` to sort by name length, preserving original order for equal lengths.',
    setup: 'import "sort"\nnames := []string{"bob", "alice", "eve", "dan"}',
    setupCode: 'import "sort"\nnames := []string{"bob", "alice", "eve", "dan"}',
    expected: ['bob', 'eve', 'dan', 'alice'],
    sample: 'sort.SliceStable(names, func(i, j int) bool { return len(names[i]) < len(names[j]) })',
    hints: ['SliceStable preserves original order', 'Equal elements keep relative position'],
    validPatterns: [/sort\.SliceStable\s*\(\s*names\s*,\s*func\s*\(/],
    tags: ['sort', 'SliceStable', 'stable'],
  },
  {
    id: 'go-sort-search-string-1',
    category: 'Sort Package',
    difficulty: 'medium',
    title: 'Binary Search in String Slice',
    text: 'Use `sort.SearchStrings()` to find where "go" would be inserted.',
    setup: 'import "sort"\nwords := []string{"c", "go", "java", "python", "rust"}',
    setupCode: 'import "sort"\nwords := []string{"c", "go", "java", "python", "rust"}',
    expected: 1,
    sample: 'sort.SearchStrings(words, "go")',
    hints: ['Slice must be sorted', 'Returns insertion point index'],
    validPatterns: [/sort\.SearchStrings\s*\(\s*words\s*,\s*["']go["']\s*\)/],
    tags: ['sort', 'SearchStrings', 'binary'],
  },
  {
    id: 'go-sort-multikey-1',
    category: 'Sort Package',
    difficulty: 'hard',
    title: 'Sort by Multiple Keys',
    text: 'Sort people by age ascending, then by name alphabetically for same age.',
    setup:
      'import "sort"\ntype Person struct { Name string; Age int }\npeople := []Person{{"Bob", 25}, {"Alice", 25}, {"Carol", 20}}',
    setupCode:
      'import "sort"\ntype Person struct { Name string; Age int }\npeople := []Person{{"Bob", 25}, {"Alice", 25}, {"Carol", 20}}',
    expected: [
      { Name: 'Carol', Age: 20 },
      { Name: 'Alice', Age: 25 },
      { Name: 'Bob', Age: 25 },
    ],
    sample:
      'sort.Slice(people, func(i, j int) bool { if people[i].Age != people[j].Age { return people[i].Age < people[j].Age }; return people[i].Name < people[j].Name })',
    hints: [
      'Compare primary key first',
      'Only compare secondary key if primary is equal',
      'Use if statement for multi-key logic',
    ],
    validPatterns: [/sort\.Slice\s*\(\s*people\s*,\s*func\s*\(/, /Age\s*!=/, /\.Name\s*</],
    tags: ['sort', 'multikey', 'custom'],
  },

  // ============================================================
  // strconv Package
  // ============================================================

  {
    id: 'go-strconv-parseint-1',
    category: 'strconv Package',
    difficulty: 'medium',
    title: 'Parse Integer with Base',
    text: 'Use `strconv.ParseInt()` to parse the hex string "ff" as base 16.',
    setup: 'import "strconv"\ns := "ff"',
    setupCode: 'import "strconv"\ns := "ff"',
    expected: 255,
    sample: 'n, err := strconv.ParseInt(s, 16, 64); if err != nil { panic(err) }; n',
    hints: ['ParseInt(str, base, bitSize)', 'Base 16 for hexadecimal'],
    validPatterns: [/strconv\.ParseInt\s*\(\s*s\s*,\s*16\s*,\s*\d+\s*\)/],
    tags: ['strconv', 'ParseInt', 'hex'],
  },
  {
    id: 'go-strconv-formatint-1',
    category: 'strconv Package',
    difficulty: 'medium',
    title: 'Format Integer to Binary',
    text: 'Use `strconv.FormatInt()` to convert 42 to a binary string.',
    setup: 'import "strconv"\nn := int64(42)',
    setupCode: 'import "strconv"\nn := int64(42)',
    expected: '101010',
    sample: 'strconv.FormatInt(n, 2)',
    hints: ['FormatInt(value, base)', 'Base 2 for binary'],
    validPatterns: [/strconv\.FormatInt\s*\(\s*n\s*,\s*2\s*\)/],
    tags: ['strconv', 'FormatInt', 'binary'],
  },
  {
    id: 'go-strconv-parsefloat-1',
    category: 'strconv Package',
    difficulty: 'medium',
    title: 'Parse Float from String',
    text: 'Use `strconv.ParseFloat()` to parse "3.14159" as a float64.',
    setup: 'import "strconv"\ns := "3.14159"',
    setupCode: 'import "strconv"\ns := "3.14159"',
    expected: 3.14159,
    sample: 'f, err := strconv.ParseFloat(s, 64); if err != nil { panic(err) }; f',
    hints: ['ParseFloat(str, bitSize)', '64 for float64'],
    validPatterns: [/strconv\.ParseFloat\s*\(\s*s\s*,\s*64\s*\)/],
    tags: ['strconv', 'ParseFloat', 'float'],
  },
  {
    id: 'go-strconv-formatfloat-1',
    category: 'strconv Package',
    difficulty: 'hard',
    title: 'Format Float with Precision',
    text: 'Use `strconv.FormatFloat()` to format pi with 2 decimal places.',
    setup: 'import "strconv"\npi := 3.14159265359',
    setupCode: 'import "strconv"\npi := 3.14159265359',
    expected: '3.14',
    sample: "strconv.FormatFloat(pi, 'f', 2, 64)",
    hints: ['FormatFloat(f, fmt, prec, bitSize)', "'f' for decimal notation"],
    validPatterns: [/strconv\.FormatFloat\s*\(\s*pi\s*,\s*'f'\s*,\s*2\s*,\s*64\s*\)/],
    tags: ['strconv', 'FormatFloat', 'precision'],
  },
  {
    id: 'go-strconv-parsebool-1',
    category: 'strconv Package',
    difficulty: 'easy',
    title: 'Parse Boolean from String',
    text: 'Use `strconv.ParseBool()` to parse "true" as a boolean.',
    setup: 'import "strconv"\ns := "true"',
    setupCode: 'import "strconv"\ns := "true"',
    expected: true,
    sample: 'b, err := strconv.ParseBool(s); if err != nil { panic(err) }; b',
    hints: ['Accepts "1", "t", "T", "TRUE", "true", "True"', 'Returns (bool, error)'],
    validPatterns: [/strconv\.ParseBool\s*\(\s*s\s*\)/],
    tags: ['strconv', 'ParseBool', 'boolean'],
  },
  {
    id: 'go-strconv-formatbool-1',
    category: 'strconv Package',
    difficulty: 'easy',
    title: 'Format Boolean to String',
    text: 'Use `strconv.FormatBool()` to convert false to a string.',
    setup: 'import "strconv"\nb := false',
    setupCode: 'import "strconv"\nb := false',
    expected: 'false',
    sample: 'strconv.FormatBool(b)',
    hints: ['FormatBool returns "true" or "false"', 'Simple and predictable'],
    validPatterns: [/strconv\.FormatBool\s*\(\s*b\s*\)/],
    tags: ['strconv', 'FormatBool', 'boolean'],
  },
  {
    id: 'go-strconv-quote-1',
    category: 'strconv Package',
    difficulty: 'medium',
    title: 'Quote String with Escapes',
    text: 'Use `strconv.Quote()` to create a double-quoted Go string literal.',
    setup: 'import "strconv"\ns := "hello\\nworld"',
    setupCode: 'import "strconv"\ns := "hello\\nworld"',
    expected: '"hello\\nworld"',
    sample: 'strconv.Quote(s)',
    hints: ['Quote adds quotes and escapes special chars', 'Useful for generating Go code'],
    validPatterns: [/strconv\.Quote\s*\(\s*s\s*\)/],
    tags: ['strconv', 'Quote', 'escape'],
  },

  // ============================================================
  // String Manipulation (Advanced)
  // ============================================================

  // --- EASY (8 problems) ---

  {
    id: 'go-str-builder-write-1',
    category: 'String Manipulation',
    difficulty: 'easy',
    title: 'Write Byte to Builder',
    text: 'Use `strings.Builder` to write a single byte character "X" to the builder.',
    setup: 'import "strings"\nvar b strings.Builder',
    setupCode: 'import "strings"\nvar b strings.Builder',
    expected: 'X',
    sample: "b.WriteByte('X'); b.String()",
    hints: ['WriteByte writes a single byte', 'Use single quotes for byte literals'],
    validPatterns: [/\.WriteByte\s*\(\s*'X'\s*\)/, /\.WriteByte\s*\(\s*88\s*\)/],
    tags: ['Builder', 'WriteByte', 'strings'],
  },
  {
    id: 'go-str-builder-write-rune-1',
    category: 'String Manipulation',
    difficulty: 'easy',
    title: 'Write Rune to Builder',
    text: 'Use `strings.Builder` to write the Unicode character "..." (U+4E16) to the builder.',
    setup: 'import "strings"\nvar b strings.Builder',
    setupCode: 'import "strings"\nvar b strings.Builder',
    expected: '\u4e16',
    sample: "b.WriteRune('\u4e16'); b.String()",
    hints: ['WriteRune handles multi-byte Unicode characters', 'Runes can be more than one byte'],
    validPatterns: [/\.WriteRune\s*\(/, /\.WriteRune\s*\(\s*0x4E16\s*\)/],
    tags: ['Builder', 'WriteRune', 'unicode', 'strings'],
  },
  {
    id: 'go-str-rune-iterate-1',
    category: 'String Manipulation',
    difficulty: 'easy',
    title: 'Iterate Over Runes',
    text: 'Use a for-range loop to iterate over each rune in the string.',
    setup: 's := "Go..."',
    setupCode: 's := "Go..."',
    expected: 'for i, r := range s',
    sample: 'for i, r := range s { fmt.Printf("%d: %c\\n", i, r) }',
    hints: ['for-range on string yields runes', 'Index is byte position, not rune position'],
    validPatterns: [/for\s+\w+\s*,\s*\w+\s*:=\s*range\s+s/],
    tags: ['rune', 'iterate', 'unicode', 'range'],
  },
  {
    id: 'go-str-bytes-to-string-1',
    category: 'String Manipulation',
    difficulty: 'easy',
    title: 'Convert Bytes to String',
    text: 'Convert a byte slice to a string.',
    setup: 'data := []byte{72, 101, 108, 108, 111}',
    setupCode: 'data := []byte{72, 101, 108, 108, 111}',
    expected: 'Hello',
    sample: 'string(data)',
    hints: ['Use string() type conversion', 'Each byte is an ASCII code'],
    validPatterns: [/string\s*\(\s*data\s*\)/],
    tags: ['bytes', 'string', 'convert'],
  },
  {
    id: 'go-str-string-to-bytes-1',
    category: 'String Manipulation',
    difficulty: 'easy',
    title: 'Convert String to Bytes',
    text: 'Convert the string to a byte slice.',
    setup: 's := "Hello"',
    setupCode: 's := "Hello"',
    expected: [72, 101, 108, 108, 111],
    sample: '[]byte(s)',
    hints: ['Use []byte() type conversion', 'Creates a copy of the string data'],
    validPatterns: [/\[\s*\]\s*byte\s*\(\s*s\s*\)/],
    tags: ['bytes', 'string', 'convert'],
  },
  {
    id: 'go-str-string-to-runes-1',
    category: 'String Manipulation',
    difficulty: 'easy',
    title: 'Convert String to Runes',
    text: 'Convert the string to a rune slice to properly handle Unicode.',
    setup: 's := "Hello..."',
    setupCode: 's := "Hello..."',
    expected: '[]rune(s)',
    sample: '[]rune(s)',
    hints: ['Use []rune() for Unicode-safe operations', 'Each rune is a Unicode code point'],
    validPatterns: [/\[\s*\]\s*rune\s*\(\s*s\s*\)/],
    tags: ['rune', 'string', 'convert', 'unicode'],
  },
  {
    id: 'go-str-fmt-padding-1',
    category: 'String Manipulation',
    difficulty: 'easy',
    title: 'Pad String with Spaces',
    text: 'Use `fmt.Sprintf()` to right-align the string in a 10-character field.',
    setup: 'import "fmt"\ns := "Go"',
    setupCode: 'import "fmt"\ns := "Go"',
    expected: '        Go',
    sample: 'fmt.Sprintf("%10s", s)',
    hints: ['%10s pads to 10 characters', 'Positive width right-aligns'],
    validPatterns: [/fmt\.Sprintf\s*\(\s*["']%10s["']\s*,\s*s\s*\)/],
    tags: ['fmt', 'Sprintf', 'padding', 'format'],
  },
  {
    id: 'go-str-fmt-left-pad-1',
    category: 'String Manipulation',
    difficulty: 'easy',
    title: 'Left-Align String',
    text: 'Use `fmt.Sprintf()` to left-align the string in a 10-character field.',
    setup: 'import "fmt"\ns := "Go"',
    setupCode: 'import "fmt"\ns := "Go"',
    expected: 'Go        ',
    sample: 'fmt.Sprintf("%-10s", s)',
    hints: ['%-10s left-aligns', 'Negative width left-aligns'],
    validPatterns: [/fmt\.Sprintf\s*\(\s*["']%-10s["']\s*,\s*s\s*\)/],
    tags: ['fmt', 'Sprintf', 'padding', 'format'],
  },

  // --- MEDIUM (12 problems) ---

  {
    id: 'go-str-builder-grow-1',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Pre-allocate Builder Capacity',
    text: 'Use `strings.Builder.Grow()` to pre-allocate space for 100 bytes.',
    setup: 'import "strings"\nvar b strings.Builder',
    setupCode: 'import "strings"\nvar b strings.Builder',
    expected: 'b.Grow(100)',
    sample: 'b.Grow(100)',
    hints: ['Grow pre-allocates capacity', 'Reduces allocations during writes'],
    validPatterns: [/b\.Grow\s*\(\s*100\s*\)/],
    tags: ['Builder', 'Grow', 'performance', 'strings'],
  },
  {
    id: 'go-str-reader-1',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Create String Reader',
    text: 'Use `strings.NewReader()` to create a Reader from the string.',
    setup: 'import "strings"\ns := "Hello, World!"',
    setupCode: 'import "strings"\ns := "Hello, World!"',
    expected: 'strings.NewReader(s)',
    sample: 'r := strings.NewReader(s)',
    hints: ['NewReader returns *strings.Reader', 'Implements io.Reader interface'],
    validPatterns: [/strings\.NewReader\s*\(\s*s\s*\)/],
    tags: ['Reader', 'strings', 'io'],
  },
  {
    id: 'go-str-replacer-1',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Create String Replacer',
    text: 'Use `strings.NewReplacer()` to replace multiple patterns: "<" with "&lt;" and ">" with "&gt;".',
    setup: 'import "strings"\ns := "<html>content</html>"',
    setupCode: 'import "strings"\ns := "<html>content</html>"',
    expected: '&lt;html&gt;content&lt;/html&gt;',
    sample: 'r := strings.NewReplacer("<", "&lt;", ">", "&gt;"); r.Replace(s)',
    hints: ['NewReplacer takes old/new pairs', 'Efficient for multiple replacements'],
    validPatterns: [/strings\.NewReplacer\s*\(/, /\.Replace\s*\(\s*s\s*\)/],
    tags: ['Replacer', 'strings', 'escape', 'html'],
  },
  {
    id: 'go-str-bytes-buffer-1',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Create Bytes Buffer',
    text: 'Use `bytes.NewBufferString()` to create a buffer from the string.',
    setup: 'import "bytes"\ns := "initial content"',
    setupCode: 'import "bytes"\ns := "initial content"',
    expected: 'bytes.NewBufferString(s)',
    sample: 'buf := bytes.NewBufferString(s)',
    hints: ['NewBufferString creates a Buffer', 'Buffer implements io.Reader and io.Writer'],
    validPatterns: [/bytes\.NewBufferString\s*\(\s*s\s*\)/],
    tags: ['bytes', 'Buffer', 'io'],
  },
  {
    id: 'go-str-bytes-contains-1',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Check Bytes Contains',
    text: 'Use `bytes.Contains()` to check if the byte slice contains "world".',
    setup: 'import "bytes"\ndata := []byte("hello world")',
    setupCode: 'import "bytes"\ndata := []byte("hello world")',
    expected: true,
    sample: 'bytes.Contains(data, []byte("world"))',
    hints: ['bytes.Contains works like strings.Contains', 'Second arg must be []byte'],
    validPatterns: [
      /bytes\.Contains\s*\(\s*data\s*,\s*\[\s*\]\s*byte\s*\(\s*["']world["']\s*\)\s*\)/,
    ],
    tags: ['bytes', 'Contains', 'search'],
  },
  {
    id: 'go-str-fmt-zero-pad-1',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Zero-Pad Integer',
    text: 'Use `fmt.Sprintf()` to format the number with leading zeros to 5 digits.',
    setup: 'import "fmt"\nn := 42',
    setupCode: 'import "fmt"\nn := 42',
    expected: '00042',
    sample: 'fmt.Sprintf("%05d", n)',
    hints: ['%05d pads with zeros', '0 flag enables zero-padding'],
    validPatterns: [/fmt\.Sprintf\s*\(\s*["']%05d["']\s*,\s*n\s*\)/],
    tags: ['fmt', 'Sprintf', 'padding', 'format'],
  },
  {
    id: 'go-str-fmt-hex-1',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Format as Hexadecimal',
    text: 'Use `fmt.Sprintf()` to format the number as uppercase hexadecimal with 0x prefix.',
    setup: 'import "fmt"\nn := 255',
    setupCode: 'import "fmt"\nn := 255',
    expected: '0xFF',
    sample: 'fmt.Sprintf("0x%X", n)',
    hints: ['%X for uppercase hex', '%x for lowercase hex'],
    validPatterns: [/fmt\.Sprintf\s*\(\s*["']0x%X["']\s*,\s*n\s*\)/],
    tags: ['fmt', 'Sprintf', 'hex', 'format'],
  },
  {
    id: 'go-str-strconv-appendint-1',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Append Integer to Byte Slice',
    text: 'Use `strconv.AppendInt()` to append 42 in base 10 to the byte slice.',
    setup: 'import "strconv"\nbuf := []byte("value: ")',
    setupCode: 'import "strconv"\nbuf := []byte("value: ")',
    expected: 'value: 42',
    sample: 'string(strconv.AppendInt(buf, 42, 10))',
    hints: ['AppendInt is more efficient than Itoa+append', 'Third arg is the base'],
    validPatterns: [/strconv\.AppendInt\s*\(\s*buf\s*,\s*42\s*,\s*10\s*\)/],
    tags: ['strconv', 'AppendInt', 'performance'],
  },
  {
    id: 'go-str-unicode-isletter-1',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Check if Rune is Letter',
    text: 'Use `unicode.IsLetter()` to check if the rune is a letter.',
    setup: 'import "unicode"\nr := \'A\'',
    setupCode: 'import "unicode"\nr := \'A\'',
    expected: true,
    sample: 'unicode.IsLetter(r)',
    hints: ['Works with any Unicode letter', 'Not just ASCII a-zA-Z'],
    validPatterns: [/unicode\.IsLetter\s*\(\s*r\s*\)/],
    tags: ['unicode', 'IsLetter', 'rune'],
  },
  {
    id: 'go-str-unicode-toupper-1',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Convert Rune to Uppercase',
    text: 'Use `unicode.ToUpper()` to convert the rune to uppercase.',
    setup: 'import "unicode"\nr := \'a\'',
    setupCode: 'import "unicode"\nr := \'a\'',
    expected: 'A',
    sample: 'unicode.ToUpper(r)',
    hints: ['ToUpper works on individual runes', 'Returns the uppercase rune'],
    validPatterns: [/unicode\.ToUpper\s*\(\s*r\s*\)/],
    tags: ['unicode', 'ToUpper', 'rune'],
  },
  {
    id: 'go-str-regexp-match-1',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Check Regex Match',
    text: 'Use `regexp.MatchString()` to check if the string matches the email pattern.',
    setup:
      'import "regexp"\nemail := "test@example.com"\npattern := `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$`',
    setupCode:
      'import "regexp"\nemail := "test@example.com"\npattern := `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$`',
    expected: true,
    sample:
      'matched, err := regexp.MatchString(pattern, email); if err != nil { panic(err) }; matched',
    hints: ['MatchString returns (bool, error)', 'Compile regex for repeated use'],
    validPatterns: [/regexp\.MatchString\s*\(\s*pattern\s*,\s*email\s*\)/],
    tags: ['regexp', 'MatchString', 'regex'],
  },
  {
    id: 'go-str-regexp-find-1',
    category: 'String Manipulation',
    difficulty: 'medium',
    title: 'Find First Match',
    text: 'Use compiled regex `FindString()` to find the first number in the string.',
    setup: 'import "regexp"\nre := regexp.MustCompile(`\\d+`)\ns := "abc123def456"',
    setupCode: 'import "regexp"\nre := regexp.MustCompile(`\\d+`)\ns := "abc123def456"',
    expected: '123',
    sample: 're.FindString(s)',
    hints: ['FindString returns first match', 'Returns empty string if no match'],
    validPatterns: [/re\.FindString\s*\(\s*s\s*\)/],
    tags: ['regexp', 'FindString', 'regex'],
  },

  // --- HARD (5 problems) ---

  {
    id: 'go-str-builder-reset-1',
    category: 'String Manipulation',
    difficulty: 'hard',
    title: 'Reuse Builder with Reset',
    text: 'Use `strings.Builder` to build "Hello", get the result, reset, then build "World".',
    setup: 'import "strings"\nvar b strings.Builder',
    setupCode: 'import "strings"\nvar b strings.Builder',
    expected: ['Hello', 'World'],
    sample:
      'b.WriteString("Hello"); s1 := b.String(); b.Reset(); b.WriteString("World"); s2 := b.String()',
    hints: ['Reset() clears the builder', 'Allows reusing without new allocation'],
    validPatterns: [/\.WriteString\s*\(/, /\.Reset\s*\(\s*\)/, /\.String\s*\(\s*\)/],
    tags: ['Builder', 'Reset', 'strings', 'performance'],
  },
  {
    id: 'go-str-regexp-replace-1',
    category: 'String Manipulation',
    difficulty: 'hard',
    title: 'Regex Replace All',
    text: 'Use compiled regex `ReplaceAllString()` to replace all digits with "X".',
    setup: 'import "regexp"\nre := regexp.MustCompile(`\\d`)\ns := "Phone: 123-456-7890"',
    setupCode: 'import "regexp"\nre := regexp.MustCompile(`\\d`)\ns := "Phone: 123-456-7890"',
    expected: 'Phone: XXX-XXX-XXXX',
    sample: 're.ReplaceAllString(s, "X")',
    hints: ['ReplaceAllString replaces all matches', 'Compiled regex is more efficient'],
    validPatterns: [/re\.ReplaceAllString\s*\(\s*s\s*,\s*["']X["']\s*\)/],
    tags: ['regexp', 'ReplaceAllString', 'regex'],
  },
  {
    id: 'go-str-regexp-groups-1',
    category: 'String Manipulation',
    difficulty: 'hard',
    title: 'Extract Regex Groups',
    text: 'Use `FindStringSubmatch()` to extract name and domain from the email.',
    setup: 'import "regexp"\nre := regexp.MustCompile(`(.+)@(.+)`)\nemail := "user@example.com"',
    setupCode:
      'import "regexp"\nre := regexp.MustCompile(`(.+)@(.+)`)\nemail := "user@example.com"',
    expected: ['user@example.com', 'user', 'example.com'],
    sample: 're.FindStringSubmatch(email)',
    hints: ['Returns slice: [fullMatch, group1, group2, ...]', 'Index 0 is full match'],
    validPatterns: [/re\.FindStringSubmatch\s*\(\s*email\s*\)/],
    tags: ['regexp', 'FindStringSubmatch', 'groups', 'regex'],
  },
  {
    id: 'go-str-normalize-whitespace-1',
    category: 'String Manipulation',
    difficulty: 'hard',
    title: 'Normalize Whitespace',
    text: 'Use `strings.Fields()` and `strings.Join()` to normalize whitespace to single spaces.',
    setup: 'import "strings"\ns := "  hello    world   go  "',
    setupCode: 'import "strings"\ns := "  hello    world   go  "',
    expected: 'hello world go',
    sample: 'strings.Join(strings.Fields(s), " ")',
    hints: ['Fields splits on any whitespace', 'Join with single space normalizes'],
    validPatterns: [/strings\.Join\s*\(\s*strings\.Fields\s*\(\s*s\s*\)\s*,\s*["'] ["']\s*\)/],
    tags: ['strings', 'Fields', 'Join', 'normalize'],
  },
  {
    id: 'go-str-title-case-1',
    category: 'String Manipulation',
    difficulty: 'hard',
    title: 'Convert to Title Case',
    text: 'Use `strings.Title()` or manual approach to convert the string to title case.',
    setup: 'import "strings"\nimport "unicode"\ns := "hello world"',
    setupCode: 'import "strings"\nimport "unicode"\ns := "hello world"',
    expected: 'Hello World',
    sample: 'strings.Title(s)',
    hints: ['strings.Title is deprecated but works', 'For new code, use golang.org/x/text/cases'],
    validPatterns: [/strings\.Title\s*\(\s*s\s*\)/, /cases\.Title/],
    tags: ['strings', 'Title', 'case', 'deprecated'],
  },

  // ============================================================
  // Go Slice Advanced Operations
  // ============================================================

  // --- EASY (8 problems) ---

  {
    id: 'go-slice-len-cap-diff-1',
    category: 'Slice Advanced Operations',
    difficulty: 'easy',
    title: 'Understand len vs cap',
    text: 'Create a slice with `make()` that has length 3 and capacity 10. What is `cap(s) - len(s)`?',
    setup: 's := make([]int, 3, 10)',
    setupCode: 's := make([]int, 3, 10)',
    expected: 7,
    sample: 'cap(s) - len(s)',
    hints: [
      'len() returns number of elements',
      'cap() returns total capacity',
      'Difference is room for growth',
    ],
    validPatterns: [/cap\s*\(\s*s\s*\)\s*-\s*len\s*\(\s*s\s*\)/],
    tags: ['slice', 'len', 'cap', 'internals'],
  },
  {
    id: 'go-slice-reslice-1',
    category: 'Slice Advanced Operations',
    difficulty: 'easy',
    title: 'Reslice to Extend Length',
    text: 'Given a slice with length 2 and capacity 5, extend it to length 4 using reslicing.',
    setup: 's := make([]int, 2, 5)\ns[0], s[1] = 1, 2',
    setupCode: 's := make([]int, 2, 5)\ns[0], s[1] = 1, 2',
    expected: [1, 2, 0, 0],
    sample: 's[:4]',
    hints: ['You can reslice up to capacity', 's[:n] extends length if n <= cap(s)'],
    validPatterns: [/s\s*\[\s*:\s*4\s*\]/],
    tags: ['slice', 'reslice', 'capacity'],
  },
  {
    id: 'go-slice-nil-check-1',
    category: 'Slice Advanced Operations',
    difficulty: 'easy',
    title: 'Check for Nil Slice',
    text: 'Check if the slice is nil.',
    setup: 'var s []int',
    setupCode: 'var s []int',
    expected: true,
    sample: 's == nil',
    hints: ['Uninitialized slice is nil', 'nil slice has len and cap of 0'],
    validPatterns: [/s\s*==\s*nil/],
    tags: ['slice', 'nil', 'check'],
  },
  {
    id: 'go-slice-empty-vs-nil-1',
    category: 'Slice Advanced Operations',
    difficulty: 'easy',
    title: 'Empty Slice vs Nil Slice',
    text: 'Create an empty (non-nil) slice using a literal. Check that it is not nil.',
    setup: '// Create empty non-nil slice',
    setupCode: '// Create empty non-nil slice',
    expected: false,
    sample: 's := []int{}; s == nil',
    hints: ['[]int{} creates empty non-nil slice', 'make([]int, 0) also creates non-nil'],
    validPatterns: [/\[\s*\]\s*int\s*\{\s*\}/, /make\s*\(\s*\[\s*\]\s*int\s*,\s*0\s*\)/],
    tags: ['slice', 'empty', 'nil', 'literal'],
  },
  {
    id: 'go-slice-copy-full-1',
    category: 'Slice Advanced Operations',
    difficulty: 'easy',
    title: 'Full Copy of Slice',
    text: 'Create a complete independent copy of the slice using append.',
    setup: 'original := []int{1, 2, 3, 4, 5}',
    setupCode: 'original := []int{1, 2, 3, 4, 5}',
    expected: [1, 2, 3, 4, 5],
    sample: 'append([]int(nil), original...)',
    hints: ['append to nil slice creates new backing array', 'This is a common copy idiom'],
    validPatterns: [
      /append\s*\(\s*\[\s*\]\s*int\s*\(\s*nil\s*\)\s*,\s*original\s*\.\.\.\s*\)/,
      /append\s*\(\s*\[\s*\]\s*int\s*\{\s*\}\s*,\s*original\s*\.\.\.\s*\)/,
      /slices\.Clone\s*\(\s*original\s*\)/,
    ],
    tags: ['slice', 'copy', 'append', 'idiom'],
  },
  {
    id: 'go-slice-zero-value-1',
    category: 'Slice Advanced Operations',
    difficulty: 'easy',
    title: 'Slice Zero Values',
    text: 'What are the elements of a slice created with `make([]int, 3)`?',
    setup: 's := make([]int, 3)',
    setupCode: 's := make([]int, 3)',
    expected: [0, 0, 0],
    sample: 's',
    hints: ['make initializes to zero values', 'int zero value is 0'],
    validPatterns: [/^s$/, /make\s*\(\s*\[\s*\]\s*int\s*,\s*3\s*\)/],
    tags: ['slice', 'make', 'zero-value'],
  },
  {
    id: 'go-slice-three-index-1',
    category: 'Slice Advanced Operations',
    difficulty: 'easy',
    title: 'Three-Index Slice (Limit Capacity)',
    text: 'Use three-index slicing to get elements 1-3 with capacity limited to 3.',
    setup: 's := []int{0, 1, 2, 3, 4, 5}',
    setupCode: 's := []int{0, 1, 2, 3, 4, 5}',
    expected: 'cap = 2',
    sample: 's[1:3:3]',
    hints: ['s[low:high:max] limits capacity', 'cap = max - low'],
    validPatterns: [/s\s*\[\s*1\s*:\s*3\s*:\s*3\s*\]/],
    tags: ['slice', 'three-index', 'capacity'],
  },
  {
    id: 'go-slice-clear-builtin-1',
    category: 'Slice Advanced Operations',
    difficulty: 'easy',
    title: 'Clear Slice with Built-in',
    text: 'Use the `clear()` built-in to zero all elements in the slice.',
    setup: 'numbers := []int{1, 2, 3, 4, 5}',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5}',
    expected: [0, 0, 0, 0, 0],
    sample: 'clear(numbers); numbers',
    hints: ['clear() zeros elements but keeps length', 'Go 1.21+ built-in'],
    validPatterns: [/clear\s*\(\s*numbers\s*\)/],
    tags: ['slice', 'clear', 'builtin', 'Go1.21'],
  },

  // --- MEDIUM (12 problems) ---

  {
    id: 'go-slice-capacity-growth-1',
    category: 'Slice Advanced Operations',
    difficulty: 'medium',
    title: 'Understand Capacity Growth',
    text: 'Starting with empty slice, append 5 elements and check if cap > len.',
    setup: 'var s []int\nfor i := 0; i < 5; i++ { s = append(s, i) }',
    setupCode: 'var s []int\nfor i := 0; i < 5; i++ { s = append(s, i) }',
    expected: true,
    sample: 'cap(s) > len(s)',
    hints: ['Go over-allocates on append', 'Typically doubles capacity'],
    validPatterns: [/cap\s*\(\s*s\s*\)\s*>\s*len\s*\(\s*s\s*\)/],
    tags: ['slice', 'capacity', 'growth', 'append'],
  },
  {
    id: 'go-slice-preallocate-1',
    category: 'Slice Advanced Operations',
    difficulty: 'medium',
    title: 'Preallocate for Performance',
    text: 'Create a slice to hold exactly 1000 elements with no reallocation during append.',
    setup: '// Create slice that can hold 1000 elements',
    setupCode: '// Create slice that can hold 1000 elements',
    expected: 'make([]int, 0, 1000)',
    sample: 'make([]int, 0, 1000)',
    hints: ['Length 0, capacity 1000', 'Prevents reallocations during append'],
    validPatterns: [/make\s*\(\s*\[\s*\]\s*int\s*,\s*0\s*,\s*1000\s*\)/],
    tags: ['slice', 'preallocate', 'performance', 'make'],
  },
  {
    id: 'go-slice-filter-generic-1',
    category: 'Slice Advanced Operations',
    difficulty: 'medium',
    title: 'Generic Filter Function',
    text: 'Use `slices.DeleteFunc()` to remove all negative numbers from the slice.',
    setup: 'import "slices"\nnumbers := []int{-2, 3, -5, 8, -1, 4}',
    setupCode: 'import "slices"\nnumbers := []int{-2, 3, -5, 8, -1, 4}',
    expected: [3, 8, 4],
    sample: 'slices.DeleteFunc(numbers, func(n int) bool { return n < 0 })',
    hints: ['DeleteFunc removes elements matching predicate', 'Return true to delete'],
    validPatterns: [/slices\.DeleteFunc\s*\(\s*numbers\s*,\s*func\s*\(\s*n\s+int\s*\)\s*bool/],
    tags: ['slices', 'DeleteFunc', 'filter', 'generic', 'Go1.21'],
  },
  {
    id: 'go-slice-transform-1',
    category: 'Slice Advanced Operations',
    difficulty: 'medium',
    title: 'Transform Slice Elements',
    text: 'Double each element in the slice in-place using a for loop with index.',
    setup: 'numbers := []int{1, 2, 3, 4, 5}',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5}',
    expected: [2, 4, 6, 8, 10],
    sample: 'for i := range numbers { numbers[i] *= 2 }',
    hints: ['Use index-based range', 'Modify in place using index'],
    validPatterns: [/for\s+\w+\s*:=\s*range\s+numbers/, /numbers\s*\[\s*\w+\s*\]\s*\*=\s*2/],
    tags: ['slice', 'transform', 'in-place', 'loop'],
  },
  {
    id: 'go-slice-2d-create-1',
    category: 'Slice Advanced Operations',
    difficulty: 'medium',
    title: 'Create 2D Slice',
    text: 'Create a 3x4 matrix (3 rows, 4 columns) of integers initialized to zero.',
    setup: '// Create 3x4 matrix',
    setupCode: '// Create 3x4 matrix',
    expected: '3 rows, 4 columns each',
    sample: 'matrix := make([][]int, 3); for i := range matrix { matrix[i] = make([]int, 4) }',
    hints: ['Create outer slice first', 'Initialize each row separately'],
    validPatterns: [
      /make\s*\(\s*\[\s*\]\s*\[\s*\]\s*int\s*,\s*3\s*\)/,
      /make\s*\(\s*\[\s*\]\s*int\s*,\s*4\s*\)/,
    ],
    tags: ['slice', '2d', 'matrix', 'multidimensional'],
  },
  {
    id: 'go-slice-to-array-1',
    category: 'Slice Advanced Operations',
    difficulty: 'medium',
    title: 'Convert Slice to Array (Go 1.20+)',
    text: 'Convert the slice to a fixed-size array of 3 elements.',
    setup: 's := []int{10, 20, 30, 40, 50}',
    setupCode: 's := []int{10, 20, 30, 40, 50}',
    expected: [10, 20, 30],
    sample: '[3]int(s)',
    hints: ['Go 1.20+ allows direct conversion', 'Array size must be <= slice length'],
    validPatterns: [/\[\s*3\s*\]\s*int\s*\(\s*s\s*\)/, /\(\*\[\s*3\s*\]\s*int\)\s*\(\s*s\s*\)/],
    tags: ['slice', 'array', 'conversion', 'Go1.20'],
  },
  {
    id: 'go-slice-binary-search-1',
    category: 'Slice Advanced Operations',
    difficulty: 'medium',
    title: 'Binary Search in Sorted Slice',
    text: 'Use `slices.BinarySearch()` to find the index of value 30 in the sorted slice.',
    setup: 'import "slices"\nnumbers := []int{10, 20, 30, 40, 50}',
    setupCode: 'import "slices"\nnumbers := []int{10, 20, 30, 40, 50}',
    expected: 2,
    sample: 'idx, _ := slices.BinarySearch(numbers, 30); idx',
    hints: ['Returns (index, found)', 'Slice must be sorted'],
    validPatterns: [/slices\.BinarySearch\s*\(\s*numbers\s*,\s*30\s*\)/],
    tags: ['slices', 'BinarySearch', 'sorted', 'Go1.21'],
  },
  {
    id: 'go-slice-sortfunc-1',
    category: 'Slice Advanced Operations',
    difficulty: 'medium',
    title: 'Sort with Custom Comparison (slices package)',
    text: 'Use `slices.SortFunc()` to sort strings by length (shortest first).',
    setup: 'import "slices"\nimport "cmp"\nwords := []string{"golang", "is", "awesome"}',
    setupCode: 'import "slices"\nimport "cmp"\nwords := []string{"golang", "is", "awesome"}',
    expected: ['is', 'golang', 'awesome'],
    sample: 'slices.SortFunc(words, func(a, b string) int { return cmp.Compare(len(a), len(b)) })',
    hints: ['SortFunc takes comparison function', 'Return negative/zero/positive like cmp.Compare'],
    validPatterns: [/slices\.SortFunc\s*\(\s*words\s*,\s*func\s*\(/],
    tags: ['slices', 'SortFunc', 'custom', 'Go1.21'],
  },
  {
    id: 'go-slice-equal-1',
    category: 'Slice Advanced Operations',
    difficulty: 'medium',
    title: 'Compare Two Slices for Equality',
    text: 'Use `slices.Equal()` to check if two slices have the same elements.',
    setup: 'import "slices"\na := []int{1, 2, 3}\nb := []int{1, 2, 3}',
    setupCode: 'import "slices"\na := []int{1, 2, 3}\nb := []int{1, 2, 3}',
    expected: true,
    sample: 'slices.Equal(a, b)',
    hints: ['slices.Equal compares length and elements', 'Element-by-element comparison'],
    validPatterns: [/slices\.Equal\s*\(\s*a\s*,\s*b\s*\)/],
    tags: ['slices', 'Equal', 'compare', 'Go1.21'],
  },
  {
    id: 'go-slice-concat-1',
    category: 'Slice Advanced Operations',
    difficulty: 'medium',
    title: 'Concatenate Multiple Slices',
    text: 'Use `slices.Concat()` to combine three slices into one.',
    setup: 'import "slices"\na := []int{1, 2}\nb := []int{3, 4}\nc := []int{5, 6}',
    setupCode: 'import "slices"\na := []int{1, 2}\nb := []int{3, 4}\nc := []int{5, 6}',
    expected: [1, 2, 3, 4, 5, 6],
    sample: 'slices.Concat(a, b, c)',
    hints: ['slices.Concat is variadic', 'Returns new slice with all elements'],
    validPatterns: [/slices\.Concat\s*\(\s*a\s*,\s*b\s*,\s*c\s*\)/],
    tags: ['slices', 'Concat', 'combine', 'Go1.22'],
  },
  {
    id: 'go-slice-clip-1',
    category: 'Slice Advanced Operations',
    difficulty: 'medium',
    title: 'Clip Slice Capacity',
    text: 'Use `slices.Clip()` to reduce the slice capacity to match its length.',
    setup: 'import "slices"\ns := make([]int, 3, 100)\ns[0], s[1], s[2] = 1, 2, 3',
    setupCode: 'import "slices"\ns := make([]int, 3, 100)\ns[0], s[1], s[2] = 1, 2, 3',
    expected: 'cap(s) == len(s)',
    sample: 's = slices.Clip(s); cap(s) == len(s)',
    hints: ['Clip sets capacity equal to length', 'Frees excess capacity memory'],
    validPatterns: [/slices\.Clip\s*\(\s*s\s*\)/],
    tags: ['slices', 'Clip', 'memory', 'Go1.21'],
  },
  {
    id: 'go-slice-replace-1',
    category: 'Slice Advanced Operations',
    difficulty: 'medium',
    title: 'Replace Slice Elements',
    text: 'Use `slices.Replace()` to replace elements at indices 1-3 with 99, 88.',
    setup: 'import "slices"\ns := []int{1, 2, 3, 4, 5}',
    setupCode: 'import "slices"\ns := []int{1, 2, 3, 4, 5}',
    expected: [1, 99, 88, 4, 5],
    sample: 'slices.Replace(s, 1, 3, 99, 88)',
    hints: ['Replace(s, i, j, v...) replaces s[i:j]', 'Can change length of slice'],
    validPatterns: [/slices\.Replace\s*\(\s*s\s*,\s*1\s*,\s*3\s*,\s*99\s*,\s*88\s*\)/],
    tags: ['slices', 'Replace', 'modify', 'Go1.21'],
  },

  // --- HARD (5 problems) ---

  {
    id: 'go-slice-memory-leak-1',
    category: 'Slice Advanced Operations',
    difficulty: 'hard',
    title: 'Avoid Memory Leak with Subslice',
    text: 'Copy the first 2 elements to a new slice to avoid holding reference to large backing array.',
    setup: 'bigSlice := make([]int, 1000000)\nbigSlice[0], bigSlice[1] = 1, 2',
    setupCode: 'bigSlice := make([]int, 1000000)\nbigSlice[0], bigSlice[1] = 1, 2',
    expected: [1, 2],
    sample: 'small := make([]int, 2); copy(small, bigSlice[:2]); small',
    hints: [
      'Subslice shares backing array',
      'Copy to new slice to release memory',
      'Or use slices.Clone',
    ],
    validPatterns: [
      /copy\s*\(\s*\w+\s*,\s*bigSlice\s*\[\s*:\s*2\s*\]\s*\)/,
      /slices\.Clone\s*\(\s*bigSlice\s*\[\s*:\s*2\s*\]\s*\)/,
      /append\s*\(\s*\[\s*\]\s*int\s*\(\s*nil\s*\)\s*,\s*bigSlice\s*\[\s*:\s*2\s*\]\s*\.\.\.\s*\)/,
    ],
    tags: ['slice', 'memory', 'leak', 'copy'],
  },
  {
    id: 'go-slice-delete-preserve-1',
    category: 'Slice Advanced Operations',
    difficulty: 'hard',
    title: 'Delete Without Preserving Order',
    text: 'Delete element at index 2 efficiently by swapping with last element (order not important).',
    setup: 's := []int{1, 2, 3, 4, 5}',
    setupCode: 's := []int{1, 2, 3, 4, 5}',
    expected: [1, 2, 5, 4],
    sample: 's[2] = s[len(s)-1]; s = s[:len(s)-1]',
    hints: ['Swap with last element', 'Truncate slice by 1', 'O(1) instead of O(n)'],
    validPatterns: [
      /s\s*\[\s*2\s*\]\s*=\s*s\s*\[\s*len\s*\(\s*s\s*\)\s*-\s*1\s*\]/,
      /s\s*=\s*s\s*\[\s*:\s*len\s*\(\s*s\s*\)\s*-\s*1\s*\]/,
    ],
    tags: ['slice', 'delete', 'performance', 'swap'],
  },
  {
    id: 'go-slice-stack-1',
    category: 'Slice Advanced Operations',
    difficulty: 'hard',
    title: 'Implement Stack with Slice',
    text: 'Pop the last element from the slice (implement stack pop operation).',
    setup: 'stack := []int{1, 2, 3, 4, 5}',
    setupCode: 'stack := []int{1, 2, 3, 4, 5}',
    expected: [5, [1, 2, 3, 4]],
    sample: 'top := stack[len(stack)-1]; stack = stack[:len(stack)-1]',
    hints: [
      'Get last element first',
      'Then reslice to remove it',
      'Two operations: read then shrink',
    ],
    validPatterns: [
      /\w+\s*:=\s*stack\s*\[\s*len\s*\(\s*stack\s*\)\s*-\s*1\s*\]/,
      /stack\s*=\s*stack\s*\[\s*:\s*len\s*\(\s*stack\s*\)\s*-\s*1\s*\]/,
    ],
    tags: ['slice', 'stack', 'pop', 'data-structure'],
  },
  {
    id: 'go-slice-chunk-1',
    category: 'Slice Advanced Operations',
    difficulty: 'hard',
    title: 'Chunk Slice into Batches',
    text: 'Use `slices.Chunk()` to split the slice into chunks of size 3.',
    setup: 'import "slices"\nnumbers := []int{1, 2, 3, 4, 5, 6, 7, 8}',
    setupCode: 'import "slices"\nnumbers := []int{1, 2, 3, 4, 5, 6, 7, 8}',
    expected: [
      [1, 2, 3],
      [4, 5, 6],
      [7, 8],
    ],
    sample: 'chunks := slices.Collect(slices.Chunk(numbers, 3))',
    hints: [
      'Chunk returns an iterator',
      'Use slices.Collect to get slice of slices',
      'Last chunk may be smaller',
    ],
    validPatterns: [
      /slices\.Chunk\s*\(\s*numbers\s*,\s*3\s*\)/,
      /slices\.Collect\s*\(\s*slices\.Chunk/,
    ],
    tags: ['slices', 'Chunk', 'batch', 'iterator', 'Go1.23'],
  },
  {
    id: 'go-slice-generic-map-1',
    category: 'Slice Advanced Operations',
    difficulty: 'hard',
    title: 'Generic Map Function Pattern',
    text: 'Write a generic map function signature and use it to square all numbers.',
    setup: 'numbers := []int{1, 2, 3, 4, 5}',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5}',
    expected: [1, 4, 9, 16, 25],
    sample:
      'func Map[T, U any](s []T, f func(T) U) []U { r := make([]U, len(s)); for i, v := range s { r[i] = f(v) }; return r }; Map(numbers, func(n int) int { return n * n })',
    hints: [
      'Use type parameters [T, U any]',
      'Accept slice and transform function',
      'Return new slice of transformed elements',
    ],
    validPatterns: [
      /func\s+\w*\s*\[\s*\w+\s*,\s*\w+\s+any\s*\]/,
      /func\s*\(\s*\w+\s+int\s*\)\s*int\s*\{\s*return\s+\w+\s*\*\s*\w+/,
      /make\s*\(\s*\[\s*\]\s*\w+\s*,\s*len\s*\(/,
    ],
    tags: ['slice', 'generic', 'map', 'transform', 'Go1.18'],
  },

  // ============================================================
  // Go Patterns and Idioms
  // ============================================================

  // --- EASY (8 problems) ---

  {
    id: 'go-patterns-slice-filter-1',
    category: 'Go Patterns',
    difficulty: 'easy',
    title: 'Filter Slice with Range',
    text: 'Use a range loop to filter and keep only even numbers in a new slice.',
    setup: 'numbers := []int{1, 2, 3, 4, 5, 6, 7, 8}\nvar result []int',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5, 6, 7, 8}\nvar result []int',
    expected: [2, 4, 6, 8],
    sample: 'for _, n := range numbers { if n%2 == 0 { result = append(result, n) } }',
    hints: ['Use modulo to check for even numbers', 'Append matching elements to result'],
    validPatterns: [
      /for\s*(?:_\s*,)?\s*\w+\s*:=\s*range\s+numbers\s*\{[^}]*%\s*2\s*==\s*0[^}]*append/,
    ],
    tags: ['slice', 'filter', 'range', 'pattern'],
  },
  {
    id: 'go-patterns-slice-transform-1',
    category: 'Go Patterns',
    difficulty: 'easy',
    title: 'Transform Slice Elements In-Place',
    text: 'Double each element in the slice using range with index.',
    setup: 'numbers := []int{1, 2, 3, 4, 5}',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5}',
    expected: [2, 4, 6, 8, 10],
    sample: 'for i := range numbers { numbers[i] *= 2 }',
    hints: ['Use index to modify slice in place', 'Multiply each element by 2'],
    validPatterns: [/for\s+\w+\s*:=\s*range\s+numbers\s*\{[^}]*\*=\s*2/],
    tags: ['slice', 'transform', 'range', 'index'],
  },
  {
    id: 'go-patterns-slice-sum-1',
    category: 'Go Patterns',
    difficulty: 'easy',
    title: 'Sum Slice Elements',
    text: 'Calculate the sum of all elements in the slice using range.',
    setup: 'numbers := []int{1, 2, 3, 4, 5}\nsum := 0',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5}\nsum := 0',
    expected: 15,
    sample: 'for _, n := range numbers { sum += n }',
    hints: ['Use range to iterate', 'Accumulate into sum variable'],
    validPatterns: [/for\s*(?:_\s*,)?\s*\w+\s*:=\s*range\s+numbers\s*\{[^}]*\+=\s*\w+/],
    tags: ['slice', 'sum', 'range', 'accumulate'],
  },
  {
    id: 'go-patterns-map-values-1',
    category: 'Go Patterns',
    difficulty: 'easy',
    title: 'Collect Map Values into Slice',
    text: 'Extract all values from the map into a slice.',
    setup: 'm := map[string]int{"a": 1, "b": 2, "c": 3}\nvar values []int',
    setupCode: 'm := map[string]int{"a": 1, "b": 2, "c": 3}\nvar values []int',
    expected: 'values contains 1, 2, 3',
    sample: 'for _, v := range m { values = append(values, v) }',
    hints: ['Use _ to ignore the key', 'Append each value to the slice'],
    validPatterns: [/for\s*_\s*,\s*\w+\s*:=\s*range\s+m\s*\{[^}]*append\s*\([^)]*\)/],
    tags: ['map', 'values', 'range', 'pattern'],
  },
  {
    id: 'go-patterns-map-keys-collect-1',
    category: 'Go Patterns',
    difficulty: 'easy',
    title: 'Collect Map Keys into Slice',
    text: 'Extract all keys from the map into a slice.',
    setup: 'm := map[string]int{"x": 10, "y": 20, "z": 30}\nvar keys []string',
    setupCode: 'm := map[string]int{"x": 10, "y": 20, "z": 30}\nvar keys []string',
    expected: 'keys contains x, y, z',
    sample: 'for k := range m { keys = append(keys, k) }',
    hints: ['Use single variable in range', 'Append each key to the slice'],
    validPatterns: [/for\s+\w+\s*:=\s*range\s+m\s*\{[^}]*append\s*\([^)]*\)/],
    tags: ['map', 'keys', 'range', 'pattern'],
  },
  {
    id: 'go-patterns-error-check-1',
    category: 'Go Patterns',
    difficulty: 'easy',
    title: 'Basic Error Check Pattern',
    text: 'Write the idiomatic Go error check that returns early on error.',
    setup: 'func process() error {\n    err := doSomething()\n    // Check error here',
    setupCode: 'func process() error {\n    err := doSomething()\n    // Check error here',
    expected: 'if err != nil { return err }',
    sample: 'if err != nil { return err }',
    hints: ['Check if err is not nil', 'Return early with the error'],
    validPatterns: [/if\s+err\s*!=\s*nil\s*\{\s*return\s+err\s*\}/],
    tags: ['error', 'check', 'idiom', 'pattern'],
  },
  {
    id: 'go-patterns-error-sentinel-1',
    category: 'Go Patterns',
    difficulty: 'easy',
    title: 'Define Sentinel Error',
    text: 'Define a package-level sentinel error for "not found" condition.',
    setup: 'import "errors"\n// Define sentinel error here',
    setupCode: 'import "errors"\n// Define sentinel error here',
    expected: 'var ErrNotFound = errors.New("not found")',
    sample: 'var ErrNotFound = errors.New("not found")',
    hints: ['Use var for package-level errors', 'Start name with Err prefix'],
    validPatterns: [/var\s+Err\w+\s*=\s*errors\.New\s*\(/],
    tags: ['error', 'sentinel', 'idiom', 'pattern'],
  },
  {
    id: 'go-patterns-interface-stringer-1',
    category: 'Go Patterns',
    difficulty: 'easy',
    title: 'Implement Stringer Interface',
    text: 'Implement the String() method to make Person satisfy fmt.Stringer.',
    setup: 'type Person struct { Name string; Age int }\n// Implement String() method',
    setupCode: 'type Person struct { Name string; Age int }\n// Implement String() method',
    expected: 'func (p Person) String() string',
    sample: 'func (p Person) String() string { return fmt.Sprintf("%s (%d)", p.Name, p.Age) }',
    hints: ['String() must return string', 'Use value receiver for small structs'],
    validPatterns: [/func\s*\(\s*\w+\s+Person\s*\)\s*String\s*\(\s*\)\s*string/],
    tags: ['interface', 'stringer', 'method', 'pattern'],
  },

  // --- MEDIUM (12 problems) ---

  {
    id: 'go-patterns-method-pointer-1',
    category: 'Go Patterns',
    difficulty: 'medium',
    title: 'Method with Pointer Receiver',
    text: 'Add a method to increment the counter using a pointer receiver.',
    setup: 'type Counter struct { value int }\n// Add Increment method',
    setupCode: 'type Counter struct { value int }\n// Add Increment method',
    expected: 'func (c *Counter) Increment()',
    sample: 'func (c *Counter) Increment() { c.value++ }',
    hints: ['Use pointer receiver to modify struct', '*Counter instead of Counter'],
    validPatterns: [/func\s*\(\s*\w+\s+\*Counter\s*\)\s*Increment\s*\(\s*\)/],
    tags: ['method', 'pointer', 'receiver', 'pattern'],
  },
  {
    id: 'go-patterns-method-chain-1',
    category: 'Go Patterns',
    difficulty: 'medium',
    title: 'Method Chaining Pattern',
    text: 'Implement SetName that returns *Builder for method chaining.',
    setup: 'type Builder struct { name string }\n// Add SetName method that returns *Builder',
    setupCode: 'type Builder struct { name string }\n// Add SetName method that returns *Builder',
    expected: 'func (b *Builder) SetName(name string) *Builder',
    sample: 'func (b *Builder) SetName(name string) *Builder { b.name = name; return b }',
    hints: ['Return pointer to receiver for chaining', 'Allows b.SetName("x").SetAge(20)'],
    validPatterns: [
      /func\s*\(\s*\w+\s+\*Builder\s*\)\s*SetName\s*\(\s*\w+\s+string\s*\)\s*\*Builder/,
    ],
    tags: ['method', 'chain', 'builder', 'pattern'],
  },
  {
    id: 'go-patterns-defer-close-1',
    category: 'Go Patterns',
    difficulty: 'medium',
    title: 'Defer Resource Cleanup',
    text: 'Use defer to ensure the file is closed after opening.',
    setup:
      'import "os"\nf, err := os.Open("file.txt")\nif err != nil { return err }\n// Defer close here',
    setupCode:
      'import "os"\nf, err := os.Open("file.txt")\nif err != nil { return err }\n// Defer close here',
    expected: 'defer f.Close()',
    sample: 'defer f.Close()',
    hints: ['defer executes when function returns', 'Place defer right after error check'],
    validPatterns: [/defer\s+\w+\.Close\s*\(\s*\)/],
    tags: ['defer', 'close', 'resource', 'pattern'],
  },
  {
    id: 'go-patterns-defer-unlock-1',
    category: 'Go Patterns',
    difficulty: 'medium',
    title: 'Defer Mutex Unlock',
    text: 'Lock the mutex and defer its unlock.',
    setup: 'import "sync"\nvar mu sync.Mutex\n// Lock and defer unlock',
    setupCode: 'import "sync"\nvar mu sync.Mutex\n// Lock and defer unlock',
    expected: 'mu.Lock(); defer mu.Unlock()',
    sample: 'mu.Lock()\ndefer mu.Unlock()',
    hints: ['Lock first, then defer unlock', 'Ensures unlock even on panic'],
    validPatterns: [/mu\.Lock\s*\(\s*\)[;\s]*defer\s+mu\.Unlock\s*\(\s*\)/],
    tags: ['defer', 'mutex', 'sync', 'pattern'],
  },
  {
    id: 'go-patterns-defer-recover-1',
    category: 'Go Patterns',
    difficulty: 'medium',
    title: 'Defer with Recover',
    text: 'Use defer with recover to catch panics.',
    setup: 'func safeCall() {\n    // Add defer recover pattern',
    setupCode: 'func safeCall() {\n    // Add defer recover pattern',
    expected: 'defer func() { if r := recover(); r != nil { /* handle */ } }()',
    sample: 'defer func() { if r := recover(); r != nil { fmt.Println("recovered:", r) } }()',
    hints: ['recover() must be in deferred function', 'Returns nil if no panic'],
    validPatterns: [/defer\s+func\s*\(\s*\)\s*\{[^}]*recover\s*\(\s*\)/],
    tags: ['defer', 'recover', 'panic', 'pattern'],
  },
  {
    id: 'go-patterns-range-index-1',
    category: 'Go Patterns',
    difficulty: 'medium',
    title: 'Range with Conditional Index Skip',
    text: 'Iterate slice and build new slice keeping elements at even indices (0, 2, 4...).',
    setup: 'numbers := []int{1, 2, 3, 4, 5, 6}\nvar result []int',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5, 6}\nvar result []int',
    expected: [1, 3, 5],
    sample: 'for i, n := range numbers { if i%2 == 0 { result = append(result, n) } }',
    hints: ['Use index to determine which elements to keep', 'Even indices are 0, 2, 4...'],
    validPatterns: [
      /for\s+\w+\s*,\s*\w+\s*:=\s*range\s+numbers\s*\{[^}]*%\s*2\s*==\s*0[^}]*append/,
    ],
    tags: ['range', 'index', 'filter', 'pattern'],
  },
  {
    id: 'go-patterns-range-reverse-1',
    category: 'Go Patterns',
    difficulty: 'medium',
    title: 'Iterate Slice in Reverse',
    text: 'Iterate the slice in reverse order using index.',
    setup: 'numbers := []int{1, 2, 3, 4, 5}\nvar result []int',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5}\nvar result []int',
    expected: [5, 4, 3, 2, 1],
    sample: 'for i := len(numbers) - 1; i >= 0; i-- { result = append(result, numbers[i]) }',
    hints: ['Start from len-1, go down to 0', 'Classic for loop, not range'],
    validPatterns: [
      /for\s+\w+\s*:=\s*len\s*\(\s*numbers\s*\)\s*-\s*1\s*;\s*\w+\s*>=\s*0\s*;\s*\w+\s*--/,
    ],
    tags: ['range', 'reverse', 'index', 'pattern'],
  },
  {
    id: 'go-patterns-range-enumerate-1',
    category: 'Go Patterns',
    difficulty: 'medium',
    title: 'Enumerate with Custom Start Index',
    text: 'Create enumerated pairs starting from 1 instead of 0.',
    setup:
      'items := []string{"a", "b", "c"}\ntype Enum struct { Index int; Value string }\nvar result []Enum',
    setupCode:
      'items := []string{"a", "b", "c"}\ntype Enum struct { Index int; Value string }\nvar result []Enum',
    expected: [
      { Index: 1, Value: 'a' },
      { Index: 2, Value: 'b' },
      { Index: 3, Value: 'c' },
    ],
    sample: 'for i, v := range items { result = append(result, Enum{i + 1, v}) }',
    hints: ['Add 1 to index in the loop', 'Create struct with adjusted index'],
    validPatterns: [/for\s+\w+\s*,\s*\w+\s*:=\s*range\s+items\s*\{[^}]*\w+\s*\+\s*1/],
    tags: ['range', 'enumerate', 'index', 'pattern'],
  },
  {
    id: 'go-patterns-range-window-1',
    category: 'Go Patterns',
    difficulty: 'medium',
    title: 'Sliding Window with Range',
    text: 'Iterate with a sliding window of size 2 to get consecutive pairs.',
    setup: 'numbers := []int{1, 2, 3, 4, 5}\ntype Pair struct { A, B int }\nvar pairs []Pair',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5}\ntype Pair struct { A, B int }\nvar pairs []Pair',
    expected: [
      { A: 1, B: 2 },
      { A: 2, B: 3 },
      { A: 3, B: 4 },
      { A: 4, B: 5 },
    ],
    sample:
      'for i := 0; i < len(numbers)-1; i++ { pairs = append(pairs, Pair{numbers[i], numbers[i+1]}) }',
    hints: ['Stop at len-1 to avoid out of bounds', 'Access current and next element'],
    validPatterns: [/for\s+\w+\s*:=\s*0\s*;\s*\w+\s*<\s*len\s*\(\s*numbers\s*\)\s*-\s*1/],
    tags: ['range', 'window', 'pairs', 'pattern'],
  },
  {
    id: 'go-patterns-map-groupby-1',
    category: 'Go Patterns',
    difficulty: 'medium',
    title: 'Group By Pattern',
    text: 'Group people by their age into a map of slices.',
    setup:
      'type Person struct { Name string; Age int }\npeople := []Person{{"Alice", 30}, {"Bob", 25}, {"Carol", 30}}\ngrouped := make(map[int][]Person)',
    setupCode:
      'type Person struct { Name string; Age int }\npeople := []Person{{"Alice", 30}, {"Bob", 25}, {"Carol", 30}}\ngrouped := make(map[int][]Person)',
    expected: {
      25: [{ Name: 'Bob', Age: 25 }],
      30: [
        { Name: 'Alice', Age: 30 },
        { Name: 'Carol', Age: 30 },
      ],
    },
    sample: 'for _, p := range people { grouped[p.Age] = append(grouped[p.Age], p) }',
    hints: ['Use the grouping key as map key', 'Append to slice value in map'],
    validPatterns: [
      /for\s*(?:_\s*,)?\s*\w+\s*:=\s*range\s+people\s*\{[^}]*grouped\s*\[\s*\w+\.Age\s*\]\s*=\s*append/,
    ],
    tags: ['map', 'groupby', 'pattern', 'slice'],
  },
  {
    id: 'go-patterns-map-invert-1',
    category: 'Go Patterns',
    difficulty: 'medium',
    title: 'Invert Map Keys and Values',
    text: 'Swap keys and values of the map (assumes unique values).',
    setup: 'm := map[string]int{"a": 1, "b": 2}\ninverted := make(map[int]string)',
    setupCode: 'm := map[string]int{"a": 1, "b": 2}\ninverted := make(map[int]string)',
    expected: { 1: 'a', 2: 'b' },
    sample: 'for k, v := range m { inverted[v] = k }',
    hints: ['Iterate over original map', 'Use value as new key, key as new value'],
    validPatterns: [
      /for\s+\w+\s*,\s*\w+\s*:=\s*range\s+m\s*\{[^}]*inverted\s*\[\s*\w+\s*\]\s*=\s*\w+/,
    ],
    tags: ['map', 'invert', 'range', 'pattern'],
  },
  {
    id: 'go-patterns-interface-typeswitch-1',
    category: 'Go Patterns',
    difficulty: 'medium',
    title: 'Type Switch Pattern',
    text: 'Use type switch to handle different types in an any value.',
    setup: 'var v any = 42\nvar result string',
    setupCode: 'var v any = 42\nvar result string',
    expected: 'int',
    sample:
      'switch v.(type) { case int: result = "int"; case string: result = "string"; default: result = "unknown" }',
    hints: ['Use switch v.(type)', 'Each case handles a specific type'],
    validPatterns: [/switch\s+\w+\.\(type\)\s*\{[^}]*case\s+int:/],
    tags: ['interface', 'type-switch', 'any', 'pattern'],
  },

  // --- HARD (5 problems) ---

  {
    id: 'go-patterns-slice-unique-1',
    category: 'Go Patterns',
    difficulty: 'hard',
    title: 'Remove Duplicates from Slice',
    text: 'Remove duplicate integers using a map to track seen values.',
    setup: 'numbers := []int{1, 2, 2, 3, 3, 3, 4}\nseen := make(map[int]bool)\nvar result []int',
    setupCode:
      'numbers := []int{1, 2, 2, 3, 3, 3, 4}\nseen := make(map[int]bool)\nvar result []int',
    expected: [1, 2, 3, 4],
    sample:
      'for _, n := range numbers { if !seen[n] { seen[n] = true; result = append(result, n) } }',
    hints: ['Use map to track seen elements', 'Only append if not seen before'],
    validPatterns: [
      /for\s*(?:_\s*,)?\s*\w+\s*:=\s*range\s+numbers\s*\{[^}]*seen\s*\[\s*\w+\s*\][^}]*append/,
    ],
    tags: ['slice', 'unique', 'dedupe', 'pattern'],
  },
  {
    id: 'go-patterns-slice-chunk-1',
    category: 'Go Patterns',
    difficulty: 'hard',
    title: 'Chunk Slice into Batches',
    text: 'Split slice into chunks of size 3.',
    setup: 'numbers := []int{1, 2, 3, 4, 5, 6, 7, 8}\nchunkSize := 3\nvar chunks [][]int',
    setupCode: 'numbers := []int{1, 2, 3, 4, 5, 6, 7, 8}\nchunkSize := 3\nvar chunks [][]int',
    expected: [
      [1, 2, 3],
      [4, 5, 6],
      [7, 8],
    ],
    sample:
      'for i := 0; i < len(numbers); i += chunkSize { end := i + chunkSize; if end > len(numbers) { end = len(numbers) }; chunks = append(chunks, numbers[i:end]) }',
    hints: ['Iterate with step size equal to chunk size', 'Handle last chunk that may be smaller'],
    validPatterns: [
      /for\s+\w+\s*:=\s*0\s*;\s*\w+\s*<\s*len\s*\(\s*numbers\s*\)\s*;\s*\w+\s*\+=\s*chunkSize/,
    ],
    tags: ['slice', 'chunk', 'batch', 'pattern'],
  },
  {
    id: 'go-patterns-slice-zip-1',
    category: 'Go Patterns',
    difficulty: 'hard',
    title: 'Zip Two Slices Together',
    text: 'Combine two slices into pairs (stop at shorter slice length).',
    setup:
      'a := []string{"x", "y", "z"}\nb := []int{1, 2, 3}\ntype Pair struct { S string; N int }\nvar result []Pair',
    setupCode:
      'a := []string{"x", "y", "z"}\nb := []int{1, 2, 3}\ntype Pair struct { S string; N int }\nvar result []Pair',
    expected: [
      { S: 'x', N: 1 },
      { S: 'y', N: 2 },
      { S: 'z', N: 3 },
    ],
    sample:
      'n := len(a); if len(b) < n { n = len(b) }; for i := 0; i < n; i++ { result = append(result, Pair{a[i], b[i]}) }',
    hints: ['Find minimum length of both slices', 'Iterate using index to access both slices'],
    validPatterns: [/for\s+\w+\s*:=\s*0\s*;\s*\w+\s*<\s*\w+\s*;\s*\w+\+\+\s*\{[^}]*Pair\s*\{/],
    tags: ['slice', 'zip', 'combine', 'pattern'],
  },
  {
    id: 'go-patterns-error-custom-1',
    category: 'Go Patterns',
    difficulty: 'hard',
    title: 'Custom Error Type with Context',
    text: 'Define a custom error type that includes operation name and underlying error.',
    setup:
      '// Define OpError struct with Op string and Err error fields\n// Implement Error() and Unwrap() methods',
    setupCode:
      '// Define OpError struct with Op string and Err error fields\n// Implement Error() and Unwrap() methods',
    expected:
      'type OpError struct { Op string; Err error }; func (e *OpError) Error() string; func (e *OpError) Unwrap() error',
    sample:
      'type OpError struct { Op string; Err error }\nfunc (e *OpError) Error() string { return e.Op + ": " + e.Err.Error() }\nfunc (e *OpError) Unwrap() error { return e.Err }',
    hints: ['Implement Error() for error interface', 'Implement Unwrap() for error chaining'],
    validPatterns: [
      /type\s+OpError\s+struct\s*\{[^}]*Op\s+string[^}]*Err\s+error/,
      /func\s*\(\s*\w+\s+\*?OpError\s*\)\s*Error\s*\(\s*\)\s*string/,
    ],
    tags: ['error', 'custom', 'unwrap', 'pattern'],
  },
  {
    id: 'go-patterns-error-multi-1',
    category: 'Go Patterns',
    difficulty: 'hard',
    title: 'Join Multiple Errors',
    text: 'Use errors.Join to combine multiple errors into one (Go 1.20+).',
    setup:
      'import "errors"\nerr1 := errors.New("error 1")\nerr2 := errors.New("error 2")\nerr3 := errors.New("error 3")',
    setupCode:
      'import "errors"\nerr1 := errors.New("error 1")\nerr2 := errors.New("error 2")\nerr3 := errors.New("error 3")',
    expected: 'combined error with all three',
    sample: 'errors.Join(err1, err2, err3)',
    hints: ['errors.Join combines multiple errors', 'Result works with errors.Is for any of them'],
    validPatterns: [/errors\.Join\s*\(\s*err1\s*,\s*err2\s*,\s*err3\s*\)/],
    tags: ['error', 'join', 'multiple', 'Go1.20'],
  },
];

export default goProblems;
