/**
 * C Cheatsheet
 *
 * Essential C functions and patterns for coding interviews.
 * Covers string.h, stdlib.h, stdio.h, and memory manipulation.
 */

import type { CheatsheetEntry } from './types';

export const cCheatsheet: CheatsheetEntry[] = [
  // ============================================================
  // String Functions (string.h)
  // ============================================================
  {
    name: 'strlen',
    category: 'strings',
    syntax: 'size_t strlen(const char *str)',
    description: 'Returns the length of a string (excluding null terminator)',
    example: {
      code: 'char s[] = "hello";\nsize_t len = strlen(s);',
      output: 'len = 5',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Does not count the null terminator',
      'Undefined behavior if string is not null-terminated',
    ],
    interviewTip: 'Cache strlen result in loops to avoid O(n^2) complexity',
    priority: 'essential',
  },
  {
    name: 'strcpy',
    category: 'strings',
    syntax: 'char *strcpy(char *dest, const char *src)',
    description: 'Copies string from src to dest including null terminator',
    example: {
      code: 'char dest[20];\nstrcpy(dest, "hello");',
      output: 'dest = "hello"',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['No bounds checking - buffer overflow risk', 'dest must have enough space'],
    interviewTip: 'Prefer strncpy or manually check bounds in interviews',
    priority: 'essential',
  },
  {
    name: 'strncpy',
    category: 'strings',
    syntax: 'char *strncpy(char *dest, const char *src, size_t n)',
    description: 'Copies at most n characters from src to dest',
    example: {
      code: 'char dest[10];\nstrncpy(dest, "hello world", 5);\ndest[5] = \'\\0\';',
      output: 'dest = "hello"',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Does NOT null-terminate if src >= n chars', 'Must manually add null terminator'],
    interviewTip: "Always set dest[n-1] = '\\0' after strncpy for safety",
    priority: 'essential',
  },
  {
    name: 'strcat',
    category: 'strings',
    syntax: 'char *strcat(char *dest, const char *src)',
    description: 'Appends src string to the end of dest',
    example: {
      code: 'char dest[20] = "hello ";\nstrcat(dest, "world");',
      output: 'dest = "hello world"',
    },
    timeComplexity: 'O(n + m)',
    spaceComplexity: 'O(1)',
    gotchas: ['No bounds checking', 'dest must have space for both strings + null'],
    interviewTip: 'Track dest length separately to avoid repeated strlen calls',
    priority: 'essential',
  },
  {
    name: 'strncat',
    category: 'strings',
    syntax: 'char *strncat(char *dest, const char *src, size_t n)',
    description: 'Appends at most n characters from src to dest',
    example: {
      code: 'char dest[20] = "hello ";\nstrncat(dest, "world!!!", 5);',
      output: 'dest = "hello world"',
    },
    timeComplexity: 'O(n + m)',
    spaceComplexity: 'O(1)',
    gotchas: ['Always null-terminates (unlike strncpy)', 'Need space for n+1 additional chars'],
    priority: 'common',
  },
  {
    name: 'strcmp',
    category: 'strings',
    syntax: 'int strcmp(const char *s1, const char *s2)',
    description: 'Compares two strings lexicographically',
    example: {
      code: 'int result = strcmp("abc", "abd");',
      output: 'result < 0 (negative)',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns 0 for equal strings (falsy in C)', 'Comparison is case-sensitive'],
    interviewTip: 'Return value: <0 if s1<s2, 0 if equal, >0 if s1>s2',
    priority: 'essential',
  },
  {
    name: 'strncmp',
    category: 'strings',
    syntax: 'int strncmp(const char *s1, const char *s2, size_t n)',
    description: 'Compares at most n characters of two strings',
    example: {
      code: 'int result = strncmp("hello", "help", 3);',
      output: 'result = 0 (first 3 chars equal)',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Stops at null terminator even if n not reached'],
    interviewTip: 'Useful for prefix matching in interview problems',
    priority: 'common',
  },
  {
    name: 'strchr',
    category: 'strings',
    syntax: 'char *strchr(const char *str, int c)',
    description: 'Finds first occurrence of character c in string',
    example: {
      code: 'char *p = strchr("hello", \'l\');',
      output: 'p points to "llo"',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns NULL if not found', 'Can search for null terminator'],
    interviewTip: 'Use to check if character exists: if (strchr(str, c))',
    priority: 'essential',
  },
  {
    name: 'strrchr',
    category: 'strings',
    syntax: 'char *strrchr(const char *str, int c)',
    description: 'Finds last occurrence of character c in string',
    example: {
      code: 'char *p = strrchr("hello", \'l\');',
      output: 'p points to "lo"',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns NULL if not found'],
    interviewTip: 'Useful for finding file extensions or last delimiter',
    priority: 'common',
  },
  {
    name: 'strstr',
    category: 'strings',
    syntax: 'char *strstr(const char *haystack, const char *needle)',
    description: 'Finds first occurrence of substring needle in haystack',
    example: {
      code: 'char *p = strstr("hello world", "world");',
      output: 'p points to "world"',
    },
    timeComplexity: 'O(n * m)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns NULL if not found', 'Returns haystack if needle is empty'],
    interviewTip: 'Classic interview problem - implement your own strstr using KMP',
    priority: 'essential',
  },
  {
    name: 'strtok',
    category: 'strings',
    syntax: 'char *strtok(char *str, const char *delim)',
    description: 'Tokenizes string by delimiters (modifies original string)',
    example: {
      code: 'char s[] = "a,b,c";\nchar *tok = strtok(s, ",");\nwhile (tok) {\n  printf("%s\\n", tok);\n  tok = strtok(NULL, ",");\n}',
      output: 'a\\nb\\nc',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Modifies original string',
      'Not thread-safe (uses static state)',
      'Pass NULL for subsequent calls',
    ],
    interviewTip: 'Mention thread-safe strtok_r alternative in interviews',
    priority: 'common',
  },
  {
    name: 'memset',
    category: 'memory',
    syntax: 'void *memset(void *ptr, int value, size_t num)',
    description: 'Fills memory block with specified byte value',
    example: {
      code: 'int arr[5];\nmemset(arr, 0, sizeof(arr));',
      output: 'arr = {0, 0, 0, 0, 0}',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Sets bytes, not ints - only use 0 or -1 for int arrays',
      'memset(arr, 1, ...) does NOT set ints to 1',
    ],
    interviewTip: 'Only safe values for int arrays are 0 and -1',
    priority: 'essential',
  },
  {
    name: 'memcpy',
    category: 'memory',
    syntax: 'void *memcpy(void *dest, const void *src, size_t n)',
    description: 'Copies n bytes from src to dest (non-overlapping)',
    example: {
      code: 'int src[] = {1, 2, 3};\nint dest[3];\nmemcpy(dest, src, sizeof(src));',
      output: 'dest = {1, 2, 3}',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Undefined behavior if regions overlap', 'Use memmove for overlapping regions'],
    interviewTip: 'Faster than memmove but requires non-overlapping memory',
    priority: 'essential',
  },
  {
    name: 'memmove',
    category: 'memory',
    syntax: 'void *memmove(void *dest, const void *src, size_t n)',
    description: 'Copies n bytes from src to dest (handles overlapping)',
    example: {
      code: 'char s[] = "hello";\nmemmove(s + 1, s, 4);',
      output: 's = "hhell"',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Slightly slower than memcpy due to overlap handling'],
    interviewTip: 'Use when shifting elements within same array',
    priority: 'essential',
  },
  {
    name: 'memcmp',
    category: 'memory',
    syntax: 'int memcmp(const void *s1, const void *s2, size_t n)',
    description: 'Compares n bytes of two memory blocks',
    example: {
      code: 'int a[] = {1, 2, 3};\nint b[] = {1, 2, 4};\nint r = memcmp(a, b, sizeof(a));',
      output: 'r < 0 (a < b)',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Compares raw bytes, not values', 'Padding bytes in structs may differ'],
    interviewTip: 'Useful for comparing binary data or struct equality',
    priority: 'common',
  },

  // ============================================================
  // Memory Allocation (stdlib.h)
  // ============================================================
  {
    name: 'malloc',
    category: 'memory',
    syntax: 'void *malloc(size_t size)',
    description: 'Allocates size bytes of uninitialized memory',
    example: {
      code: 'int *arr = (int *)malloc(5 * sizeof(int));',
      output: 'arr points to 5 uninitialized ints',
    },
    timeComplexity: 'O(1) typical',
    spaceComplexity: 'O(n)',
    gotchas: [
      'Returns NULL on failure - always check',
      'Memory is uninitialized (garbage values)',
      'Must free to avoid leaks',
    ],
    interviewTip: 'Always check for NULL and pair with free()',
    priority: 'essential',
  },
  {
    name: 'calloc',
    category: 'memory',
    syntax: 'void *calloc(size_t num, size_t size)',
    description: 'Allocates and zero-initializes array of num elements',
    example: {
      code: 'int *arr = (int *)calloc(5, sizeof(int));',
      output: 'arr points to {0, 0, 0, 0, 0}',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Slower than malloc due to zeroing', 'Returns NULL on failure'],
    interviewTip: 'Prefer calloc when you need zero-initialized memory',
    priority: 'essential',
  },
  {
    name: 'realloc',
    category: 'memory',
    syntax: 'void *realloc(void *ptr, size_t new_size)',
    description: 'Resizes previously allocated memory block',
    example: {
      code: 'int *arr = malloc(5 * sizeof(int));\narr = realloc(arr, 10 * sizeof(int));',
      output: 'arr now has space for 10 ints',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: [
      'May return new pointer - must reassign',
      'Old pointer invalid after realloc',
      'New memory is uninitialized',
    ],
    interviewTip: 'Use temp pointer: tmp = realloc(arr, ...) to avoid memory leaks on failure',
    priority: 'common',
  },
  {
    name: 'free',
    category: 'memory',
    syntax: 'void free(void *ptr)',
    description: 'Deallocates previously allocated memory',
    example: {
      code: 'int *arr = malloc(5 * sizeof(int));\nfree(arr);\narr = NULL;',
      output: 'Memory freed, arr set to NULL',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Double free is undefined behavior',
      'Use-after-free is undefined behavior',
      'free(NULL) is safe (no-op)',
    ],
    interviewTip: 'Set pointer to NULL after freeing to prevent use-after-free',
    priority: 'essential',
  },

  // ============================================================
  // Sorting and Searching (stdlib.h)
  // ============================================================
  {
    name: 'qsort',
    category: 'sorting',
    syntax: 'void qsort(void *base, size_t num, size_t size, int (*cmp)(const void*, const void*))',
    description: 'Sorts array using quicksort algorithm',
    example: {
      code: 'int cmp(const void *a, const void *b) {\n  return *(int*)a - *(int*)b;\n}\nint arr[] = {3, 1, 4, 1, 5};\nqsort(arr, 5, sizeof(int), cmp);',
      output: 'arr = {1, 1, 3, 4, 5}',
    },
    timeComplexity: 'O(n log n) average',
    spaceComplexity: 'O(log n)',
    gotchas: [
      'Comparator must return negative/zero/positive',
      'Not stable sort',
      'Comparator subtraction can overflow for large ints',
    ],
    interviewTip: 'For large ints, use if-else instead of subtraction in comparator',
    priority: 'essential',
  },
  {
    name: 'bsearch',
    category: 'searching',
    syntax:
      'void *bsearch(const void *key, const void *base, size_t num, size_t size, int (*cmp)(const void*, const void*))',
    description: 'Binary search in sorted array',
    example: {
      code: 'int arr[] = {1, 2, 3, 4, 5};\nint key = 3;\nint *p = bsearch(&key, arr, 5, sizeof(int), cmp);',
      output: 'p points to element 3',
    },
    timeComplexity: 'O(log n)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Array must be sorted',
      'Returns NULL if not found',
      'Returns any match (not first/last)',
    ],
    interviewTip: 'Know how to implement binary search manually for variants',
    priority: 'essential',
  },

  // ============================================================
  // Type Conversion (stdlib.h)
  // ============================================================
  {
    name: 'atoi',
    category: 'type-conversion',
    syntax: 'int atoi(const char *str)',
    description: 'Converts string to integer',
    example: {
      code: 'int n = atoi("42");',
      output: 'n = 42',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['No error checking', 'Returns 0 for invalid input', 'Undefined behavior on overflow'],
    interviewTip: 'Classic interview problem - implement atoi with error handling',
    priority: 'essential',
  },
  {
    name: 'strtol',
    category: 'type-conversion',
    syntax: 'long strtol(const char *str, char **endptr, int base)',
    description: 'Converts string to long with error detection and base support',
    example: {
      code: 'char *end;\nlong n = strtol("42abc", &end, 10);',
      output: 'n = 42, end points to "abc"',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Check endptr to detect partial conversion', 'Check errno for overflow'],
    interviewTip: 'More robust than atoi - supports error checking and different bases',
    priority: 'common',
  },
  {
    name: 'sprintf',
    category: 'strings',
    syntax: 'int sprintf(char *str, const char *format, ...)',
    description: 'Writes formatted output to string buffer',
    example: {
      code: 'char buf[50];\nsprintf(buf, "Value: %d", 42);',
      output: 'buf = "Value: 42"',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['No bounds checking - buffer overflow risk', 'Use snprintf instead'],
    interviewTip: 'Prefer snprintf with buffer size for safety',
    priority: 'common',
  },
  {
    name: 'snprintf',
    category: 'strings',
    syntax: 'int snprintf(char *str, size_t size, const char *format, ...)',
    description: 'Writes formatted output to string with size limit',
    example: {
      code: 'char buf[10];\nsnprintf(buf, sizeof(buf), "Hello %s", "World");',
      output: 'buf = "Hello Wor" (truncated)',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Returns chars that would be written (may exceed size)',
      'Always null-terminates if size > 0',
    ],
    interviewTip: 'Safe alternative to sprintf - always use in production code',
    priority: 'essential',
  },
  {
    name: 'sscanf',
    category: 'strings',
    syntax: 'int sscanf(const char *str, const char *format, ...)',
    description: 'Reads formatted input from string',
    example: {
      code: 'int a, b;\nsscanf("10 20", "%d %d", &a, &b);',
      output: 'a = 10, b = 20',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns number of items matched', 'Buffer overflow with %s - use width specifier'],
    interviewTip: 'Use %[^\\n] to read until newline, %*d to skip integers',
    priority: 'common',
  },

  // ============================================================
  // I/O Functions (stdio.h)
  // ============================================================
  {
    name: 'printf',
    category: 'io',
    syntax: 'int printf(const char *format, ...)',
    description: 'Prints formatted output to stdout',
    example: {
      code: 'printf("x=%d, pi=%.2f\\n", 5, 3.14159);',
      output: 'x=5, pi=3.14',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Format specifier must match argument type',
      '%d for int, %ld for long, %f for double',
    ],
    interviewTip: 'Know common format specifiers: %d, %s, %c, %f, %x, %p',
    priority: 'essential',
  },
  {
    name: 'scanf',
    category: 'io',
    syntax: 'int scanf(const char *format, ...)',
    description: 'Reads formatted input from stdin',
    example: {
      code: 'int n;\nscanf("%d", &n);',
      output: 'n = (user input)',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Must pass address (&var)',
      'Returns number of items read',
      'Buffer overflow with %s',
    ],
    interviewTip: 'Use fgets for strings instead of scanf %s',
    priority: 'essential',
  },
  {
    name: 'fgets',
    category: 'io',
    syntax: 'char *fgets(char *str, int n, FILE *stream)',
    description: 'Reads line from stream into buffer (safe)',
    example: {
      code: 'char buf[100];\nfgets(buf, sizeof(buf), stdin);',
      output: 'buf contains line with newline',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Keeps trailing newline', 'Returns NULL on EOF or error'],
    interviewTip: 'Safer than gets() - always use fgets for reading lines',
    priority: 'essential',
  },
  {
    name: 'fputs',
    category: 'io',
    syntax: 'int fputs(const char *str, FILE *stream)',
    description: 'Writes string to stream (no newline)',
    example: {
      code: 'fputs("Hello", stdout);',
      output: 'Hello (no newline)',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Does not append newline (unlike puts)'],
    priority: 'common',
  },
  {
    name: 'getchar',
    category: 'io',
    syntax: 'int getchar(void)',
    description: 'Reads single character from stdin',
    example: {
      code: 'int c = getchar();',
      output: 'c = ASCII value of input char',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns int (not char) to handle EOF', 'EOF is typically -1'],
    interviewTip: 'Use int type to properly detect EOF',
    priority: 'common',
  },
  {
    name: 'putchar',
    category: 'io',
    syntax: 'int putchar(int c)',
    description: 'Writes single character to stdout',
    example: {
      code: "putchar('A');",
      output: 'A',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns character written or EOF on error'],
    priority: 'common',
  },

  // ============================================================
  // Math Functions (math.h / stdlib.h)
  // ============================================================
  {
    name: 'abs',
    category: 'math',
    syntax: 'int abs(int n)',
    description: 'Returns absolute value of integer',
    example: {
      code: 'int a = abs(-5);',
      output: 'a = 5',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Undefined for INT_MIN (-2^31)', 'Use labs for long, llabs for long long'],
    interviewTip: 'abs(INT_MIN) overflows - handle edge case in interviews',
    priority: 'essential',
  },
  {
    name: 'fabs',
    category: 'math',
    syntax: 'double fabs(double x)',
    description: 'Returns absolute value of double',
    example: {
      code: 'double a = fabs(-3.14);',
      output: 'a = 3.14',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Include math.h', 'Link with -lm flag'],
    priority: 'common',
  },
  {
    name: 'sqrt',
    category: 'math',
    syntax: 'double sqrt(double x)',
    description: 'Returns square root of x',
    example: {
      code: 'double r = sqrt(16.0);',
      output: 'r = 4.0',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Domain error for negative numbers', 'Returns NaN for negative input'],
    interviewTip: "For integer square root, use binary search or Newton's method",
    priority: 'common',
  },
  {
    name: 'pow',
    category: 'math',
    syntax: 'double pow(double base, double exp)',
    description: 'Returns base raised to power exp',
    example: {
      code: 'double r = pow(2.0, 10.0);',
      output: 'r = 1024.0',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Floating point precision issues', 'Use bit shifting for powers of 2'],
    interviewTip: 'Implement integer power with O(log n) binary exponentiation',
    priority: 'common',
  },
  {
    name: 'floor',
    category: 'math',
    syntax: 'double floor(double x)',
    description: 'Rounds down to nearest integer',
    example: {
      code: 'double f = floor(3.7);',
      output: 'f = 3.0',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['floor(-3.7) = -4.0 (towards negative infinity)'],
    priority: 'common',
  },
  {
    name: 'ceil',
    category: 'math',
    syntax: 'double ceil(double x)',
    description: 'Rounds up to nearest integer',
    example: {
      code: 'double c = ceil(3.2);',
      output: 'c = 4.0',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['ceil(-3.2) = -3.0 (towards positive infinity)'],
    interviewTip: 'For integer ceil division: (a + b - 1) / b',
    priority: 'common',
  },

  // ============================================================
  // Character Functions (ctype.h)
  // ============================================================
  {
    name: 'isalpha',
    category: 'strings',
    syntax: 'int isalpha(int c)',
    description: 'Checks if character is alphabetic (a-z, A-Z)',
    example: {
      code: "if (isalpha('A')) { /* true */ }",
      output: 'true for A-Z, a-z',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Takes int, not char (for EOF handling)', 'Returns non-zero for true, 0 for false'],
    interviewTip: 'Combine with tolower/toupper for case-insensitive comparison',
    priority: 'essential',
  },
  {
    name: 'isdigit',
    category: 'strings',
    syntax: 'int isdigit(int c)',
    description: 'Checks if character is digit (0-9)',
    example: {
      code: "if (isdigit('5')) { /* true */ }",
      output: 'true for 0-9',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Only ASCII digits 0-9, not other numeric chars'],
    interviewTip: "Use in string parsing: c - '0' converts char to int",
    priority: 'essential',
  },
  {
    name: 'isalnum',
    category: 'strings',
    syntax: 'int isalnum(int c)',
    description: 'Checks if character is alphanumeric',
    example: {
      code: "if (isalnum('A') && isalnum('1')) { /* true */ }",
      output: 'true for a-z, A-Z, 0-9',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Equivalent to isalpha(c) || isdigit(c)'],
    interviewTip: 'Useful for valid palindrome problems (ignore non-alphanumeric)',
    priority: 'essential',
  },
  {
    name: 'isspace',
    category: 'strings',
    syntax: 'int isspace(int c)',
    description: 'Checks if character is whitespace',
    example: {
      code: "if (isspace(' ') && isspace('\\t')) { /* true */ }",
      output: 'true for space, tab, newline, etc.',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Includes: space, tab, newline, vertical tab, form feed, carriage return'],
    interviewTip: 'Use to skip whitespace in string parsing',
    priority: 'common',
  },
  {
    name: 'tolower',
    category: 'strings',
    syntax: 'int tolower(int c)',
    description: 'Converts character to lowercase',
    example: {
      code: "char c = tolower('A');",
      output: "c = 'a'",
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns unchanged if not uppercase', 'Returns int, cast to char if needed'],
    interviewTip: 'Manual: c | 32 or c + 32 (if uppercase)',
    priority: 'essential',
  },
  {
    name: 'toupper',
    category: 'strings',
    syntax: 'int toupper(int c)',
    description: 'Converts character to uppercase',
    example: {
      code: "char c = toupper('a');",
      output: "c = 'A'",
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns unchanged if not lowercase', 'Returns int, cast to char if needed'],
    interviewTip: 'Manual: c & ~32 or c - 32 (if lowercase)',
    priority: 'essential',
  },

  // ============================================================
  // Array Operations
  // ============================================================
  {
    name: 'sizeof',
    category: 'arrays',
    syntax: 'sizeof(type) or sizeof(expression)',
    description: 'Returns size in bytes of type or variable',
    example: {
      code: 'int arr[5];\nsize_t size = sizeof(arr) / sizeof(arr[0]);',
      output: 'size = 5',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'For pointers, returns pointer size not array size',
      'Compile-time constant for fixed arrays',
    ],
    interviewTip: 'sizeof(arr)/sizeof(arr[0]) gives array length for static arrays only',
    priority: 'essential',
  },

  // ============================================================
  // Utility Functions
  // ============================================================
  {
    name: 'rand',
    category: 'math',
    syntax: 'int rand(void)',
    description: 'Returns pseudo-random number between 0 and RAND_MAX',
    example: {
      code: 'srand(time(NULL));\nint r = rand() % 100;',
      output: 'r = random 0-99',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Call srand once at program start', 'rand() % n has slight bias for large n'],
    interviewTip: 'For unbiased range: rand() / (RAND_MAX / n + 1)',
    priority: 'common',
  },
  {
    name: 'exit',
    category: 'io',
    syntax: 'void exit(int status)',
    description: 'Terminates program with status code',
    example: {
      code: 'if (error) exit(1);\nexit(0);',
      output: 'Program exits with status',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['EXIT_SUCCESS = 0, EXIT_FAILURE = 1', 'Calls atexit handlers and flushes buffers'],
    priority: 'useful',
  },
  {
    name: 'assert',
    category: 'error-handling',
    syntax: 'void assert(int expression)',
    description: 'Aborts if expression is false (debugging)',
    example: {
      code: '#include <assert.h>\nassert(ptr != NULL);',
      output: 'Aborts if ptr is NULL',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Disabled with NDEBUG macro', 'Do not use for runtime error checking in production'],
    interviewTip: 'Use for invariant checking during development',
    priority: 'useful',
  },
];
