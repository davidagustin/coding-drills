/**
 * Ruby Cheatsheet
 *
 * Essential Ruby methods for coding interviews.
 * Covers Array, Hash, String, and Enumerable methods.
 */

import type { CheatsheetEntry } from './types';

export const rubyCheatsheet: CheatsheetEntry[] = [
  // ========== ARRAYS ==========
  {
    name: 'push / <<',
    category: 'arrays',
    syntax: 'array.push(item) or array << item',
    description: 'Adds one or more elements to the end of the array',
    example: { code: 'arr = [1, 2]\narr.push(3)\narr << 4\narr', output: '[1, 2, 3, 4]' },
    timeComplexity: 'O(1) amortized',
    spaceComplexity: 'O(1)',
    gotchas: ['Mutates the original array'],
    interviewTip: 'Use << for cleaner syntax when adding single elements',
    priority: 'essential',
  },
  {
    name: 'pop',
    category: 'arrays',
    syntax: 'array.pop or array.pop(n)',
    description: 'Removes and returns the last element(s) from the array',
    example: { code: 'arr = [1, 2, 3]\narr.pop', output: '3' },
    timeComplexity: 'O(1) for single, O(n) for multiple',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns nil if array is empty', 'Mutates the original array'],
    interviewTip: 'Use with push for stack operations',
    priority: 'essential',
  },
  {
    name: 'shift',
    category: 'arrays',
    syntax: 'array.shift or array.shift(n)',
    description: 'Removes and returns the first element(s) from the array',
    example: { code: 'arr = [1, 2, 3]\narr.shift', output: '1' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['O(n) because elements must be shifted', 'Mutates the original array'],
    interviewTip:
      'Use with push for queue operations, but consider using Queue class for better performance',
    priority: 'essential',
  },
  {
    name: 'unshift',
    category: 'arrays',
    syntax: 'array.unshift(item)',
    description: 'Adds one or more elements to the beginning of the array',
    example: { code: 'arr = [2, 3]\narr.unshift(1)', output: '[1, 2, 3]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['O(n) because elements must be shifted', 'Mutates the original array'],
    priority: 'common',
  },
  {
    name: 'first / last',
    category: 'arrays',
    syntax: 'array.first or array.first(n) / array.last or array.last(n)',
    description: 'Returns the first/last element(s) without modifying the array',
    example: {
      code: 'arr = [1, 2, 3, 4, 5]\n[arr.first, arr.last, arr.first(2)]',
      output: '[1, 5, [1, 2]]',
    },
    timeComplexity: 'O(1) for single, O(n) for multiple',
    spaceComplexity: 'O(1) for single, O(n) for multiple',
    gotchas: ['Returns nil if array is empty (single), empty array (multiple)'],
    interviewTip: 'Non-destructive alternative to shift/pop for just reading',
    priority: 'essential',
  },
  {
    name: 'flatten',
    category: 'arrays',
    syntax: 'array.flatten or array.flatten(depth)',
    description: 'Returns a new array that is a one-dimensional flattening',
    example: { code: '[[1, 2], [3, [4, 5]]].flatten', output: '[1, 2, 3, 4, 5]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['flatten! mutates in place', 'Use depth param for partial flattening'],
    interviewTip: 'Great for matrix problems and nested data structures',
    priority: 'essential',
  },
  {
    name: 'uniq',
    category: 'arrays',
    syntax: 'array.uniq or array.uniq { |item| block }',
    description: 'Returns a new array with duplicate values removed',
    example: { code: '[1, 2, 2, 3, 3, 3].uniq', output: '[1, 2, 3]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: [
      'uniq! mutates in place and returns nil if no changes',
      'Block form for custom uniqueness',
    ],
    interviewTip: 'Essential for removing duplicates; use Set for O(1) lookups',
    priority: 'essential',
  },
  {
    name: 'compact',
    category: 'arrays',
    syntax: 'array.compact',
    description: 'Returns a new array with all nil values removed',
    example: { code: '[1, nil, 2, nil, 3].compact', output: '[1, 2, 3]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['compact! mutates in place', 'Only removes nil, not false'],
    interviewTip: 'Clean up arrays after operations that may produce nil values',
    priority: 'common',
  },
  {
    name: 'reverse',
    category: 'arrays',
    syntax: 'array.reverse',
    description: 'Returns a new array with elements in reverse order',
    example: { code: '[1, 2, 3].reverse', output: '[3, 2, 1]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['reverse! mutates in place'],
    interviewTip: 'Useful for palindrome checks and reversing linked lists represented as arrays',
    priority: 'essential',
  },
  {
    name: 'sort',
    category: 'sorting',
    syntax: 'array.sort or array.sort { |a, b| block }',
    description: 'Returns a new sorted array',
    example: { code: '[3, 1, 2].sort', output: '[1, 2, 3]' },
    timeComplexity: 'O(n log n)',
    spaceComplexity: 'O(n)',
    gotchas: ['sort! mutates in place', 'Block should return -1, 0, or 1'],
    interviewTip: 'Use sort_by for complex sorting criteria',
    priority: 'essential',
  },
  {
    name: 'sort_by',
    category: 'sorting',
    syntax: 'array.sort_by { |item| key }',
    description: 'Sorts by the value returned from the block',
    example: { code: '["bb", "a", "ccc"].sort_by { |s| s.length }', output: '["a", "bb", "ccc"]' },
    timeComplexity: 'O(n log n)',
    spaceComplexity: 'O(n)',
    gotchas: ['More efficient than sort with block for expensive comparisons'],
    interviewTip: 'Use for sorting objects by a specific attribute',
    priority: 'essential',
  },
  {
    name: 'include?',
    category: 'searching',
    syntax: 'array.include?(item)',
    description: 'Returns true if the array contains the given item',
    example: { code: '[1, 2, 3].include?(2)', output: 'true' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Uses == for comparison', 'Consider Set for O(1) lookups'],
    interviewTip: 'For frequent lookups, convert to Set first',
    priority: 'essential',
  },
  {
    name: 'index / find_index',
    category: 'searching',
    syntax: 'array.index(item) or array.index { |x| block }',
    description: 'Returns the index of the first matching element, or nil',
    example: { code: '[1, 2, 3, 2].index(2)', output: '1' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns nil if not found, not -1'],
    interviewTip: 'Use rindex for last occurrence',
    priority: 'essential',
  },
  {
    name: 'slice / []',
    category: 'arrays',
    syntax: 'array[index] or array[start, length] or array[range]',
    description: 'Access elements or subarrays by index or range',
    example: {
      code: 'arr = [1, 2, 3, 4, 5]\n[arr[1], arr[1, 3], arr[1..3]]',
      output: '[2, [2, 3, 4], [2, 3, 4]]',
    },
    timeComplexity: 'O(1) for single, O(k) for range of k elements',
    spaceComplexity: 'O(1) for single, O(k) for range',
    gotchas: ['Negative indices count from end', 'Returns nil for out of bounds single index'],
    interviewTip: 'arr[-1] is idiomatic for last element',
    priority: 'essential',
  },
  {
    name: 'take / drop',
    category: 'arrays',
    syntax: 'array.take(n) / array.drop(n)',
    description: 'Returns first n elements / returns array without first n elements',
    example: {
      code: 'arr = [1, 2, 3, 4, 5]\n[arr.take(2), arr.drop(2)]',
      output: '[[1, 2], [3, 4, 5]]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Non-destructive operations'],
    interviewTip: 'Cleaner than slicing for simple head/tail operations',
    priority: 'common',
  },
  {
    name: 'zip',
    category: 'arrays',
    syntax: 'array.zip(other_array, ...)',
    description: 'Combines arrays element-wise into arrays of arrays',
    example: { code: '[1, 2, 3].zip(["a", "b", "c"])', output: '[[1, "a"], [2, "b"], [3, "c"]]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Fills with nil if arrays have different lengths'],
    interviewTip: 'Useful for parallel iteration over multiple arrays',
    priority: 'common',
  },
  {
    name: 'rotate',
    category: 'arrays',
    syntax: 'array.rotate(count = 1)',
    description: 'Returns new array rotated by count positions',
    example: { code: '[1, 2, 3, 4, 5].rotate(2)', output: '[3, 4, 5, 1, 2]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Negative count rotates in opposite direction', 'rotate! mutates in place'],
    interviewTip: 'Useful for circular array problems',
    priority: 'useful',
  },

  // ========== ENUMERABLE / ITERATION ==========
  {
    name: 'each',
    category: 'iteration',
    syntax: 'collection.each { |item| block }',
    description: 'Iterates over each element, returns the original collection',
    example: { code: '[1, 2, 3].each { |n| puts n }', output: '1\n2\n3' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns original collection, not block results'],
    interviewTip: 'Use map if you need transformed results',
    priority: 'essential',
  },
  {
    name: 'each_with_index',
    category: 'iteration',
    syntax: 'collection.each_with_index { |item, index| block }',
    description: 'Iterates with both element and its index',
    example: {
      code: '["a", "b"].each_with_index { |c, i| puts "#{i}: #{c}" }',
      output: '0: a\n1: b',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Index is second parameter'],
    interviewTip: 'Essential when you need both value and position',
    priority: 'essential',
  },
  {
    name: 'map / collect',
    category: 'functional',
    syntax: 'collection.map { |item| block }',
    description: 'Returns a new array with block results for each element',
    example: { code: '[1, 2, 3].map { |n| n * 2 }', output: '[2, 4, 6]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['map! mutates in place', 'Returns array even for hashes'],
    interviewTip: 'Most common transformation method; master this',
    priority: 'essential',
  },
  {
    name: 'select / filter',
    category: 'functional',
    syntax: 'collection.select { |item| condition }',
    description: 'Returns array of elements for which block returns truthy',
    example: { code: '[1, 2, 3, 4, 5].select { |n| n.even? }', output: '[2, 4]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['select! mutates in place', 'filter is an alias in Ruby 2.6+'],
    interviewTip: 'Pair with map for filter-then-transform patterns',
    priority: 'essential',
  },
  {
    name: 'reject',
    category: 'functional',
    syntax: 'collection.reject { |item| condition }',
    description: 'Returns array of elements for which block returns falsy',
    example: { code: '[1, 2, 3, 4, 5].reject { |n| n.even? }', output: '[1, 3, 5]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['reject! mutates in place'],
    interviewTip: 'Opposite of select; use whichever is more readable',
    priority: 'essential',
  },
  {
    name: 'reduce / inject',
    category: 'functional',
    syntax: 'collection.reduce(initial) { |acc, item| block }',
    description: 'Combines all elements by applying binary operation',
    example: { code: '[1, 2, 3, 4].reduce(0) { |sum, n| sum + n }', output: '10' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['First element is used as initial if not provided', 'Can use symbol: reduce(:+)'],
    interviewTip: 'Master this for sum, product, building hashes, and complex aggregations',
    priority: 'essential',
  },
  {
    name: 'find / detect',
    category: 'searching',
    syntax: 'collection.find { |item| condition }',
    description: 'Returns the first element for which block returns truthy',
    example: { code: '[1, 2, 3, 4].find { |n| n > 2 }', output: '3' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns nil if not found', 'Stops at first match'],
    interviewTip: 'More efficient than select.first when you only need one result',
    priority: 'essential',
  },
  {
    name: 'find_all',
    category: 'searching',
    syntax: 'collection.find_all { |item| condition }',
    description: 'Alias for select; returns all matching elements',
    example: { code: '[1, 2, 3, 4].find_all { |n| n > 2 }', output: '[3, 4]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Same as select'],
    priority: 'common',
  },
  {
    name: 'any? / all? / none?',
    category: 'searching',
    syntax: 'collection.any? { |item| condition }',
    description: 'Tests if any/all/none elements satisfy the condition',
    example: { code: '[1, 2, 3].any? { |n| n > 2 }', output: 'true' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Short-circuits on first matching/non-matching element'],
    interviewTip: 'Use for validation checks instead of count comparisons',
    priority: 'essential',
  },
  {
    name: 'count',
    category: 'arrays',
    syntax: 'collection.count or collection.count(item) or collection.count { |x| block }',
    description: 'Returns count of elements, optionally matching condition',
    example: { code: '[1, 2, 2, 3].count(2)', output: '2' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['count with no args is same as length/size'],
    interviewTip: 'Use tally for counting all unique elements at once',
    priority: 'essential',
  },
  {
    name: 'tally',
    category: 'arrays',
    syntax: 'collection.tally',
    description: 'Returns hash counting occurrences of each element',
    example: { code: '["a", "b", "a", "c", "a"].tally', output: '{"a"=>3, "b"=>1, "c"=>1}' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Ruby 2.7+ only'],
    interviewTip: 'Perfect for frequency counting problems',
    priority: 'essential',
  },
  {
    name: 'group_by',
    category: 'functional',
    syntax: 'collection.group_by { |item| key }',
    description: 'Groups elements into hash by block result',
    example: {
      code: '[1, 2, 3, 4, 5].group_by { |n| n % 2 }',
      output: '{1=>[1, 3, 5], 0=>[2, 4]}',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Keys are block results, values are arrays of elements'],
    interviewTip: 'Extremely useful for categorization problems',
    priority: 'essential',
  },
  {
    name: 'partition',
    category: 'functional',
    syntax: 'collection.partition { |item| condition }',
    description: 'Splits into two arrays: truthy and falsy',
    example: { code: '[1, 2, 3, 4, 5].partition { |n| n.even? }', output: '[[2, 4], [1, 3, 5]]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Returns [truthy_array, falsy_array]'],
    interviewTip: 'More efficient than calling select and reject separately',
    priority: 'common',
  },
  {
    name: 'min / max',
    category: 'searching',
    syntax: 'collection.min or collection.min(n) or collection.min { |a, b| block }',
    description: 'Returns minimum/maximum element(s)',
    example: { code: '[3, 1, 4, 1, 5].min', output: '1' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns nil for empty collection', 'min(n) returns smallest n elements'],
    interviewTip: 'Use minmax to get both in single pass',
    priority: 'essential',
  },
  {
    name: 'min_by / max_by',
    category: 'searching',
    syntax: 'collection.min_by { |item| value }',
    description: 'Returns element with minimum/maximum block value',
    example: { code: '["abc", "de", "f"].min_by { |s| s.length }', output: '"f"' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns the element, not the computed value'],
    interviewTip: 'More efficient than sort_by.first for finding extremes',
    priority: 'essential',
  },
  {
    name: 'sum',
    category: 'arrays',
    syntax: 'collection.sum or collection.sum(init) { |item| block }',
    description: 'Returns sum of elements',
    example: { code: '[1, 2, 3, 4].sum', output: '10' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Ruby 2.4+', 'Works with block for transforming before summing'],
    interviewTip: 'Cleaner than reduce(:+) for simple sums',
    priority: 'essential',
  },

  // ========== STRINGS ==========
  {
    name: 'split',
    category: 'strings',
    syntax: 'string.split(delimiter) or string.split(regex)',
    description: 'Splits string into array by delimiter',
    example: { code: '"a,b,c".split(",")', output: '["a", "b", "c"]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Default delimiter is whitespace', 'Empty strings may be included'],
    interviewTip: 'Essential for parsing input; combine with map for number conversion',
    priority: 'essential',
  },
  {
    name: 'join',
    category: 'arrays',
    syntax: 'array.join(separator)',
    description: 'Joins array elements into a string',
    example: { code: '["a", "b", "c"].join("-")', output: '"a-b-c"' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Elements are converted to strings'],
    interviewTip: 'Use with chars.reverse.join for string reversal',
    priority: 'essential',
  },
  {
    name: 'chars',
    category: 'strings',
    syntax: 'string.chars',
    description: 'Returns array of characters',
    example: { code: '"hello".chars', output: '["h", "e", "l", "l", "o"]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Each char is a string, not a character type'],
    interviewTip: 'Use for character-level string manipulation',
    priority: 'essential',
  },
  {
    name: 'gsub',
    category: 'strings',
    syntax: 'string.gsub(pattern, replacement)',
    description: 'Returns string with all occurrences replaced',
    example: { code: '"hello world".gsub("o", "0")', output: '"hell0 w0rld"' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['gsub! mutates in place', 'Supports regex and block'],
    interviewTip: 'Use sub for single replacement',
    priority: 'essential',
  },
  {
    name: 'strip',
    category: 'strings',
    syntax: 'string.strip',
    description: 'Returns string with leading/trailing whitespace removed',
    example: { code: '"  hello  ".strip', output: '"hello"' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['strip! mutates in place', 'Use lstrip/rstrip for one side only'],
    interviewTip: 'Always strip user input before processing',
    priority: 'common',
  },
  {
    name: 'downcase / upcase',
    category: 'strings',
    syntax: 'string.downcase / string.upcase',
    description: 'Returns string with all characters lowercased/uppercased',
    example: { code: '"Hello".downcase', output: '"hello"' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['downcase!/upcase! mutate in place'],
    interviewTip: 'Use for case-insensitive comparisons',
    priority: 'essential',
  },
  {
    name: 'start_with? / end_with?',
    category: 'strings',
    syntax: 'string.start_with?(prefix) / string.end_with?(suffix)',
    description: 'Tests if string starts/ends with given substring',
    example: { code: '"hello".start_with?("he")', output: 'true' },
    timeComplexity: 'O(m) where m is prefix/suffix length',
    spaceComplexity: 'O(1)',
    gotchas: ['Can check multiple prefixes: str.start_with?("a", "b")'],
    interviewTip: 'More readable than regex for simple prefix/suffix checks',
    priority: 'common',
  },

  // ========== HASHES (OBJECTS) ==========
  {
    name: 'Hash[] / to_h',
    category: 'objects',
    syntax: 'Hash[array] or array.to_h',
    description: 'Creates hash from array of key-value pairs',
    example: { code: '[[:a, 1], [:b, 2]].to_h', output: '{:a=>1, :b=>2}' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Array must contain [key, value] pairs'],
    interviewTip: 'Combine with map to build hashes from arrays',
    priority: 'common',
  },
  {
    name: 'keys / values',
    category: 'objects',
    syntax: 'hash.keys / hash.values',
    description: 'Returns array of all keys/values',
    example: { code: '{a: 1, b: 2}.keys', output: '[:a, :b]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Order is insertion order in Ruby 1.9+'],
    interviewTip: 'Use keys.include? only for small hashes; use key? instead',
    priority: 'essential',
  },
  {
    name: 'key? / has_key? / include?',
    category: 'objects',
    syntax: 'hash.key?(key)',
    description: 'Returns true if hash contains the key',
    example: { code: '{a: 1, b: 2}.key?(:a)', output: 'true' },
    timeComplexity: 'O(1) average',
    spaceComplexity: 'O(1)',
    gotchas: ['has_key? and include? are aliases'],
    interviewTip: 'O(1) lookup is why hashes are essential for interview problems',
    priority: 'essential',
  },
  {
    name: 'fetch',
    category: 'objects',
    syntax: 'hash.fetch(key, default) or hash.fetch(key) { block }',
    description: 'Gets value for key with explicit missing key handling',
    example: { code: '{a: 1}.fetch(:b, 0)', output: '0' },
    timeComplexity: 'O(1) average',
    spaceComplexity: 'O(1)',
    gotchas: ['Raises KeyError if key missing and no default', 'Block form for computed defaults'],
    interviewTip: 'Safer than [] when you want explicit missing key handling',
    priority: 'common',
  },
  {
    name: 'merge',
    category: 'objects',
    syntax: 'hash.merge(other_hash) { |key, old, new| block }',
    description: 'Returns new hash combining both hashes',
    example: { code: '{a: 1}.merge({b: 2})', output: '{:a=>1, :b=>2}' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['merge! mutates in place', 'Block resolves conflicts'],
    interviewTip: 'Use block form for custom conflict resolution',
    priority: 'common',
  },
  {
    name: 'transform_values',
    category: 'objects',
    syntax: 'hash.transform_values { |v| block }',
    description: 'Returns new hash with values transformed by block',
    example: { code: '{a: 1, b: 2}.transform_values { |v| v * 2 }', output: '{:a=>2, :b=>4}' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Ruby 2.4+', 'transform_values! mutates in place'],
    interviewTip: 'Cleaner than map + to_h for value transformations',
    priority: 'common',
  },
  {
    name: 'default / default=',
    category: 'objects',
    syntax: 'hash.default = value or Hash.new(default)',
    description: 'Sets default value for missing keys',
    example: { code: 'h = Hash.new(0)\nh[:a] += 1\nh[:a]', output: '1' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Default object is shared; use block for mutable defaults: Hash.new { |h, k| h[k] = [] }',
    ],
    interviewTip: 'Hash.new(0) is perfect for counting problems',
    priority: 'essential',
  },

  // ========== SETS ==========
  {
    name: 'Set.new',
    category: 'sets',
    syntax: 'require "set"\nSet.new(array)',
    description: 'Creates a Set from an array for O(1) lookups',
    example: { code: 'require "set"\nSet.new([1, 2, 3]).include?(2)', output: 'true' },
    timeComplexity: 'O(n) to create',
    spaceComplexity: 'O(n)',
    gotchas: ['Must require "set"', 'Elements must be hashable'],
    interviewTip: 'Convert array to Set when you need frequent membership checks',
    priority: 'essential',
  },
  {
    name: 'Set operations',
    category: 'sets',
    syntax: 'set1 & set2 (intersection), set1 | set2 (union), set1 - set2 (difference)',
    description: 'Set operations for combining or comparing sets',
    example: { code: 'require "set"\nSet[1,2,3] & Set[2,3,4]', output: '#<Set: {2, 3}>' },
    timeComplexity: 'O(min(n, m))',
    spaceComplexity: 'O(n)',
    gotchas: ['Also available as intersection, union, difference methods'],
    interviewTip: 'Essential for problems involving common elements or unique combinations',
    priority: 'essential',
  },

  // ========== RANGES ==========
  {
    name: 'Range',
    category: 'iteration',
    syntax: '(start..end) or (start...end)',
    description: 'Creates a range; .. is inclusive, ... excludes end',
    example: { code: '(1..5).to_a', output: '[1, 2, 3, 4, 5]' },
    timeComplexity: 'O(1) to create',
    spaceComplexity: 'O(1)',
    gotchas: ['... excludes end value', 'Ranges are lazy; use to_a to materialize'],
    interviewTip: 'Use (0...n) for 0-indexed iteration',
    priority: 'essential',
  },
  {
    name: 'times / upto / downto',
    category: 'iteration',
    syntax: 'n.times { |i| block } / start.upto(end) / start.downto(end)',
    description: 'Integer-based iteration methods',
    example: { code: '3.times { |i| puts i }', output: '0\n1\n2' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['times starts at 0', 'upto/downto are inclusive'],
    interviewTip: '5.times is more idiomatic than (0...5).each',
    priority: 'essential',
  },
];
