/**
 * Clojure Cheatsheet
 *
 * Essential Clojure functions for coding interviews.
 * Covers sequences, vectors, maps, sets, and functional programming.
 */

import type { CheatsheetEntry } from './types';

export const clojureCheatsheet: CheatsheetEntry[] = [
  // ============ Sequence Functions (Functional) ============
  {
    name: 'map',
    category: 'functional',
    syntax: '(map f coll) (map f c1 c2 ...)',
    description: 'Returns lazy sequence of applying f to each element',
    example: { code: '(map inc [1 2 3])', output: '(2 3 4)' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: [
      'Returns lazy sequence - use doall/vec to force evaluation',
      'Works on nil (returns empty seq)',
    ],
    interviewTip: 'Use mapv for eager vector result when you need immediate evaluation',
    priority: 'essential',
  },
  {
    name: 'filter',
    category: 'functional',
    syntax: '(filter pred coll)',
    description: 'Returns lazy sequence of elements where pred returns truthy',
    example: { code: '(filter even? [1 2 3 4 5])', output: '(2 4)' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Lazy evaluation - chain with care', 'Use filterv for vector result'],
    interviewTip: 'Combine with complement for negation: (filter (complement even?) coll)',
    priority: 'essential',
  },
  {
    name: 'reduce',
    category: 'functional',
    syntax: '(reduce f coll) (reduce f init coll)',
    description: 'Reduces collection to single value by applying f cumulatively',
    example: { code: '(reduce + 0 [1 2 3 4])', output: '10' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Without init, uses first element as initial value',
      'Empty coll without init calls (f) with no args',
    ],
    interviewTip: 'Use reduced to short-circuit reduction early',
    priority: 'essential',
  },
  {
    name: 'take',
    category: 'functional',
    syntax: '(take n coll)',
    description: 'Returns lazy sequence of first n elements',
    example: { code: '(take 3 [1 2 3 4 5])', output: '(1 2 3)' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Returns lazy sequence', 'Safe with infinite sequences'],
    interviewTip: 'Essential for working with lazy/infinite sequences',
    priority: 'essential',
  },
  {
    name: 'drop',
    category: 'functional',
    syntax: '(drop n coll)',
    description: 'Returns lazy sequence with first n elements removed',
    example: { code: '(drop 2 [1 2 3 4 5])', output: '(3 4 5)' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Does not modify original collection', 'Returns lazy sequence'],
    interviewTip: 'Combine with take for sliding window: (take n (drop i coll))',
    priority: 'essential',
  },
  {
    name: 'first',
    category: 'functional',
    syntax: '(first coll)',
    description: 'Returns first element of collection, or nil if empty',
    example: { code: '(first [1 2 3])', output: '1' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns nil for empty collection', 'Works on strings too'],
    interviewTip: 'Use (first (filter pred coll)) to find first matching element',
    priority: 'essential',
  },
  {
    name: 'rest',
    category: 'functional',
    syntax: '(rest coll)',
    description: 'Returns sequence of all elements except the first',
    example: { code: '(rest [1 2 3])', output: '(2 3)' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns empty seq for empty/single-element coll', 'Never returns nil'],
    interviewTip: 'Use next instead if you want nil for empty result',
    priority: 'essential',
  },
  {
    name: 'cons',
    category: 'functional',
    syntax: '(cons x coll)',
    description: 'Returns new sequence with x as first element',
    example: { code: '(cons 0 [1 2 3])', output: '(0 1 2 3)' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Always returns a seq, not vector',
      'Different from conj which adds to natural position',
    ],
    interviewTip: 'Prefer conj for vectors - it adds to end in O(1)',
    priority: 'common',
  },
  {
    name: 'concat',
    category: 'functional',
    syntax: '(concat) (concat x) (concat x y) (concat x y & zs)',
    description: 'Returns lazy sequence of concatenated collections',
    example: { code: '(concat [1 2] [3 4])', output: '(1 2 3 4)' },
    timeComplexity: 'O(n+m)',
    spaceComplexity: 'O(n+m)',
    gotchas: ['Lazy - use vec or into for eager evaluation', 'Does not flatten nested collections'],
    interviewTip: 'Use into for combining into specific collection type',
    priority: 'common',
  },
  {
    name: 'partition',
    category: 'functional',
    syntax: '(partition n coll) (partition n step coll)',
    description: 'Partitions coll into chunks of n elements',
    example: { code: '(partition 2 [1 2 3 4])', output: '((1 2) (3 4))' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Drops incomplete final partition', 'Use partition-all to keep incomplete'],
    interviewTip: 'Great for processing pairs: (partition 2 1 coll) for sliding window',
    priority: 'common',
  },
  {
    name: 'group-by',
    category: 'functional',
    syntax: '(group-by f coll)',
    description: 'Returns map of elements grouped by result of f',
    example: { code: '(group-by even? [1 2 3 4])', output: '{false [1 3], true [2 4]}' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Values are vectors, not sequences', 'Key is result of applying f'],
    interviewTip: 'Essential for grouping/bucketing problems',
    priority: 'essential',
  },
  {
    name: 'frequencies',
    category: 'functional',
    syntax: '(frequencies coll)',
    description: 'Returns map of distinct elements to their counts',
    example: { code: '(frequencies [1 1 2 3 3 3])', output: '{1 2, 2 1, 3 3}' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Returns unsorted map', 'Elements must be valid map keys'],
    interviewTip: 'Perfect for counting problems and finding duplicates',
    priority: 'essential',
  },
  {
    name: 'sort',
    category: 'sorting',
    syntax: '(sort coll) (sort comparator coll)',
    description: 'Returns sorted sequence of elements',
    example: { code: '(sort [3 1 4 1 5])', output: '(1 1 3 4 5)' },
    timeComplexity: 'O(n log n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Returns lazy sequence', 'Use sort-by for custom key extraction'],
    interviewTip: 'Use (sort > coll) for descending order',
    priority: 'essential',
  },
  {
    name: 'sort-by',
    category: 'sorting',
    syntax: '(sort-by keyfn coll) (sort-by keyfn comparator coll)',
    description: 'Sorts collection by result of applying keyfn to each element',
    example: { code: '(sort-by count ["bb" "aaa" "c"])', output: '("c" "bb" "aaa")' },
    timeComplexity: 'O(n log n)',
    spaceComplexity: 'O(n)',
    gotchas: [
      'keyfn applied once per element during sort',
      'Stable sort preserves order of equal elements',
    ],
    interviewTip: 'Use for custom object sorting in interviews',
    priority: 'common',
  },
  {
    name: 'reverse',
    category: 'functional',
    syntax: '(reverse coll)',
    description: 'Returns sequence of elements in reverse order',
    example: { code: '(reverse [1 2 3])', output: '(3 2 1)' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Not lazy - realizes entire sequence', 'Use rseq for O(1) reverse of vectors'],
    interviewTip: 'Use rseq for vectors when performance matters',
    priority: 'common',
  },
  {
    name: 'distinct',
    category: 'functional',
    syntax: '(distinct coll)',
    description: 'Returns lazy sequence with duplicates removed',
    example: { code: '(distinct [1 2 1 3 2])', output: '(1 2 3)' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Preserves first occurrence order', 'Uses set internally'],
    interviewTip: 'Use set if you only need unique elements without order',
    priority: 'common',
  },
  {
    name: 'flatten',
    category: 'functional',
    syntax: '(flatten coll)',
    description: 'Completely flattens nested collections into single sequence',
    example: { code: '(flatten [[1 2] [3 [4 5]]])', output: '(1 2 3 4 5)' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Flattens ALL levels - no depth control', 'Use mapcat for single-level flatten'],
    interviewTip: 'Be careful with over-flattening - mapcat is often better',
    priority: 'common',
  },
  {
    name: 'mapcat',
    category: 'functional',
    syntax: '(mapcat f coll)',
    description: 'Maps f over coll and concatenates results',
    example: { code: '(mapcat #(repeat 2 %) [1 2 3])', output: '(1 1 2 2 3 3)' },
    timeComplexity: 'O(n*m)',
    spaceComplexity: 'O(n*m)',
    gotchas: ['f must return a collection', 'Lazy evaluation'],
    interviewTip: 'Perfect for flatMap-style operations',
    priority: 'common',
  },
  {
    name: 'some',
    category: 'functional',
    syntax: '(some pred coll)',
    description: 'Returns first truthy value of (pred x) for any x in coll',
    example: { code: '(some even? [1 3 4 5])', output: 'true' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Returns the truthy value, not the element',
      'Use (some #{target} coll) to find element',
    ],
    interviewTip: 'For finding element: (some #(when (pred %) %) coll)',
    priority: 'essential',
  },
  {
    name: 'every?',
    category: 'functional',
    syntax: '(every? pred coll)',
    description: 'Returns true if pred returns truthy for all elements',
    example: { code: '(every? even? [2 4 6])', output: 'true' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns true for empty collection', 'Short-circuits on first false'],
    interviewTip: 'Use not-every? for the opposite check',
    priority: 'essential',
  },
  {
    name: 'apply',
    category: 'functional',
    syntax: '(apply f args) (apply f x y z args)',
    description: 'Applies function to argument list',
    example: { code: '(apply + [1 2 3 4])', output: '10' },
    timeComplexity: 'O(1) + f cost',
    spaceComplexity: 'O(1)',
    gotchas: ['Last arg must be a collection', 'Can prepend individual args before collection'],
    interviewTip: 'Use for functions that take multiple args: (apply max nums)',
    priority: 'essential',
  },
  {
    name: 'comp',
    category: 'functional',
    syntax: '(comp f) (comp f g) (comp f g & more)',
    description: 'Returns composition of functions, right to left',
    example: { code: '((comp inc #(* 2 %)) 3)', output: '7' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Rightmost function applied first', 'All but rightmost must take single arg'],
    interviewTip: 'Great for point-free style: (map (comp inc :value) items)',
    priority: 'common',
  },
  {
    name: 'partial',
    category: 'functional',
    syntax: '(partial f arg1 arg2 ...)',
    description: 'Returns function with some arguments pre-filled',
    example: { code: '((partial + 10) 5)', output: '15' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Arguments are prepended, not appended', 'Returns variadic function'],
    interviewTip: 'Useful for creating specialized functions from general ones',
    priority: 'common',
  },
  // ============ Vector Operations ============
  {
    name: 'vector',
    category: 'arrays',
    syntax: '(vector) (vector a) (vector a b c ...)',
    description: 'Creates a new vector containing the supplied objects',
    example: { code: '(vector 1 2 3)', output: '[1 2 3]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Does not flatten arguments', 'Use vec to convert existing collection'],
    interviewTip: 'Use literal [1 2 3] when values are known at compile time',
    priority: 'essential',
  },
  {
    name: 'vec',
    category: 'arrays',
    syntax: '(vec coll)',
    description: 'Converts collection to vector',
    example: { code: "(vec '(1 2 3))", output: '[1 2 3]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Creates new vector even if already a vector', 'Works on strings too'],
    interviewTip: 'Use to force evaluation of lazy sequences into vectors',
    priority: 'essential',
  },
  {
    name: 'conj',
    category: 'arrays',
    syntax: '(conj coll x) (conj coll x y ...)',
    description: 'Returns new collection with items added (at end for vectors)',
    example: { code: '(conj [1 2] 3 4)', output: '[1 2 3 4]' },
    timeComplexity: 'O(1) for vectors',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Position depends on collection type - end for vectors, front for lists',
      'Returns new collection',
    ],
    interviewTip: 'Prefer conj for adding elements - adapts to collection type',
    priority: 'essential',
  },
  {
    name: 'nth',
    category: 'arrays',
    syntax: '(nth coll index) (nth coll index not-found)',
    description: 'Returns element at index, throws if out of bounds',
    example: { code: '(nth [1 2 3] 1)', output: '2' },
    timeComplexity: 'O(1) for vectors, O(n) for lists',
    spaceComplexity: 'O(1)',
    gotchas: ['Zero-indexed', 'Throws exception without not-found default'],
    interviewTip: 'Use get for maps; nth for sequential access',
    priority: 'essential',
  },
  {
    name: 'get',
    category: 'arrays',
    syntax: '(get coll key) (get coll key not-found)',
    description: 'Returns value at key/index, or nil/not-found if missing',
    example: { code: '(get [1 2 3] 1)', output: '2' },
    timeComplexity: 'O(1) for vectors/maps',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns nil for out of bounds (not exception)', 'Works on vectors, maps, sets'],
    interviewTip: 'Safer than nth - returns nil instead of throwing',
    priority: 'essential',
  },
  {
    name: 'assoc',
    category: 'arrays',
    syntax: '(assoc coll key val) (assoc coll k v k2 v2 ...)',
    description: 'Returns new collection with value at key/index replaced',
    example: { code: '(assoc [1 2 3] 1 :two)', output: '[1 :two 3]' },
    timeComplexity: 'O(log32 n) for vectors',
    spaceComplexity: 'O(log32 n)',
    gotchas: ['Index must exist for vectors (use conj to extend)', 'Works on vectors and maps'],
    interviewTip: 'Immutable update - original unchanged',
    priority: 'essential',
  },
  {
    name: 'update',
    category: 'arrays',
    syntax: '(update coll key f) (update coll key f args...)',
    description: 'Returns coll with value at key updated by applying f',
    example: { code: '(update [1 2 3] 1 inc)', output: '[1 3 3]' },
    timeComplexity: 'O(log32 n)',
    spaceComplexity: 'O(log32 n)',
    gotchas: [
      'f receives current value as first arg',
      'Additional args passed after current value',
    ],
    interviewTip: 'Cleaner than assoc when modifying existing value',
    priority: 'common',
  },
  {
    name: 'subvec',
    category: 'arrays',
    syntax: '(subvec v start) (subvec v start end)',
    description: 'Returns subvector from start to end (exclusive)',
    example: { code: '(subvec [1 2 3 4 5] 1 4)', output: '[2 3 4]' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['O(1) because shares structure with original', 'Only works on vectors, not lists'],
    interviewTip: 'Very efficient - use for sliding windows on vectors',
    priority: 'common',
  },
  {
    name: 'peek',
    category: 'arrays',
    syntax: '(peek coll)',
    description: 'Returns last element of vector (or first of list)',
    example: { code: '(peek [1 2 3])', output: '3' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns nil for empty collection', 'End for vectors, front for lists/queues'],
    interviewTip: 'Use with pop for stack-like operations',
    priority: 'common',
  },
  {
    name: 'pop',
    category: 'arrays',
    syntax: '(pop coll)',
    description: 'Returns collection without last element (for vectors)',
    example: { code: '(pop [1 2 3])', output: '[1 2]' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Throws on empty collection', 'Removes from end of vector, front of list'],
    interviewTip: 'peek + pop = efficient stack operations',
    priority: 'common',
  },
  // ============ Map Operations ============
  {
    name: 'hash-map',
    category: 'maps',
    syntax: '(hash-map) (hash-map k1 v1 k2 v2 ...)',
    description: 'Creates hash map from key-value pairs',
    example: { code: '(hash-map :a 1 :b 2)', output: '{:a 1, :b 2}' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Order not guaranteed', 'Use array-map or sorted-map if order matters'],
    interviewTip: 'Use literal {:a 1 :b 2} when keys are known',
    priority: 'essential',
  },
  {
    name: 'keys',
    category: 'maps',
    syntax: '(keys map)',
    description: 'Returns sequence of map keys',
    example: { code: '(keys {:a 1 :b 2})', output: '(:a :b)' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Returns nil for nil input', 'Order matches iteration order'],
    interviewTip: 'Use (into #{} (keys m)) for key set',
    priority: 'essential',
  },
  {
    name: 'vals',
    category: 'maps',
    syntax: '(vals map)',
    description: 'Returns sequence of map values',
    example: { code: '(vals {:a 1 :b 2})', output: '(1 2)' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Returns nil for nil input', 'May contain duplicates'],
    interviewTip: 'Pair with keys for parallel iteration',
    priority: 'essential',
  },
  {
    name: 'contains?',
    category: 'maps',
    syntax: '(contains? coll key)',
    description: 'Returns true if key is present in collection',
    example: { code: '(contains? {:a 1 :b 2} :a)', output: 'true' },
    timeComplexity: 'O(1) for maps/sets',
    spaceComplexity: 'O(1)',
    gotchas: ['Checks KEY presence, not value', 'For vectors, checks if INDEX exists'],
    interviewTip: 'For value existence, use some or (get m k) with nil check',
    priority: 'essential',
  },
  {
    name: 'dissoc',
    category: 'maps',
    syntax: '(dissoc map key) (dissoc map k1 k2 ...)',
    description: 'Returns map without the specified key(s)',
    example: { code: '(dissoc {:a 1 :b 2} :a)', output: '{:b 2}' },
    timeComplexity: 'O(log32 n)',
    spaceComplexity: 'O(log32 n)',
    gotchas: ['No error if key missing', 'Returns nil if map is nil'],
    interviewTip: 'Immutable - original map unchanged',
    priority: 'common',
  },
  {
    name: 'merge',
    category: 'maps',
    syntax: '(merge map1 map2 ...)',
    description: 'Returns map that combines all maps, later values override',
    example: { code: '(merge {:a 1} {:b 2} {:a 3})', output: '{:a 3, :b 2}' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['nil maps are ignored', 'Right-most value wins for duplicate keys'],
    interviewTip: 'Use merge-with for custom conflict resolution',
    priority: 'common',
  },
  {
    name: 'select-keys',
    category: 'maps',
    syntax: '(select-keys map keyseq)',
    description: 'Returns map containing only the specified keys',
    example: { code: '(select-keys {:a 1 :b 2 :c 3} [:a :c])', output: '{:a 1, :c 3}' },
    timeComplexity: 'O(k) where k is number of keys',
    spaceComplexity: 'O(k)',
    gotchas: ['Missing keys are simply omitted', 'Returns empty map if no keys match'],
    interviewTip: 'Great for extracting subset of fields',
    priority: 'common',
  },
  {
    name: 'update-in',
    category: 'maps',
    syntax: '(update-in m ks f & args)',
    description: 'Updates value at nested path by applying f',
    example: { code: '(update-in {:a {:b 1}} [:a :b] inc)', output: '{:a {:b 2}}' },
    timeComplexity: 'O(depth)',
    spaceComplexity: 'O(depth)',
    gotchas: [
      'Creates intermediate maps if path does not exist',
      'f receives nil for missing paths',
    ],
    interviewTip: 'Essential for nested data structure updates',
    priority: 'common',
  },
  {
    name: 'get-in',
    category: 'maps',
    syntax: '(get-in m ks) (get-in m ks not-found)',
    description: 'Returns value at nested path in data structure',
    example: { code: '(get-in {:a {:b {:c 1}}} [:a :b :c])', output: '1' },
    timeComplexity: 'O(depth)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns nil for missing paths', 'Works with vectors too using indices'],
    interviewTip: 'Safe nested access - no null pointer errors',
    priority: 'common',
  },
  {
    name: 'assoc-in',
    category: 'maps',
    syntax: '(assoc-in m ks v)',
    description: 'Associates value at nested path, creating maps as needed',
    example: { code: '(assoc-in {} [:a :b :c] 1)', output: '{:a {:b {:c 1}}}' },
    timeComplexity: 'O(depth)',
    spaceComplexity: 'O(depth)',
    gotchas: ['Creates intermediate maps automatically', 'Overwrites existing values'],
    interviewTip: 'Powerful for building nested structures',
    priority: 'common',
  },
  // ============ Set Operations ============
  {
    name: 'set',
    category: 'sets',
    syntax: '(set coll)',
    description: 'Creates set from collection elements',
    example: { code: '(set [1 2 2 3 3 3])', output: '#{1 2 3}' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Duplicates automatically removed', 'Order not preserved'],
    interviewTip: 'Use #{} literal for known values: #{1 2 3}',
    priority: 'essential',
  },
  {
    name: 'clojure.set/union',
    category: 'sets',
    syntax: '(clojure.set/union s1 s2 ...)',
    description: 'Returns union of sets',
    example: { code: '(clojure.set/union #{1 2} #{2 3})', output: '#{1 2 3}' },
    timeComplexity: 'O(n+m)',
    spaceComplexity: 'O(n+m)',
    gotchas: ['Requires clojure.set namespace', 'Works only with sets'],
    interviewTip: 'Combine with into for non-set collections',
    priority: 'common',
  },
  {
    name: 'clojure.set/intersection',
    category: 'sets',
    syntax: '(clojure.set/intersection s1 s2 ...)',
    description: 'Returns intersection of sets',
    example: { code: '(clojure.set/intersection #{1 2 3} #{2 3 4})', output: '#{2 3}' },
    timeComplexity: 'O(min(n,m))',
    spaceComplexity: 'O(min(n,m))',
    gotchas: ['Requires clojure.set namespace', 'Empty if no common elements'],
    interviewTip: 'Efficient for finding common elements',
    priority: 'common',
  },
  {
    name: 'clojure.set/difference',
    category: 'sets',
    syntax: '(clojure.set/difference s1 s2 ...)',
    description: 'Returns elements in first set not in others',
    example: { code: '(clojure.set/difference #{1 2 3} #{2})', output: '#{1 3}' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Order matters - removes s2 elements from s1', 'Requires clojure.set'],
    interviewTip: 'Use for finding unique/missing elements',
    priority: 'common',
  },
  {
    name: 'disj',
    category: 'sets',
    syntax: '(disj set key) (disj set k1 k2 ...)',
    description: 'Returns set with specified elements removed',
    example: { code: '(disj #{1 2 3} 2)', output: '#{1 3}' },
    timeComplexity: 'O(log32 n)',
    spaceComplexity: 'O(log32 n)',
    gotchas: ['No error if element missing', 'Only works on sets'],
    interviewTip: 'dissoc is for maps, disj is for sets',
    priority: 'common',
  },
  // ============ String Operations ============
  {
    name: 'str',
    category: 'strings',
    syntax: '(str x) (str x y z ...)',
    description: 'Concatenates arguments into string',
    example: { code: '(str "Hello " "World" 123)', output: '"Hello World123"' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['nil becomes empty string', 'Calls toString on objects'],
    interviewTip: 'Use clojure.string/join for collections with separator',
    priority: 'essential',
  },
  {
    name: 'clojure.string/split',
    category: 'strings',
    syntax: '(clojure.string/split s re)',
    description: 'Splits string on regex pattern',
    example: { code: '(clojure.string/split "a,b,c" #",")', output: '["a" "b" "c"]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Returns vector, not lazy seq', 'Empty strings may be removed'],
    interviewTip: 'Use #"\\s+" to split on whitespace',
    priority: 'essential',
  },
  {
    name: 'clojure.string/join',
    category: 'strings',
    syntax: '(clojure.string/join coll) (clojure.string/join sep coll)',
    description: 'Joins collection elements into string with optional separator',
    example: { code: '(clojure.string/join ", " [1 2 3])', output: '"1, 2, 3"' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Elements converted to strings', 'nil elements become "null"'],
    interviewTip: 'Inverse of split for reconstruction',
    priority: 'essential',
  },
  {
    name: 'subs',
    category: 'strings',
    syntax: '(subs s start) (subs s start end)',
    description: 'Returns substring from start to end (exclusive)',
    example: { code: '(subs "hello" 1 4)', output: '"ell"' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Throws on out of bounds', 'Zero-indexed'],
    interviewTip: 'Clojure strings are Java strings - use Java methods too',
    priority: 'common',
  },
  // ============ Other Essentials ============
  {
    name: 'count',
    category: 'collections',
    syntax: '(count coll)',
    description: 'Returns number of elements in collection',
    example: { code: '(count [1 2 3 4])', output: '4' },
    timeComplexity: 'O(1) for counted colls, O(n) for lazy seqs',
    spaceComplexity: 'O(1)',
    gotchas: ['Realizes lazy sequences', 'nil returns 0'],
    interviewTip: 'Use bounded-count for lazy seqs when you only need to check threshold',
    priority: 'essential',
  },
  {
    name: 'empty?',
    category: 'collections',
    syntax: '(empty? coll)',
    description: 'Returns true if collection has no elements',
    example: { code: '(empty? [])', output: 'true' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['nil returns true', 'Preferred over (= 0 (count coll))'],
    interviewTip: 'Use seq for nil-punning: (if (seq coll) ...)',
    priority: 'essential',
  },
  {
    name: 'into',
    category: 'collections',
    syntax: '(into to from) (into to xform from)',
    description: 'Returns new collection with all elements from from added to to',
    example: { code: '(into [] (range 5))', output: '[0 1 2 3 4]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Uses conj internally - respects collection type', 'Can apply transducer'],
    interviewTip: 'Perfect for converting between collection types',
    priority: 'essential',
  },
  {
    name: 'range',
    category: 'functional',
    syntax: '(range) (range end) (range start end) (range start end step)',
    description: 'Returns lazy sequence of numbers',
    example: { code: '(range 1 5)', output: '(1 2 3 4)' },
    timeComplexity: 'O(1) creation',
    spaceComplexity: 'O(1)',
    gotchas: ['Lazy and potentially infinite', 'End is exclusive'],
    interviewTip: 'Use (range) carefully - infinite sequence!',
    priority: 'essential',
  },
  {
    name: 'repeat',
    category: 'functional',
    syntax: '(repeat x) (repeat n x)',
    description: 'Returns lazy sequence of x repeated n times (or infinitely)',
    example: { code: '(repeat 3 "hi")', output: '("hi" "hi" "hi")' },
    timeComplexity: 'O(1) creation',
    spaceComplexity: 'O(1)',
    gotchas: ['Without n, infinite sequence', 'Often used with take'],
    interviewTip: 'Useful for initializing data structures',
    priority: 'common',
  },
  {
    name: 'iterate',
    category: 'functional',
    syntax: '(iterate f x)',
    description: 'Returns lazy sequence: x, (f x), (f (f x)), ...',
    example: { code: '(take 5 (iterate inc 0))', output: '(0 1 2 3 4)' },
    timeComplexity: 'O(1) creation',
    spaceComplexity: 'O(1)',
    gotchas: ['Infinite sequence - always use with take', 'f must be pure'],
    interviewTip: 'Great for state machine simulation',
    priority: 'common',
  },
  {
    name: 'reduce-kv',
    category: 'maps',
    syntax: '(reduce-kv f init map)',
    description: 'Reduces map with function receiving accumulator, key, and value',
    example: { code: '(reduce-kv #(assoc %1 %3 %2) {} {:a 1 :b 2})', output: '{1 :a, 2 :b}' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Only works on maps', 'f takes 3 args: acc, k, v'],
    interviewTip: 'More efficient than reduce on maps - no entry destructuring',
    priority: 'common',
  },
  {
    name: 'zipmap',
    category: 'maps',
    syntax: '(zipmap keys vals)',
    description: 'Creates map from parallel sequences of keys and values',
    example: { code: '(zipmap [:a :b :c] [1 2 3])', output: '{:a 1, :b 2, :c 3}' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Extra keys/vals ignored', 'Duplicate keys take later value'],
    interviewTip: 'Perfect for pairing indices with values',
    priority: 'common',
  },
];
