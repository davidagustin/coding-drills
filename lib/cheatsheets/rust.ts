/**
 * Rust Cheatsheet
 *
 * Essential Rust methods and patterns for coding interviews.
 * Covers Vec, String/&str, HashMap, HashSet, Iterator, Option, and Result.
 */

import type { CheatsheetEntry } from './types';

export const rustCheatsheet: CheatsheetEntry[] = [
  // ============================================================
  // Vec (Arrays) Methods
  // ============================================================
  {
    name: 'push',
    category: 'arrays',
    syntax: 'vec.push(value)',
    description: 'Appends an element to the back of the Vec',
    example: {
      code: 'let mut v = vec![1, 2]; v.push(3);',
      output: 'v = [1, 2, 3]',
    },
    timeComplexity: 'O(1) amortized',
    spaceComplexity: 'O(1)',
    gotchas: ['Vec must be mutable', 'May reallocate if capacity exceeded'],
    interviewTip: 'Use with_capacity() to pre-allocate when size is known',
    priority: 'essential',
  },
  {
    name: 'pop',
    category: 'arrays',
    syntax: 'vec.pop() -> Option<T>',
    description: 'Removes and returns the last element, or None if empty',
    example: {
      code: 'let mut v = vec![1, 2, 3]; let x = v.pop();',
      output: 'x = Some(3), v = [1, 2]',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns Option, must handle None case'],
    interviewTip: 'Use for stack-like operations',
    priority: 'essential',
  },
  {
    name: 'len',
    category: 'arrays',
    syntax: 'vec.len() -> usize',
    description: 'Returns the number of elements in the Vec',
    example: {
      code: 'let v = vec![1, 2, 3]; let n = v.len();',
      output: 'n = 3',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    priority: 'essential',
  },
  {
    name: 'is_empty',
    category: 'arrays',
    syntax: 'vec.is_empty() -> bool',
    description: 'Returns true if the Vec has no elements',
    example: {
      code: 'let v: Vec<i32> = vec![]; v.is_empty();',
      output: 'true',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    interviewTip: 'Prefer is_empty() over len() == 0 for clarity',
    priority: 'essential',
  },
  {
    name: 'get',
    category: 'arrays',
    syntax: 'vec.get(index) -> Option<&T>',
    description: 'Returns a reference to the element at index, or None if out of bounds',
    example: {
      code: 'let v = vec![1, 2, 3]; let x = v.get(1);',
      output: 'x = Some(&2)',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns Option, safer than direct indexing which panics'],
    interviewTip: 'Use get() for safe access, [] for when you know index is valid',
    priority: 'essential',
  },
  {
    name: 'sort',
    category: 'arrays',
    syntax: 'vec.sort()',
    description: 'Sorts the Vec in ascending order (requires Ord trait)',
    example: {
      code: 'let mut v = vec![3, 1, 2]; v.sort();',
      output: 'v = [1, 2, 3]',
    },
    timeComplexity: 'O(n log n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Mutates in place', 'For floats use sort_by with partial_cmp'],
    interviewTip:
      'Use sort_unstable() for better performance when order of equal elements does not matter',
    priority: 'essential',
  },
  {
    name: 'sort_by',
    category: 'arrays',
    syntax: 'vec.sort_by(|a, b| a.cmp(b))',
    description: 'Sorts with a custom comparator function',
    example: {
      code: 'let mut v = vec![3, 1, 2]; v.sort_by(|a, b| b.cmp(a));',
      output: 'v = [3, 2, 1]',
    },
    timeComplexity: 'O(n log n)',
    spaceComplexity: 'O(n)',
    interviewTip: 'Use for custom sorting logic like descending order',
    priority: 'essential',
  },
  {
    name: 'reverse',
    category: 'arrays',
    syntax: 'vec.reverse()',
    description: 'Reverses the order of elements in place',
    example: {
      code: 'let mut v = vec![1, 2, 3]; v.reverse();',
      output: 'v = [3, 2, 1]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    priority: 'common',
  },
  {
    name: 'binary_search',
    category: 'arrays',
    syntax: 'vec.binary_search(&value) -> Result<usize, usize>',
    description: 'Searches for element in sorted slice, returns Ok(index) or Err(insertion_point)',
    example: {
      code: 'let v = vec![1, 3, 5]; let r = v.binary_search(&3);',
      output: 'r = Ok(1)',
    },
    timeComplexity: 'O(log n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Vec must be sorted', 'Returns Result, not Option'],
    interviewTip: 'Err variant gives insertion index for maintaining sorted order',
    priority: 'essential',
  },
  {
    name: 'contains',
    category: 'arrays',
    syntax: 'slice.contains(&value) -> bool',
    description: 'Returns true if the slice contains the value',
    example: {
      code: 'let v = vec![1, 2, 3]; v.contains(&2);',
      output: 'true',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    interviewTip: 'Use HashSet for O(1) lookups if checking multiple times',
    priority: 'common',
  },
  {
    name: 'swap',
    category: 'arrays',
    syntax: 'vec.swap(i, j)',
    description: 'Swaps two elements in the Vec',
    example: {
      code: 'let mut v = vec![1, 2, 3]; v.swap(0, 2);',
      output: 'v = [3, 2, 1]',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    interviewTip: 'Useful for in-place algorithms like partitioning',
    priority: 'common',
  },
  {
    name: 'retain',
    category: 'arrays',
    syntax: 'vec.retain(|x| predicate)',
    description: 'Keeps only elements that satisfy the predicate',
    example: {
      code: 'let mut v = vec![1, 2, 3, 4]; v.retain(|&x| x % 2 == 0);',
      output: 'v = [2, 4]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    interviewTip: 'In-place filter, more efficient than creating new Vec',
    priority: 'common',
  },
  {
    name: 'dedup',
    category: 'arrays',
    syntax: 'vec.dedup()',
    description: 'Removes consecutive duplicate elements',
    example: {
      code: 'let mut v = vec![1, 1, 2, 2, 3]; v.dedup();',
      output: 'v = [1, 2, 3]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Only removes consecutive duplicates, sort first for all duplicates'],
    priority: 'common',
  },
  {
    name: 'windows',
    category: 'arrays',
    syntax: 'slice.windows(size) -> impl Iterator',
    description: 'Returns an iterator over overlapping windows of given size',
    example: {
      code: 'let v = vec![1, 2, 3, 4]; v.windows(2).collect::<Vec<_>>();',
      output: '[[1, 2], [2, 3], [3, 4]]',
    },
    timeComplexity: 'O(n) for full iteration',
    spaceComplexity: 'O(1)',
    interviewTip: 'Perfect for sliding window problems',
    priority: 'essential',
  },
  {
    name: 'chunks',
    category: 'arrays',
    syntax: 'slice.chunks(size) -> impl Iterator',
    description: 'Returns an iterator over non-overlapping chunks',
    example: {
      code: 'let v = vec![1, 2, 3, 4, 5]; v.chunks(2).collect::<Vec<_>>();',
      output: '[[1, 2], [3, 4], [5]]',
    },
    timeComplexity: 'O(n) for full iteration',
    spaceComplexity: 'O(1)',
    interviewTip: 'Last chunk may be smaller than size',
    priority: 'common',
  },

  // ============================================================
  // String Methods
  // ============================================================
  {
    name: 'chars',
    category: 'strings',
    syntax: 'string.chars() -> impl Iterator<Item=char>',
    description: 'Returns an iterator over the characters of the string',
    example: {
      code: '"hello".chars().collect::<Vec<_>>();',
      output: "['h', 'e', 'l', 'l', 'o']",
    },
    timeComplexity: 'O(n) for full iteration',
    spaceComplexity: 'O(1)',
    gotchas: ['UTF-8 aware, not byte indices'],
    interviewTip: 'Essential for string manipulation problems',
    priority: 'essential',
  },
  {
    name: 'split',
    category: 'strings',
    syntax: 'string.split(pattern) -> impl Iterator<Item=&str>',
    description: 'Splits string by a pattern and returns an iterator',
    example: {
      code: '"a,b,c".split(\',\').collect::<Vec<_>>();',
      output: '["a", "b", "c"]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    interviewTip: 'Use split_whitespace() for whitespace-delimited strings',
    priority: 'essential',
  },
  {
    name: 'trim',
    category: 'strings',
    syntax: 'string.trim() -> &str',
    description: 'Returns string slice with leading and trailing whitespace removed',
    example: {
      code: '"  hello  ".trim();',
      output: '"hello"',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    priority: 'essential',
  },
  {
    name: 'parse',
    category: 'strings',
    syntax: 'string.parse::<T>() -> Result<T, ParseError>',
    description: 'Parses string into another type (like i32, f64)',
    example: {
      code: '"42".parse::<i32>();',
      output: 'Ok(42)',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns Result, must handle parse errors'],
    interviewTip: 'Use unwrap_or_default() for safe parsing with fallback',
    priority: 'essential',
  },

  // ============================================================
  // HashMap Methods
  // ============================================================
  {
    name: 'insert',
    category: 'maps',
    syntax: 'map.insert(key, value) -> Option<V>',
    description: 'Inserts a key-value pair, returns old value if key existed',
    example: {
      code: 'let mut m = HashMap::new(); m.insert("a", 1);',
      output: 'None (first insert)',
    },
    timeComplexity: 'O(1) average',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns old value if key existed'],
    priority: 'essential',
  },
  {
    name: 'get',
    category: 'maps',
    syntax: 'map.get(&key) -> Option<&V>',
    description: 'Returns a reference to the value for the key, or None',
    example: {
      code: 'let m: HashMap<&str, i32> = [("a", 1)].into(); m.get(&"a");',
      output: 'Some(&1)',
    },
    timeComplexity: 'O(1) average',
    spaceComplexity: 'O(1)',
    interviewTip: 'Use get_mut() when you need to modify the value',
    priority: 'essential',
  },
  {
    name: 'entry',
    category: 'maps',
    syntax: 'map.entry(key).or_insert(default)',
    description: 'Gets entry for in-place manipulation, inserting default if absent',
    example: {
      code: 'let mut m = HashMap::new(); *m.entry("a").or_insert(0) += 1;',
      output: 'm = {"a": 1}',
    },
    timeComplexity: 'O(1) average',
    spaceComplexity: 'O(1)',
    interviewTip: 'Essential for counting/frequency problems',
    priority: 'essential',
  },
  {
    name: 'contains_key',
    category: 'maps',
    syntax: 'map.contains_key(&key) -> bool',
    description: 'Returns true if the map contains the key',
    example: {
      code: 'let m: HashMap<&str, i32> = [("a", 1)].into(); m.contains_key(&"a");',
      output: 'true',
    },
    timeComplexity: 'O(1) average',
    spaceComplexity: 'O(1)',
    priority: 'common',
  },
  {
    name: 'remove',
    category: 'maps',
    syntax: 'map.remove(&key) -> Option<V>',
    description: 'Removes key from map, returning the value if present',
    example: {
      code: 'let mut m: HashMap<&str, i32> = [("a", 1)].into(); m.remove(&"a");',
      output: 'Some(1)',
    },
    timeComplexity: 'O(1) average',
    spaceComplexity: 'O(1)',
    priority: 'common',
  },

  // ============================================================
  // HashSet Methods
  // ============================================================
  {
    name: 'insert (HashSet)',
    category: 'sets',
    syntax: 'set.insert(value) -> bool',
    description: 'Adds value to set, returns true if it was not present',
    example: {
      code: 'let mut s = HashSet::new(); s.insert(1);',
      output: 'true',
    },
    timeComplexity: 'O(1) average',
    spaceComplexity: 'O(1)',
    interviewTip: 'Return value useful for detecting duplicates',
    priority: 'essential',
  },
  {
    name: 'contains (HashSet)',
    category: 'sets',
    syntax: 'set.contains(&value) -> bool',
    description: 'Returns true if the set contains the value',
    example: {
      code: 'let s: HashSet<i32> = [1, 2, 3].into(); s.contains(&2);',
      output: 'true',
    },
    timeComplexity: 'O(1) average',
    spaceComplexity: 'O(1)',
    priority: 'essential',
  },
  {
    name: 'intersection',
    category: 'sets',
    syntax: 'set1.intersection(&set2) -> impl Iterator',
    description: 'Returns an iterator over values in both sets',
    example: {
      code: 'let s1: HashSet<i32> = [1, 2].into(); let s2: HashSet<i32> = [2, 3].into(); s1.intersection(&s2).collect::<Vec<_>>();',
      output: '[2]',
    },
    timeComplexity: 'O(min(n, m))',
    spaceComplexity: 'O(1)',
    priority: 'common',
  },

  // ============================================================
  // Iterator Methods (Functional)
  // ============================================================
  {
    name: 'map (Iterator)',
    category: 'functional',
    syntax: 'iter.map(|x| transform) -> impl Iterator',
    description: 'Transforms each element using the closure',
    example: {
      code: 'vec![1, 2, 3].iter().map(|x| x * 2).collect::<Vec<_>>();',
      output: '[2, 4, 6]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1) (lazy)',
    gotchas: ['Lazy - must call collect() or consume iterator'],
    priority: 'essential',
  },
  {
    name: 'filter (Iterator)',
    category: 'functional',
    syntax: 'iter.filter(|x| predicate) -> impl Iterator',
    description: 'Keeps only elements that satisfy the predicate',
    example: {
      code: 'vec![1, 2, 3, 4].iter().filter(|&&x| x % 2 == 0).collect::<Vec<_>>();',
      output: '[&2, &4]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1) (lazy)',
    gotchas: ['Closure receives references'],
    priority: 'essential',
  },
  {
    name: 'fold',
    category: 'functional',
    syntax: 'iter.fold(init, |acc, x| combine) -> T',
    description: 'Reduces iterator to single value using accumulator',
    example: {
      code: 'vec![1, 2, 3].iter().fold(0, |acc, x| acc + x);',
      output: '6',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    interviewTip: 'Rust equivalent of reduce, more flexible than sum()',
    priority: 'essential',
  },
  {
    name: 'collect',
    category: 'functional',
    syntax: 'iter.collect::<Collection>() -> Collection',
    description: 'Transforms iterator into a collection',
    example: {
      code: '(0..5).collect::<Vec<_>>();',
      output: '[0, 1, 2, 3, 4]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Often needs type annotation with turbofish ::<>'],
    interviewTip: 'Can collect into Vec, HashSet, HashMap, String, and more',
    priority: 'essential',
  },
  {
    name: 'enumerate',
    category: 'iteration',
    syntax: 'iter.enumerate() -> impl Iterator<Item=(usize, T)>',
    description: 'Returns iterator yielding (index, value) pairs',
    example: {
      code: 'vec!["a", "b"].iter().enumerate().collect::<Vec<_>>();',
      output: '[(0, "a"), (1, "b")]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    interviewTip: 'Essential when you need both index and value',
    priority: 'essential',
  },
  {
    name: 'zip',
    category: 'iteration',
    syntax: 'iter1.zip(iter2) -> impl Iterator<Item=(A, B)>',
    description: 'Zips two iterators into pairs',
    example: {
      code: 'vec![1, 2].iter().zip(vec!["a", "b"].iter()).collect::<Vec<_>>();',
      output: '[(1, "a"), (2, "b")]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Stops at shorter iterator'],
    priority: 'common',
  },
  {
    name: 'take',
    category: 'iteration',
    syntax: 'iter.take(n) -> impl Iterator',
    description: 'Returns iterator over first n elements',
    example: {
      code: '(0..).take(3).collect::<Vec<_>>();',
      output: '[0, 1, 2]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    interviewTip: 'Useful with infinite iterators',
    priority: 'common',
  },
  {
    name: 'skip',
    category: 'iteration',
    syntax: 'iter.skip(n) -> impl Iterator',
    description: 'Skips first n elements',
    example: {
      code: 'vec![1, 2, 3, 4].iter().skip(2).collect::<Vec<_>>();',
      output: '[&3, &4]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    priority: 'common',
  },
  {
    name: 'find',
    category: 'functional',
    syntax: 'iter.find(|x| predicate) -> Option<T>',
    description: 'Returns first element satisfying predicate, or None',
    example: {
      code: 'vec![1, 2, 3].iter().find(|&&x| x > 1);',
      output: 'Some(&2)',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    interviewTip: 'Short-circuits on first match',
    priority: 'essential',
  },
  {
    name: 'any',
    category: 'functional',
    syntax: 'iter.any(|x| predicate) -> bool',
    description: 'Returns true if any element satisfies predicate',
    example: {
      code: 'vec![1, 2, 3].iter().any(|&x| x > 2);',
      output: 'true',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    interviewTip: 'Short-circuits on first true',
    priority: 'common',
  },
  {
    name: 'all',
    category: 'functional',
    syntax: 'iter.all(|x| predicate) -> bool',
    description: 'Returns true if all elements satisfy predicate',
    example: {
      code: 'vec![2, 4, 6].iter().all(|&x| x % 2 == 0);',
      output: 'true',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    interviewTip: 'Short-circuits on first false',
    priority: 'common',
  },
  {
    name: 'sum',
    category: 'functional',
    syntax: 'iter.sum::<T>() -> T',
    description: 'Sums all elements (requires Sum trait)',
    example: {
      code: 'vec![1, 2, 3].iter().sum::<i32>();',
      output: '6',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Often needs type annotation'],
    priority: 'essential',
  },
  {
    name: 'max / min',
    category: 'functional',
    syntax: 'iter.max() -> Option<T>',
    description: 'Returns maximum/minimum element',
    example: {
      code: 'vec![1, 3, 2].iter().max();',
      output: 'Some(&3)',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns Option (None for empty iterator)'],
    priority: 'essential',
  },
  {
    name: 'flatten',
    category: 'functional',
    syntax: 'iter.flatten() -> impl Iterator',
    description: 'Flattens nested iterators into a single iterator',
    example: {
      code: 'vec![vec![1, 2], vec![3, 4]].into_iter().flatten().collect::<Vec<_>>();',
      output: '[1, 2, 3, 4]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    interviewTip: 'Use flat_map() to map and flatten in one step',
    priority: 'common',
  },

  // ============================================================
  // Option/Result (Error Handling)
  // ============================================================
  {
    name: 'unwrap',
    category: 'error-handling',
    syntax: 'option.unwrap() -> T',
    description: 'Returns inner value, panics if None/Err',
    example: {
      code: 'Some(5).unwrap();',
      output: '5',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Panics on None/Err - avoid in production code'],
    interviewTip: 'Use unwrap_or() or ? operator instead in real code',
    priority: 'essential',
  },
  {
    name: 'unwrap_or',
    category: 'error-handling',
    syntax: 'option.unwrap_or(default) -> T',
    description: 'Returns inner value or default if None/Err',
    example: {
      code: 'None::<i32>.unwrap_or(0);',
      output: '0',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    interviewTip: 'Safe alternative to unwrap()',
    priority: 'essential',
  },
  {
    name: 'map (Option)',
    category: 'error-handling',
    syntax: 'option.map(|x| transform) -> Option<U>',
    description: 'Transforms the inner value if Some, otherwise returns None',
    example: {
      code: 'Some(5).map(|x| x * 2);',
      output: 'Some(10)',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    interviewTip: 'Chain with and_then() for operations that may fail',
    priority: 'essential',
  },
  {
    name: 'and_then',
    category: 'error-handling',
    syntax: 'option.and_then(|x| Some(y)) -> Option<U>',
    description: 'Chains Option-returning operations (flatMap equivalent)',
    example: {
      code: 'Some(5).and_then(|x| if x > 0 { Some(x * 2) } else { None });',
      output: 'Some(10)',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    interviewTip: 'Prevents nested Option<Option<T>>',
    priority: 'essential',
  },
  {
    name: 'is_some / is_none',
    category: 'error-handling',
    syntax: 'option.is_some() -> bool',
    description: 'Returns true if Option contains a value / is empty',
    example: {
      code: 'Some(5).is_some();',
      output: 'true',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    priority: 'essential',
  },

  // ============================================================
  // Memory / Ownership
  // ============================================================
  {
    name: 'clone',
    category: 'memory',
    syntax: 'value.clone() -> T',
    description: 'Creates a deep copy of the value (requires Clone trait)',
    example: {
      code: 'let v = vec![1, 2, 3]; let v2 = v.clone();',
      output: 'v2 = [1, 2, 3]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Expensive for large data structures'],
    interviewTip: 'Avoid excessive cloning - use references when possible',
    priority: 'essential',
  },
  {
    name: 'iter / iter_mut / into_iter',
    category: 'iteration',
    syntax: 'collection.iter() | iter_mut() | into_iter()',
    description: 'Creates iterators: borrowing, mutable borrowing, or consuming',
    example: {
      code: 'let v = vec![1, 2]; v.iter(); // borrows\nv.into_iter(); // consumes v',
      output: 'Iterator over &T, &mut T, or T',
    },
    timeComplexity: 'O(1) to create',
    spaceComplexity: 'O(1)',
    gotchas: ['into_iter() takes ownership, iter() borrows'],
    interviewTip: 'Use iter() when you need the collection after, into_iter() otherwise',
    priority: 'essential',
  },
];
