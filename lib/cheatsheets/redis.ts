/**
 * Redis Cheatsheet
 *
 * Comprehensive Redis commands and operations for coding interviews.
 *
 * Sections covered:
 * - String Operations (SET, GET, INCR, MSET, DECR, GETEX, GETDEL, SETRANGE, APPEND, STRLEN)
 * - List Operations (LPUSH, RPUSH, LPOP, RPOP, LRANGE, BLPOP, BRPOP, LPOS, LINSERT, LTRIM, LMOVE, LLEN)
 * - Hash Operations (HSET, HGET, HGETALL, HINCRBY, HMGET, HSETNX, HVALS, HKEYS, HDEL, HEXISTS, HLEN, HSCAN)
 * - Set Operations (SADD, SMEMBERS, SISMEMBER, SUNION, SINTER, SDIFF, SREM, SPOP, SRANDMEMBER, SMOVE, SINTERSTORE, SUNIONSTORE, SDIFFSTORE, SCARD, SSCAN)
 * - Sorted Set Operations (ZADD, ZRANGE, ZREVRANGE, ZSCORE, ZRANK, ZINCRBY, ZCOUNT, ZRANGEBYSCORE, ZPOPMIN, ZPOPMAX, BZPOPMIN, BZPOPMAX, ZUNIONSTORE, ZINTERSTORE, ZRANGEBYLEX, ZLEXCOUNT, ZREM, ZCARD, ZMSCORE, ZSCAN)
 * - Key Management (DEL, EXISTS, EXPIRE, TTL, KEYS, SCAN, UNLINK, COPY, DUMP, RESTORE, OBJECT ENCODING, TOUCH, RANDOMKEY, DBSIZE)
 * - Transactions (MULTI, EXEC, WATCH, UNWATCH, DISCARD)
 * - Pub/Sub (PUBLISH, SUBSCRIBE)
 * - HyperLogLog (PFADD, PFCOUNT, PFMERGE)
 * - Streams (XADD, XREAD, XRANGE, XREVRANGE, XLEN, XGROUP CREATE, XREADGROUP, XACK, XPENDING, XTRIM, XINFO)
 * - Geospatial (GEOADD, GEOPOS, GEODIST, GEOSEARCH, GEOHASH)
 * - Bitmaps (SETBIT, GETBIT, BITCOUNT, BITOP, BITPOS, BITFIELD)
 * - Scripting (EVAL, EVALSHA, SCRIPT LOAD, SCRIPT EXISTS, SCRIPT FLUSH)
 * - Server (INFO, CLIENT LIST, CONFIG GET/SET, SLOWLOG, DEBUG SLEEP)
 */

import type { CheatsheetEntry } from './types';

export const redisCheatsheet: CheatsheetEntry[] = [
  // ============================================
  // STRING OPERATIONS
  // ============================================
  {
    name: 'SET',
    category: 'collections',
    syntax: 'SET key value [EX seconds] [NX|XX]',
    description: 'Set a key-value pair with optional expiration and conditions',
    example: {
      code: 'SET session abc123 EX 3600 NX',
      output: 'OK (if key did not exist)',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'NX = only if not exists',
      'XX = only if exists',
      'EX for seconds, PX for milliseconds',
    ],
    interviewTip: 'SET with NX is commonly used for distributed locks',
    priority: 'essential',
  },
  {
    name: 'GET',
    category: 'collections',
    syntax: 'GET key',
    description: 'Retrieve the value of a key',
    example: {
      code: 'GET session',
      output: '"abc123"',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns nil if key does not exist', 'Only works with string values'],
    interviewTip: 'Most basic operation, always O(1) in Redis',
    priority: 'essential',
  },
  {
    name: 'INCR / INCRBY',
    category: 'math',
    syntax: 'INCR key | INCRBY key increment',
    description: 'Atomically increment a numeric value',
    example: {
      code: 'INCR page_views\nINCRBY score 50',
      output: '1\n50',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Creates key with 0 if not exists',
      'Atomic operation',
      'Value must be integer string',
    ],
    interviewTip: 'Perfect for counters, rate limiters, and atomic updates',
    priority: 'essential',
  },
  {
    name: 'DECR / DECRBY',
    category: 'math',
    syntax: 'DECR key | DECRBY key decrement',
    description: 'Atomically decrement a numeric value',
    example: {
      code: 'SET counter 100\nDECR counter\nDECRBY counter 10',
      output: 'OK\n99\n89',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Creates key with 0 if not exists then decrements',
      'Can result in negative values',
      'Atomic operation',
    ],
    interviewTip: 'Use for decrementing inventory, quotas, or countdown scenarios',
    priority: 'common',
  },
  {
    name: 'MSET / MGET',
    category: 'collections',
    syntax: 'MSET k1 v1 k2 v2 | MGET k1 k2',
    description: 'Set or get multiple keys atomically',
    example: {
      code: 'MSET a 1 b 2 c 3\nMGET a b c',
      output: 'OK\n["1", "2", "3"]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['MSET is atomic', 'MGET returns nil for missing keys', 'Reduces network round trips'],
    interviewTip: 'Batch operations improve performance by reducing network latency',
    priority: 'common',
  },
  {
    name: 'GETEX',
    category: 'collections',
    syntax: 'GETEX key [EX seconds | PX milliseconds | EXAT timestamp | PXAT timestamp | PERSIST]',
    description: 'Get value and optionally set or remove expiration in one atomic operation',
    example: {
      code: 'SET session abc123\nGETEX session EX 3600',
      output: 'OK\n"abc123" (now expires in 3600s)',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'PERSIST removes expiration',
      'EXAT/PXAT use Unix timestamps',
      'Returns nil if key does not exist',
    ],
    interviewTip: 'Useful for sliding window expiration patterns in caching',
    priority: 'useful',
  },
  {
    name: 'GETDEL',
    category: 'collections',
    syntax: 'GETDEL key',
    description: 'Get the value and delete the key atomically',
    example: {
      code: 'SET token xyz789\nGETDEL token\nGET token',
      output: 'OK\n"xyz789"\nnil',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Returns nil if key does not exist',
      'Atomic get + delete',
      'Useful for one-time tokens',
    ],
    interviewTip: 'Perfect for one-time-use tokens, nonces, or claiming resources',
    priority: 'useful',
  },
  {
    name: 'SETRANGE',
    category: 'strings',
    syntax: 'SETRANGE key offset value',
    description: 'Overwrite part of a string at specified offset',
    example: {
      code: 'SET greeting "Hello World"\nSETRANGE greeting 6 "Redis"\nGET greeting',
      output: 'OK\n11\n"Hello Redis"',
    },
    timeComplexity: 'O(1) if not increasing length, O(n) otherwise',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Returns new string length',
      'Zero-pads if offset is past string end',
      'Creates key if not exists',
    ],
    interviewTip: 'Can be used for fixed-width record updates in string-based storage',
    priority: 'useful',
  },
  {
    name: 'APPEND',
    category: 'strings',
    syntax: 'APPEND key value',
    description: 'Append value to existing string or create new',
    example: {
      code: 'SET log "Entry1;"\nAPPEND log "Entry2;"\nGET log',
      output: 'OK\n14\n"Entry1;Entry2;"',
    },
    timeComplexity: 'O(1) amortized',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Creates key if not exists',
      'Returns new string length',
      'Efficient for log-style appends',
    ],
    interviewTip: 'Useful for building strings incrementally like logs or buffers',
    priority: 'useful',
  },
  {
    name: 'STRLEN',
    category: 'strings',
    syntax: 'STRLEN key',
    description: 'Get the length of a string value',
    example: {
      code: 'SET msg "Hello"\nSTRLEN msg',
      output: 'OK\n5',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Returns 0 if key does not exist',
      'Error if key is not a string',
      'Returns byte length, not character count for UTF-8',
    ],
    interviewTip: 'Useful for validating string sizes before processing',
    priority: 'useful',
  },
  // ============================================
  // LIST OPERATIONS
  // ============================================
  {
    name: 'LPUSH / RPUSH',
    category: 'collections',
    syntax: 'LPUSH key value [value ...] | RPUSH key value [value ...]',
    description: 'Push elements to the head (L) or tail (R) of a list',
    example: {
      code: 'LPUSH queue job1 job2\nRPUSH queue job3',
      output: '2\n3',
    },
    timeComplexity: 'O(1) per element',
    spaceComplexity: 'O(n)',
    gotchas: [
      'Creates list if not exists',
      'Returns new list length',
      'LPUSH reverses order when pushing multiple',
    ],
    interviewTip: 'Lists are perfect for queues (LPUSH + RPOP) and stacks (LPUSH + LPOP)',
    priority: 'essential',
  },
  {
    name: 'LPOP / RPOP',
    category: 'collections',
    syntax: 'LPOP key [count] | RPOP key [count]',
    description: 'Remove and return elements from list head or tail',
    example: {
      code: 'LPOP queue\nRPOP queue 2',
      output: '"job2"\n["job3", "job1"]',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns nil if list is empty', 'Count parameter returns array'],
    interviewTip: 'Use BRPOP/BLPOP for blocking versions (message queues)',
    priority: 'essential',
  },
  {
    name: 'LRANGE',
    category: 'collections',
    syntax: 'LRANGE key start stop',
    description: 'Get a range of elements from a list',
    example: {
      code: 'LRANGE mylist 0 -1',
      output: '["a", "b", "c", "d"]',
    },
    timeComplexity: 'O(s+n) where s is start offset and n is range',
    spaceComplexity: 'O(n)',
    gotchas: ['-1 means last element', 'Both indices are inclusive', 'Empty array if out of range'],
    interviewTip: 'LRANGE 0 -1 returns all elements, useful for debugging',
    priority: 'essential',
  },
  {
    name: 'BLPOP / BRPOP',
    category: 'concurrency',
    syntax: 'BLPOP key [key ...] timeout | BRPOP key [key ...] timeout',
    description: 'Blocking pop from list head or tail, waits until element available',
    example: {
      code: 'BRPOP queue 30',
      output: '["queue", "job1"] (after element available or nil after timeout)',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Timeout 0 means block forever',
      'Returns [key, value] tuple',
      'Checks multiple keys in order',
    ],
    interviewTip: 'Essential for building reliable message queues and job workers',
    priority: 'essential',
  },
  {
    name: 'LPOS',
    category: 'searching',
    syntax: 'LPOS key element [RANK rank] [COUNT count] [MAXLEN len]',
    description: 'Find position of element in list',
    example: {
      code: 'RPUSH mylist a b c b d b\nLPOS mylist b\nLPOS mylist b COUNT 2',
      output: '6\n1\n[1, 3]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Returns nil if not found',
      'RANK negative searches from tail',
      'COUNT 0 returns all matches',
    ],
    interviewTip: 'Use MAXLEN to limit search scope for performance',
    priority: 'useful',
  },
  {
    name: 'LINSERT',
    category: 'collections',
    syntax: 'LINSERT key BEFORE|AFTER pivot element',
    description: 'Insert element before or after a pivot value',
    example: {
      code: 'RPUSH mylist a c\nLINSERT mylist BEFORE c b\nLRANGE mylist 0 -1',
      output: '2\n3\n["a", "b", "c"]',
    },
    timeComplexity: 'O(n) to find pivot',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Returns -1 if pivot not found',
      'Returns 0 if key does not exist',
      'Only inserts at first occurrence of pivot',
    ],
    interviewTip: 'Useful for maintaining ordered lists without sorting',
    priority: 'useful',
  },
  {
    name: 'LTRIM',
    category: 'collections',
    syntax: 'LTRIM key start stop',
    description: 'Trim list to specified range, removing elements outside range',
    example: {
      code: 'RPUSH mylist a b c d e\nLTRIM mylist 1 3\nLRANGE mylist 0 -1',
      output: '5\nOK\n["b", "c", "d"]',
    },
    timeComplexity: 'O(n) where n is elements removed',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Both indices inclusive',
      '-1 means last element',
      'Commonly used with LPUSH to maintain capped lists',
    ],
    interviewTip: 'LPUSH + LTRIM pattern creates a fixed-size recent items list',
    priority: 'common',
  },
  {
    name: 'LMOVE',
    category: 'collections',
    syntax: 'LMOVE source destination LEFT|RIGHT LEFT|RIGHT',
    description: 'Atomically pop from one list and push to another',
    example: {
      code: 'RPUSH src a b c\nLMOVE src dst RIGHT LEFT\nLRANGE dst 0 -1',
      output: '3\n"c"\n["c"]',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Replaces RPOPLPUSH (deprecated)',
      'Returns moved element',
      'Creates destination if not exists',
    ],
    interviewTip: 'Use for reliable queue patterns with backup list for processing items',
    priority: 'common',
  },
  {
    name: 'LLEN',
    category: 'collections',
    syntax: 'LLEN key',
    description: 'Get the length of a list',
    example: {
      code: 'RPUSH mylist a b c\nLLEN mylist',
      output: '3\n3',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Returns 0 for non-existing keys',
      'Error if key is not a list',
      'Length is stored, not computed',
    ],
    interviewTip: 'Use to check queue depth or validate list size before operations',
    priority: 'common',
  },
  // ============================================
  // HASH OPERATIONS
  // ============================================
  {
    name: 'HSET / HGET',
    category: 'collections',
    syntax: 'HSET key field value [field value ...] | HGET key field',
    description: 'Set or get hash field values',
    example: {
      code: 'HSET user:1 name Alice age 30\nHGET user:1 name',
      output: '2\n"Alice"',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'HSET can set multiple fields',
      'Returns number of new fields',
      'HGET returns nil if missing',
    ],
    interviewTip: 'Hashes are ideal for storing objects, more memory efficient than separate keys',
    priority: 'essential',
  },
  {
    name: 'HGETALL',
    category: 'collections',
    syntax: 'HGETALL key',
    description: 'Get all fields and values of a hash',
    example: {
      code: 'HGETALL user:1',
      output: '["name", "Alice", "age", "30"]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Returns flat array of field-value pairs', 'Use HSCAN for large hashes'],
    interviewTip: 'Avoid on large hashes in production, use HSCAN instead',
    priority: 'essential',
  },
  {
    name: 'HINCRBY',
    category: 'math',
    syntax: 'HINCRBY key field increment',
    description: 'Atomically increment a hash field',
    example: {
      code: 'HINCRBY article:1 views 1',
      output: '101',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Creates field with 0 if not exists',
      'Works with integers only',
      'Use HINCRBYFLOAT for floats',
    ],
    interviewTip: 'Perfect for per-object counters like view counts or scores',
    priority: 'common',
  },
  {
    name: 'HMGET',
    category: 'collections',
    syntax: 'HMGET key field [field ...]',
    description: 'Get values of multiple hash fields',
    example: {
      code: 'HSET user:1 name Alice age 30 city NYC\nHMGET user:1 name city',
      output: '3\n["Alice", "NYC"]',
    },
    timeComplexity: 'O(n) where n is number of fields',
    spaceComplexity: 'O(n)',
    gotchas: [
      'Returns nil for missing fields',
      'More efficient than multiple HGET calls',
      'Order matches requested fields',
    ],
    interviewTip: 'Use when you need specific fields, not the entire hash',
    priority: 'common',
  },
  {
    name: 'HSETNX',
    category: 'collections',
    syntax: 'HSETNX key field value',
    description: 'Set hash field only if it does not exist',
    example: {
      code: 'HSETNX user:1 email alice@example.com\nHSETNX user:1 email bob@example.com',
      output: '1 (set)\n0 (not set, already exists)',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Returns 1 if field was set, 0 if existed',
      'Atomic operation',
      'Only sets single field unlike HSET',
    ],
    interviewTip: 'Use for initializing fields that should not be overwritten',
    priority: 'useful',
  },
  {
    name: 'HKEYS / HVALS',
    category: 'collections',
    syntax: 'HKEYS key | HVALS key',
    description: 'Get all field names or all values from a hash',
    example: {
      code: 'HSET user:1 name Alice age 30\nHKEYS user:1\nHVALS user:1',
      output: '2\n["name", "age"]\n["Alice", "30"]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: [
      'HKEYS returns only field names',
      'HVALS returns only values',
      'Use HSCAN for large hashes',
    ],
    interviewTip: 'Useful for iterating hash structure without fetching all data',
    priority: 'common',
  },
  {
    name: 'HDEL',
    category: 'collections',
    syntax: 'HDEL key field [field ...]',
    description: 'Delete one or more hash fields',
    example: {
      code: 'HSET user:1 name Alice temp_data xyz\nHDEL user:1 temp_data\nHGETALL user:1',
      output: '2\n1\n["name", "Alice"]',
    },
    timeComplexity: 'O(n) where n is number of fields',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Returns count of deleted fields',
      'Ignores non-existing fields',
      'Does not delete the hash key itself',
    ],
    interviewTip: 'Use for removing specific attributes from stored objects',
    priority: 'common',
  },
  {
    name: 'HEXISTS',
    category: 'searching',
    syntax: 'HEXISTS key field',
    description: 'Check if a hash field exists',
    example: {
      code: 'HSET user:1 name Alice\nHEXISTS user:1 name\nHEXISTS user:1 age',
      output: '1\n1\n0',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Returns 1 if exists, 0 if not',
      'Returns 0 if key does not exist',
      'Does not return the value',
    ],
    interviewTip: 'Use before HGET when you need to distinguish nil from missing',
    priority: 'useful',
  },
  {
    name: 'HLEN',
    category: 'collections',
    syntax: 'HLEN key',
    description: 'Get the number of fields in a hash',
    example: {
      code: 'HSET user:1 name Alice age 30 city NYC\nHLEN user:1',
      output: '3\n3',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Returns 0 for non-existing keys',
      'Field count is stored, not computed',
      'Error if key is not a hash',
    ],
    interviewTip: 'Use to validate object completeness or check hash size',
    priority: 'useful',
  },
  {
    name: 'HSCAN',
    category: 'iteration',
    syntax: 'HSCAN key cursor [MATCH pattern] [COUNT count]',
    description: 'Incrementally iterate hash fields and values',
    example: {
      code: 'HSCAN user:1 0 MATCH name* COUNT 10',
      output: '["0", ["name", "Alice"]]',
    },
    timeComplexity: 'O(1) per call, O(n) total',
    spaceComplexity: 'O(1) per call',
    gotchas: [
      'Returns [cursor, [field, value, ...]]',
      'Cursor 0 means complete',
      'COUNT is a hint, not exact',
    ],
    interviewTip: 'Use for iterating large hashes without blocking the server',
    priority: 'common',
  },
  // ============================================
  // SET OPERATIONS
  // ============================================
  {
    name: 'SADD / SMEMBERS',
    category: 'collections',
    syntax: 'SADD key member [member ...] | SMEMBERS key',
    description: 'Add members to a set or get all members',
    example: {
      code: 'SADD tags redis database nosql\nSMEMBERS tags',
      output: '3\n["redis", "database", "nosql"]',
    },
    timeComplexity: 'O(1) for SADD, O(n) for SMEMBERS',
    spaceComplexity: 'O(n)',
    gotchas: ['Duplicates are ignored', 'Order is not guaranteed', 'Use SSCAN for large sets'],
    interviewTip: 'Sets are perfect for tags, unique visitors, and membership tests',
    priority: 'essential',
  },
  {
    name: 'SISMEMBER',
    category: 'searching',
    syntax: 'SISMEMBER key member',
    description: 'Check if a member exists in a set',
    example: {
      code: 'SISMEMBER tags redis',
      output: '1 (true)',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns 1 or 0', 'SMISMEMBER checks multiple members'],
    interviewTip: "O(1) membership test is one of Redis sets' main advantages",
    priority: 'essential',
  },
  {
    name: 'SUNION / SINTER / SDIFF',
    category: 'collections',
    syntax: 'SUNION key1 key2 | SINTER key1 key2 | SDIFF key1 key2',
    description: 'Set operations: union, intersection, difference',
    example: {
      code: 'SADD s1 a b c\nSADD s2 b c d\nSINTER s1 s2',
      output: '["b", "c"]',
    },
    timeComplexity: 'O(n*m) where n and m are set sizes',
    spaceComplexity: 'O(n)',
    gotchas: [
      'SDIFF returns elements in first set not in others',
      'Use SUNIONSTORE to save results',
    ],
    interviewTip: 'Great for finding common friends, shared interests, etc.',
    priority: 'common',
  },
  {
    name: 'SREM',
    category: 'collections',
    syntax: 'SREM key member [member ...]',
    description: 'Remove one or more members from a set',
    example: {
      code: 'SADD tags redis nosql sql\nSREM tags sql\nSMEMBERS tags',
      output: '3\n1\n["redis", "nosql"]',
    },
    timeComplexity: 'O(n) where n is members to remove',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Returns count of removed members',
      'Ignores non-existing members',
      'Does not error on non-existing key',
    ],
    interviewTip: 'Use for removing tags, revoking permissions, or unsubscribing',
    priority: 'common',
  },
  {
    name: 'SPOP / SRANDMEMBER',
    category: 'collections',
    syntax: 'SPOP key [count] | SRANDMEMBER key [count]',
    description: 'Remove and return random member(s) or just return without removing',
    example: {
      code: 'SADD deck ace king queen jack\nSPOP deck\nSRANDMEMBER deck 2',
      output: '4\n"king"\n["ace", "queen"]',
    },
    timeComplexity: 'O(1) for single, O(n) for count',
    spaceComplexity: 'O(1)',
    gotchas: [
      'SPOP removes, SRANDMEMBER does not',
      'Negative count allows duplicates in SRANDMEMBER',
      'Returns nil if set is empty',
    ],
    interviewTip: 'SPOP for lottery/raffle systems, SRANDMEMBER for sampling',
    priority: 'common',
  },
  {
    name: 'SMOVE',
    category: 'collections',
    syntax: 'SMOVE source destination member',
    description: 'Atomically move a member from one set to another',
    example: {
      code: 'SADD pending task1 task2\nSADD done task0\nSMOVE pending done task1',
      output: '2\n1\n1',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Returns 1 if moved, 0 if member not in source',
      'Atomic operation',
      'Creates destination if not exists',
    ],
    interviewTip: 'Perfect for state machine transitions or task queue workflows',
    priority: 'useful',
  },
  {
    name: 'SINTERSTORE / SUNIONSTORE / SDIFFSTORE',
    category: 'collections',
    syntax: 'SINTERSTORE dest key1 key2 | SUNIONSTORE dest key1 key2 | SDIFFSTORE dest key1 key2',
    description: 'Store result of set operations in a destination key',
    example: {
      code: 'SADD s1 a b c\nSADD s2 b c d\nSINTERSTORE result s1 s2\nSMEMBERS result',
      output: '3\n3\n2\n["b", "c"]',
    },
    timeComplexity: 'O(n*m)',
    spaceComplexity: 'O(n)',
    gotchas: [
      'Overwrites destination if exists',
      'Returns size of resulting set',
      'Can use with EXPIRE for temporary results',
    ],
    interviewTip: 'Use to precompute common queries like mutual friends',
    priority: 'useful',
  },
  {
    name: 'SCARD',
    category: 'collections',
    syntax: 'SCARD key',
    description: 'Get the number of members in a set (cardinality)',
    example: {
      code: 'SADD users alice bob charlie\nSCARD users',
      output: '3\n3',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Returns 0 for non-existing keys',
      'Cardinality is stored, not computed',
      'Error if key is not a set',
    ],
    interviewTip: 'Use for counting unique items like daily active users',
    priority: 'common',
  },
  {
    name: 'SSCAN',
    category: 'iteration',
    syntax: 'SSCAN key cursor [MATCH pattern] [COUNT count]',
    description: 'Incrementally iterate set members',
    example: {
      code: 'SADD users alice bob charlie\nSSCAN users 0 MATCH a*',
      output: '3\n["0", ["alice"]]',
    },
    timeComplexity: 'O(1) per call, O(n) total',
    spaceComplexity: 'O(1) per call',
    gotchas: [
      'Returns [cursor, [members]]',
      'Cursor 0 means iteration complete',
      'COUNT is a hint, not exact',
    ],
    interviewTip: 'Essential for iterating large sets without blocking',
    priority: 'common',
  },
  // ============================================
  // SORTED SET OPERATIONS
  // ============================================
  {
    name: 'ZADD',
    category: 'collections',
    syntax: 'ZADD key [NX|XX] score member [score member ...]',
    description: 'Add members with scores to a sorted set',
    example: {
      code: 'ZADD leaderboard 100 alice 200 bob 150 charlie',
      output: '3',
    },
    timeComplexity: 'O(log n)',
    spaceComplexity: 'O(n)',
    gotchas: [
      'Sorted by score ascending',
      'NX = only add new, XX = only update',
      'Ties sorted alphabetically',
    ],
    interviewTip: 'Sorted sets are perfect for leaderboards, rankings, and priority queues',
    priority: 'essential',
  },
  {
    name: 'ZRANGE / ZREVRANGE',
    category: 'collections',
    syntax: 'ZRANGE key start stop [WITHSCORES] | ZREVRANGE key start stop [WITHSCORES]',
    description: 'Get members by rank (ZREVRANGE for high-to-low)',
    example: {
      code: 'ZREVRANGE leaderboard 0 2 WITHSCORES',
      output: '["bob", "200", "charlie", "150", "alice", "100"]',
    },
    timeComplexity: 'O(log n + m) where m is result size',
    spaceComplexity: 'O(m)',
    gotchas: ['-1 means last element', 'WITHSCORES includes scores in output'],
    interviewTip: 'ZREVRANGE 0 9 gives top 10 in a leaderboard',
    priority: 'essential',
  },
  {
    name: 'ZSCORE / ZRANK',
    category: 'searching',
    syntax: 'ZSCORE key member | ZRANK key member',
    description: 'Get score or rank of a member',
    example: {
      code: 'ZSCORE leaderboard alice\nZRANK leaderboard alice',
      output: '"100"\n0',
    },
    timeComplexity: 'O(1) for ZSCORE, O(log n) for ZRANK',
    spaceComplexity: 'O(1)',
    gotchas: [
      'ZRANK is 0-based',
      'Use ZREVRANK for descending rank',
      'Returns nil if member not found',
    ],
    interviewTip: 'ZREVRANK + 1 gives position on a leaderboard',
    priority: 'essential',
  },
  {
    name: 'ZINCRBY',
    category: 'math',
    syntax: 'ZINCRBY key increment member',
    description: 'Increment the score of a sorted set member',
    example: {
      code: 'ZINCRBY leaderboard 50 alice',
      output: '"150"',
    },
    timeComplexity: 'O(log n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Creates member with score 0 if not exists', 'Negative increment decreases score'],
    interviewTip: 'Use for updating scores in real-time leaderboards',
    priority: 'common',
  },
  {
    name: 'ZCOUNT',
    category: 'searching',
    syntax: 'ZCOUNT key min max',
    description: 'Count members with scores in given range',
    example: {
      code: 'ZADD scores 10 a 20 b 30 c 40 d\nZCOUNT scores 15 35',
      output: '4\n2',
    },
    timeComplexity: 'O(log n)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Use -inf and +inf for unbounded',
      'Use ( prefix for exclusive bounds',
      'Returns 0 for empty range',
    ],
    interviewTip: 'Useful for counting items in score buckets or price ranges',
    priority: 'common',
  },
  {
    name: 'ZRANGEBYSCORE',
    category: 'collections',
    syntax: 'ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]',
    description: 'Get members by score range',
    example: {
      code: 'ZADD temps 68 nyc 72 la 65 sf\nZRANGEBYSCORE temps 66 73 WITHSCORES',
      output: '3\n["nyc", "68", "la", "72"]',
    },
    timeComplexity: 'O(log n + m)',
    spaceComplexity: 'O(m)',
    gotchas: [
      'Use -inf/+inf for unbounded',
      '( prefix for exclusive',
      'LIMIT works like SQL OFFSET/COUNT',
    ],
    interviewTip: 'Use for time-based queries with Unix timestamps as scores',
    priority: 'common',
  },
  {
    name: 'ZPOPMIN / ZPOPMAX',
    category: 'collections',
    syntax: 'ZPOPMIN key [count] | ZPOPMAX key [count]',
    description: 'Remove and return members with lowest/highest scores',
    example: {
      code: 'ZADD pq 1 low 5 mid 10 high\nZPOPMIN pq\nZPOPMAX pq',
      output: '3\n["low", "1"]\n["high", "10"]',
    },
    timeComplexity: 'O(log n * m)',
    spaceComplexity: 'O(m)',
    gotchas: ['Returns [member, score] pairs', 'Returns empty if set is empty', 'Atomic operation'],
    interviewTip: 'ZPOPMIN implements a priority queue (lowest score = highest priority)',
    priority: 'common',
  },
  {
    name: 'BZPOPMIN / BZPOPMAX',
    category: 'concurrency',
    syntax: 'BZPOPMIN key [key ...] timeout | BZPOPMAX key [key ...] timeout',
    description: 'Blocking pop of lowest/highest score member',
    example: {
      code: 'BZPOPMIN priority_queue 30',
      output: '["priority_queue", "task1", "1"] (or nil after timeout)',
    },
    timeComplexity: 'O(log n)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Timeout 0 blocks forever',
      'Returns [key, member, score]',
      'Checks multiple keys in order',
    ],
    interviewTip: 'Use for priority-based job queues with blocking workers',
    priority: 'useful',
  },
  {
    name: 'ZUNIONSTORE / ZINTERSTORE',
    category: 'collections',
    syntax: 'ZUNIONSTORE dest numkeys key [key ...] [WEIGHTS w1 w2] [AGGREGATE SUM|MIN|MAX]',
    description: 'Store union or intersection of sorted sets with score aggregation',
    example: {
      code: 'ZADD z1 1 a 2 b\nZADD z2 3 b 4 c\nZUNIONSTORE result 2 z1 z2\nZRANGE result 0 -1 WITHSCORES',
      output: '2\n2\n3\n["a", "1", "b", "5", "c", "4"]',
    },
    timeComplexity: 'O(n*log n)',
    spaceComplexity: 'O(n)',
    gotchas: [
      'WEIGHTS multiplies scores',
      'AGGREGATE controls how scores combine',
      'Default is SUM',
    ],
    interviewTip: 'Use for combining rankings from multiple sources with weights',
    priority: 'useful',
  },
  {
    name: 'ZRANGEBYLEX / ZLEXCOUNT',
    category: 'collections',
    syntax: 'ZRANGEBYLEX key min max [LIMIT offset count] | ZLEXCOUNT key min max',
    description: 'Query sorted set lexicographically (when all scores are equal)',
    example: {
      code: 'ZADD names 0 alice 0 bob 0 charlie\nZRANGEBYLEX names [a [c',
      output: '3\n["alice", "bob"]',
    },
    timeComplexity: 'O(log n + m)',
    spaceComplexity: 'O(m)',
    gotchas: [
      'Requires all members have same score',
      '[ is inclusive, ( is exclusive',
      'Use - and + for min/max',
    ],
    interviewTip: 'Enables autocomplete and prefix search functionality',
    priority: 'useful',
  },
  {
    name: 'ZREM',
    category: 'collections',
    syntax: 'ZREM key member [member ...]',
    description: 'Remove one or more members from a sorted set',
    example: {
      code: 'ZADD scores 100 alice 200 bob\nZREM scores alice\nZRANGE scores 0 -1',
      output: '2\n1\n["bob"]',
    },
    timeComplexity: 'O(m*log n)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Returns count of removed members',
      'Ignores non-existing members',
      'Does not error on non-existing key',
    ],
    interviewTip: 'Use for removing players from leaderboards or expiring entries',
    priority: 'common',
  },
  {
    name: 'ZCARD',
    category: 'collections',
    syntax: 'ZCARD key',
    description: 'Get the number of members in a sorted set',
    example: {
      code: 'ZADD scores 100 a 200 b 300 c\nZCARD scores',
      output: '3\n3',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Returns 0 for non-existing keys',
      'Cardinality is stored, not computed',
      'Error if key is not a sorted set',
    ],
    interviewTip: 'Use to get leaderboard size or validate set before operations',
    priority: 'common',
  },
  {
    name: 'ZMSCORE',
    category: 'searching',
    syntax: 'ZMSCORE key member [member ...]',
    description: 'Get scores of multiple members in one call',
    example: {
      code: 'ZADD scores 100 alice 200 bob\nZMSCORE scores alice bob charlie',
      output: '2\n["100", "200", nil]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: [
      'Returns nil for missing members',
      'More efficient than multiple ZSCORE',
      'Maintains order of requested members',
    ],
    interviewTip: 'Use for batch score lookups in leaderboard displays',
    priority: 'useful',
  },
  {
    name: 'ZSCAN',
    category: 'iteration',
    syntax: 'ZSCAN key cursor [MATCH pattern] [COUNT count]',
    description: 'Incrementally iterate sorted set members and scores',
    example: {
      code: 'ZSCAN scores 0 MATCH a* COUNT 10',
      output: '["0", ["alice", "100"]]',
    },
    timeComplexity: 'O(1) per call, O(n) total',
    spaceComplexity: 'O(1) per call',
    gotchas: [
      'Returns [cursor, [member, score, ...]]',
      'Cursor 0 means complete',
      'COUNT is a hint, not exact',
    ],
    interviewTip: 'Use for paginating through large sorted sets',
    priority: 'common',
  },
  // ============================================
  // KEY MANAGEMENT
  // ============================================
  {
    name: 'DEL / EXISTS',
    category: 'collections',
    syntax: 'DEL key [key ...] | EXISTS key [key ...]',
    description: 'Delete keys or check existence',
    example: {
      code: 'DEL temp_key\nEXISTS user:1 user:2',
      output: '1\n2',
    },
    timeComplexity: 'O(1) per key',
    spaceComplexity: 'O(1)',
    gotchas: [
      'DEL returns count of deleted keys',
      'EXISTS returns count of existing keys',
      'Use UNLINK for async delete',
    ],
    interviewTip: 'UNLINK is non-blocking alternative to DEL for large keys',
    priority: 'essential',
  },
  {
    name: 'EXPIRE / TTL',
    category: 'collections',
    syntax: 'EXPIRE key seconds | TTL key',
    description: 'Set key expiration or check remaining time',
    example: {
      code: 'EXPIRE session 3600\nTTL session',
      output: '1\n3600',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'TTL returns -1 if no expiration, -2 if key missing',
      'PEXPIRE/PTTL for milliseconds',
    ],
    interviewTip: 'Essential for caching with automatic expiration',
    priority: 'essential',
  },
  {
    name: 'KEYS / SCAN',
    category: 'searching',
    syntax: 'KEYS pattern | SCAN cursor [MATCH pattern] [COUNT count]',
    description: 'Find keys by pattern (SCAN is non-blocking)',
    example: {
      code: 'KEYS user:*\nSCAN 0 MATCH user:* COUNT 100',
      output: '["user:1", "user:2"]\n["42", ["user:1", "user:2"]]',
    },
    timeComplexity: 'O(n) for KEYS, O(1) per SCAN call',
    spaceComplexity: 'O(n)',
    gotchas: [
      'KEYS blocks server, avoid in production',
      'SCAN returns cursor for next iteration',
      'Use 0 cursor to start',
    ],
    interviewTip: 'Always use SCAN in production, KEYS is only for debugging',
    priority: 'common',
  },
  {
    name: 'UNLINK',
    category: 'collections',
    syntax: 'UNLINK key [key ...]',
    description: 'Delete keys asynchronously in background thread',
    example: {
      code: 'UNLINK large_set large_hash',
      output: '2',
    },
    timeComplexity: 'O(1) for command, O(n) async for reclaim',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Non-blocking unlike DEL',
      'Memory freed asynchronously',
      'Returns count of keys unlinked',
    ],
    interviewTip: 'Always prefer UNLINK over DEL for large keys in production',
    priority: 'common',
  },
  {
    name: 'COPY',
    category: 'collections',
    syntax: 'COPY source destination [DB db] [REPLACE]',
    description: 'Copy a key to another key',
    example: {
      code: 'SET original "value"\nCOPY original backup\nGET backup',
      output: 'OK\n1\n"value"',
    },
    timeComplexity: 'O(n) for collections',
    spaceComplexity: 'O(n)',
    gotchas: [
      'Returns 0 if source does not exist',
      'Returns 0 if dest exists without REPLACE',
      'Can copy across databases with DB option',
    ],
    interviewTip: 'Useful for creating snapshots or backups of keys',
    priority: 'useful',
  },
  {
    name: 'DUMP / RESTORE',
    category: 'collections',
    syntax: 'DUMP key | RESTORE key ttl serialized-value [REPLACE]',
    description: 'Serialize key to binary format or restore from serialized form',
    example: {
      code: 'SET mykey "hello"\nDUMP mykey\nRESTORE newkey 0 "\\x00\\x05hello..."',
      output: 'OK\n"\\x00\\x05hello..."\nOK',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: [
      'DUMP returns binary string',
      'ttl 0 means no expiration',
      'Use for cross-cluster migration',
    ],
    interviewTip: 'Use for migrating keys between Redis instances',
    priority: 'useful',
  },
  {
    name: 'OBJECT ENCODING',
    category: 'memory',
    syntax: 'OBJECT ENCODING key',
    description: 'Get the internal encoding of a key value',
    example: {
      code: 'SET num 12345\nOBJECT ENCODING num\nSET str "hello world"\nOBJECT ENCODING str',
      output: 'OK\n"int"\nOK\n"embstr"',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Returns encoding type (int, embstr, raw, ziplist, etc.)',
      'Useful for memory optimization',
      'Encoding can change based on data size',
    ],
    interviewTip: 'Understanding encodings helps optimize memory usage',
    priority: 'useful',
  },
  {
    name: 'TOUCH',
    category: 'collections',
    syntax: 'TOUCH key [key ...]',
    description: 'Update last access time of keys for LRU eviction',
    example: {
      code: 'SET key1 val1\nTOUCH key1 key2 key3',
      output: 'OK\n1 (only key1 exists)',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Returns count of existing keys touched',
      'Affects LRU eviction order',
      'Does not modify the value',
    ],
    interviewTip: 'Use to keep frequently accessed keys in memory under LRU eviction',
    priority: 'useful',
  },
  {
    name: 'SCAN with TYPE',
    category: 'searching',
    syntax: 'SCAN cursor [MATCH pattern] [COUNT count] [TYPE type]',
    description: 'Scan keys filtered by data type',
    example: {
      code: 'SCAN 0 TYPE hash COUNT 100',
      output: '["42", ["user:1", "user:2"]]',
    },
    timeComplexity: 'O(1) per call',
    spaceComplexity: 'O(1)',
    gotchas: [
      'TYPE can be: string, list, set, zset, hash, stream',
      'Combine with MATCH for pattern + type filter',
      'More efficient than filtering after scan',
    ],
    interviewTip: 'Use for finding all keys of a specific data structure type',
    priority: 'useful',
  },
  {
    name: 'RANDOMKEY',
    category: 'collections',
    syntax: 'RANDOMKEY',
    description: 'Return a random key from the database',
    example: {
      code: 'RANDOMKEY',
      output: '"user:42" (random existing key)',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Returns nil if database is empty',
      'Useful for sampling or testing',
      'Not cryptographically random',
    ],
    interviewTip: 'Useful for sampling data or debugging',
    priority: 'useful',
  },
  {
    name: 'DBSIZE',
    category: 'collections',
    syntax: 'DBSIZE',
    description: 'Return the number of keys in the current database',
    example: {
      code: 'DBSIZE',
      output: '42',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Only counts keys in current DB (SELECT)',
      'Includes keys with expiration',
      'Use INFO keyspace for all DBs',
    ],
    interviewTip: 'Quick way to check database size for monitoring',
    priority: 'useful',
  },
  // ============================================
  // TRANSACTIONS
  // ============================================
  {
    name: 'MULTI / EXEC',
    category: 'collections',
    syntax: 'MULTI ... commands ... EXEC',
    description: 'Execute commands atomically as a transaction',
    example: {
      code: 'MULTI\nSET balance 100\nINCRBY balance 50\nEXEC',
      output: '["OK", "150"]',
    },
    timeComplexity: 'O(n) where n is number of commands',
    spaceComplexity: 'O(n)',
    gotchas: [
      'Commands are queued until EXEC',
      'No rollback on individual command failure',
      'Use DISCARD to abort',
    ],
    interviewTip: 'WATCH + MULTI + EXEC provides optimistic locking (CAS)',
    priority: 'common',
  },
  {
    name: 'WATCH / UNWATCH',
    category: 'concurrency',
    syntax: 'WATCH key [key ...] | UNWATCH',
    description: 'Watch keys for changes, abort transaction if modified',
    example: {
      code: 'WATCH balance\nGET balance\nMULTI\nSET balance 200\nEXEC',
      output: 'OK\n"100"\nOK\n["OK"] or nil if balance changed',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'EXEC returns nil if watched key changed',
      'UNWATCH clears all watches',
      'Watch is cleared after EXEC',
    ],
    interviewTip: 'Implements optimistic locking / check-and-set (CAS) pattern',
    priority: 'common',
  },
  {
    name: 'DISCARD',
    category: 'collections',
    syntax: 'DISCARD',
    description: 'Abort a transaction, discarding all queued commands',
    example: {
      code: 'MULTI\nSET key1 val1\nDISCARD',
      output: 'OK\nQUEUED\nOK',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Clears command queue', 'Clears any WATCH', 'Must be called between MULTI and EXEC'],
    interviewTip: 'Use to cancel a transaction when preconditions fail',
    priority: 'useful',
  },
  // ============================================
  // PUB/SUB
  // ============================================
  {
    name: 'PUBLISH / SUBSCRIBE',
    category: 'collections',
    syntax: 'PUBLISH channel message | SUBSCRIBE channel [channel ...]',
    description: 'Publish messages to channels or subscribe to receive them',
    example: {
      code: 'SUBSCRIBE notifications\nPUBLISH notifications "New message"',
      output: 'Subscriber receives: ["message", "notifications", "New message"]',
    },
    timeComplexity: 'O(n+m) where n is clients and m is patterns',
    spaceComplexity: 'O(n)',
    gotchas: [
      'Messages are not persisted',
      'Subscriber misses messages sent before subscribing',
      'Use Streams for persistence',
    ],
    interviewTip: 'Pub/Sub is fire-and-forget, use Streams for reliable messaging',
    priority: 'common',
  },
  // ============================================
  // HYPERLOGLOG
  // ============================================
  {
    name: 'PFADD',
    category: 'memory',
    syntax: 'PFADD key element [element ...]',
    description: 'Add elements to HyperLogLog for cardinality estimation',
    example: {
      code: 'PFADD visitors user1 user2 user3\nPFADD visitors user1 user4',
      output: '1\n1',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1) - max 12KB',
    gotchas: [
      'Returns 1 if cardinality changed, 0 otherwise',
      'Approximate count with 0.81% standard error',
      'Cannot retrieve individual elements',
    ],
    interviewTip: 'Perfect for counting unique visitors with minimal memory (12KB max)',
    priority: 'common',
  },
  {
    name: 'PFCOUNT',
    category: 'memory',
    syntax: 'PFCOUNT key [key ...]',
    description: 'Get approximate cardinality from HyperLogLog(s)',
    example: {
      code: 'PFADD hll1 a b c\nPFADD hll2 c d e\nPFCOUNT hll1\nPFCOUNT hll1 hll2',
      output: '1\n1\n3\n5',
    },
    timeComplexity: 'O(1) single key, O(n) multiple keys',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Multiple keys returns union cardinality',
      'Approximate, not exact count',
      'Returns 0 for non-existing keys',
    ],
    interviewTip: 'Use for unique counts where 0.81% error is acceptable',
    priority: 'common',
  },
  {
    name: 'PFMERGE',
    category: 'memory',
    syntax: 'PFMERGE destkey sourcekey [sourcekey ...]',
    description: 'Merge multiple HyperLogLogs into one',
    example: {
      code: 'PFADD hll1 a b\nPFADD hll2 b c\nPFMERGE merged hll1 hll2\nPFCOUNT merged',
      output: '1\n1\nOK\n3',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Creates union HyperLogLog',
      'Source keys are not modified',
      'Useful for aggregating daily counts',
    ],
    interviewTip: 'Use for combining per-day unique counts into weekly/monthly totals',
    priority: 'useful',
  },
  // ============================================
  // STREAMS
  // ============================================
  {
    name: 'XADD',
    category: 'io',
    syntax: 'XADD key [MAXLEN ~ count] * field value [field value ...]',
    description: 'Append an entry to a stream',
    example: {
      code: 'XADD mystream * sensor-id 1234 temperature 19.5',
      output: '"1609459200000-0"',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1) per entry',
    gotchas: [
      '* generates timestamp-based ID',
      'MAXLEN caps stream size',
      '~ makes MAXLEN approximate (faster)',
    ],
    interviewTip: 'Streams are like append-only logs, perfect for event sourcing',
    priority: 'essential',
  },
  {
    name: 'XREAD',
    category: 'io',
    syntax: 'XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]',
    description: 'Read entries from one or more streams',
    example: {
      code: 'XREAD COUNT 2 STREAMS mystream 0',
      output: '[["mystream", [["1609459200000-0", ["sensor-id", "1234"]]]]]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['ID 0 reads from beginning', 'ID $ reads only new entries', 'BLOCK 0 waits forever'],
    interviewTip: 'Use BLOCK for efficient polling of new stream entries',
    priority: 'essential',
  },
  {
    name: 'XRANGE / XREVRANGE',
    category: 'io',
    syntax: 'XRANGE key start end [COUNT count] | XREVRANGE key end start [COUNT count]',
    description: 'Read entries in ID range (forward or reverse)',
    example: {
      code: 'XRANGE mystream - + COUNT 10',
      output: '[["1609459200000-0", ["sensor-id", "1234", "temperature", "19.5"]]]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: [
      '- means minimum ID, + means maximum',
      'Exclusive bounds with ( prefix',
      'XREVRANGE is descending order',
    ],
    interviewTip: 'Use for replaying events or querying by time range',
    priority: 'common',
  },
  {
    name: 'XLEN',
    category: 'io',
    syntax: 'XLEN key',
    description: 'Get the number of entries in a stream',
    example: {
      code: 'XLEN mystream',
      output: '42',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Returns 0 for non-existing streams',
      'Length is stored, not computed',
      'May not match unique IDs if entries deleted',
    ],
    interviewTip: 'Use for monitoring stream size and backlog',
    priority: 'common',
  },
  {
    name: 'XGROUP CREATE',
    category: 'io',
    syntax: 'XGROUP CREATE key groupname id [MKSTREAM]',
    description: 'Create a consumer group for a stream',
    example: {
      code: 'XGROUP CREATE mystream mygroup $ MKSTREAM',
      output: 'OK',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      '$ means only new messages',
      '0 means all messages from start',
      'MKSTREAM creates stream if not exists',
    ],
    interviewTip: 'Consumer groups enable parallel processing with acknowledgment',
    priority: 'common',
  },
  {
    name: 'XREADGROUP',
    category: 'io',
    syntax:
      'XREADGROUP GROUP group consumer [COUNT n] [BLOCK ms] STREAMS key [key ...] id [id ...]',
    description: 'Read from stream as a consumer in a group',
    example: {
      code: 'XREADGROUP GROUP mygroup consumer1 COUNT 1 STREAMS mystream >',
      output: '[["mystream", [["1609459200000-0", ["key", "value"]]]]]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: [
      '> means only new undelivered messages',
      'ID 0 returns pending entries for this consumer',
      'Messages need XACK to be acknowledged',
    ],
    interviewTip: 'Use > for new messages, 0 to reprocess pending failures',
    priority: 'common',
  },
  {
    name: 'XACK',
    category: 'io',
    syntax: 'XACK key group id [id ...]',
    description: 'Acknowledge message processing in consumer group',
    example: {
      code: 'XACK mystream mygroup 1609459200000-0',
      output: '1',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Returns count of acknowledged messages',
      'Removes from pending entries list (PEL)',
      'Required for at-least-once delivery',
    ],
    interviewTip: 'Always acknowledge after successful processing to avoid redelivery',
    priority: 'common',
  },
  {
    name: 'XPENDING',
    category: 'io',
    syntax: 'XPENDING key group [start end count] [consumer]',
    description: 'View pending (unacknowledged) messages in a consumer group',
    example: {
      code: 'XPENDING mystream mygroup - + 10',
      output: '[["1609459200000-0", "consumer1", 120000, 1]]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: [
      'Shows [id, consumer, idle_time_ms, delivery_count]',
      'Use to detect stuck/failed consumers',
      'Filter by consumer name optionally',
    ],
    interviewTip: 'Monitor pending list to detect and handle failed consumers',
    priority: 'useful',
  },
  {
    name: 'XTRIM',
    category: 'io',
    syntax: 'XTRIM key MAXLEN|MINID [= | ~] threshold',
    description: 'Trim stream to maximum length or minimum ID',
    example: {
      code: 'XTRIM mystream MAXLEN ~ 1000',
      output: '42 (entries removed)',
    },
    timeComplexity: 'O(n) where n is entries removed',
    spaceComplexity: 'O(1)',
    gotchas: [
      '~ makes it approximate (faster)',
      'MINID removes entries older than ID',
      'Usually use with XADD MAXLEN instead',
    ],
    interviewTip: 'Use ~ for performance, exact trimming is expensive',
    priority: 'useful',
  },
  {
    name: 'XINFO',
    category: 'io',
    syntax: 'XINFO STREAM key | XINFO GROUPS key | XINFO CONSUMERS key groupname',
    description: 'Get stream, consumer group, or consumer info',
    example: {
      code: 'XINFO STREAM mystream\nXINFO GROUPS mystream',
      output: '[length, radix-tree-keys, ...]\n[[name, consumers, pending, ...]]',
    },
    timeComplexity: 'O(1) to O(n)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'STREAM shows length, first/last entry',
      'GROUPS shows all consumer groups',
      'CONSUMERS shows consumers in a group',
    ],
    interviewTip: 'Essential for monitoring stream health and consumer lag',
    priority: 'useful',
  },
  // ============================================
  // GEOSPATIAL
  // ============================================
  {
    name: 'GEOADD',
    category: 'collections',
    syntax: 'GEOADD key [NX|XX] longitude latitude member [longitude latitude member ...]',
    description: 'Add geospatial items (longitude, latitude, name) to a sorted set',
    example: {
      code: 'GEOADD locations -122.4194 37.7749 "San Francisco" -73.9857 40.7484 "New York"',
      output: '2',
    },
    timeComplexity: 'O(log n)',
    spaceComplexity: 'O(n)',
    gotchas: [
      'Stored as sorted set with geohash as score',
      'Longitude: -180 to 180, Latitude: -85.05 to 85.05',
      'NX/XX work like ZADD',
    ],
    interviewTip: 'Under the hood uses sorted set with geohash encoding',
    priority: 'common',
  },
  {
    name: 'GEOPOS',
    category: 'collections',
    syntax: 'GEOPOS key member [member ...]',
    description: 'Get longitude and latitude of members',
    example: {
      code: 'GEOPOS locations "San Francisco"',
      output: '[["-122.4194", "37.7749"]]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: [
      'Returns [longitude, latitude] pairs',
      'Returns nil for missing members',
      'Coordinates may have small precision loss',
    ],
    interviewTip: 'Geohash encoding causes slight coordinate precision loss',
    priority: 'useful',
  },
  {
    name: 'GEODIST',
    category: 'math',
    syntax: 'GEODIST key member1 member2 [m|km|ft|mi]',
    description: 'Calculate distance between two geospatial members',
    example: {
      code: 'GEODIST locations "San Francisco" "New York" km',
      output: '"4128.7684"',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Default unit is meters',
      'Returns nil if member missing',
      'Uses haversine formula (spherical)',
    ],
    interviewTip: 'Great for calculating distances in ride-sharing or delivery apps',
    priority: 'common',
  },
  {
    name: 'GEOSEARCH',
    category: 'searching',
    syntax:
      'GEOSEARCH key FROMMEMBER member|FROMLONLAT lon lat BYRADIUS dist unit|BYBOX w h unit [ASC|DESC] [COUNT n]',
    description: 'Search for members within radius or box (replaces GEORADIUS)',
    example: {
      code: 'GEOSEARCH locations FROMMEMBER "San Francisco" BYRADIUS 100 km ASC COUNT 5',
      output: '["Oakland", "San Jose", "Berkeley"]',
    },
    timeComplexity: 'O(n+log m)',
    spaceComplexity: 'O(n)',
    gotchas: [
      'BYRADIUS for circular search',
      'BYBOX for rectangular search',
      'Use GEOSEARCHSTORE to save results',
    ],
    interviewTip: 'Modern replacement for deprecated GEORADIUS command',
    priority: 'common',
  },
  {
    name: 'GEOHASH',
    category: 'collections',
    syntax: 'GEOHASH key member [member ...]',
    description: 'Get geohash strings for members',
    example: {
      code: 'GEOHASH locations "San Francisco"',
      output: '["9q8yy9kz5z"]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: [
      'Returns 11-character geohash',
      'Can be used with geohash.org for visualization',
      'Geohash has hierarchical spatial properties',
    ],
    interviewTip: 'Geohashes with same prefix are geographically close',
    priority: 'useful',
  },
  // ============================================
  // BITMAPS
  // ============================================
  {
    name: 'SETBIT',
    category: 'collections',
    syntax: 'SETBIT key offset value',
    description: 'Set or clear a bit at offset in string value',
    example: {
      code: 'SETBIT active_users 1000 1\nSETBIT active_users 2000 1',
      output: '0\n0',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns previous bit value', 'Auto-extends string if needed', 'Offset is 0-based'],
    interviewTip: 'Use user IDs as offsets for tracking active users efficiently',
    priority: 'common',
  },
  {
    name: 'GETBIT',
    category: 'searching',
    syntax: 'GETBIT key offset',
    description: 'Get bit value at offset',
    example: {
      code: 'SETBIT flags 7 1\nGETBIT flags 7\nGETBIT flags 0',
      output: '0\n1\n0',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Returns 0 for out of range or missing key',
      'Offset is 0-based from left',
      'Bit 0 is most significant bit of byte 0',
    ],
    interviewTip: 'O(1) check for user-specific flags or permissions',
    priority: 'common',
  },
  {
    name: 'BITCOUNT',
    category: 'math',
    syntax: 'BITCOUNT key [start end [BYTE|BIT]]',
    description: 'Count set bits (1s) in a string',
    example: {
      code: 'SETBIT daily:2024-01-01 1000 1\nSETBIT daily:2024-01-01 2000 1\nBITCOUNT daily:2024-01-01',
      output: '0\n0\n2',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Without range counts entire string',
      'BYTE mode uses byte indices (default)',
      'BIT mode uses bit indices (Redis 7.0+)',
    ],
    interviewTip: 'Perfect for counting daily active users from bitmap',
    priority: 'common',
  },
  {
    name: 'BITOP',
    category: 'collections',
    syntax: 'BITOP AND|OR|XOR|NOT destkey key [key ...]',
    description: 'Perform bitwise operations between strings',
    example: {
      code: 'BITOP AND active_both day1 day2\nBITCOUNT active_both',
      output: '250\n42',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: [
      'AND finds users active on ALL days',
      'OR finds users active on ANY day',
      'NOT only takes one source key',
    ],
    interviewTip: 'AND bitmaps to find users active on multiple consecutive days',
    priority: 'common',
  },
  {
    name: 'BITPOS',
    category: 'searching',
    syntax: 'BITPOS key bit [start [end [BYTE|BIT]]]',
    description: 'Find first bit set to 0 or 1',
    example: {
      code: 'SETBIT mykey 100 1\nBITPOS mykey 1',
      output: '0\n100',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Returns -1 if bit not found',
      'Can search in byte or bit ranges',
      'Useful for finding first free slot',
    ],
    interviewTip: 'Use to find first available ID in a sparse ID space',
    priority: 'useful',
  },
  {
    name: 'BITFIELD',
    category: 'collections',
    syntax: 'BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment]',
    description: 'Treat string as array of arbitrary bit-width integers',
    example: {
      code: 'BITFIELD counters SET u8 0 100 INCRBY u8 0 1',
      output: '[0, 101]',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'u8 = unsigned 8-bit, i16 = signed 16-bit, etc.',
      'Supports GET, SET, INCRBY, OVERFLOW',
      'Can pack multiple counters in one key',
    ],
    interviewTip: 'Efficiently store multiple small counters in a single key',
    priority: 'useful',
  },
  // ============================================
  // SCRIPTING
  // ============================================
  {
    name: 'EVAL',
    category: 'collections',
    syntax: 'EVAL script numkeys key [key ...] arg [arg ...]',
    description: 'Execute a Lua script server-side',
    example: {
      code: 'EVAL "return redis.call(\'SET\', KEYS[1], ARGV[1])" 1 mykey myvalue',
      output: 'OK',
    },
    timeComplexity: 'Depends on script',
    spaceComplexity: 'Depends on script',
    gotchas: [
      'Scripts are atomic (blocking)',
      'KEYS and ARGV are 1-indexed in Lua',
      'Use redis.call() for commands',
    ],
    interviewTip: 'Lua scripts execute atomically, perfect for complex atomic operations',
    priority: 'common',
  },
  {
    name: 'EVALSHA',
    category: 'collections',
    syntax: 'EVALSHA sha1 numkeys key [key ...] arg [arg ...]',
    description: 'Execute cached Lua script by SHA1 hash',
    example: {
      code: 'EVALSHA d41d8cd98f00b204e9800998ecf8427e 1 mykey myvalue',
      output: 'OK (or NOSCRIPT error if not cached)',
    },
    timeComplexity: 'Depends on script',
    spaceComplexity: 'O(1) for lookup',
    gotchas: [
      'Faster than EVAL (no script parsing)',
      'Returns NOSCRIPT if not cached',
      'Fall back to EVAL if needed',
    ],
    interviewTip: 'Use SCRIPT LOAD then EVALSHA for frequently used scripts',
    priority: 'common',
  },
  {
    name: 'SCRIPT LOAD',
    category: 'collections',
    syntax: 'SCRIPT LOAD script',
    description: 'Load script into cache and return SHA1 hash',
    example: {
      code: 'SCRIPT LOAD "return redis.call(\'GET\', KEYS[1])"',
      output: '"d41d8cd98f00b204e9800998ecf8427e"',
    },
    timeComplexity: 'O(n) where n is script length',
    spaceComplexity: 'O(n)',
    gotchas: [
      'Script stays cached until SCRIPT FLUSH',
      'Same script always returns same SHA1',
      'Cached per Redis instance, not cluster-wide',
    ],
    interviewTip: 'Pre-load scripts at application startup for performance',
    priority: 'useful',
  },
  {
    name: 'SCRIPT EXISTS',
    category: 'searching',
    syntax: 'SCRIPT EXISTS sha1 [sha1 ...]',
    description: 'Check if scripts are cached',
    example: {
      code: 'SCRIPT EXISTS d41d8cd98f00b204e9800998ecf8427e abc123',
      output: '[1, 0]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: [
      'Returns 1 for cached, 0 for not',
      'Check before EVALSHA to avoid NOSCRIPT',
      'Order matches input order',
    ],
    interviewTip: 'Use to verify script cache before EVALSHA in production',
    priority: 'useful',
  },
  {
    name: 'SCRIPT FLUSH',
    category: 'collections',
    syntax: 'SCRIPT FLUSH [ASYNC|SYNC]',
    description: 'Clear all cached scripts',
    example: {
      code: 'SCRIPT FLUSH',
      output: 'OK',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'ASYNC flushes in background',
      'Existing EVALSHA calls will fail',
      'Usually only needed for debugging',
    ],
    interviewTip: 'Rarely needed in production, scripts auto-evict under memory pressure',
    priority: 'useful',
  },
  // ============================================
  // SERVER
  // ============================================
  {
    name: 'INFO',
    category: 'collections',
    syntax: 'INFO [section]',
    description: 'Get server information and statistics',
    example: {
      code: 'INFO memory\nINFO replication',
      output: '# Memory\\nused_memory:1000000\\n...',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Sections: server, clients, memory, persistence, stats, replication, cpu, cluster, keyspace',
      'No section returns all',
      'Essential for monitoring',
    ],
    interviewTip: 'Use INFO memory to monitor memory usage in production',
    priority: 'common',
  },
  {
    name: 'CLIENT LIST',
    category: 'collections',
    syntax: 'CLIENT LIST [TYPE normal|master|replica|pubsub]',
    description: 'Get list of connected clients',
    example: {
      code: 'CLIENT LIST',
      output: 'id=3 addr=127.0.0.1:52542 fd=8 name= age=6 idle=0 ...',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: [
      'Shows connection details, idle time, commands',
      'Use to debug connection issues',
      'Filter by TYPE for specific clients',
    ],
    interviewTip: 'Use to identify long-running or blocked connections',
    priority: 'useful',
  },
  {
    name: 'CONFIG GET / SET',
    category: 'collections',
    syntax: 'CONFIG GET pattern | CONFIG SET parameter value',
    description: 'Read or modify server configuration at runtime',
    example: {
      code: 'CONFIG GET maxmemory\nCONFIG SET maxmemory 2gb',
      output: '["maxmemory", "0"]\nOK',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'Some configs require restart',
      'Use CONFIG REWRITE to persist changes',
      'Pattern supports glob-style matching',
    ],
    interviewTip: 'Dynamically adjust memory limits or eviction policies',
    priority: 'useful',
  },
  {
    name: 'SLOWLOG',
    category: 'collections',
    syntax: 'SLOWLOG GET [count] | SLOWLOG LEN | SLOWLOG RESET',
    description: 'Access the slow queries log',
    example: {
      code: 'SLOWLOG GET 10',
      output: '[[1, 1609459200, 10000, ["KEYS", "*"]]]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: [
      'Shows [id, timestamp, duration_us, command]',
      'Threshold set by slowlog-log-slower-than',
      'Essential for performance debugging',
    ],
    interviewTip: 'First place to check when debugging Redis performance issues',
    priority: 'common',
  },
  {
    name: 'DEBUG SLEEP',
    category: 'concurrency',
    syntax: 'DEBUG SLEEP seconds',
    description: 'Block the server for specified seconds (testing only)',
    example: {
      code: 'DEBUG SLEEP 0.5',
      output: 'OK (after 500ms)',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: [
      'NEVER use in production',
      'Blocks all clients',
      'Useful for testing timeout handling',
    ],
    interviewTip: 'Only for testing client timeout behavior in development',
    priority: 'useful',
  },
];
