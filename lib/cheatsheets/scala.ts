/**
 * Scala Cheatsheet
 *
 * Essential Scala methods for coding interviews.
 * Covers List, Seq, Map, Set, Option, and functional programming patterns.
 */

import type { CheatsheetEntry } from './types';

export const scalaCheatsheet: CheatsheetEntry[] = [
  // ============ LIST/SEQ METHODS ============
  {
    name: 'map',
    category: 'functional',
    syntax: 'list.map(f: A => B): List[B]',
    description: 'Transform each element using a function',
    example: {
      code: 'List(1, 2, 3).map(_ * 2)',
      output: 'List(2, 4, 6)',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Returns new collection, original unchanged'],
    interviewTip: 'Use map for 1-to-1 transformations; prefer over manual loops',
    priority: 'essential',
  },
  {
    name: 'filter',
    category: 'functional',
    syntax: 'list.filter(p: A => Boolean): List[A]',
    description: 'Keep only elements matching predicate',
    example: {
      code: 'List(1, 2, 3, 4).filter(_ % 2 == 0)',
      output: 'List(2, 4)',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['filterNot is the inverse operation'],
    interviewTip: 'Combine with map for filter-map patterns',
    priority: 'essential',
  },
  {
    name: 'flatMap',
    category: 'functional',
    syntax: 'list.flatMap(f: A => IterableOnce[B]): List[B]',
    description: 'Map then flatten results into single collection',
    example: {
      code: 'List(1, 2).flatMap(x => List(x, x * 10))',
      output: 'List(1, 10, 2, 20)',
    },
    timeComplexity: 'O(n * m)',
    spaceComplexity: 'O(n * m)',
    gotchas: ['Essential for Option/Either chaining'],
    interviewTip: 'Use for nested iterations and monadic composition',
    priority: 'essential',
  },
  {
    name: 'foldLeft',
    category: 'functional',
    syntax: 'list.foldLeft(z: B)(op: (B, A) => B): B',
    description: 'Reduce left-to-right with accumulator and initial value',
    example: {
      code: 'List(1, 2, 3).foldLeft(0)(_ + _)',
      output: '6',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['foldRight processes right-to-left', 'Initial value type determines result type'],
    interviewTip: 'Most versatile reduction - can implement map, filter, etc.',
    priority: 'essential',
  },
  {
    name: 'reduce',
    category: 'functional',
    syntax: 'list.reduce(op: (A, A) => A): A',
    description: 'Reduce elements without initial value',
    example: {
      code: 'List(1, 2, 3, 4).reduce(_ + _)',
      output: '10',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Throws on empty collection - use reduceOption for safety'],
    interviewTip: 'Use foldLeft when you need a different result type',
    priority: 'essential',
  },
  {
    name: 'collect',
    category: 'functional',
    syntax: 'list.collect(pf: PartialFunction[A, B]): List[B]',
    description: 'Filter and map using partial function',
    example: {
      code: 'List(1, "a", 2).collect { case i: Int => i * 2 }',
      output: 'List(2, 4)',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Only applies to elements where partial function is defined'],
    interviewTip: 'Cleaner than filter + map when using pattern matching',
    priority: 'common',
  },
  {
    name: 'groupBy',
    category: 'collections',
    syntax: 'list.groupBy(f: A => K): Map[K, List[A]]',
    description: 'Group elements by key function',
    example: {
      code: 'List("apple", "ant", "bat").groupBy(_.head)',
      output: "Map('a' -> List(apple, ant), 'b' -> List(bat))",
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Returns immutable Map by default'],
    interviewTip: 'Essential for grouping/bucketing problems',
    priority: 'essential',
  },
  {
    name: 'partition',
    category: 'collections',
    syntax: 'list.partition(p: A => Boolean): (List[A], List[A])',
    description: 'Split into two lists based on predicate',
    example: {
      code: 'List(1, 2, 3, 4).partition(_ % 2 == 0)',
      output: '(List(2, 4), List(1, 3))',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['First list contains matches, second contains non-matches'],
    interviewTip: 'More efficient than calling filter twice',
    priority: 'common',
  },
  {
    name: 'zip',
    category: 'collections',
    syntax: 'list1.zip(list2): List[(A, B)]',
    description: 'Combine two lists into pairs',
    example: {
      code: 'List(1, 2, 3).zip(List("a", "b", "c"))',
      output: 'List((1,a), (2,b), (3,c))',
    },
    timeComplexity: 'O(min(n, m))',
    spaceComplexity: 'O(min(n, m))',
    gotchas: ['Stops at shorter list length', 'Use zipAll to pad shorter list'],
    interviewTip: 'Use zipWithIndex for element-index pairs',
    priority: 'essential',
  },
  {
    name: 'zipWithIndex',
    category: 'collections',
    syntax: 'list.zipWithIndex: List[(A, Int)]',
    description: 'Pair each element with its index',
    example: {
      code: 'List("a", "b", "c").zipWithIndex',
      output: 'List((a,0), (b,1), (c,2))',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Index starts at 0'],
    interviewTip: 'Essential when you need both element and position',
    priority: 'essential',
  },
  {
    name: 'take / drop',
    category: 'arrays',
    syntax: 'list.take(n) / list.drop(n)',
    description: 'Take first n elements or drop first n elements',
    example: {
      code: 'List(1, 2, 3, 4, 5).take(3)\nList(1, 2, 3, 4, 5).drop(2)',
      output: 'List(1, 2, 3)\nList(3, 4, 5)',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Safe on out-of-bounds - returns available elements'],
    interviewTip: 'Use takeWhile/dropWhile for predicate-based slicing',
    priority: 'essential',
  },
  {
    name: 'head / tail',
    category: 'arrays',
    syntax: 'list.head / list.tail',
    description: 'First element / all except first',
    example: {
      code: 'List(1, 2, 3).head\nList(1, 2, 3).tail',
      output: '1\nList(2, 3)',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1) / O(n)',
    gotchas: ['Throws on empty list - use headOption for safety'],
    interviewTip: 'Fundamental for recursive list processing',
    priority: 'essential',
  },
  {
    name: 'last / init',
    category: 'arrays',
    syntax: 'list.last / list.init',
    description: 'Last element / all except last',
    example: {
      code: 'List(1, 2, 3).last\nList(1, 2, 3).init',
      output: '3\nList(1, 2)',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1) / O(n)',
    gotchas: ['O(n) for List - use Vector for O(1) last access'],
    interviewTip: 'Use lastOption for safe access on potentially empty lists',
    priority: 'common',
  },
  {
    name: 'sorted / sortBy / sortWith',
    category: 'sorting',
    syntax: 'list.sorted / list.sortBy(f) / list.sortWith(cmp)',
    description: 'Sort using natural order, key function, or comparator',
    example: {
      code: 'List(3, 1, 2).sorted\nList("bb", "a", "ccc").sortBy(_.length)',
      output: 'List(1, 2, 3)\nList(a, bb, ccc)',
    },
    timeComplexity: 'O(n log n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Requires Ordering typeclass for sorted'],
    interviewTip: 'sortBy is most common - sortWith for complex comparisons',
    priority: 'essential',
  },
  {
    name: 'distinct',
    category: 'arrays',
    syntax: 'list.distinct: List[A]',
    description: 'Remove duplicate elements preserving order',
    example: {
      code: 'List(1, 2, 2, 3, 1).distinct',
      output: 'List(1, 2, 3)',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Uses equals for comparison', 'distinctBy available for custom key'],
    interviewTip: 'Use Set if order does not matter for better performance',
    priority: 'common',
  },
  {
    name: 'reverse',
    category: 'arrays',
    syntax: 'list.reverse: List[A]',
    description: 'Reverse the order of elements',
    example: {
      code: 'List(1, 2, 3).reverse',
      output: 'List(3, 2, 1)',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Creates new list'],
    interviewTip: 'Often used with foldLeft for right-to-left building',
    priority: 'common',
  },
  {
    name: 'flatten',
    category: 'collections',
    syntax: 'list.flatten: List[B]',
    description: 'Flatten nested collections by one level',
    example: {
      code: 'List(List(1, 2), List(3, 4)).flatten',
      output: 'List(1, 2, 3, 4)',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Only flattens one level deep'],
    interviewTip: 'Works on List[Option[A]] to extract values',
    priority: 'common',
  },
  {
    name: 'sliding',
    category: 'collections',
    syntax: 'list.sliding(size, step): Iterator[List[A]]',
    description: 'Create sliding window iterator',
    example: {
      code: 'List(1, 2, 3, 4).sliding(2).toList',
      output: 'List(List(1, 2), List(2, 3), List(3, 4))',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(size)',
    gotchas: ['Returns Iterator - call toList to materialize'],
    interviewTip: 'Perfect for sliding window problems',
    priority: 'essential',
  },
  {
    name: 'grouped',
    category: 'collections',
    syntax: 'list.grouped(size): Iterator[List[A]]',
    description: 'Split into fixed-size chunks',
    example: {
      code: 'List(1, 2, 3, 4, 5).grouped(2).toList',
      output: 'List(List(1, 2), List(3, 4), List(5))',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(size)',
    gotchas: ['Last group may be smaller'],
    interviewTip: 'Use for batch processing or chunking problems',
    priority: 'common',
  },
  {
    name: 'span',
    category: 'collections',
    syntax: 'list.span(p: A => Boolean): (List[A], List[A])',
    description: 'Split at first element not matching predicate',
    example: {
      code: 'List(1, 2, 3, 4, 1).span(_ < 3)',
      output: '(List(1, 2), List(3, 4, 1))',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Different from partition - stops at first non-match'],
    interviewTip: 'Use for takeWhile + dropWhile in single pass',
    priority: 'useful',
  },
  {
    name: 'find',
    category: 'searching',
    syntax: 'list.find(p: A => Boolean): Option[A]',
    description: 'Find first element matching predicate',
    example: {
      code: 'List(1, 2, 3, 4).find(_ > 2)',
      output: 'Some(3)',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns Option - None if not found'],
    interviewTip: 'Short-circuits on first match',
    priority: 'essential',
  },
  {
    name: 'exists / forall',
    category: 'searching',
    syntax: 'list.exists(p) / list.forall(p)',
    description: 'Check if any/all elements match predicate',
    example: {
      code: 'List(1, 2, 3).exists(_ > 2)\nList(1, 2, 3).forall(_ > 0)',
      output: 'true\ntrue',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Both short-circuit when result is determined'],
    interviewTip: 'exists = any, forall = all in other languages',
    priority: 'essential',
  },
  {
    name: 'contains',
    category: 'searching',
    syntax: 'list.contains(elem: A): Boolean',
    description: 'Check if element exists in collection',
    example: {
      code: 'List(1, 2, 3).contains(2)',
      output: 'true',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Uses equals for comparison', 'O(1) for Set'],
    interviewTip: 'Convert to Set for O(1) lookups if checking multiple times',
    priority: 'essential',
  },
  {
    name: 'indexOf',
    category: 'searching',
    syntax: 'list.indexOf(elem: A): Int',
    description: 'Find index of first occurrence',
    example: {
      code: 'List("a", "b", "c", "b").indexOf("b")',
      output: '1',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns -1 if not found'],
    interviewTip: 'Use indexWhere for predicate-based search',
    priority: 'common',
  },
  {
    name: 'count',
    category: 'collections',
    syntax: 'list.count(p: A => Boolean): Int',
    description: 'Count elements matching predicate',
    example: {
      code: 'List(1, 2, 3, 4).count(_ % 2 == 0)',
      output: '2',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Different from size/length which count all elements'],
    interviewTip: 'More efficient than filter(...).length',
    priority: 'common',
  },
  // ============ MAP METHODS ============
  {
    name: 'Map apply / get',
    category: 'maps',
    syntax: 'map(key) / map.get(key)',
    description: 'Access value by key (throws or returns Option)',
    example: {
      code: 'val m = Map("a" -> 1, "b" -> 2)\nm("a")\nm.get("c")',
      output: '1\nNone',
    },
    timeComplexity: 'O(1) average',
    spaceComplexity: 'O(1)',
    gotchas: ['apply throws NoSuchElementException if key missing', 'get returns Option'],
    interviewTip: 'Use getOrElse for default values',
    priority: 'essential',
  },
  {
    name: 'getOrElse',
    category: 'maps',
    syntax: 'map.getOrElse(key, default): V',
    description: 'Get value or return default if missing',
    example: {
      code: 'Map("a" -> 1).getOrElse("b", 0)',
      output: '0',
    },
    timeComplexity: 'O(1) average',
    spaceComplexity: 'O(1)',
    gotchas: ['Default is by-name (lazy evaluation)'],
    interviewTip: 'Essential for frequency counting patterns',
    priority: 'essential',
  },
  {
    name: 'updated / +',
    category: 'maps',
    syntax: 'map.updated(key, value) / map + (key -> value)',
    description: 'Add or update key-value pair',
    example: {
      code: 'Map("a" -> 1) + ("b" -> 2)',
      output: 'Map(a -> 1, b -> 2)',
    },
    timeComplexity: 'O(1) average',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns new Map - original unchanged'],
    interviewTip: 'Use mutable.Map for frequent updates in performance-critical code',
    priority: 'essential',
  },
  {
    name: 'Map removed / -',
    category: 'maps',
    syntax: 'map.removed(key) / map - key',
    description: 'Remove key from map',
    example: {
      code: 'Map("a" -> 1, "b" -> 2) - "a"',
      output: 'Map(b -> 2)',
    },
    timeComplexity: 'O(1) average',
    spaceComplexity: 'O(1)',
    gotchas: ['No error if key does not exist'],
    interviewTip: 'Use -- for removing multiple keys',
    priority: 'common',
  },
  {
    name: 'keys / values',
    category: 'maps',
    syntax: 'map.keys / map.values',
    description: 'Get iterable of keys or values',
    example: {
      code: 'Map("a" -> 1, "b" -> 2).keys.toList\nMap("a" -> 1, "b" -> 2).values.toList',
      output: 'List(a, b)\nList(1, 2)',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns Iterable, not List - convert if needed'],
    interviewTip: 'Use keySet for Set operations on keys',
    priority: 'essential',
  },
  {
    name: 'mapValues',
    category: 'maps',
    syntax: 'map.view.mapValues(f).toMap',
    description: 'Transform all values in map',
    example: {
      code: 'Map("a" -> 1, "b" -> 2).view.mapValues(_ * 2).toMap',
      output: 'Map(a -> 2, b -> 4)',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['mapValues deprecated in 2.13 - use view.mapValues(...).toMap'],
    interviewTip: 'Use map for transforming both keys and values',
    priority: 'common',
  },
  {
    name: 'withDefaultValue',
    category: 'maps',
    syntax: 'map.withDefaultValue(default): Map[K, V]',
    description: 'Create map with default value for missing keys',
    example: {
      code: 'val m = Map("a" -> 1).withDefaultValue(0)\nm("b")',
      output: '0',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Default value computed once at creation'],
    interviewTip: 'Great for frequency counters - avoids getOrElse everywhere',
    priority: 'common',
  },
  // ============ SET METHODS ============
  {
    name: 'Set + / -',
    category: 'sets',
    syntax: 'set + elem / set - elem',
    description: 'Add or remove element from set',
    example: {
      code: 'Set(1, 2) + 3\nSet(1, 2, 3) - 2',
      output: 'Set(1, 2, 3)\nSet(1, 3)',
    },
    timeComplexity: 'O(1) average',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns new Set - original unchanged'],
    interviewTip: 'Use ++ / -- for bulk operations',
    priority: 'essential',
  },
  {
    name: 'Set union / intersect / diff',
    category: 'sets',
    syntax: 'set1 union set2 / set1 intersect set2 / set1 diff set2',
    description: 'Set operations: union, intersection, difference',
    example: {
      code: 'Set(1, 2) union Set(2, 3)\nSet(1, 2) intersect Set(2, 3)\nSet(1, 2) diff Set(2, 3)',
      output: 'Set(1, 2, 3)\nSet(2)\nSet(1)',
    },
    timeComplexity: 'O(n + m)',
    spaceComplexity: 'O(n + m)',
    gotchas: ['Can also use | for union, & for intersect, &~ for diff'],
    interviewTip: 'Essential for set-based interview problems',
    priority: 'essential',
  },
  {
    name: 'subsetOf',
    category: 'sets',
    syntax: 'set1.subsetOf(set2): Boolean',
    description: 'Check if set1 is subset of set2',
    example: {
      code: 'Set(1, 2).subsetOf(Set(1, 2, 3))',
      output: 'true',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Empty set is subset of all sets'],
    interviewTip: 'Use for containment checks in set problems',
    priority: 'common',
  },
  // ============ OPTION HANDLING ============
  {
    name: 'Option map / flatMap',
    category: 'functional',
    syntax: 'option.map(f) / option.flatMap(f)',
    description: 'Transform Option value if present',
    example: {
      code: 'Some(5).map(_ * 2)\nSome(5).flatMap(x => if (x > 3) Some(x) else None)',
      output: 'Some(10)\nSome(5)',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['None.map returns None', 'flatMap flattens nested Options'],
    interviewTip: 'Chain operations safely without null checks',
    priority: 'essential',
  },
  {
    name: 'Option getOrElse',
    category: 'functional',
    syntax: 'option.getOrElse(default): A',
    description: 'Extract value or use default',
    example: {
      code: 'Some(5).getOrElse(0)\nNone.getOrElse(0)',
      output: '5\n0',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Default is by-name (lazy)', 'Use orElse for Option chaining'],
    interviewTip: 'Prefer over pattern matching for simple default cases',
    priority: 'essential',
  },
  {
    name: 'Option orElse',
    category: 'functional',
    syntax: 'option1.orElse(option2): Option[A]',
    description: 'Return first Option if Some, else second',
    example: {
      code: 'None.orElse(Some(5))\nSome(3).orElse(Some(5))',
      output: 'Some(5)\nSome(3)',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Second option is by-name (lazy)'],
    interviewTip: 'Chain multiple fallback options',
    priority: 'common',
  },
  {
    name: 'Option fold',
    category: 'functional',
    syntax: 'option.fold(ifEmpty)(f): B',
    description: 'Handle both Some and None cases',
    example: {
      code: 'Some(5).fold("empty")(x => s"value: $x")',
      output: 'value: 5',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['First param is default, second is transform function'],
    interviewTip: 'Cleaner than pattern matching for simple cases',
    priority: 'common',
  },
  {
    name: 'Option toList',
    category: 'functional',
    syntax: 'option.toList: List[A]',
    description: 'Convert Option to List (0 or 1 element)',
    example: {
      code: 'Some(5).toList\nNone.toList',
      output: 'List(5)\nList()',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Useful for flatMap with List of Options'],
    interviewTip: 'Use with flatten: List(opt1, opt2).flatten',
    priority: 'useful',
  },
  // ============ STRING METHODS ============
  {
    name: 'mkString',
    category: 'strings',
    syntax: 'list.mkString(sep) / list.mkString(start, sep, end)',
    description: 'Join elements into string with separator',
    example: {
      code: 'List(1, 2, 3).mkString(", ")\nList(1, 2, 3).mkString("[", ", ", "]")',
      output: '1, 2, 3\n[1, 2, 3]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Works on any collection'],
    interviewTip: 'Essential for formatting output in interviews',
    priority: 'essential',
  },
  {
    name: 'split',
    category: 'strings',
    syntax: 'string.split(regex): Array[String]',
    description: 'Split string by regex pattern',
    example: {
      code: '"a,b,c".split(",")\n"a  b  c".split("\\\\s+")',
      output: 'Array(a, b, c)\nArray(a, b, c)',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Takes regex - escape special chars', 'Returns Array not List'],
    interviewTip: 'Use toList to convert result if needed',
    priority: 'essential',
  },
  {
    name: 'String interpolation',
    category: 'strings',
    syntax: 's"text $var" / f"$num%d" / raw"\\n"',
    description: 'Embed expressions in strings',
    example: {
      code: 'val x = 42\nval msg = s"value is $x"\nprintln(msg)',
      output: 'value is 42',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Use curly braces for complex expressions', 'f-strings support printf formatting'],
    interviewTip: 'Cleaner than string concatenation',
    priority: 'essential',
  },
  // ============ PATTERN MATCHING ============
  {
    name: 'match expression',
    category: 'functional',
    syntax: 'expr match { case pattern => result }',
    description: 'Pattern matching expression',
    example: {
      code: 'List(1, 2, 3) match {\n  case Nil => "empty"\n  case h :: t => s"head: $h"\n}',
      output: 'head: 1',
    },
    timeComplexity: 'O(1) to O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['MatchError if no case matches - use case _ for default'],
    interviewTip: 'Core Scala feature - use for destructuring',
    priority: 'essential',
  },
  {
    name: 'case class unapply',
    category: 'functional',
    syntax: 'case ClassName(a, b) => ...',
    description: 'Destructure case class in pattern match',
    example: {
      code: 'case class Point(x: Int, y: Int)\nPoint(3, 4) match { case Point(x, y) => x + y }',
      output: '7',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Works with case classes automatically'],
    interviewTip: 'Case classes generate unapply for free',
    priority: 'essential',
  },
  {
    name: 'guard clause',
    category: 'functional',
    syntax: 'case pattern if condition => result',
    description: 'Add condition to pattern match case',
    example: {
      code: 'List(1, 2, 3).map {\n  case x if x % 2 == 0 => "even"\n  case _ => "odd"\n}',
      output: 'List(odd, even, odd)',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Guard evaluated after pattern matches'],
    interviewTip: 'Use for conditional filtering in pattern match',
    priority: 'common',
  },
  // ============ ITERATION ============
  {
    name: 'foreach',
    category: 'iteration',
    syntax: 'list.foreach(f: A => Unit): Unit',
    description: 'Execute side effect for each element',
    example: {
      code: 'List(1, 2, 3).foreach(println)',
      output: '1\n2\n3',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns Unit - use for side effects only'],
    interviewTip: 'Use map when you need results',
    priority: 'common',
  },
  {
    name: 'for comprehension',
    category: 'iteration',
    syntax: 'for { x <- list; y <- list2 } yield expr',
    description: 'Syntactic sugar for map/flatMap/filter',
    example: {
      code: 'for {\n  x <- List(1, 2)\n  y <- List("a", "b")\n} yield (x, y)',
      output: 'List((1,a), (1,b), (2,a), (2,b))',
    },
    timeComplexity: 'O(n * m)',
    spaceComplexity: 'O(n * m)',
    gotchas: ['yield required for results', 'Desugars to flatMap/map'],
    interviewTip: 'Cleaner syntax for nested iterations',
    priority: 'essential',
  },
  {
    name: 'Range / until / to',
    category: 'iteration',
    syntax: '(start to end) / (start until end) / (start to end by step)',
    description: 'Create numeric ranges',
    example: {
      code: '(1 to 5).toList\n(1 until 5).toList\n(0 to 10 by 2).toList',
      output: 'List(1, 2, 3, 4, 5)\nList(1, 2, 3, 4)\nList(0, 2, 4, 6, 8, 10)',
    },
    timeComplexity: 'O(1) creation',
    spaceComplexity: 'O(1) until materialized',
    gotchas: ['to is inclusive, until is exclusive'],
    interviewTip: 'Lazy - only computed when accessed',
    priority: 'essential',
  },
  // ============ USEFUL EXTRAS ============
  {
    name: 'LazyList / Stream',
    category: 'collections',
    syntax: 'LazyList.from(n) / LazyList.iterate(start)(f)',
    description: 'Create lazy infinite sequences',
    example: {
      code: 'LazyList.from(1).take(5).toList\nLazyList.iterate(1)(_ * 2).take(5).toList',
      output: 'List(1, 2, 3, 4, 5)\nList(1, 2, 4, 8, 16)',
    },
    timeComplexity: 'O(1) per element',
    spaceComplexity: 'O(n) when materialized',
    gotchas: ['Stream deprecated in 2.13 - use LazyList'],
    interviewTip: 'Useful for generating sequences lazily',
    priority: 'useful',
  },
  {
    name: 'Option / Try / Either',
    category: 'error-handling',
    syntax: 'Option[A] / Try[A] / Either[L, R]',
    description: 'Functional error handling types',
    example: {
      code: 'import scala.util.Try\nTry(10 / 0).getOrElse(-1)\nTry(10 / 2).getOrElse(-1)',
      output: '-1\n5',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Try catches exceptions', 'Either for typed errors'],
    interviewTip: 'Use Try for exception handling in functional style',
    priority: 'common',
  },
  {
    name: 'min / max / sum / product',
    category: 'math',
    syntax: 'list.min / list.max / list.sum / list.product',
    description: 'Aggregate operations on numeric collections',
    example: {
      code: 'List(3, 1, 4, 1, 5).min\nList(3, 1, 4, 1, 5).max\nList(1, 2, 3).sum',
      output: '1\n5\n6',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Throw on empty list - use minOption/maxOption for safety'],
    interviewTip: 'Use minBy/maxBy for custom comparison',
    priority: 'essential',
  },
  {
    name: 'minBy / maxBy',
    category: 'math',
    syntax: 'list.minBy(f) / list.maxBy(f)',
    description: 'Find min/max by key function',
    example: {
      code: 'List("aa", "b", "ccc").minBy(_.length)\nList("aa", "b", "ccc").maxBy(_.length)',
      output: 'b\nccc',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns element, not the key value'],
    interviewTip: 'Essential for finding extremes by custom criteria',
    priority: 'essential',
  },
];
