/**
 * Haskell Cheatsheet
 *
 * Essential Haskell functions for coding interviews.
 * Covers list operations, string handling, Maybe/Either, and common Prelude functions.
 */

import type { CheatsheetEntry } from './types';

export const haskellCheatsheet: CheatsheetEntry[] = [
  // ============================================
  // LIST OPERATIONS (Arrays)
  // ============================================
  {
    name: 'map',
    category: 'functional',
    syntax: 'map :: (a -> b) -> [a] -> [b]',
    description: 'Apply a function to every element in a list',
    example: { code: 'map (*2) [1,2,3]', output: '[2,4,6]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Lazy evaluation - list not computed until needed'],
    interviewTip: 'Use map for transformations instead of manual recursion',
    priority: 'essential',
  },
  {
    name: 'filter',
    category: 'functional',
    syntax: 'filter :: (a -> Bool) -> [a] -> [a]',
    description: 'Keep only elements that satisfy a predicate',
    example: { code: 'filter even [1,2,3,4,5]', output: '[2,4]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Returns empty list if no elements match'],
    interviewTip: 'Combine with map for filter-map patterns',
    priority: 'essential',
  },
  {
    name: 'foldl',
    category: 'functional',
    syntax: 'foldl :: (b -> a -> b) -> b -> [a] -> b',
    description: 'Left fold - reduce list from left with accumulator',
    example: { code: 'foldl (+) 0 [1,2,3]', output: '6' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: [
      'Not tail-recursive, can stack overflow on large lists',
      "Use foldl' for strict evaluation",
    ],
    interviewTip: 'Use for aggregations like sum, product, or building results',
    priority: 'essential',
  },
  {
    name: 'foldr',
    category: 'functional',
    syntax: 'foldr :: (a -> b -> b) -> b -> [a] -> b',
    description: 'Right fold - reduce list from right with accumulator',
    example: { code: 'foldr (:) [] [1,2,3]', output: '[1,2,3]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Works on infinite lists if function is lazy in second arg'],
    interviewTip: 'Preferred for building lists, works with infinite lists',
    priority: 'essential',
  },
  {
    name: 'head',
    category: 'arrays',
    syntax: 'head :: [a] -> a',
    description: 'Get the first element of a list',
    example: { code: 'head [1,2,3]', output: '1' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Throws error on empty list - use listToMaybe for safety'],
    interviewTip: 'Always check for empty list or use pattern matching',
    priority: 'essential',
  },
  {
    name: 'tail',
    category: 'arrays',
    syntax: 'tail :: [a] -> [a]',
    description: 'Get all elements except the first',
    example: { code: 'tail [1,2,3]', output: '[2,3]' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Throws error on empty list'],
    interviewTip: 'Use pattern matching (x:xs) instead when possible',
    priority: 'essential',
  },
  {
    name: 'take',
    category: 'arrays',
    syntax: 'take :: Int -> [a] -> [a]',
    description: 'Take first n elements from a list',
    example: { code: 'take 2 [1,2,3,4]', output: '[1,2]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Returns entire list if n > length, empty if n <= 0'],
    interviewTip: 'Safe on infinite lists - great for limiting results',
    priority: 'essential',
  },
  {
    name: 'drop',
    category: 'arrays',
    syntax: 'drop :: Int -> [a] -> [a]',
    description: 'Drop first n elements from a list',
    example: { code: 'drop 2 [1,2,3,4]', output: '[3,4]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns empty list if n >= length'],
    interviewTip: 'Use with take for pagination: take n . drop offset',
    priority: 'essential',
  },
  {
    name: 'zip',
    category: 'arrays',
    syntax: 'zip :: [a] -> [b] -> [(a, b)]',
    description: 'Combine two lists into list of pairs',
    example: { code: 'zip [1,2,3] ["a","b"]', output: '[(1,"a"),(2,"b")]' },
    timeComplexity: 'O(min(n,m))',
    spaceComplexity: 'O(min(n,m))',
    gotchas: ['Stops at shorter list length'],
    interviewTip: 'Use zip [0..] xs to add indices to elements',
    priority: 'essential',
  },
  {
    name: 'zipWith',
    category: 'arrays',
    syntax: 'zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]',
    description: 'Combine two lists using a function',
    example: { code: 'zipWith (+) [1,2,3] [10,20,30]', output: '[11,22,33]' },
    timeComplexity: 'O(min(n,m))',
    spaceComplexity: 'O(min(n,m))',
    gotchas: ['Stops at shorter list'],
    interviewTip: 'More efficient than zip followed by map',
    priority: 'essential',
  },
  {
    name: 'length',
    category: 'arrays',
    syntax: 'length :: [a] -> Int',
    description: 'Get the number of elements in a list',
    example: { code: 'length [1,2,3,4,5]', output: '5' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Traverses entire list - expensive on large lists'],
    interviewTip: 'Avoid calling multiple times; store result if needed',
    priority: 'essential',
  },
  {
    name: 'reverse',
    category: 'arrays',
    syntax: 'reverse :: [a] -> [a]',
    description: 'Reverse a list',
    example: { code: 'reverse [1,2,3]', output: '[3,2,1]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Creates new list, does not modify in place'],
    interviewTip: 'Useful for building lists efficiently with (:) then reversing',
    priority: 'essential',
  },
  {
    name: 'concat',
    category: 'arrays',
    syntax: 'concat :: [[a]] -> [a]',
    description: 'Flatten a list of lists into a single list',
    example: { code: 'concat [[1,2],[3,4],[5]]', output: '[1,2,3,4,5]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Only flattens one level deep'],
    interviewTip: 'concatMap f = concat . map f for flat-mapping',
    priority: 'common',
  },
  {
    name: 'concatMap',
    category: 'functional',
    syntax: 'concatMap :: (a -> [b]) -> [a] -> [b]',
    description: 'Map a function and concatenate results (flatMap)',
    example: { code: 'concatMap (\\x -> [x,x]) [1,2,3]', output: '[1,1,2,2,3,3]' },
    timeComplexity: 'O(n*m)',
    spaceComplexity: 'O(n*m)',
    gotchas: ['Result size depends on function output'],
    interviewTip: 'Equivalent to >>= for lists; essential for combinations',
    priority: 'common',
  },
  {
    name: '(++)',
    category: 'arrays',
    syntax: '(++) :: [a] -> [a] -> [a]',
    description: 'Concatenate two lists',
    example: { code: '[1,2] ++ [3,4]', output: '[1,2,3,4]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Left list is traversed - prepending with (:) is O(1)'],
    interviewTip: 'Avoid repeated (++) on left side; use difference lists',
    priority: 'essential',
  },
  {
    name: '(:)',
    category: 'arrays',
    syntax: '(:) :: a -> [a] -> [a]',
    description: 'Prepend element to list (cons)',
    example: { code: '1 : [2,3,4]', output: '[1,2,3,4]' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Only adds to front, not back'],
    interviewTip: 'Build lists with (:) and reverse for O(n) instead of (++) O(n^2)',
    priority: 'essential',
  },
  {
    name: 'elem',
    category: 'searching',
    syntax: 'elem :: Eq a => a -> [a] -> Bool',
    description: 'Check if element exists in list',
    example: { code: 'elem 3 [1,2,3,4]', output: 'True' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Linear search - use Set for frequent lookups'],
    interviewTip: 'Can use infix: 3 `elem` [1,2,3]',
    priority: 'essential',
  },
  {
    name: 'null',
    category: 'arrays',
    syntax: 'null :: [a] -> Bool',
    description: 'Check if list is empty',
    example: { code: 'null []', output: 'True' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Preferred over length xs == 0'],
    interviewTip: 'Always use null instead of comparing length to 0',
    priority: 'essential',
  },
  {
    name: 'takeWhile',
    category: 'arrays',
    syntax: 'takeWhile :: (a -> Bool) -> [a] -> [a]',
    description: 'Take elements while predicate is true',
    example: { code: 'takeWhile (<3) [1,2,3,4,1]', output: '[1,2]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Stops at first false, ignores rest'],
    interviewTip: 'Works on infinite lists - stops when predicate fails',
    priority: 'common',
  },
  {
    name: 'replicate',
    category: 'arrays',
    syntax: 'replicate :: Int -> a -> [a]',
    description: 'Create list with n copies of element',
    example: { code: 'replicate 3 "ha"', output: '["ha","ha","ha"]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Returns empty list if n <= 0'],
    interviewTip: 'Useful for initialization and padding',
    priority: 'common',
  },

  // ============================================
  // STRING OPERATIONS
  // ============================================
  {
    name: 'words',
    category: 'strings',
    syntax: 'words :: String -> [String]',
    description: 'Split string into words by whitespace',
    example: { code: 'words "hello world"', output: '["hello","world"]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Multiple spaces treated as single separator'],
    interviewTip: 'Inverse of unwords; handles multiple spaces correctly',
    priority: 'essential',
  },
  {
    name: 'lines',
    category: 'strings',
    syntax: 'lines :: String -> [String]',
    description: 'Split string into lines',
    example: { code: 'lines "a\\nb\\nc"', output: '["a","b","c"]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Empty string returns empty list'],
    interviewTip: 'Essential for parsing multi-line input',
    priority: 'essential',
  },
  {
    name: 'show',
    category: 'type-conversion',
    syntax: 'show :: Show a => a -> String',
    description: 'Convert value to string representation',
    example: { code: 'show 42', output: '"42"' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Requires Show instance'],
    interviewTip: 'Use for debugging and string building',
    priority: 'essential',
  },
  {
    name: 'read',
    category: 'type-conversion',
    syntax: 'read :: Read a => String -> a',
    description: 'Parse string to value',
    example: { code: 'read "42" :: Int', output: '42' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Throws error on parse failure - use readMaybe'],
    interviewTip: 'Always specify type or use readMaybe for safety',
    priority: 'essential',
  },
  {
    name: 'intercalate',
    category: 'strings',
    syntax: 'intercalate :: [a] -> [[a]] -> [a]',
    description: 'Join lists with separator',
    example: { code: 'intercalate ", " ["a","b","c"]', output: '"a, b, c"' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Import from Data.List', 'Works on any list of lists'],
    interviewTip: 'Haskell equivalent of join in other languages',
    priority: 'common',
  },

  // ============================================
  // MAYBE / EITHER HANDLING
  // ============================================
  {
    name: 'maybe',
    category: 'error-handling',
    syntax: 'maybe :: b -> (a -> b) -> Maybe a -> b',
    description: 'Extract value from Maybe with default and transform',
    example: { code: 'maybe 0 (+1) (Just 5)', output: '6' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Default evaluated even if not used (use fromMaybe for simple cases)'],
    interviewTip: 'Pattern: maybe defaultVal id for simple extraction',
    priority: 'essential',
  },
  {
    name: 'fromMaybe',
    category: 'error-handling',
    syntax: 'fromMaybe :: a -> Maybe a -> a',
    description: 'Extract value from Maybe with default',
    example: { code: 'fromMaybe 0 (Just 5)', output: '5' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Import from Data.Maybe'],
    interviewTip: 'Simpler than maybe when no transformation needed',
    priority: 'essential',
  },
  {
    name: 'catMaybes',
    category: 'error-handling',
    syntax: 'catMaybes :: [Maybe a] -> [a]',
    description: 'Extract all Just values from list',
    example: { code: 'catMaybes [Just 1, Nothing, Just 3]', output: '[1,3]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Import from Data.Maybe'],
    interviewTip: 'Great for filtering failed operations',
    priority: 'common',
  },
  {
    name: 'mapMaybe',
    category: 'error-handling',
    syntax: 'mapMaybe :: (a -> Maybe b) -> [a] -> [b]',
    description: 'Map function and keep only Just results',
    example: {
      code: 'mapMaybe (\\x -> if even x then Just x else Nothing) [1,2,3,4]',
      output: '[2,4]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Import from Data.Maybe'],
    interviewTip: 'Combines filter and map in one pass',
    priority: 'common',
  },
  {
    name: 'either',
    category: 'error-handling',
    syntax: 'either :: (a -> c) -> (b -> c) -> Either a b -> c',
    description: 'Apply function based on Either value',
    example: { code: 'either length (*2) (Right 5)', output: '10' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Left is conventionally for errors'],
    interviewTip: 'Either is the functional way to handle errors with context',
    priority: 'common',
  },

  // ============================================
  // MATH OPERATIONS
  // ============================================
  {
    name: 'sum',
    category: 'math',
    syntax: 'sum :: Num a => [a] -> a',
    description: 'Sum all elements in list',
    example: { code: 'sum [1,2,3,4,5]', output: '15' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns 0 for empty list'],
    interviewTip: 'Equivalent to foldl (+) 0',
    priority: 'essential',
  },
  {
    name: 'maximum',
    category: 'math',
    syntax: 'maximum :: Ord a => [a] -> a',
    description: 'Find largest element',
    example: { code: 'maximum [3,1,4,1,5]', output: '5' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Error on empty list'],
    interviewTip: 'Use maximumBy with custom comparison function',
    priority: 'essential',
  },
  {
    name: 'minimum',
    category: 'math',
    syntax: 'minimum :: Ord a => [a] -> a',
    description: 'Find smallest element',
    example: { code: 'minimum [3,1,4,1,5]', output: '1' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Error on empty list'],
    interviewTip: 'Use minimumBy with custom comparison function',
    priority: 'essential',
  },
  {
    name: 'div',
    category: 'math',
    syntax: 'div :: Integral a => a -> a -> a',
    description: 'Integer division (floor)',
    example: { code: '7 `div` 2', output: '3' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Rounds toward negative infinity', 'Different from quot'],
    interviewTip: 'Use div for floor division, quot for truncation toward zero',
    priority: 'essential',
  },
  {
    name: 'mod',
    category: 'math',
    syntax: 'mod :: Integral a => a -> a -> a',
    description: 'Modulo operation',
    example: { code: '7 `mod` 3', output: '1' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Result has same sign as divisor', 'Use rem for C-style remainder'],
    interviewTip: 'mod gives non-negative result for positive divisor',
    priority: 'essential',
  },

  // ============================================
  // SORTING
  // ============================================
  {
    name: 'sort',
    category: 'sorting',
    syntax: 'sort :: Ord a => [a] -> [a]',
    description: 'Sort list in ascending order',
    example: { code: 'sort [3,1,4,1,5]', output: '[1,1,3,4,5]' },
    timeComplexity: 'O(n log n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Import from Data.List', 'Stable sort'],
    interviewTip: 'Use sortBy or sortOn for custom ordering',
    priority: 'essential',
  },
  {
    name: 'sortBy',
    category: 'sorting',
    syntax: 'sortBy :: (a -> a -> Ordering) -> [a] -> [a]',
    description: 'Sort with custom comparison function',
    example: { code: 'sortBy (flip compare) [1,3,2]', output: '[3,2,1]' },
    timeComplexity: 'O(n log n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Import from Data.List'],
    interviewTip: 'Use flip compare for descending order',
    priority: 'common',
  },

  // ============================================
  // COMMON PRELUDE / UTILITY
  // ============================================
  {
    name: '(.)',
    category: 'functional',
    syntax: '(.) :: (b -> c) -> (a -> b) -> a -> c',
    description: 'Function composition',
    example: { code: '((*2) . (+1)) 3', output: '8' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Right to left: (f . g) x = f (g x)'],
    interviewTip: 'Chain transformations: map (f . g) instead of map f . map g',
    priority: 'essential',
  },
  {
    name: '($)',
    category: 'functional',
    syntax: '($) :: (a -> b) -> a -> b',
    description: 'Function application (low precedence)',
    example: { code: 'sum $ map (*2) [1,2,3]', output: '12' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Right associative, lowest precedence'],
    interviewTip: 'Use to avoid parentheses: f $ g $ h x instead of f (g (h x))',
    priority: 'essential',
  },
  {
    name: 'flip',
    category: 'functional',
    syntax: 'flip :: (a -> b -> c) -> b -> a -> c',
    description: 'Swap function arguments',
    example: { code: 'flip (/) 2 10', output: '5.0' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Only flips first two arguments'],
    interviewTip: 'flip compare for descending sort',
    priority: 'common',
  },
  {
    name: 'id',
    category: 'functional',
    syntax: 'id :: a -> a',
    description: 'Identity function - returns its argument',
    example: { code: 'id 5', output: '5' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Useful as placeholder function'],
    interviewTip: 'Use in maybe/either when no transformation needed',
    priority: 'common',
  },
  {
    name: 'any',
    category: 'searching',
    syntax: 'any :: (a -> Bool) -> [a] -> Bool',
    description: 'Check if any element satisfies predicate',
    example: { code: 'any even [1,3,5,6]', output: 'True' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Short-circuits on first True'],
    interviewTip: 'any (== x) is same as elem x',
    priority: 'essential',
  },
  {
    name: 'all',
    category: 'searching',
    syntax: 'all :: (a -> Bool) -> [a] -> Bool',
    description: 'Check if all elements satisfy predicate',
    example: { code: 'all even [2,4,6]', output: 'True' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Short-circuits on first False', 'True for empty list'],
    interviewTip: 'Useful for validation checks',
    priority: 'essential',
  },
  {
    name: 'lookup',
    category: 'searching',
    syntax: 'lookup :: Eq a => a -> [(a, b)] -> Maybe b',
    description: 'Find value by key in association list',
    example: { code: 'lookup 2 [(1,"a"),(2,"b")]', output: 'Just "b"' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns first match', 'Use Map for frequent lookups'],
    interviewTip: 'Safe lookup - returns Maybe instead of throwing',
    priority: 'common',
  },
  {
    name: 'nub',
    category: 'arrays',
    syntax: 'nub :: Eq a => [a] -> [a]',
    description: 'Remove duplicate elements',
    example: { code: 'nub [1,2,1,3,2]', output: '[1,2,3]' },
    timeComplexity: 'O(n^2)',
    spaceComplexity: 'O(n)',
    gotchas: [
      'Import from Data.List',
      'Preserves first occurrence',
      'O(n^2) - use Set for large lists',
    ],
    interviewTip: 'Use nubBy for custom equality',
    priority: 'common',
  },
  {
    name: 'group',
    category: 'arrays',
    syntax: 'group :: Eq a => [a] -> [[a]]',
    description: 'Group consecutive equal elements',
    example: { code: 'group [1,1,2,2,2,1]', output: '[[1,1],[2,2,2],[1]]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Import from Data.List', 'Only groups consecutive elements'],
    interviewTip: 'Sort first for true grouping: group . sort',
    priority: 'common',
  },
  {
    name: 'partition',
    category: 'arrays',
    syntax: 'partition :: (a -> Bool) -> [a] -> ([a], [a])',
    description: 'Split list by predicate into (pass, fail)',
    example: { code: 'partition even [1,2,3,4,5]', output: '([2,4],[1,3,5])' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Import from Data.List'],
    interviewTip: 'More efficient than two separate filters',
    priority: 'common',
  },
];
