/**
 * TypeScript Cheatsheet
 *
 * Essential TypeScript methods and type utilities for coding interviews.
 * Includes both standard JavaScript methods and TypeScript-specific patterns.
 */

import type { CheatsheetEntry } from './types';

export const typescriptCheatsheet: CheatsheetEntry[] = [
  // ==================== ARRAYS ====================
  {
    name: 'push / pop',
    category: 'arrays',
    syntax: 'arr.push(...items): number | arr.pop(): T | undefined',
    description: 'Add to end / remove from end (stack operations)',
    example: { code: 'const arr = [1, 2]; arr.push(3); arr.pop();', output: '3 // arr = [1, 2]' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Both mutate original array', 'push returns length, pop returns element'],
    interviewTip: 'Use together for stack implementation (LIFO)',
    priority: 'essential',
  },
  {
    name: 'shift / unshift',
    category: 'arrays',
    syntax: 'arr.shift(): T | undefined | arr.unshift(...items): number',
    description: 'Remove from start / add to start',
    example: {
      code: 'const arr = [1, 2]; arr.unshift(0); arr.shift();',
      output: '0 // arr = [1, 2]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['O(n) due to re-indexing all elements'],
    interviewTip: 'Use push+shift for queue, but prefer linked list for large queues',
    priority: 'essential',
  },
  {
    name: 'slice',
    category: 'arrays',
    syntax: 'array.slice(start?, end?): T[]',
    description: 'Returns shallow copy of portion of array',
    example: { code: '[1, 2, 3, 4, 5].slice(1, 4);', output: '[2, 3, 4]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['End index is exclusive', 'Negative indices count from end'],
    interviewTip: 'Clone array with arr.slice() or [...arr]',
    priority: 'essential',
  },
  {
    name: 'splice',
    category: 'arrays',
    syntax: 'array.splice(start, deleteCount?, ...items): T[]',
    description: 'Removes/replaces/adds elements in place',
    example: {
      code: 'const arr = [1, 2, 3]; arr.splice(1, 1, 5, 6);',
      output: '[2] // arr = [1, 5, 6, 3]',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Mutates original array', 'Returns removed elements'],
    interviewTip: 'In-place deletion: arr.splice(i, 1)',
    priority: 'essential',
  },
  {
    name: 'indexOf / includes',
    category: 'searching',
    syntax: 'arr.indexOf(el): number | arr.includes(el): boolean',
    description: 'Find index of element / check if element exists',
    example: { code: '[1, 2, 3].indexOf(2); [1, 2, 3].includes(2);', output: '1; true' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['indexOf returns -1 if not found', 'Both use strict equality'],
    interviewTip: 'For O(1) lookup, convert to Set first',
    priority: 'essential',
  },
  {
    name: 'find / findIndex',
    category: 'searching',
    syntax: 'arr.find(predicate): T | undefined | arr.findIndex(predicate): number',
    description: 'Find first element/index satisfying predicate',
    example: { code: '[1, 2, 3, 4].find(x => x > 2);', output: '3' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['find returns undefined if not found', 'findIndex returns -1'],
    interviewTip: 'Useful for finding objects by property value',
    priority: 'essential',
  },
  {
    name: 'reverse',
    category: 'arrays',
    syntax: 'array.reverse(): T[]',
    description: 'Reverses array in place',
    example: { code: '[1, 2, 3].reverse();', output: '[3, 2, 1]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Mutates original array'],
    interviewTip: 'Non-mutating: [...arr].reverse() or arr.toReversed()',
    priority: 'essential',
  },
  {
    name: 'fill',
    category: 'arrays',
    syntax: 'array.fill(value, start?, end?): T[]',
    description: 'Fills array with static value',
    example: { code: 'new Array(5).fill(0);', output: '[0, 0, 0, 0, 0]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Same reference for objects!', 'Mutates original'],
    interviewTip: 'For 2D: Array.from({length: n}, () => new Array(m).fill(0))',
    priority: 'essential',
  },
  {
    name: 'Array.from',
    category: 'arrays',
    syntax: 'Array.from(iterable, mapFn?): T[]',
    description: 'Creates array from iterable with optional mapping',
    example: { code: 'Array.from({length: 3}, (_, i) => i * 2);', output: '[0, 2, 4]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Second arg is map function, not thisArg'],
    interviewTip: 'Great for creating initialized arrays or converting Sets/Maps',
    priority: 'essential',
  },
  {
    name: 'join',
    category: 'arrays',
    syntax: 'array.join(separator?): string',
    description: 'Joins array elements into string',
    example: { code: '["a", "b", "c"].join("-");', output: '"a-b-c"' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Default separator is comma'],
    interviewTip: 'Combine with split() for string manipulation',
    priority: 'essential',
  },
  {
    name: 'flat / concat',
    category: 'arrays',
    syntax: 'arr.flat(depth?) | arr.concat(...arrays) | [...arr1, ...arr2]',
    description: 'Flatten nested arrays or merge arrays',
    example: { code: '[1, [2, [3]]].flat(2); [1].concat([2]);', output: '[1, 2, 3]; [1, 2]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['flat default depth is 1', 'Use Infinity for complete flatten'],
    interviewTip: 'Prefer spread [...arr1, ...arr2] for merging',
    priority: 'common',
  },

  // ==================== FUNCTIONAL ====================
  {
    name: 'map',
    category: 'functional',
    syntax: 'array.map(callback): U[]',
    description: 'Creates new array with results of calling function on every element',
    example: { code: '[1, 2, 3].map(x => x * 2);', output: '[2, 4, 6]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Returns new array', 'Callback receives (value, index, array)'],
    interviewTip: 'Chain with filter() for transform + filter operations',
    priority: 'essential',
  },
  {
    name: 'filter',
    category: 'functional',
    syntax: 'array.filter(predicate): T[]',
    description: 'Creates new array with elements passing the test',
    example: { code: '[1, 2, 3, 4].filter(x => x % 2 === 0);', output: '[2, 4]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Returns empty array if no matches'],
    interviewTip: 'Combine with map() but consider reduce() for single pass',
    priority: 'essential',
  },
  {
    name: 'reduce',
    category: 'functional',
    syntax: 'array.reduce(callback, initialValue?): U',
    description: 'Reduces array to single value by applying function',
    example: { code: '[1, 2, 3].reduce((acc, x) => acc + x, 0);', output: '6' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Always provide initialValue', 'Empty array without initial throws'],
    interviewTip: 'Extremely versatile - can implement map, filter, groupBy',
    priority: 'essential',
  },
  {
    name: 'forEach',
    category: 'iteration',
    syntax: 'array.forEach(callback): void',
    description: 'Executes function for each element',
    example: { code: '[1, 2, 3].forEach(x => console.log(x));', output: '1 2 3' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Cannot break early', 'Returns undefined'],
    interviewTip: 'Use for loop if you need to break early',
    priority: 'essential',
  },
  {
    name: 'some / every',
    category: 'functional',
    syntax: 'arr.some(predicate): boolean | arr.every(predicate): boolean',
    description: 'Test if any/all elements pass predicate',
    example: {
      code: '[1, 2, 3].some(x => x > 2); [2, 4, 6].every(x => x % 2 === 0);',
      output: 'true; true',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Both short-circuit', 'Empty array: some=false, every=true'],
    interviewTip: 'Like logical OR/AND across array elements',
    priority: 'essential',
  },

  // ==================== SORTING ====================
  {
    name: 'sort',
    category: 'sorting',
    syntax: 'array.sort(compareFn?): T[]',
    description: 'Sorts array in place',
    example: { code: '[3, 1, 2].sort((a, b) => a - b);', output: '[1, 2, 3]' },
    timeComplexity: 'O(n log n)',
    spaceComplexity: 'O(log n)',
    gotchas: ['Default sorts as strings!', 'Mutates original array', 'a - b for ascending'],
    interviewTip: 'Always provide compareFn for numbers. Descending: (a, b) => b - a',
    priority: 'essential',
  },

  // ==================== STRINGS ====================
  {
    name: 'split',
    category: 'strings',
    syntax: 'string.split(separator, limit?): string[]',
    description: 'Splits string into array by separator',
    example: { code: '"a,b,c".split(",");', output: '["a", "b", "c"]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['str.split("") for character array', 'Regex separators supported'],
    interviewTip: 'Essential for string manipulation problems',
    priority: 'essential',
  },
  {
    name: 'substring / slice',
    category: 'strings',
    syntax: 'str.substring(start, end?) | str.slice(start, end?)',
    description: 'Extract part of string',
    example: { code: '"hello".substring(1, 4); "hello".slice(-2);', output: '"ell"; "lo"' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['End is exclusive', 'slice handles negatives, substring does not'],
    interviewTip: 'Prefer slice() for consistency with arrays',
    priority: 'essential',
  },
  {
    name: 'charCodeAt / fromCharCode',
    category: 'strings',
    syntax: 'str.charCodeAt(i): number | String.fromCharCode(...codes): string',
    description: 'Convert between characters and ASCII/Unicode codes',
    example: { code: '"A".charCodeAt(0); String.fromCharCode(65);', output: '65; "A"' },
    timeComplexity: 'O(1) / O(n)',
    spaceComplexity: 'O(1) / O(n)',
    gotchas: ['charCodeAt returns NaN for invalid index'],
    interviewTip: 'Character math: charCodeAt(0) - 97 gives 0-25 for a-z',
    priority: 'essential',
  },
  {
    name: 'toLowerCase / toUpperCase',
    category: 'strings',
    syntax: 'str.toLowerCase(): string | str.toUpperCase(): string',
    description: 'Convert string case',
    example: { code: '"Hello".toLowerCase(); "hello".toUpperCase();', output: '"hello"; "HELLO"' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Returns new string', 'Locale-independent'],
    interviewTip: 'Always normalize case for case-insensitive comparison',
    priority: 'essential',
  },
  {
    name: 'trim',
    category: 'strings',
    syntax: 'str.trim(): string',
    description: 'Removes whitespace from both ends',
    example: { code: '"  hello  ".trim();', output: '"hello"' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Does not modify interior whitespace'],
    interviewTip: 'Use trimStart()/trimEnd() for one-sided trim',
    priority: 'common',
  },
  {
    name: 'repeat / padStart / padEnd',
    category: 'strings',
    syntax: 'str.repeat(n) | str.padStart(len, pad?) | str.padEnd(len, pad?)',
    description: 'Repeat string or pad to length',
    example: { code: '"ab".repeat(3); "5".padStart(3, "0");', output: '"ababab"; "005"' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['repeat throws for negative/Infinity'],
    interviewTip: 'Great for formatting numbers and generating patterns',
    priority: 'common',
  },
  {
    name: 'startsWith / endsWith / includes',
    category: 'strings',
    syntax: 'str.startsWith(s) | str.endsWith(s) | str.includes(s)',
    description: 'Check if string contains/starts/ends with substring',
    example: { code: '"hello".startsWith("he"); "hello".includes("ll");', output: 'true; true' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['All are case-sensitive'],
    interviewTip: 'More readable than indexOf checks',
    priority: 'common',
  },
  {
    name: 'replace / replaceAll',
    category: 'strings',
    syntax: 'str.replace(search, replacement) | str.replaceAll(search, replacement)',
    description: 'Replace first/all occurrences',
    example: {
      code: '"hello".replace("l", "L"); "hello".replaceAll("l", "L");',
      output: '"heLlo"; "heLLo"',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['replace only replaces first match', 'Can use regex with /g flag'],
    interviewTip: 'replaceAll is cleaner than /pattern/g for simple cases',
    priority: 'common',
  },
  {
    name: 'Template literals',
    category: 'strings',
    syntax: '`string $expression`',
    description: 'String interpolation with embedded expressions using backticks',
    example: {
      code: 'const name = "World";\nconst msg = `Hello, ` + name + `!`;',
      output: '"Hello, World!"',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Supports multi-line strings', 'Expressions are toString()ed'],
    interviewTip: 'Cleaner than string concatenation',
    priority: 'essential',
  },

  // ==================== MAPS ====================
  {
    name: 'Map basics',
    category: 'maps',
    syntax: 'map.set(k, v) | map.get(k) | map.has(k) | map.delete(k)',
    description: 'Key-value store with any type as key',
    example: {
      code: 'const m = new Map(); m.set("a", 1); m.get("a"); m.has("a");',
      output: 'Map; 1; true',
    },
    timeComplexity: 'O(1) for all',
    spaceComplexity: 'O(1)',
    gotchas: ['get returns undefined if not found', 'set returns the Map'],
    interviewTip: 'Use Map over object when keys are not strings or need order',
    priority: 'essential',
  },
  {
    name: 'Map iteration',
    category: 'maps',
    syntax: 'map.keys() | map.values() | map.entries() | map.forEach()',
    description: 'Iterate over Map contents',
    example: {
      code: 'for (const [k, v] of map) { }; [...map.keys()];',
      output: 'Iterates in insertion order',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n) for spread',
    gotchas: ['Maintains insertion order', 'entries() is default iterator'],
    interviewTip: 'Essential for frequency counting problems',
    priority: 'essential',
  },

  // ==================== SETS ====================
  {
    name: 'Set basics',
    category: 'sets',
    syntax: 'set.add(v) | set.has(v) | set.delete(v) | set.size',
    description: 'Collection of unique values',
    example: { code: 'const s = new Set([1, 2, 2]); s.has(2); s.size;', output: 'true; 2' },
    timeComplexity: 'O(1) for add/has/delete',
    spaceComplexity: 'O(1)',
    gotchas: ['add is chainable', 'Duplicate values ignored'],
    interviewTip: 'Perfect for tracking seen elements with O(1) lookup',
    priority: 'essential',
  },
  {
    name: 'Set conversion',
    category: 'sets',
    syntax: '[...new Set(arr)] | Array.from(set)',
    description: 'Convert between Set and Array',
    example: { code: '[...new Set([1, 2, 2, 3])];', output: '[1, 2, 3]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    interviewTip: 'Quick way to remove duplicates from array',
    priority: 'essential',
  },

  // ==================== OBJECTS ====================
  {
    name: 'Object.keys / values / entries',
    category: 'objects',
    syntax: 'Object.keys(obj) | Object.values(obj) | Object.entries(obj)',
    description: 'Get arrays of keys, values, or [key, value] pairs',
    example: { code: 'Object.entries({ a: 1, b: 2 });', output: '[["a", 1], ["b", 2]]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Keys are always strings', 'Only own enumerable properties'],
    interviewTip: 'Use entries for destructuring: for (const [k, v] of Object.entries(obj))',
    priority: 'essential',
  },
  {
    name: 'Object.fromEntries',
    category: 'objects',
    syntax: 'Object.fromEntries(iterable): object',
    description: 'Creates object from key-value pairs',
    example: { code: 'Object.fromEntries([["a", 1], ["b", 2]]);', output: '{ a: 1, b: 2 }' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    interviewTip: 'Inverse of Object.entries - great for Map to object',
    priority: 'common',
  },
  {
    name: 'Optional chaining',
    category: 'objects',
    syntax: 'obj?.prop | obj?.[expr] | func?.()',
    description: 'Safely access nested properties',
    example: { code: 'const x = obj?.nested?.value;', output: 'undefined if any null/undefined' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Short-circuits to undefined', 'Does not prevent accessing undefined.prop'],
    interviewTip: 'Essential for safely navigating nullable objects',
    priority: 'essential',
  },
  {
    name: 'Nullish coalescing',
    category: 'objects',
    syntax: 'value ?? defaultValue',
    description: 'Returns right side if left is null/undefined',
    example: { code: 'null ?? "default"; 0 ?? "default";', output: '"default"; 0' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Only null/undefined trigger default', '0 and "" do NOT trigger'],
    interviewTip: 'Prefer over || when 0 or "" are valid values',
    priority: 'essential',
  },
  {
    name: 'Spread operator',
    category: 'objects',
    syntax: '[...arr] | {...obj}',
    description: 'Spreads iterable elements or object properties',
    example: {
      code: 'const copy = [...arr]; const merged = {...a, ...b};',
      output: 'Shallow copies/merges',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Shallow copy only', 'Object spread overwrites left with right'],
    interviewTip: 'Standard way to clone arrays/objects immutably',
    priority: 'essential',
  },
  {
    name: 'Destructuring',
    category: 'objects',
    syntax: 'const { a, b } = obj; const [x, y] = arr;',
    description: 'Extract values from objects/arrays into variables',
    example: {
      code: 'const { name, age = 0 } = person; const [first, ...rest] = arr;',
      output: 'Extracts with defaults/rest',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Can rename: { a: newName }', 'Can set defaults: { a = 1 }'],
    interviewTip: 'Use in function params for cleaner API',
    priority: 'essential',
  },

  // ==================== MATH ====================
  {
    name: 'Math.max / Math.min',
    category: 'math',
    syntax: 'Math.max(...values) | Math.min(...values)',
    description: 'Returns largest/smallest of given numbers',
    example: { code: 'Math.max(1, 5, 3); Math.max(...arr);', output: '5' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['max() returns -Infinity, min() returns Infinity if no args'],
    interviewTip: 'Use spread for arrays: Math.max(...arr)',
    priority: 'essential',
  },
  {
    name: 'Math.floor / ceil / round',
    category: 'math',
    syntax: 'Math.floor(x) | Math.ceil(x) | Math.round(x)',
    description: 'Round down / up / to nearest integer',
    example: { code: 'Math.floor(4.7); Math.ceil(4.2); Math.round(4.5);', output: '4; 5; 5' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['floor(-4.7) = -5, not -4', 'round(4.5) = 5'],
    interviewTip: 'Use floor for array midpoint: Math.floor(arr.length / 2)',
    priority: 'essential',
  },
  {
    name: 'Math.abs / sqrt / pow',
    category: 'math',
    syntax: 'Math.abs(x) | Math.sqrt(x) | Math.pow(base, exp)',
    description: 'Absolute value / square root / power',
    example: { code: 'Math.abs(-5); Math.sqrt(16); 2 ** 10;', output: '5; 4; 1024' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['sqrt returns NaN for negative numbers', 'Prefer ** over pow()'],
    interviewTip: 'abs() essential for distance calculations',
    priority: 'essential',
  },

  // ==================== TYPE CONVERSION ====================
  {
    name: 'parseInt / parseFloat / Number',
    category: 'type-conversion',
    syntax: 'parseInt(str, radix) | parseFloat(str) | Number(val)',
    description: 'Parse strings to numbers',
    example: { code: 'parseInt("42", 10); Number("3.14"); +"42";', output: '42; 3.14; 42' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Always use radix with parseInt!', 'Number("") = 0, parseInt("") = NaN'],
    interviewTip: 'Use + for quick conversion: +str',
    priority: 'essential',
  },
  {
    name: 'String / toString',
    category: 'type-conversion',
    syntax: 'String(val) | val.toString() | template literal',
    description: 'Convert to string',
    example: { code: 'String(42); (255).toString(16);', output: '"42"; "ff"' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['null.toString() throws', 'String(null) = "null"'],
    interviewTip: 'toString(radix) useful for base conversion',
    priority: 'common',
  },
  {
    name: 'JSON.stringify / parse',
    category: 'type-conversion',
    syntax: 'JSON.stringify(val) | JSON.parse(str)',
    description: 'Serialize to / parse from JSON',
    example: {
      code: 'JSON.stringify({ a: 1 }); JSON.parse(\'{"a":1}\');',
      output: '\'{"a":1}\'; { a: 1 }',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Circular refs throw', 'undefined/functions/symbols are omitted'],
    interviewTip: 'Quick deep clone (slow): JSON.parse(JSON.stringify(obj))',
    priority: 'essential',
  },

  // ==================== TYPESCRIPT-SPECIFIC ====================
  {
    name: 'typeof type guard',
    category: 'type-conversion',
    syntax: 'typeof value === "string"',
    description: 'Narrows type based on typeof check',
    example: {
      code: 'function f(x: string | number) { if (typeof x === "string") x.toUpperCase(); }',
      output: 'Type narrowed to string',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Works for: string, number, boolean, undefined, function, symbol, bigint'],
    interviewTip: 'Essential for union type handling',
    priority: 'essential',
  },
  {
    name: 'instanceof type guard',
    category: 'type-conversion',
    syntax: 'value instanceof Class',
    description: 'Narrows type based on class check',
    example: {
      code: 'function f(e: Error | string) { if (e instanceof Error) e.message; }',
      output: 'Type narrowed to Error',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Only works with classes', 'Does not work across realms'],
    interviewTip: 'Use for class-based type narrowing',
    priority: 'essential',
  },
  {
    name: 'in type guard',
    category: 'type-conversion',
    syntax: '"property" in object',
    description: 'Narrows type based on property existence',
    example: {
      code: 'function f(x: A | B) { if ("name" in x) x.name; }',
      output: 'Type narrowed by discriminant',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Checks prototype chain too'],
    interviewTip: 'Great for discriminated unions',
    priority: 'common',
  },
  {
    name: 'as assertion / as const',
    category: 'type-conversion',
    syntax: 'value as Type | value as const',
    description: 'Type assertion / const assertion',
    example: {
      code: 'const el = doc.getElementById("id") as HTMLInputElement; const arr = [1, 2] as const;',
      output: 'Type assertions',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['as Type has no runtime check!', 'as const makes readonly'],
    interviewTip: 'Prefer type guards over assertions when possible',
    priority: 'common',
  },
  {
    name: 'Array.isArray',
    category: 'type-conversion',
    syntax: 'Array.isArray(value): boolean',
    description: 'Type guard for arrays',
    example: { code: 'Array.isArray([1, 2]); Array.isArray("abc");', output: 'true; false' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['typeof [] returns "object"', 'Works across realms'],
    interviewTip: 'Always use this over typeof for array check',
    priority: 'essential',
  },
  {
    name: 'Number.isNaN / isFinite / isInteger',
    category: 'type-conversion',
    syntax: 'Number.isNaN(v) | Number.isFinite(v) | Number.isInteger(v)',
    description: 'Type-safe number checks',
    example: { code: 'Number.isNaN(NaN); Number.isInteger(5.0);', output: 'true; true' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Different from global isNaN()!', 'Number.isNaN("NaN") = false'],
    interviewTip: 'Always use Number.isNaN, not global isNaN',
    priority: 'common',
  },
];
