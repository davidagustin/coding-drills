/**
 * Elixir Cheatsheet
 *
 * Essential Elixir functions and patterns for coding interviews.
 * Covers Enum, List, String, Map operations, and pattern matching.
 */

import type { CheatsheetEntry } from './types';

export const elixirCheatsheet: CheatsheetEntry[] = [
  // ============================================
  // ENUM MODULE - Essential Operations
  // ============================================
  {
    name: 'Enum.map',
    category: 'functional',
    syntax: 'Enum.map(enumerable, fun)',
    description: 'Transforms each element by applying a function',
    example: { code: 'Enum.map([1, 2, 3], fn x -> x * 2 end)', output: '[2, 4, 6]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Returns a list even for other enumerable types'],
    interviewTip: 'Use capture syntax &(&1 * 2) for concise transformations',
    priority: 'essential',
  },
  {
    name: 'Enum.filter',
    category: 'functional',
    syntax: 'Enum.filter(enumerable, fun)',
    description: 'Returns elements where the function returns truthy value',
    example: { code: 'Enum.filter([1, 2, 3, 4], fn x -> rem(x, 2) == 0 end)', output: '[2, 4]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Function must return boolean-like value'],
    interviewTip: 'Combine with pattern matching in anonymous functions',
    priority: 'essential',
  },
  {
    name: 'Enum.reduce',
    category: 'functional',
    syntax: 'Enum.reduce(enumerable, acc, fun)',
    description: 'Reduces enumerable to a single value using accumulator',
    example: { code: 'Enum.reduce([1, 2, 3], 0, fn x, acc -> x + acc end)', output: '6' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Without initial acc, uses first element', 'Empty list without acc raises error'],
    interviewTip: 'Most versatile function - can implement map, filter, and more',
    priority: 'essential',
  },
  {
    name: 'Enum.find',
    category: 'functional',
    syntax: 'Enum.find(enumerable, default \\\\ nil, fun)',
    description: 'Returns first element where function returns truthy value',
    example: { code: 'Enum.find([1, 2, 3], fn x -> x > 1 end)', output: '2' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns nil if not found (or default if provided)'],
    interviewTip: 'Short-circuits on first match - efficient for early termination',
    priority: 'essential',
  },
  {
    name: 'Enum.sort',
    category: 'sorting',
    syntax: 'Enum.sort(enumerable, sorter \\\\ :asc)',
    description: 'Sorts elements using merge sort algorithm',
    example: { code: 'Enum.sort([3, 1, 2])', output: '[1, 2, 3]' },
    timeComplexity: 'O(n log n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Uses merge sort (stable)', 'Custom sorter must return boolean'],
    interviewTip: 'Use :desc for descending or custom comparator for complex sorting',
    priority: 'essential',
  },
  {
    name: 'Enum.sort_by',
    category: 'sorting',
    syntax: 'Enum.sort_by(enumerable, mapper, sorter \\\\ :asc)',
    description: 'Sorts by applying mapper function to determine order',
    example: {
      code: 'Enum.sort_by(["bb", "a", "ccc"], &String.length/1)',
      output: '["a", "bb", "ccc"]',
    },
    timeComplexity: 'O(n log n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Mapper called once per element (efficient)'],
    interviewTip: 'Use for sorting complex structures by specific fields',
    priority: 'common',
  },
  {
    name: 'Enum.reverse',
    category: 'arrays',
    syntax: 'Enum.reverse(enumerable)',
    description: 'Reverses the enumerable',
    example: { code: 'Enum.reverse([1, 2, 3])', output: '[3, 2, 1]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    interviewTip: 'Often used after building list with prepend operations',
    priority: 'essential',
  },
  {
    name: 'Enum.any?',
    category: 'functional',
    syntax: 'Enum.any?(enumerable, fun \\\\ fn x -> x end)',
    description: 'Returns true if any element satisfies the function',
    example: { code: 'Enum.any?([1, 2, 3], fn x -> x > 2 end)', output: 'true' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Short-circuits on first truthy result'],
    interviewTip: 'Use for existence checks in validation logic',
    priority: 'essential',
  },
  {
    name: 'Enum.all?',
    category: 'functional',
    syntax: 'Enum.all?(enumerable, fun \\\\ fn x -> x end)',
    description: 'Returns true if all elements satisfy the function',
    example: { code: 'Enum.all?([2, 4, 6], fn x -> rem(x, 2) == 0 end)', output: 'true' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Short-circuits on first falsy result', 'Empty enumerable returns true'],
    interviewTip: 'Useful for validating entire collections',
    priority: 'essential',
  },
  {
    name: 'Enum.count',
    category: 'arrays',
    syntax: 'Enum.count(enumerable) | Enum.count(enumerable, fun)',
    description: 'Returns count of elements (optionally matching function)',
    example: { code: 'Enum.count([1, 2, 3, 4], fn x -> x > 2 end)', output: '2' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['For lists, length/1 is O(n) too but more idiomatic'],
    priority: 'essential',
  },
  {
    name: 'Enum.sum',
    category: 'math',
    syntax: 'Enum.sum(enumerable)',
    description: 'Sums all elements in the enumerable',
    example: { code: 'Enum.sum([1, 2, 3, 4])', output: '10' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Elements must be numbers'],
    interviewTip: 'Quick way to sum without explicit reduce',
    priority: 'common',
  },
  {
    name: 'Enum.max/min',
    category: 'math',
    syntax: 'Enum.max(enumerable) | Enum.min(enumerable)',
    description: 'Returns maximum or minimum element',
    example: { code: 'Enum.max([1, 3, 2])', output: '3' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Raises on empty enumerable - use max/2 with default'],
    interviewTip: 'Use max_by/min_by for complex comparisons',
    priority: 'essential',
  },
  {
    name: 'Enum.take/drop',
    category: 'arrays',
    syntax: 'Enum.take(enumerable, n) | Enum.drop(enumerable, n)',
    description: 'Takes or drops first n elements from enumerable',
    example: { code: 'Enum.take([1, 2, 3, 4, 5], 3)', output: '[1, 2, 3]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Negative amount operates from end'],
    interviewTip: 'Use take_while/drop_while for conditional operations',
    priority: 'common',
  },
  {
    name: 'Enum.at',
    category: 'arrays',
    syntax: 'Enum.at(enumerable, index, default \\\\ nil)',
    description: 'Returns element at index (0-based)',
    example: { code: 'Enum.at([1, 2, 3], 1)', output: '2' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Lists have O(n) random access - consider other data structures'],
    interviewTip: 'Negative indices count from end',
    priority: 'common',
  },
  {
    name: 'Enum.member?',
    category: 'searching',
    syntax: 'Enum.member?(enumerable, element)',
    description: 'Checks if element exists in enumerable',
    example: { code: 'Enum.member?([1, 2, 3], 2)', output: 'true' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Uses === for comparison'],
    interviewTip: 'For frequent lookups, convert to MapSet first',
    priority: 'common',
  },
  {
    name: 'Enum.zip',
    category: 'functional',
    syntax: 'Enum.zip(enumerables)',
    description: 'Zips corresponding elements from multiple enumerables',
    example: { code: 'Enum.zip([[1, 2], [:a, :b]])', output: '[{1, :a}, {2, :b}]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Stops at shortest enumerable'],
    interviewTip: 'Use zip_with to transform while zipping',
    priority: 'common',
  },
  {
    name: 'Enum.group_by',
    category: 'functional',
    syntax: 'Enum.group_by(enumerable, key_fun, value_fun \\\\ fn x -> x end)',
    description: 'Groups elements by key function result',
    example: {
      code: 'Enum.group_by([1, 2, 3, 4], fn x -> rem(x, 2) end)',
      output: '%{0 => [2, 4], 1 => [1, 3]}',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    interviewTip: 'Essential for categorization problems',
    priority: 'essential',
  },
  {
    name: 'Enum.frequencies',
    category: 'functional',
    syntax: 'Enum.frequencies(enumerable)',
    description: 'Returns map with elements as keys and counts as values',
    example: {
      code: 'Enum.frequencies(["a", "b", "a", "c", "a"])',
      output: '%{"a" => 3, "b" => 1, "c" => 1}',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    interviewTip: 'Perfect for character/element counting problems',
    priority: 'essential',
  },
  {
    name: 'Enum.uniq',
    category: 'arrays',
    syntax: 'Enum.uniq(enumerable)',
    description: 'Removes duplicate elements preserving first occurrence',
    example: { code: 'Enum.uniq([1, 2, 2, 3, 1])', output: '[1, 2, 3]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Preserves order of first occurrences'],
    interviewTip: 'Use uniq_by for custom uniqueness criteria',
    priority: 'essential',
  },
  {
    name: 'Enum.flat_map',
    category: 'functional',
    syntax: 'Enum.flat_map(enumerable, fun)',
    description: 'Maps and flattens result by one level',
    example: { code: 'Enum.flat_map([1, 2], fn x -> [x, x * 2] end)', output: '[1, 2, 2, 4]' },
    timeComplexity: 'O(n*m)',
    spaceComplexity: 'O(n*m)',
    interviewTip: 'Useful for generating multiple outputs per input',
    priority: 'common',
  },
  {
    name: 'Enum.with_index',
    category: 'iteration',
    syntax: 'Enum.with_index(enumerable, offset \\\\ 0)',
    description: 'Wraps each element with its index as tuple',
    example: { code: 'Enum.with_index([:a, :b, :c])', output: '[{:a, 0}, {:b, 1}, {:c, 2}]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    interviewTip: 'Essential when you need both element and position',
    priority: 'essential',
  },

  // ============================================
  // LIST OPERATIONS
  // ============================================
  {
    name: 'hd/tl',
    category: 'arrays',
    syntax: 'hd(list) | tl(list)',
    description: 'Returns head (first element) or tail (rest) of list',
    example: { code: 'hd([1, 2, 3])', output: '1' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Raises on empty list - use pattern matching for safety'],
    interviewTip: 'Prefer pattern matching [head | tail] = list',
    priority: 'essential',
  },
  {
    name: 'List prepend [h|t]',
    category: 'arrays',
    syntax: '[element | list]',
    description: 'Prepends element to list (cons operation)',
    example: { code: '[0 | [1, 2, 3]]', output: '[0, 1, 2, 3]' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    interviewTip: 'Always prepend and reverse rather than append to lists',
    priority: 'essential',
  },
  {
    name: '++ operator',
    category: 'arrays',
    syntax: 'list1 ++ list2',
    description: 'Concatenates two lists',
    example: { code: '[1, 2] ++ [3, 4]', output: '[1, 2, 3, 4]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Copies entire left list - put shorter list on left'],
    interviewTip: 'Expensive for building lists - prefer prepend and reverse',
    priority: 'essential',
  },
  {
    name: 'List.flatten',
    category: 'arrays',
    syntax: 'List.flatten(list, tail \\\\ [])',
    description: 'Flattens nested lists into single list',
    example: { code: 'List.flatten([[1, 2], [3, [4, 5]]])', output: '[1, 2, 3, 4, 5]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    interviewTip: 'Useful for tree traversal results',
    priority: 'common',
  },
  {
    name: 'length',
    category: 'arrays',
    syntax: 'length(list)',
    description: 'Returns the length of a list',
    example: { code: 'length([1, 2, 3])', output: '3' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Must traverse entire list - cache if needed multiple times'],
    priority: 'essential',
  },

  // ============================================
  // STRING MODULE
  // ============================================
  {
    name: 'String.split',
    category: 'strings',
    syntax: 'String.split(string, pattern, opts \\\\ [])',
    description: 'Splits string by pattern into list',
    example: { code: 'String.split("a,b,c", ",")', output: '["a", "b", "c"]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Empty string splits into [""]', 'Use trim: true to remove empty strings'],
    interviewTip: 'Without pattern, splits on whitespace',
    priority: 'essential',
  },
  {
    name: 'String.join',
    category: 'strings',
    syntax: 'Enum.join(enumerable, joiner \\\\ "")',
    description: 'Joins list elements into string with separator',
    example: { code: 'Enum.join(["a", "b", "c"], ",")', output: '"a,b,c"' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    priority: 'essential',
  },
  {
    name: 'String.reverse',
    category: 'strings',
    syntax: 'String.reverse(string)',
    description: 'Reverses a string (grapheme-aware)',
    example: { code: 'String.reverse("hello")', output: '"olleh"' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Handles Unicode graphemes correctly'],
    interviewTip: 'Use for palindrome checks',
    priority: 'essential',
  },
  {
    name: 'String.length',
    category: 'strings',
    syntax: 'String.length(string)',
    description: 'Returns number of graphemes in string',
    example: { code: 'String.length("hello")', output: '5' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Counts graphemes, not bytes - use byte_size for bytes'],
    priority: 'essential',
  },
  {
    name: 'String.at/slice',
    category: 'strings',
    syntax: 'String.at(string, pos) | String.slice(string, range)',
    description: 'Returns grapheme at position or substring from range',
    example: { code: 'String.slice("hello", 1..3)', output: '"ell"' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Negative indices count from end'],
    priority: 'common',
  },
  {
    name: 'String.contains?',
    category: 'strings',
    syntax: 'String.contains?(string, contents)',
    description: 'Checks if string contains given contents',
    example: { code: 'String.contains?("hello", "ell")', output: 'true' },
    timeComplexity: 'O(n*m)',
    spaceComplexity: 'O(1)',
    interviewTip: 'Can check for multiple patterns with list',
    priority: 'essential',
  },
  {
    name: 'String.starts_with?/ends_with?',
    category: 'strings',
    syntax: 'String.starts_with?(string, prefix) | String.ends_with?(string, suffix)',
    description: 'Checks if string starts/ends with given prefix/suffix',
    example: { code: 'String.starts_with?("hello", "he")', output: 'true' },
    timeComplexity: 'O(m)',
    spaceComplexity: 'O(1)',
    priority: 'common',
  },
  {
    name: 'String.downcase/upcase/trim',
    category: 'strings',
    syntax: 'String.downcase(s) | String.upcase(s) | String.trim(s)',
    description: 'Case conversion and whitespace trimming',
    example: { code: 'String.trim("  Hello  ") |> String.downcase()', output: '"hello"' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Unicode-aware - handles non-ASCII correctly'],
    priority: 'common',
  },
  {
    name: 'String.replace',
    category: 'strings',
    syntax: 'String.replace(subject, pattern, replacement, opts \\\\ [])',
    description: 'Replaces occurrences of pattern in string',
    example: { code: 'String.replace("hello", "l", "L")', output: '"heLLo"' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Replaces all by default - use global: false for first only'],
    priority: 'common',
  },
  {
    name: 'String.graphemes',
    category: 'strings',
    syntax: 'String.graphemes(string)',
    description: 'Splits string into list of graphemes',
    example: { code: 'String.graphemes("hello")', output: '["h", "e", "l", "l", "o"]' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    interviewTip: 'Use to iterate over characters in string',
    priority: 'essential',
  },

  // ============================================
  // MAP OPERATIONS
  // ============================================
  {
    name: 'Map.new',
    category: 'maps',
    syntax: 'Map.new(enumerable) | Map.new(enumerable, transform)',
    description: 'Creates a new map from enumerable',
    example: { code: 'Map.new([{:a, 1}, {:b, 2}])', output: '%{a: 1, b: 2}' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    interviewTip: 'Useful for converting lists of tuples to maps',
    priority: 'common',
  },
  {
    name: 'Map.get',
    category: 'maps',
    syntax: 'Map.get(map, key, default \\\\ nil)',
    description: 'Gets value for key with optional default',
    example: { code: 'Map.get(%{a: 1}, :a)', output: '1' },
    timeComplexity: 'O(log n)',
    spaceComplexity: 'O(1)',
    gotchas: ['Returns nil for missing key unless default provided'],
    interviewTip: 'Use map[:key] syntax for simple access',
    priority: 'essential',
  },
  {
    name: 'Map.put',
    category: 'maps',
    syntax: 'Map.put(map, key, value)',
    description: 'Puts value under key (inserts or updates)',
    example: { code: 'Map.put(%{a: 1}, :b, 2)', output: '%{a: 1, b: 2}' },
    timeComplexity: 'O(log n)',
    spaceComplexity: 'O(log n)',
    interviewTip: 'Returns new map - maps are immutable',
    priority: 'essential',
  },
  {
    name: 'Map.update',
    category: 'maps',
    syntax: 'Map.update(map, key, default, fun)',
    description: 'Updates key with function, uses default if key missing',
    example: { code: 'Map.update(%{a: 1}, :a, 0, fn v -> v + 1 end)', output: '%{a: 2}' },
    timeComplexity: 'O(log n)',
    spaceComplexity: 'O(log n)',
    interviewTip: 'Essential for counting/accumulating in maps',
    priority: 'essential',
  },
  {
    name: 'Map.has_key?',
    category: 'maps',
    syntax: 'Map.has_key?(map, key)',
    description: 'Checks if map contains key',
    example: { code: 'Map.has_key?(%{a: 1}, :a)', output: 'true' },
    timeComplexity: 'O(log n)',
    spaceComplexity: 'O(1)',
    priority: 'essential',
  },
  {
    name: 'Map.keys/values/merge',
    category: 'maps',
    syntax: 'Map.keys(map) | Map.values(map) | Map.merge(m1, m2)',
    description: 'Get all keys/values or merge two maps',
    example: { code: 'Map.merge(%{a: 1}, %{b: 2})', output: '%{a: 1, b: 2}' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Order not guaranteed', 'Second map wins on conflicts'],
    priority: 'common',
  },

  // ============================================
  // PATTERN MATCHING & CONTROL FLOW
  // ============================================
  {
    name: 'case expression',
    category: 'functional',
    syntax: 'case expr do pattern -> result end',
    description: 'Pattern matches expression against clauses',
    example: { code: 'case {1, 2} do\n  {x, y} -> x + y\nend', output: '3' },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Must have matching clause or raises MatchError'],
    interviewTip: 'Add catch-all _ -> clause for safety',
    priority: 'essential',
  },
  {
    name: 'cond/with expressions',
    category: 'functional',
    syntax: 'cond do cond -> result end | with pattern <- expr do body end',
    description: 'Multi-condition evaluation or chained pattern matching',
    example: {
      code: 'with {:ok, a} <- {:ok, 1},\n     {:ok, b} <- {:ok, 2},\n     do: a + b',
      output: '3',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    gotchas: ['cond needs true -> default', 'with short-circuits on failure'],
    interviewTip: 'Use cond for if-else chains, with for error handling',
    priority: 'common',
  },
  {
    name: 'Guards',
    category: 'functional',
    syntax: 'when guard_expression',
    description: 'Additional conditions in pattern matching',
    example: {
      code: 'case x do\n  n when n > 0 -> "positive"\n  _ -> "non-positive"\nend',
      output: '"positive" # if x > 0',
    },
    timeComplexity: 'O(1)',
    spaceComplexity: 'O(1)',
    gotchas: ['Limited functions allowed in guards'],
    interviewTip: 'Use is_integer, is_list, etc. for type checks',
    priority: 'essential',
  },

  // ============================================
  // MAPSET (Sets)
  // ============================================
  {
    name: 'MapSet.new',
    category: 'sets',
    syntax: 'MapSet.new(enumerable)',
    description: 'Creates a set from enumerable',
    example: { code: 'MapSet.new([1, 2, 2, 3])', output: 'MapSet.new([1, 2, 3])' },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    interviewTip: 'Essential for O(1) membership tests',
    priority: 'essential',
  },
  {
    name: 'MapSet.member?',
    category: 'sets',
    syntax: 'MapSet.member?(set, value)',
    description: 'Checks if value is in set',
    example: { code: 'MapSet.member?(MapSet.new([1, 2]), 1)', output: 'true' },
    timeComplexity: 'O(log n)',
    spaceComplexity: 'O(1)',
    interviewTip: 'Much faster than Enum.member? for repeated lookups',
    priority: 'essential',
  },
  {
    name: 'MapSet operations',
    category: 'sets',
    syntax: 'MapSet.put(set, val) | MapSet.intersection/union/difference(s1, s2)',
    description: 'Add to set or perform set operations',
    example: {
      code: 'MapSet.intersection(MapSet.new([1,2]), MapSet.new([2,3]))',
      output: 'MapSet.new([2])',
    },
    timeComplexity: 'O(n log n)',
    spaceComplexity: 'O(n)',
    interviewTip: 'Perfect for finding common elements or differences',
    priority: 'common',
  },

  // ============================================
  // RECURSION PATTERNS
  // ============================================
  {
    name: 'Recursive list processing',
    category: 'functional',
    syntax: 'def fun([head | tail]) do ... fun(tail) end',
    description: 'Pattern match head and recurse on tail',
    example: {
      code: 'def sum([]), do: 0\ndef sum([h|t]), do: h + sum(t)',
      output: '# sum([1,2,3]) => 6',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    gotchas: ['Not tail-recursive - use accumulator for large lists'],
    interviewTip: 'Base case first, then recursive case',
    priority: 'essential',
  },
  {
    name: 'Tail recursion with accumulator',
    category: 'functional',
    syntax: 'def fun(list, acc \\\\ initial)',
    description: 'Tail-recursive pattern with accumulator',
    example: {
      code: 'def sum([], acc), do: acc\ndef sum([h|t], acc), do: sum(t, h + acc)',
      output: '# sum([1,2,3], 0) => 6',
    },
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(1)',
    interviewTip: 'Elixir optimizes tail calls - use for performance',
    priority: 'essential',
  },
];
